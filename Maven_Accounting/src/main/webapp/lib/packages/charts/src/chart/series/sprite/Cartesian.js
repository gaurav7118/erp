Ext.define("Ext.chart.series.sprite.Cartesian",{extend:"Ext.chart.series.sprite.Series",inheritableStatics:{def:{processors:{labels:"default",labelOverflowPadding:"number",selectionTolerance:"number",flipXY:"bool",renderer:"default",visibleMinX:"number",visibleMinY:"number",visibleMaxX:"number",visibleMaxY:"number",innerWidth:"number",innerHeight:"number"},defaults:{labels:null,labelOverflowPadding:10,selectionTolerance:20,flipXY:false,renderer:null,transformFillStroke:false,visibleMinX:0,visibleMinY:0,visibleMaxX:1,visibleMaxY:1,innerWidth:1,innerHeight:1},triggers:{dataX:"dataX,bbox",dataY:"dataY,bbox",visibleMinX:"panzoom",visibleMinY:"panzoom",visibleMaxX:"panzoom",visibleMaxY:"panzoom",innerWidth:"panzoom",innerHeight:"panzoom"},updaters:{dataX:function(A){this.processDataX();this.scheduleUpdater(A,"dataY",["dataY"])},dataY:function(){this.processDataY()},panzoom:function(C){var E=C.visibleMaxX-C.visibleMinX,D=C.visibleMaxY-C.visibleMinY,B=C.flipXY?C.innerHeight:C.innerWidth,G=!C.flipXY?C.innerHeight:C.innerWidth,A=this.getSurface(),F=A?A.getInherited().rtl:false;if(F&&!C.flipXY){C.translationX=B+C.visibleMinX*B/E}else{C.translationX=-C.visibleMinX*B/E}C.translationY=-C.visibleMinY*G/D;C.scalingX=(F&&!C.flipXY?-1:1)*B/E;C.scalingY=G/D;C.scalingCenterX=0;C.scalingCenterY=0;this.applyTransformations(true)}}}},processDataY:Ext.emptyFn,processDataX:Ext.emptyFn,updatePlainBBox:function(B){var A=this.attr;B.x=A.dataMinX;B.y=A.dataMinY;B.width=A.dataMaxX-A.dataMinX;B.height=A.dataMaxY-A.dataMinY},binarySearch:function(D){var B=this.attr.dataX,F=0,A=B.length;if(D<=B[0]){return F}if(D>=B[A-1]){return A-1}while(F+1<A){var C=(F+A)>>1,E=B[C];if(E===D){return C}else{if(E<D){F=C}else{A=C}}}return F},render:function(B,C,G){var F=this,A=F.attr,E=A.inverseMatrix.clone();E.appendMatrix(B.inverseMatrix);if(A.dataX===null||A.dataX===undefined){return }if(A.dataY===null||A.dataY===undefined){return }if(E.getXX()*E.getYX()||E.getXY()*E.getYY()){console.log("Cartesian Series sprite does not support rotation/sheering");return }var D=E.transformList([[G[0]-1,G[3]+1],[G[0]+G[2]+1,-1]]);D=D[0].concat(D[1]);F.renderClipped(B,C,D,G)},renderClipped:Ext.emptyFn,getIndexNearPoint:function(F,E){var V=this,P=V.attr.matrix,H=V.attr.dataX,G=V.attr.dataY,J=V.attr.selectionTolerance,S,Q,C=-1,I=P.clone().prependMatrix(V.surfaceMatrix).inverse(),T=I.transformPoint([F,E]),B=I.transformPoint([F-J,E-J]),M=I.transformPoint([F+J,E+J]),A=Math.min(B[0],M[0]),R=Math.max(B[0],M[0]),K=Math.min(B[1],M[1]),D=Math.max(B[1],M[1]),L,U,N,O;for(N=0,O=H.length;N<O;N++){L=H[N];U=G[N];if(L>A&&L<R&&U>K&&U<D){if(C===-1||(Math.abs(L-T[0])<S)&&(Math.abs(U-T[1])<Q)){S=Math.abs(L-T[0]);Q=Math.abs(U-T[1]);C=N}}}return C}})