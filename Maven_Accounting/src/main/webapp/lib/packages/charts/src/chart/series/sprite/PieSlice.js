Ext.define("Ext.chart.series.sprite.PieSlice",{extend:"Ext.draw.sprite.Sector",mixins:{markerHolder:"Ext.chart.MarkerHolder"},alias:"sprite.pieslice",inheritableStatics:{def:{processors:{doCallout:"bool",label:"string",rotateLabels:"bool",labelOverflowPadding:"number",renderer:"default"},defaults:{doCallout:true,rotateLabels:true,label:"",labelOverflowPadding:10,renderer:null}}},config:{rendererData:null,rendererIndex:0,series:null},setGradientBBox:function(P,J){var I=this,H=I.attr,G=(H.fillStyle&&H.fillStyle.isGradient)||(H.strokeStyle&&H.strokeStyle.isGradient);if(G&&!H.constrainGradients){var B=I.getMidAngle(),D=H.margin,E=H.centerX,C=H.centerY,A=H.endRho,K=H.matrix,N=K.getScaleX(),M=K.getScaleY(),L=N*A,F=M*A,O={width:L+L,height:F+F};if(D){E+=D*Math.cos(B);C+=D*Math.sin(B)}O.x=K.x(E,C)-L;O.y=K.y(E,C)-F;P.setGradientBBox(O)}else{I.callParent([P,J])}},render:function(B,C,G,F){var E=this,A=E.attr,H={},D;if(A.renderer){H={type:"sector",text:A.text,centerX:A.centerX,centerY:A.centerY,margin:A.margin,startAngle:Math.min(A.startAngle,A.endAngle),endAngle:Math.max(A.startAngle,A.endAngle),startRho:Math.min(A.startRho,A.endRho),endRho:Math.max(A.startRho,A.endRho)};D=Ext.callback(A.renderer,null,[E,H,E.rendererData,E.rendererIndex],0,E.getSeries());E.setAttributes(D);E.useAttributes(C,G)}E.callParent([B,C,G,F]);if(A.label&&E.getMarker("labels")){E.placeLabel()}},placeLabel:function(){var X=this,S=X.attr,R=S.attributeId,T=Math.min(S.startAngle,S.endAngle),P=Math.max(S.startAngle,S.endAngle),K=(T+P)*0.5,N=S.margin,H=S.centerX,G=S.centerY,F=Math.sin(K),C=Math.cos(K),V=Math.min(S.startRho,S.endRho)+N,M=Math.max(S.startRho,S.endRho)+N,L=(V+M)*0.5,B=X.surfaceMatrix,O=X.labelCfg||(X.labelCfg={}),E=X.getMarker("labels"),D=E.getTemplate(),A=D.getCalloutLine(),Q=A&&A.length||40,U,J,I,Y,W;B.appendMatrix(S.matrix);O.text=S.label;J=H+C*L;I=G+F*L;O.x=B.x(J,I);O.y=B.y(J,I);J=H+C*M;I=G+F*M;O.calloutStartX=B.x(J,I);O.calloutStartY=B.y(J,I);J=H+C*(M+Q);I=G+F*(M+Q);O.calloutPlaceX=B.x(J,I);O.calloutPlaceY=B.y(J,I);if(!S.rotateLabels){O.rotationRads=0;Ext.log.warn("'series.style.rotateLabels' config is deprecated. Use 'series.label.orientation' config instead.")}else{switch(D.attr.orientation){case"horizontal":O.rotationRads=K+Math.atan2(B.y(1,0)-B.y(0,0),B.x(1,0)-B.x(0,0))+Math.PI/2;break;case"vertical":O.rotationRads=K+Math.atan2(B.y(1,0)-B.y(0,0),B.x(1,0)-B.x(0,0));break}}O.calloutColor=(A&&A.color)||X.attr.fillStyle;if(A){if(A.width){O.calloutWidth=A.width}}else{O.calloutHasLine=false}O.globalAlpha=S.globalAlpha*S.fillOpacity;O.hidden=(S.startAngle==S.endAngle);if(D.attr.renderer){W=[X.attr.label,E,O,X.rendererData,X.rendererIndex];Y=Ext.callback(D.attr.renderer,null,W,0,X.getSeries());if(typeof Y==="string"){O.text=Y}else{Ext.apply(O,Y)}}X.putMarker("labels",O,R);U=X.getMarkerBBox("labels",R,true);if(U){if(S.doCallout){if(D.attr.display==="outside"){X.putMarker("labels",{callout:1},R)}else{if(D.attr.display==="inside"){X.putMarker("labels",{callout:0},R)}else{X.putMarker("labels",{callout:1-X.sliceContainsLabel(S,U)},R)}}}else{X.putMarker("labels",{globalAlpha:X.sliceContainsLabel(S,U)},R)}}},sliceContainsLabel:function(D,F){var E=D.labelOverflowPadding,H=(D.endRho+D.startRho)/2,G=H+(F.width+E)/2,I=H-(F.width+E)/2,J,C,B,A;if(E<0){return 1}if(F.width+E*2>(D.endRho-D.startRho)){return 0}C=Math.sqrt(D.endRho*D.endRho-G*G);B=Math.sqrt(D.endRho*D.endRho-I*I);J=Math.abs(D.endAngle-D.startAngle);A=(J>Math.PI/2?I:Math.abs(Math.tan(J/2))*I);if(F.height+E*2>Math.min(C,B,A)*2){return 0}return 1}})