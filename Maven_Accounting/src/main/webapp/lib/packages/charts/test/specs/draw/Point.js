describe("Ext.draw.Point",function(){var B=Ext.draw.Point.prototype,A=12;it("should be isPoint",function(){expect(B.isPoint).toBeTruthy()});it("should default to using degrees",function(){expect(B.angleUnits).toBe("degrees")});describe("constructor",function(){it("should take two numbers",function(){var C=new Ext.draw.Point(3,4);expect(C.x).toEqual(3);expect(C.y).toEqual(4)});it("should take a single number",function(){var C=new Ext.draw.Point(3);expect(C.x).toEqual(3);expect(C.y).toEqual(3)});it("should take an array",function(){var C=new Ext.draw.Point([3,4]);expect(C.x).toEqual(3);expect(C.y).toEqual(4)});it("should take an object",function(){var C=new Ext.draw.Point({x:3,y:4});expect(C.x).toEqual(3);expect(C.y).toEqual(4)});it("should take a point",function(){var C=new Ext.draw.Point(new Ext.draw.Point(3,4));expect(C.x).toEqual(3);expect(C.y).toEqual(4)});it("should calculate polar coordinates",function(){var C=new Ext.draw.Point(5,5);expect(C.length).toEqual(Math.sqrt(2*5*5));expect(C.angle).toEqual(45)})});describe("set, setX, setY",function(){it("should recalculate polar coordinates",function(){var C=new Ext.draw.Point(3,4);C.setX(0);expect(C.length).toEqual(4);expect(C.angle).toEqual(90);C.setY(0);expect(C.length).toEqual(0);expect(C.angle).toEqual(0);C.set(5,5);expect(C.length).toEqual(Math.sqrt(2*5*5));expect(C.angle).toEqual(45)})});describe("setPolar, setLength, setAngle",function(){it("should recalculate cartesian coordinates",function(){var C=new Ext.draw.Point();C.setLength(10);expect(C.x).toEqual(10);expect(C.y).toEqual(0);C.setAngle(90);expect(C.x).toBeCloseTo(0,A);expect(C.y).toBeCloseTo(10,A);C.setPolar(45,Math.sqrt(2*5*5));expect(C.x).toBeCloseTo(5,A);expect(C.y).toBeCloseTo(5,A)})});describe("clone",function(){it("should match original point coordinates but not the point itself",function(){var C=new Ext.draw.Point(2,3),D=C.clone();expect(D.x).toEqual(C.x);expect(D.y).toEqual(C.y);expect(D).toNotBe(C)})});describe("add",function(){it("should return a new point which x/y values are sums of respective coordinates of this point and the given point",function(){var E=new Ext.draw.Point(2,3),D=new Ext.draw.Point(-4,5),C=E.add(D);expect(C.x).toEqual(-2);expect(C.y).toEqual(8);expect(C).toNotBe(E)})});describe("sub",function(){it("should return a new point which x/y values are the difference between the respective coordinates of this point (minuend) and the given point (subtrahend)",function(){var E=new Ext.draw.Point(2,3),D=new Ext.draw.Point(-4,5),C=E.sub(D);expect(C.x).toEqual(6);expect(C.y).toEqual(-2);expect(C).toNotBe(E)})});describe("mul",function(){it("should return a new point which x/y values are the product of multiplication of coordinates of this point by a specified value",function(){var D=new Ext.draw.Point(2,3),C=D.mul(3);expect(C.x).toEqual(6);expect(C.y).toEqual(9);expect(C).toNotBe(D)})});describe("div",function(){it("should return a new point which x/y values are the product of division of coordinates of this point by a specified value",function(){var C=new Ext.draw.Point(2,3),D=C.div(2);expect(D.x).toEqual(1);expect(D.y).toEqual(1.5);expect(D).toNotBe(C)})});describe("dot",function(){it("should return a dot product (scalar) of two vectors",function(){var E=new Ext.draw.Point(2,0),G=new Ext.draw.Point(0,3),F=new Ext.draw.Point(3,4),D=E.dot(G),C=E.dot(F);expect(D).toEqual(0);expect(C).toEqual(6);expect(C).toNotBe(E)})});describe("equals",function(){it("should check if the respective coordinates of this point and provided point are equal",function(){var E=new Ext.draw.Point(2,0),D=new Ext.draw.Point({x:2,y:0}),C=E.equals(D);expect(C).toBe(true)})});describe("rotate",function(){it("should rotate the point (around origin and an arbitrary point) by a specified angle",function(){var G=new Ext.draw.Point(1,0),C=new Ext.draw.Point(0,1),H=45,E=45/180*Math.PI,F=G.rotate(H),D=G.rotate(H,C);expect(F.x).toEqual(Math.cos(E));expect(F.y).toEqual(Math.sin(E));expect(D.x).toBeCloseTo(Math.sqrt(2),A);expect(D.y).toBeCloseTo(1,A)})});describe("transform",function(){it("should transform a point from one coordinate system to another given a transformation matrix or its elements",function(){var D=new Ext.draw.Point(2,0),C=new Ext.draw.Matrix(),E;C.translate(1,1);C.rotate(Math.PI/2);C.scale(2);E=D.transform(C);expect(E.x).toBeCloseTo(1,A);expect(E.y).toBeCloseTo(5,A);E=D.transform.apply(D,C.elements);expect(E.x).toBeCloseTo(1,A);expect(E.y).toBeCloseTo(5,A)})});describe("normalize",function(){it("should return a new vector with the length of 1 and the same angle",function(){var F=new Ext.draw.Point(5,5),D=Math.cos(Math.PI/4),E=F.normalize(),C=F.normalize(5);expect(E.x).toBeCloseTo(D,A);expect(E.y).toBeCloseTo(D,A);expect(E.length).toBeCloseTo(1,A);expect(E.angle).toBeCloseTo(45,A);expect(C.x).toBeCloseTo(5*D,A);expect(C.y).toBeCloseTo(5*D,A);expect(C.length).toBeCloseTo(5,A);expect(C.angle).toBeCloseTo(45,A)})});describe("getDistanceToLine",function(){it("should return a distance from the point to the line (as a vector)",function(){var F=new Ext.draw.Point(1,1),H=new Ext.draw.Point(1,2),E=new Ext.draw.Point(2,1),D=F.getDistanceToLine(H,E),C=F.getDistanceToLine(1,2,2,1),G=Math.sqrt(2)/2;expect(D.length).toBeCloseTo(G,A);expect(C.length).toBeCloseTo(G,A)})})})