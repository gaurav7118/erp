Ext.Base=(function(C){var B=[],J,M=[],N=function(R,Q){var T=this,P,O,S;if(R){O=Ext.Config.map[R];if(!O){Ext.Logger.error("Invalid property name for getter: '"+R+"' for '"+T.$className+"'.")}S=O.names.get;if(Q&&T.hasOwnProperty(S)){P=T.config[R]}else{P=T[S]()}}else{P=T.getCurrentConfig()}return P},D=function(P,O,R){var Q='"'+P+'" is deprecated.';if(R){Q+=" "+R}else{if(O){Q+=' Please use "'+O+'" instead.'}}return function(){Ext.raise(Q)}},K=function(P,Q,O,R){if(!R){R='"'+Q+'" is deprecated.'}if(O){R+=' Please use "'+O+'" instead.'}if(R){Ext.Object.defineProperty(P,Q,{get:function(){Ext.raise(R)},set:function(S){Ext.raise(R)},configurable:true})}},G=function(O){return function(){return this[O].apply(this,arguments)}},A=Ext.Version,I=/^\d/,L={},F={},H=function(){},E=H.prototype;Ext.apply(H,{$className:"Ext.Base",$isClass:true,create:function(){return Ext.create.apply(Ext,[this].concat(Array.prototype.slice.call(arguments,0)))},addDeprecations:function(V){var f=this,P=[],R=Ext.getCompatVersion(V.name),e=f.getConfigurator(),S=(f.$className||"")+"#",d,Z,U,a,g,X,c,W,b,h,Y,O,T,Q;for(Z in V){if(I.test(Z)){Q=new Ext.Version(Z);Q.deprecations=V[Z];P.push(Q)}}P.sort(A.compare);for(U=P.length;U--;){d=(Q=P[U]).deprecations;g=f.prototype;T=d.statics;X=R&&R.lt(Q);if(!X){}else{if(!X){break}}while(d){b=d.methods;if(b){for(h in b){O=b[h];W=null;if(!O){Ext.Assert.isNotDefinedProp(g,h);W=D(S+h)}else{if(Ext.isString(O)){Ext.Assert.isNotDefinedProp(g,h);Ext.Assert.isDefinedProp(g,O);if(X){W=G(O)}else{W=D(S+h,O)}}else{a="";if(O.message||O.fn){a=O.message;O=O.fn}c=g.hasOwnProperty(h)&&g[h];if(X&&O){O.$owner=f;O.$name=h;O.name=S+h;if(c){O.$previous=c}W=O}else{if(!c){W=D(S+h,null,a)}}}}if(W){g[h]=W}}}b=d.configs;if(b){e.addDeprecations(b)}b=d.properties;if(b&&!X){for(h in b){Y=b[h];if(Ext.isString(Y)){K(g,S+h,Y)}else{if(Y&&Y.message){K(g,S+h,null,Y.message)}else{K(g,S+h)}}}}d=T;T=null;g=f}}},extend:function(S){var U=this,O=S.prototype,Q,R,T,P,V;Q=U.prototype=Ext.Object.chain(O);Q.self=U;U.superclass=Q.superclass=O;if(!S.$isClass){for(R in E){if(R in Q){Q[R]=E[R]}}}V=O.$inheritableStatics;if(V){for(R=0,T=V.length;R<T;R++){P=V[R];if(!U.hasOwnProperty(P)){U[P]=S[P]}}}if(S.$onExtended){U.$onExtended=S.$onExtended.slice()}U.getConfigurator()},$onExtended:[],triggerExtended:function(){Ext.classSystemMonitor&&Ext.classSystemMonitor(this,"Ext.Base#triggerExtended",arguments);var Q=this.$onExtended,P=Q.length,O,R;if(P>0){for(O=0;O<P;O++){R=Q[O];R.fn.apply(R.scope||this,arguments)}}},onExtended:function(P,O){this.$onExtended.push({fn:P,scope:O});return this},addStatics:function(O){this.addMembers(O,true);return this},addInheritableStatics:function(P){var T,O,R=this.prototype,Q,U;T=R.$inheritableStatics;O=R.$hasInheritableStatics;if(!T){T=R.$inheritableStatics=[];O=R.$hasInheritableStatics={}}var S=Ext.getClassName(this)+".";for(Q in P){if(P.hasOwnProperty(Q)){U=P[Q];if(typeof U=="function"){U.name=S+Q}this[Q]=U;if(!O[Q]){O[Q]=true;T.push(Q)}}}return this},addMembers:function(b,R,c){var d=this,Q=Ext.Function.clone,e=R?d:d.prototype,U=!R&&e.defaultConfig,Y=Ext.enumerables,Z=b.privates,T,X,S,O,f,W,a;var P=(d.$className||"")+"#";if(Z){delete b.privates;if(!R){a=Z.statics;delete Z.statics}W=Z.privacy||c||"framework";d.addMembers(Z,R,W);if(a){d.addMembers(a,true,W)}}for(f in b){if(b.hasOwnProperty(f)){O=b[f];if(c===true){c="framework"}if(O&&O.$nullFn&&c!==O.$privacy){Ext.raise("Cannot use stock function for private method "+(d.$className?d.$className+"#":"")+f)}if(typeof O==="function"&&!O.$isClass&&!O.$nullFn){if(O.$owner){O=Q(O)}if(e.hasOwnProperty(f)){O.$previous=e[f]}O.$owner=d;O.$name=f;O.name=P+f;var V=e[f];if(c){O.$privacy=c;if(V&&V.$privacy&&V.$privacy!==c){Ext.privacyViolation(d,V,O,R)}}else{if(V&&V.$privacy){Ext.privacyViolation(d,V,O,R)}}}else{if(U&&(f in U)&&!e.config.hasOwnProperty(f)){(T||(T={}))[f]=O;continue}}e[f]=O}}if(T){d.addConfig(T)}if(Y){for(X=0,S=Y.length;X<S;++X){if(b.hasOwnProperty(f=Y[X])){O=b[f];if(O&&!O.$nullFn){if(O.$owner){O=Q(O)}O.$owner=d;O.$name=f;O.name=P+f;if(e.hasOwnProperty(f)){O.$previous=e[f]}}e[f]=O}}}return this},addMember:function(O,P){L[O]=P;this.addMembers(L);delete L[O];return this},borrow:function(U,O){Ext.classSystemMonitor&&Ext.classSystemMonitor(this,"Ext.Base#borrow",arguments);var Q=U.prototype,S={},R,T,P;O=Ext.Array.from(O);for(R=0,T=O.length;R<T;R++){P=O[R];S[P]=Q[P]}return this.addMembers(S)},override:function(P){var R=this,U=P.statics,T=P.inheritableStatics,Q=P.config,O=P.mixins,S=P.cachedConfig;if(U||T||Q){P=Ext.apply({},P)}if(U){R.addMembers(U,true);delete P.statics}if(T){R.addInheritableStatics(T);delete P.inheritableStatics}if(Q){R.addConfig(Q);delete P.config}if(S){R.addCachedConfig(S);delete P.cachedConfig}delete P.mixins;R.addMembers(P);if(O){R.mixin(O)}return R},callParent:function(O){var P;return(P=this.callParent.caller)&&(P.$previous||((P=P.$owner?P:P.caller)&&P.$owner.superclass.self[P.$name])).apply(this,O||B)},callSuper:function(O){var P;return(P=this.callSuper.caller)&&((P=P.$owner?P:P.caller)&&P.$owner.superclass.self[P.$name]).apply(this,O||B)},mixin:function(O,P){var U=this,a,W,Z,V,Q,T,Y,X,S;if(typeof O!=="string"){S=O;if(S instanceof Array){for(Q=0,T=S.length;Q<T;Q++){a=S[Q];U.mixin(a.prototype.mixinId||a.$className,a)}}else{for(var R in S){U.mixin(R,S[R])}}return }a=P.prototype;W=U.prototype;if(a.onClassMixedIn){a.onClassMixedIn.call(P,U)}if(!W.hasOwnProperty("mixins")){if("mixins" in W){W.mixins=Ext.Object.chain(W.mixins)}else{W.mixins={}}}for(Z in a){X=a[Z];if(Z==="mixins"){Ext.applyIf(W.mixins,X)}else{if(!(Z==="mixinId"||Z==="config")&&(W[Z]===undefined)){W[Z]=X}}}V=a.$inheritableStatics;if(V){for(Q=0,T=V.length;Q<T;Q++){Y=V[Q];if(!U.hasOwnProperty(Y)){U[Y]=P[Y]}}}if("config" in a){U.addConfig(a.config,P)}W.mixins[O]=a;if(a.afterClassMixedIn){a.afterClassMixedIn.call(P,U)}return U},addConfig:function(P,Q){var O=this.$config||this.getConfigurator();O.add(P,Q)},addCachedConfig:function(O,Q){var R={},P;for(P in O){R[P]={cached:true,$value:O[P]}}this.addConfig(R,Q)},getConfigurator:function(){return this.$config||new Ext.Configurator(this)},getName:function(){return Ext.getClassName(this)},createAlias:C(function(P,O){F[P]=function(){return this[O].apply(this,arguments)};this.override(F);delete F[P]})});for(J in H){if(H.hasOwnProperty(J)){M.push(J)}}H.$staticMembers=M;H.getConfigurator();H.addMembers({$className:"Ext.Base",isInstance:true,$configPrefixed:true,$configStrict:true,isConfiguring:false,isFirstInstance:false,destroyed:false,statics:function(){var P=this.statics.caller,O=this.self;if(!P){return O}return P.$owner},callParent:function(Q){var S,O=(S=this.callParent.caller)&&(S.$previous||((S=S.$owner?S:S.caller)&&S.$owner.superclass[S.$name]));if(!O){S=this.callParent.caller;var R,P;if(!S.$owner){if(!S.caller){throw new Error("Attempting to call a protected method from the public scope, which is not allowed")}S=S.caller}R=S.$owner.superclass;P=S.$name;if(!(P in R)){throw new Error("this.callParent() was called but there's no such method ("+P+") found in the parent class ("+(Ext.getClassName(R)||"Object")+")")}}return O.apply(this,Q||B)},callSuper:function(Q){var S,O=(S=this.callSuper.caller)&&((S=S.$owner?S:S.caller)&&S.$owner.superclass[S.$name]);if(!O){S=this.callSuper.caller;var R,P;if(!S.$owner){if(!S.caller){throw new Error("Attempting to call a protected method from the public scope, which is not allowed")}S=S.caller}R=S.$owner.superclass;P=S.$name;if(!(P in R)){throw new Error("this.callSuper() was called but there's no such method ("+P+") found in the parent class ("+(Ext.getClassName(R)||"Object")+")")}}return O.apply(this,Q||B)},self:H,constructor:function(){return this},getConfigurator:function(){return this.$config||this.self.getConfigurator()},initConfig:function(Q){var P=this,O=P.getConfigurator();P.initConfig=Ext.emptyFn;P.initialConfig=Q||{};O.configure(P,Q);return P},beforeInitConfig:Ext.emptyFn,getConfig:N,setConfig:function(Q,S,P){var R=this,O;if(Q){if(typeof Q==="string"){O={};O[Q]=S}else{O=Q}R.getConfigurator().reconfigure(R,O,P)}return R},getCurrentConfig:function(){var O=this.getConfigurator();return O.getCurrentConfig(this)},hasConfig:function(O){return O in this.defaultConfig},getInitialConfig:function(P){var O=this.config;if(!P){return O}return O[P]},$links:null,link:function(P,R){var Q=this,O=Q.$links||(Q.$links={});O[P]=true;Q[P]=R;return R},unlink:function(T){var R=this,O,Q,P,S;if(!Ext.isArray(T)){Ext.raise("Invalid argument - expected array of strings")}for(O=0,Q=T.length;O<Q;O++){P=T[O];S=R[P];if(S){if(S.isInstance&&!S.destroyed){S.destroy()}else{if(S.parentNode&&"nodeType" in S){S.parentNode.removeChild(S)}}}R[P]=null}return R},destroy:function(){var P=this,O=P.$links;P.initialConfig=P.config=null;P.destroy=Ext.emptyFn;P.isDestroyed=P.destroyed=true;if(O){P.$links=null;P.unlink(Ext.Object.getKeys(O))}}});E.callOverridden=E.callParent;Ext.privacyViolation=function(W,P,R,U){var O=R.$name,V=P.$owner&&P.$owner.$className,X=U?"static ":"",Q=R.$privacy?"Private "+X+R.$privacy+' method "'+O+'"':"Public "+X+'method "'+O+'"';if(W.$className){Q=W.$className+": "+Q}if(!P.$privacy){Q+=V?" hides public method inherited from "+V:" hides inherited public method."}else{Q+=V?" conflicts with private "+P.$privacy+" method declared by "+V:" conflicts with inherited private "+P.$privacy+" method."}var T=Ext.getCompatVersion();var S=Ext.getVersion();if(S&&T&&T.lt(S)){Ext.log.error(Q)}else{Ext.raise(Q)}};return H}(Ext.Function.flexSetter))