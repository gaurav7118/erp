Ext.define("Ext.data.matrix.Slice",{constructor:function(A,B){this.id=B;this.side=A;this.members={}},attach:function(A){var B=this;Ext.Assert.falsey(B.store,"Store is already attached");B.store=A;A.matrix=B;A.on("load",B.onStoreLoad,B,{single:true})},commit:function(){var A=this.members,B;for(B in A){A[B][2]=0}},onStoreLoad:function(A){this.update(A.getData().items,0)},update:function(L,F){if(!(L instanceof Array)){Ext.raise("Only array of records or record ids are supported")}var R=this,H=Ext.data.matrix.Slice,C=R.side,I=C.index,E=L.length,K=R.id,Q=R.members,B=C.inverse,P=B.slices,G,N,M,O,A,J,D;for(M=0;M<E;++M){N=D=null;O=L[M];A=O.isEntity?(D=O).id:O;G=Q[A];if(F<0&&G&&G[2]===1){delete Q[A];J=P[A];if(J){delete J.members[K]}N=1}else{if(!G){G=[A,A,F];G[I]=K;Q[A]=G;J=P[A];if(!J){P[A]=J=new H(B,A)}J.members[K]=G;N=1}else{if(F!==G[2]&&F!==0){G[2]=F;J=P[A];N=1}}}if(N){if(R.notify){R.notify.call(R.scope,R,A,F)}if(J&&J.notify){J.notify.call(J.scope,J,K,F)}}}},updateId:function(B){var I=this,A=I.id,H=I.side,L=H.slices,K=L[A],C=K.members,F=H.index,D=H.inverse.slices,G,E,J;I.id=B;L[B]=K;delete L[A];for(E in C){G=C[E];G[F]=B;J=D[E].members;J[B]=J[A];delete J[A]}},destroy:function(){var B=this,A=B.store;if(A){A.matrix=null;A.un("load",B.onStoreLoad,B)}B.notify=B.scope=B.store=B.side=B.members=null;B.callParent()}})