Ext.define("Ext.promise.Deferred",{requires:["Ext.promise.Consequence"],promise:null,consequences:[],completed:false,completionAction:null,completionValue:null,constructor:function(){var A=this;A.promise=new Ext.promise.Promise(A);A.consequences=[];A.completed=false;A.completionAction=null;A.completionValue=null},then:function(E,A,D){var C=this,B=new Ext.promise.Consequence(E,A,D);if(C.completed){B.trigger(C.completionAction,C.completionValue)}else{C.consequences.push(B)}return B.promise},resolve:function(D){var C=this,A,B;if(C.completed){return }try{if(D===C.promise){throw new TypeError("A Promise cannot be resolved with itself.")}if((Ext.isObject(D)||Ext.isFunction(D))&&Ext.isFunction(B=D.then)){A=false;try{B.call(D,function(F){if(!A){A=true;C.resolve(F)}},function(F){if(!A){A=true;C.reject(F)}})}catch(E){if(!A){C.reject(E)}}}else{C.complete("fulfill",D)}}catch(E){C.reject(E)}},reject:function(A){if(this.completed){return }this.complete("reject",A)},update:function(B){var E=this.consequences,D,C,A;if(this.completed){return }for(C=0,A=E.length;C<A;C++){D=E[C];D.update(B)}},complete:function(F,E){var D=this,G=D.consequences,C,B,A;D.completionAction=F;D.completionValue=E;D.completed=true;for(B=0,A=G.length;B<A;B++){C=G[B];C.trigger(D.completionAction,D.completionValue)}D.consequences=null}})