Ext.define("Ext.promise.Promise",function(B){var A;return{requires:["Ext.promise.Deferred"],statics:{CancellationError:Ext.global.CancellationError||Error,_ready:function(){A=Ext.promise.Deferred},all:function(C){if(!(Ext.isArray(C)||B.is(C))){Ext.raise("Invalid parameter: expected an Array or Promise of an Array.")}return B.when(C).then(function(E){var L=new A(),H=E.length,F=new Array(H),J,D,K,G,I;if(!H){L.resolve(F)}else{K=function(N,M){return B.when(N).then(function(O){F[M]=O;if(!--H){L.resolve(F)}return O},function(O){return L.reject(O)})};for(J=G=0,I=E.length;G<I;J=++G){D=E[J];if(J in E){K(D,J)}else{H--}}}return L.promise})},is:function(C){return(Ext.isObject(C)||Ext.isFunction(C))&&Ext.isFunction(C.then)},rethrowError:function(C){Ext.asap(function(){throw C})},when:function(D){var C=new Ext.promise.Deferred();C.resolve(D);return C.promise}},owner:null,constructor:function(C){this.owner=C},then:function(G,C,F,D){var E;if(arguments.length===1&&Ext.isObject(arguments[0])){E=arguments[0];G=E.success;C=E.failure;F=E.progress;D=E.scope}if(D){if(G){G=Ext.Function.bind(G,D)}if(C){C=Ext.Function.bind(C,D)}if(F){F=Ext.Function.bind(F,D)}}return this.owner.then(G,C,F)},otherwise:function(C,D){var E;if(arguments.length===1&&Ext.isObject(arguments[0])){E=arguments[0];C=E.fn;D=E.scope}if(D!=null){C=Ext.Function.bind(C,D)}return this.owner.then(null,C)},always:function(C,D){var E;if(arguments.length===1&&Ext.isObject(arguments[0])){E=arguments[0];C=E.fn;D=E.scope}if(D!=null){C=Ext.Function.bind(C,D)}return this.owner.then(function(F){try{C()}catch(G){B.rethrowError(G)}return F},function(G){try{C()}catch(F){B.rethrowError(F)}throw G})},done:function(){this.owner.then(null,B.rethrowError)},cancel:function(C){if(C==null){C=null}this.owner.reject(new this.self.CancellationError(C))},log:function(C){if(C==null){C=""}return this._owner.then(function(D){Ext.log(""+(C||"Promise")+" resolved with value: "+D);return D},function(D){Ext.log(""+(C||"Promise")+" rejected with reason: "+D);throw D})}}},function(A){A._ready()})