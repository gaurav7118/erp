Ext.define("Ext.util.MixedCollection",{extend:"Ext.util.AbstractMixedCollection",mixins:{sortable:"Ext.util.Sortable"},constructor:function(){this.initConfig();this.callParent(arguments)},doSort:function(A){this.sortBy(A)},_sort:function(J,B,I){var H=this,D,E,C=String(B).toUpperCase()=="DESC"?-1:1,G=[],K=H.keys,F=H.items,A;I=I||function(M,L){return M-L};for(D=0,E=F.length;D<E;D++){G[G.length]={key:K[D],value:F[D],index:D}}Ext.Array.sort(G,function(M,L){return I(M[J],L[J])*C||(M.index<L.index?-1:1)});for(D=0,E=G.length;D<E;D++){A=G[D];F[D]=A.value;K[D]=A.key;H.indexMap[A.key]=D}H.generation++;H.indexGeneration=H.generation;H.fireEvent("sort",H)},sortBy:function(B){var H=this,A=H.items,G,F=H.keys,D,E=A.length,C;for(C=0;C<E;C++){A[C].$extCollectionIndex=C}Ext.Array.sort(A,function(J,I){return B(J,I)||(J.$extCollectionIndex<I.$extCollectionIndex?-1:1)});for(C=0;C<E;C++){G=A[C];D=H.getKey(G);F[C]=D;H.indexMap[D]=C;delete A.$extCollectionIndex}H.generation++;H.indexGeneration=H.generation;H.fireEvent("sort",H,A,F)},findInsertionIndex:function(E,D){var F=this,B=F.items,H=0,A=B.length-1,C,G;if(!D){D=F.generateComparator()}while(H<=A){C=(H+A)>>1;G=D(E,B[C]);if(G>=0){H=C+1}else{if(G<0){A=C-1}}}return H},reorder:function(A){this.callParent([A]);this.fireEvent("sort",this)},sortByKey:function(A,B){this._sort("key",A,B||function(D,C){var F=String(D).toUpperCase(),E=String(C).toUpperCase();return F>E?1:(F<E?-1:0)})}})