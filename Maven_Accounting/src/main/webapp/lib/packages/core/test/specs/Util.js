describe("Ext.Util",function(){describe("Ext.callback",function(){var A;beforeEach(function(){A=jasmine.createSpy()});it("should not fail if given a null callback",function(){expect(function(){Ext.callback(null)}).not.toThrow()});it("should not fail if given an undefined callback",function(){expect(function(){Ext.callback(undefined)}).not.toThrow()});it("should not fail if given an invalid callback",function(){expect(function(){Ext.callback(42)}).not.toThrow()});it("should pass arguments to the callback function",function(){Ext.callback(A,fakeScope,[1,2,3,4,6]);expect(A).toHaveBeenCalledWith(1,2,3,4,6)});it("should be able to defer function call",function(){runs(function(){Ext.callback(A,undefined,[1,2,3,4,6],1);expect(A).not.toHaveBeenCalled()});waitsFor(function(){return A.callCount>0},"deferred callback never called");runs(function(){expect(A).toHaveBeenCalledWith(1,2,3,4,6)})});it("should return the return value of the given function",function(){var B=0,C=function(E){return B=this.z*10+E},D=Ext.callback(C,{z:42},[7]);expect(B).toBe(427);expect(D).toBe(427)});describe("scoping",function(){describe("with a function",function(){describe("scope 'this'",function(){it("should resolve the scope to the defaultScope",function(){Ext.callback(A,"this",undefined,undefined,undefined,fakeScope);expect(A.mostRecentCall.object).toBe(fakeScope)});it("should resolve the scope to the caller",function(){Ext.callback(A,"this",undefined,undefined,fakeScope);expect(A.mostRecentCall.object).toBe(fakeScope)});it("should prefer the defaultScope to the caller",function(){Ext.callback(A,"this",undefined,undefined,{},fakeScope);expect(A.mostRecentCall.object).toBe(fakeScope)});it("should fallback to global scope if no caller is passed",function(){Ext.callback(A,"this");expect(A.mostRecentCall.object).toBe(Ext.global)})});describe("scope 'controller'",function(){it("should resolve the scope to the defaultScope",function(){Ext.callback(A,"controller",undefined,undefined,undefined,fakeScope);expect(A.mostRecentCall.object).toBe(fakeScope)});it("should resolve the scope to the caller",function(){Ext.callback(A,"controller",undefined,undefined,fakeScope);expect(A.mostRecentCall.object).toBe(fakeScope)});it("should prefer the defaultScope to the caller",function(){Ext.callback(A,"controller",undefined,undefined,{},fakeScope);expect(A.mostRecentCall.object).toBe(fakeScope)});it("should fallback to global scope if no caller is passed",function(){Ext.callback(A,"controller");expect(A.mostRecentCall.object).toBe(Ext.global)})});it("should execute the passed function in the specified scope",function(){Ext.callback(A,fakeScope);expect(A.mostRecentCall.object).toBe(fakeScope)});it("should default the scope to Ext.global",function(){Ext.callback(A);expect(A.mostRecentCall.object).toBe(Ext.global)})});describe("with a string",function(){var B;beforeEach(function(){B={foo:function(){}};spyOn(B,"foo")});describe("without caller",function(){it("should throw if no scope is passed",function(){expect(function(){Ext.callback("foo")}).toThrow()});it("should throw if the method cannot be found on the passed scope",function(){expect(function(){Ext.callback("foo",{})}).toThrow()});it("should throw if passed 'this' as scope",function(){expect(function(){Ext.callback("foo","this")}).toThrow()});it("should throw if passed 'controller' as scope",function(){expect(function(){Ext.callback("foo","controller")}).toThrow()});it("should call the resolved method on the passed scope",function(){Ext.callback("foo",B);expect(B.foo).toHaveBeenCalled();expect(B.foo.mostRecentCall.object).toBe(B)});it("should retain scope on defer",function(){runs(function(){Ext.callback("foo",B,undefined,1);expect(B.foo).not.toHaveBeenCalled()});waitsFor(function(){return B.foo.callCount>0},"deferred callback never called");runs(function(){expect(B.foo).toHaveBeenCalled();expect(B.foo.mostRecentCall.object).toBe(B)})})});describe("with caller",function(){var D,C;beforeEach(function(){D={foo:function(){}};C={resolveListenerScope:function(){return D}};spyOn(D,"foo")});describe("object scope",function(){it("should favour a passed scope",function(){Ext.callback("foo",B,undefined,undefined,C);expect(B.foo).toHaveBeenCalled();expect(B.foo.mostRecentCall.object).toBe(B);expect(D.foo).not.toHaveBeenCalled()});it("should throw if the method cannot be found on the passed caller",function(){expect(function(){Ext.callback("fake",undefined,undefined,undefined,C)}).toThrow()});it("should call the resolved method on the passed scope",function(){Ext.callback("foo",undefined,undefined,undefined,C);expect(D.foo).toHaveBeenCalled();expect(D.foo.mostRecentCall.object).toBe(C.resolveListenerScope())});it("should retain scope on defer",function(){runs(function(){Ext.callback("foo",undefined,undefined,1,C);expect(D.foo).not.toHaveBeenCalled()});waitsFor(function(){return D.foo.callCount>0},"deferred callback never called");runs(function(){expect(D.foo).toHaveBeenCalled();expect(D.foo.mostRecentCall.object).toBe(C.resolveListenerScope())})})});describe("scope: 'this'",function(){it("should call resolveListenerScope on the caller",function(){spyOn(C,"resolveListenerScope").andCallThrough();Ext.callback("foo","this",undefined,undefined,C);expect(C.resolveListenerScope).toHaveBeenCalledWith("this");expect(D.foo).toHaveBeenCalled();expect(D.foo.mostRecentCall.object).toBe(D)});it("should throw if the method cannot be found on the passed caller",function(){expect(function(){Ext.callback("fake","this",undefined,undefined,C)}).toThrow()});it("should retain scope on defer",function(){runs(function(){Ext.callback("foo","this",undefined,1,C);expect(D.foo).not.toHaveBeenCalled()});waitsFor(function(){return D.foo.callCount>0},"deferred callback never called");runs(function(){expect(D.foo).toHaveBeenCalled();expect(D.foo.mostRecentCall.object).toBe(D)})})});describe("scope: 'controller'",function(){it("should call resolveListenerScope on the caller",function(){spyOn(C,"resolveListenerScope").andCallThrough();Ext.callback("foo","controller",undefined,undefined,C);expect(C.resolveListenerScope).toHaveBeenCalledWith("controller");expect(D.foo).toHaveBeenCalled();expect(D.foo.mostRecentCall.object).toBe(D)});it("should throw if the method cannot be found on the passed caller",function(){expect(function(){Ext.callback("fake","controller",undefined,undefined,C)}).toThrow()});it("should retain scope on defer",function(){runs(function(){Ext.callback("foo","controller",undefined,1,C);expect(D.foo).not.toHaveBeenCalled()});waitsFor(function(){return D.foo.callCount>0},"deferred callback never called");runs(function(){expect(D.foo).toHaveBeenCalled();expect(D.foo.mostRecentCall.object).toBe(D)})})})})})})});describe("copyToIf String[]",function(){var A;var B={a:1,b:"x",c:42};beforeEach(function(){A={a:427}});it("should leave existing properties alone",function(){Ext.copyToIf(A,B,["a"]);expect(A).toEqual({a:427})});it("should add new properties",function(){Ext.copyToIf(A,B,["a","b"]);expect(A).toEqual({a:427,b:"x"})})});describe("copyToIf String",function(){var A;var B={a:1,b:"x",c:42};beforeEach(function(){A={a:427}});it("should leave existing properties alone",function(){Ext.copyToIf(A,B,"a");expect(A).toEqual({a:427})});it("should add new properties",function(){Ext.copyToIf(A,B,"a,b");expect(A).toEqual({a:427,b:"x"})})})})