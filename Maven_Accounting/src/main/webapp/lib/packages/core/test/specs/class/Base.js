describe("Ext.Base",function(){var A;afterEach(function(){A=null});describe("deprecated",function(){afterEach(function(){delete Ext.versions.foo;delete Ext.compatVersions.foo});function B(C){Ext.setCompatVersion("foo",C);A=Ext.define(null,{foo:function(){return"a"},deprecated:{name:"foo",5:{methods:{bar:"foo",foo:function(){return this.callParent()+"d"}}},5.1:{methods:{foo:{fn:function(){return this.callParent()+"c"}}}},"5.2":{methods:{foo:{message:"Foo is bad",fn:function(){return this.callParent()+"b"}}}}}})}describe("no backward compatibility",function(){beforeEach(function(){B("5.2")});it("should not activate methods when compatVersion equals curVersion",function(){var D=new A();var C=D.foo();expect(C).toBe("a")});it("should install error shim from old block",function(){var E=new A();var C="No exception";spyOn(Ext,"log");try{E.bar()}catch(D){C=D.message}expect(C).toBe('"#bar" is deprecated. Please use "foo" instead.')})});describe("one increment of backward compatibility",function(){beforeEach(function(){B("5.1")});it("should activate just one block",function(){var D=new A();var C=D.foo();expect(C).toBe("ab")});it("should install error shim from old block",function(){var E=new A();var C="No exception";spyOn(Ext,"log");try{E.bar()}catch(D){C=D.message}expect(C).toBe('"#bar" is deprecated. Please use "foo" instead.')})});describe("two increments of backward compatibility",function(){beforeEach(function(){B("5")});it("should activate just two blocks",function(){var D=new A();var C=D.foo();expect(C).toBe("abc")});it("should install error shim from old block",function(){var E=new A();var C="No exception";spyOn(Ext,"log");try{E.bar()}catch(D){C=D.message}expect(C).toBe('"#bar" is deprecated. Please use "foo" instead.')})});describe("full backward compatibility",function(){beforeEach(function(){B("4.2")});it("should activate all three blocks",function(){var D=new A();var C=D.foo();expect(C).toBe("abcd")});it("should install alias",function(){var D=new A();var C=D.bar();expect(C).toBe("abcd")})})});describe("borrow",function(){beforeEach(function(){Ext.define("spec.Foo",{a:function(){return"foo a"},b:function(){return"foo b"},c:function(){return"foo c"}});Ext.define("spec.Bar",{a:function(){return"bar a"}})});afterEach(function(){Ext.undefine("spec.Foo");Ext.undefine("spec.Bar")});it("should borrow methods",function(){spec.Bar.borrow(spec.Foo,["b","c"]);var B=new spec.Bar();expect(B.a()).toEqual("bar a");expect(B.b()).toEqual("foo b");expect(B.c()).toEqual("foo c")})});describe("createAlias",function(){var B;function C(E,D){var F={};F[D||"oldFn"]=E;A=Ext.define(null,F)}afterEach(function(){B=null});it("should create a method on the prototype",function(){C(function(){});A.createAlias("newFn","oldFn");expect(Ext.isFunction(A.prototype.newFn)).toBe(true)});it("should call through to the old method with the passed arguments",function(){var E,D;C(function(G,F){E=G;D=F});A.createAlias("newFn","oldFn");B=new A();B.newFn("Val",17);expect(E).toBe("Val");expect(D).toBe(17)});it("should dynamically resolve the old method at runtime",function(){var D=[];C(function(){D.push(1)});A.createAlias("newFn","oldFn");B=new A();B.newFn();A.override({oldFn:function(){D.push(2)}});B.newFn();B.oldFn=function(){D.push(3)};B.newFn();expect(D).toEqual([1,2,3])})});describe("override",function(){describe("mixins",function(){var C,B;beforeEach(function(){C=function(){};B=function(){};Ext.define("spec.Mix1",{extend:"Ext.Mixin",mixinConfig:{id:"mix1"},a:C});Ext.define("spec.Mix2",{extend:"Ext.Mixin",mixinConfig:{id:"mix2"},b:B})});afterEach(function(){C=B=null;Ext.undefine("spec.Mix1");Ext.undefine("spec.Mix2");Ext.undefine("spec.MyBase")});it("should add mixins on a class without mixins",function(){A=Ext.define("spec.MyBase",{});Ext.define(null,{override:"spec.MyBase",mixins:["spec.Mix1"]});expect(A.prototype.a).toBe(C);expect(A.prototype.mixins.mix1).toBe(spec.Mix1.prototype)});it("should add mixins on a class with existing mixins",function(){A=Ext.define("spec.MyBase",{mixins:["spec.Mix1"]});Ext.define(null,{override:"spec.MyBase",mixins:["spec.Mix2"]});expect(A.prototype.a).toBe(C);expect(A.prototype.mixins.mix1).toBe(spec.Mix1.prototype);expect(A.prototype.b).toBe(B);expect(A.prototype.mixins.mix2).toBe(spec.Mix2.prototype)});it("should add mixins when the type differs",function(){A=Ext.define("spec.MyBase",{mixins:{mixFoo:"spec.Mix1"}});Ext.define(null,{override:"spec.MyBase",mixins:["spec.Mix2"]});expect(A.prototype.a).toBe(C);expect(A.prototype.mixins.mixFoo).toBe(spec.Mix1.prototype);expect(A.prototype.b).toBe(B);expect(A.prototype.mixins.mix2).toBe(spec.Mix2.prototype)})})})})