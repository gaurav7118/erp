describe("Ext.Class",function(){var E=function(){},F=function(K){this.initConfig(K)},J,A,G,B,C,I,H,D;beforeEach(function(){G=function(){};I=Ext.define(null,{config:{mixinConfig:"mixinConfig"},constructor:function(K){this.initConfig(K);this.mixinConstructor1Called=true},mixinProperty1:"mixinProperty1",mixinMethod1:function(){this.mixinMethodCalled=true}});H=Ext.define(null,{constructor:function(K){this.initConfig(K);this.mixinConstructor2Called=true},mixinProperty2:"mixinProperty2",mixinMethod2:function(){this.mixinMethodCalled=true}});C=Ext.define(null,{mixins:{mixin1:I},config:{name:"parentClass",isCool:false,members:{abe:"Abraham Elias",ed:"Ed Spencer"},hobbies:["football","bowling"]},constructor:function(K){this.initConfig(K);this.parentConstructorCalled=true;this.mixins.mixin1.constructor.apply(this,arguments)},parentProperty:"parentProperty",parentMethod:function(){this.parentMethodCalled=true}});B=Ext.define(null,{extend:C,mixins:{mixin1:I,mixin2:H},config:{name:"subClass",isCool:true,members:{jacky:"Jacky Nguyen",tommy:"Tommy Maintz"},hobbies:["sleeping","eating","movies"],isSpecial:true},constructor:function(K){this.initConfig(K);this.subConstructorCalled=true;B.superclass.constructor.apply(this,arguments);this.mixins.mixin2.constructor.apply(this,arguments)},myOwnMethod:function(){this.myOwnMethodCalled=true}})});afterEach(function(){D=B,C,I,H=A=J=null});describe("extend",function(){beforeEach(function(){G=function(){};Ext.define("spec.Base",{aProp:1,aFn:G})});afterEach(function(){Ext.undefine("spec.Base")});it("should extend from Base if no 'extend' property found",function(){J=Ext.define(null,{});expect((new J()) instanceof Ext.Base).toBe(true)});describe("extending from a parent",function(){it("class reference",function(){J=Ext.define(null,{extend:spec.Base});expect((new J()) instanceof spec.Base).toBe(true)});it("class string",function(){J=Ext.define(null,{extend:"spec.Base"});expect((new J()) instanceof spec.Base).toBe(true)})});it("should have superclass reference",function(){var K=spec.Base.prototype;J=Ext.define(null,{extend:spec.Base});expect(J.superclass).toBe(K);expect((new J()).superclass).toBe(K)});it("should copy properties from the parent",function(){J=Ext.define(null,{extend:spec.Base});expect(J.prototype.aProp).toBe(1)});it("should copy functions from the parent",function(){J=Ext.define(null,{extend:spec.Base});expect(J.prototype.aFn).toBe(G)})});describe("config",function(){beforeEach(function(){G=function(){}});describe("getter/setter creation",function(){it("should create getter if not exists",function(){J=Ext.define(null,{config:{someName:"someValue"}});expect(J.prototype.getSomeName).toBeDefined()});it("should NOT create getter if already exists",function(){var K=Ext.define(null,{getSomeName:G,config:{someName:"someValue"}});expect(K.prototype.getSomeName).toBe(G)});it("should create setter if not exists",function(){J=Ext.define(null,{config:{someName:"someValue"}});expect(J.prototype.setSomeName).toBeDefined()});it("should NOT create setter if already exists",function(){J=Ext.define(null,{setSomeName:G,config:{someName:"someValue"}});expect(J.prototype.setSomeName).toBe(G)});it("should allow a custom getter to call the generated getter",function(){J=Ext.define(null,{config:{someName:"foo"},constructor:F,getSomeName:function(){return this.callParent().toUpperCase()}});D=new J();expect(D.getSomeName()).toBe("FOO")});it("should allow a custom setter to call the generated setter",function(){J=Ext.define(null,{config:{someName:"foo"},constructor:F,setSomeName:function(K){K=K.toUpperCase();return this.callParent([K])}});D=new J();expect(D.getSomeName()).toBe("FOO")});it("should not set the value if the applier returns undefined",function(){var K=false;J=Ext.define(null,{config:{foo:1},constructor:F,applyFoo:function(L){if(!K){K=true;return L}return undefined}});D=new J();D.setFoo(2);expect(D.getFoo()).toBe(1)});it("should not call the updater if the value does not change",function(){var K=0;J=Ext.define(null,{config:{foo:1},constructor:F,updateFoo:function(){++K}});D=new J();D.setFoo(1);expect(K).toBe(1)});it("should check using === to see if the value changed",function(){var K=0;J=Ext.define(null,{config:{foo:1},constructor:F,updateFoo:function(){++K}});D=new J();D.setFoo("1");expect(K).toBe(2)});describe("when getters are called by other configs' updaters",function(){var L,K;beforeEach(function(){J=Ext.define(null,{config:{foo:1,bar:2},constructor:F,updateFoo:function(){this.getBar()},applyBar:function(M){++L;return M},updateBar:function(){++K}})});it("should only call appliers/updaters once for class configs",function(){L=K=0;D=new J();expect(L).toBe(1);expect(K).toBe(1)});it("should only call appliers/updaters once for instance configs",function(){L=K=0;D=new J({foo:10,bar:20});expect(L).toBe(1);expect(K).toBe(1)})});describe("initialization",function(){describe("default values - no passed config",function(){describe("null",function(){it("should not initialize the config",function(){J=Ext.define(null,{config:{foo:null},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)}});D=new J();expect(D.setFoo).not.toHaveBeenCalled()});it("should not initialize with a custom setter",function(){var K=false;J=Ext.define(null,{config:{foo:null},constructor:F,setFoo:function(){K=true}});D=new J();expect(K).toBe(false)});it("should not initialize with an applier",function(){var K=false;J=Ext.define(null,{config:{foo:null},constructor:F,applyFoo:function(){K=true}});D=new J();expect(K).toBe(false)});it("should not initialize with an updater",function(){var K=false;J=Ext.define(null,{config:{foo:null},constructor:F,updateFoo:function(){K=true}});D=new J();expect(K).toBe(false)})});describe("other values",function(){it("should not call the setter",function(){J=Ext.define(null,{config:{foo:1},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)}});D=new J();expect(D.setFoo).not.toHaveBeenCalled()});it("should call the setter if there is a custom setter",function(){J=Ext.define(null,{config:{foo:1},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)},setFoo:function(){}});D=new J();expect(D.setFoo).toHaveBeenCalled()});it("should call the setter if there is an applier",function(){J=Ext.define(null,{config:{foo:1},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)},applyFoo:function(K){return K}});D=new J();expect(D.setFoo).toHaveBeenCalled()});it("should call the setter if there is an updater",function(){J=Ext.define(null,{config:{foo:1},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)},setFoo:function(){}});D=new J();expect(D.setFoo).toHaveBeenCalled()});it("should call the setter if the value is an object",function(){J=Ext.define(null,{config:{foo:{}},constructor:function(K){spyOn(this,"setFoo");this.initConfig(K)}});D=new J();expect(D.setFoo).toHaveBeenCalled()})})});describe("dependencies",function(){it("should force an initialization if the getter is called during init time for a primitive",function(){var K;J=Ext.define(null,{config:{first:undefined,second:undefined},constructor:F,updateFirst:function(){K=this.getSecond()}});new J({first:1,second:2});expect(K).toBe(2)});it("should have a non-config applied by the time any setter is called with non-strict mode",function(){var K;J=Ext.define(null,{config:{first:undefined},constructor:F,$configStrict:false,applyFirst:function(){K=this.second}});new J({first:1,second:2});expect(K).toBe(2)})})})});describe("get/setConfig",function(){beforeEach(function(){J=Ext.define(null,{config:{foo:1,bar:2},constructor:F})});describe("dependency ordering",function(){var K;function L(){K=[];J=Ext.define(null,{config:{b:"bbb",c:"ccc",a:"aaa"},constructor:F,applyA:function(M){K.push("a="+M)},applyB:function(M){this.getA();K.push("b="+M)},applyC:function(M){this.getB();K.push("c="+M)}})}it("should initialize dependent config first",function(){L();var M=new J();expect(K).toEqual(["a=aaa","b=bbb","c=ccc"])});it("should update configs in dependency order",function(){L();var M=new J();K.length=0;M.setConfig({a:1,c:3,b:2});expect(K).toEqual(["a=1","b=2","c=3"])})});describe("getConfig",function(){it("should be able to get a config by name",function(){D=new J();expect(D.getConfig("bar")).toBe(2)});it("should return all configs if no name is passed",function(){D=new J();expect(D.getConfig()).toEqual({foo:1,bar:2})});it("should throw an exception when asking for a config name that does not exist",function(){spyOn(Ext,"log");D=new J();expect(function(){D.getConfig("fake")}).toThrow()});describe("peek",function(){beforeEach(function(){J=Ext.define(null,{constructor:F,config:{foo:{lazy:true,$value:120}}})});it("should not call the getter if the initGetter has not yet been called",function(){D=new J({foo:1});spyOn(D,"getFoo");D.getConfig("foo",true);expect(D.getFoo).not.toHaveBeenCalled()});it("should return the pending value configured on the instance",function(){D=new J({foo:1});expect(D.getConfig("foo",true)).toBe(1)});it("should return the pending value configured on the class",function(){D=new J();expect(D.getConfig("foo",true)).toBe(120)})})});describe("setConfig",function(){it("should be able to set a config by name",function(){D=new J();D.setConfig("foo",7);expect(D.getFoo()).toBe(7)});it("should be able to set a group of configs at once",function(){D=new J();D.setConfig({foo:6,bar:8});expect(D.getFoo()).toBe(6);expect(D.getBar()).toBe(8)});it("should call the setter for a non-config property if one exists and $configStrict is false",function(){J=Ext.define(null,{$configStrict:false,constructor:F,setBaz:jasmine.createSpy()});D=new J();D.setConfig({baz:100});expect(D.setBaz).toHaveBeenCalledWith(100)});it("should set non-config properties on the instance when the strict option is false and $configStrict is false",function(){J=Ext.define(null,{$configStrict:false,constructor:F});D=new J();D.setConfig("baz",100,{strict:false});expect(D.baz).toBe(100)});it("should be able to handle undefined/null configs",function(){D=new J();expect(function(){D.setConfig(null);D.setConfig(undefined)}).not.toThrow()});it("should return the current instance",function(){D=new J();expect(D.setConfig()).toBe(D)})})});it("should merge properly",function(){var K=new B;expect(K.config).toEqual({mixinConfig:"mixinConfig",name:"subClass",isCool:true,members:{abe:"Abraham Elias",ed:"Ed Spencer",jacky:"Jacky Nguyen",tommy:"Tommy Maintz"},hobbies:["sleeping","eating","movies"],isSpecial:true})});it("should apply default config",function(){var K=new B;expect(K.getName()).toBe("subClass");expect(K.getIsCool()).toBe(true);expect(K.getHobbies()).toEqual(["sleeping","eating","movies"])});it("should apply with supplied config",function(){var K=new B({name:"newName",isCool:false,members:{aaron:"Aaron Conran"}});expect(K.getName()).toBe("newName");expect(K.getIsCool()).toBe(false);expect(K.getMembers().aaron).toBe("Aaron Conran")});it("should not share the same config",function(){var L=new B({name:"newName",isCool:false,members:{aaron:"Aaron Conran"}});var K=new B();expect(K.getName()).not.toBe("newName")});it("should copy objects",function(){var N=new C(),M=new C(),L=N.getMembers(),K=M.getMembers();expect(L).not.toBe(K);expect(L).toEqual(K)});it("should copy arrays",function(){var N=new C(),M=new C(),L=N.getHobbies(),K=M.getHobbies();expect(L).not.toBe(K);expect(L).toEqual(K)});describe("values",function(){it("should set the the config value defined",function(){J=Ext.define(null,{constructor:F,config:{foo:"bar"}});expect((new J()).getFoo()).toBe("bar")});it("should be able to set the config",function(){J=Ext.define(null,{constructor:F,config:{foo:"bar"}});D=new J();D.setFoo("baz");expect(D.getFoo()).toBe("baz");D=null});it("should use the inherited config",function(){J=Ext.define(null,{constructor:F,config:{foo:"bar"}});A=Ext.define(null,{extend:J,config:{foo:"baz"}});expect((new A()).getFoo()).toBe("baz")});it("should inherit the parent value even if not specified in the config block",function(){J=Ext.define(null,{constructor:F,config:{foo:"bar"}});A=Ext.define(null,{extend:J,config:{herp:"derp"}});expect((new A()).getFoo()).toBe("bar")})});describe("value on prototype",function(){it("should read the value from the prototype in a subclass",function(){J=Ext.define(null,{constructor:F,config:{foo:"bar"}});A=Ext.define(null,{extend:J,foo:"baz"});expect((new A()).getFoo()).toBe("baz")});it("should remove the property from the prototype",function(){J=Ext.define(null,{constructor:F,config:{foo:"bar"}});A=Ext.define(null,{extend:J,foo:"baz"});expect(A.prototype.foo).toBeUndefined()});it("should favour the property on the config",function(){J=Ext.define(null,{constructor:F,foo:"baz",config:{foo:"bar"}});expect((new J()).getFoo()).toBe("bar")});it("should favour the property on the prototype in a subclass",function(){J=Ext.define(null,{constructor:F,config:{foo:"bar"}});A=Ext.define(null,{extend:J,foo:"baz"});expect((new A()).getFoo()).toBe("baz")});it("should pull the property from the prototype in the subclass if it exists on the parent prototype",function(){J=Ext.define(null,{constructor:F,foo:"baz",config:{foo:"bar"}});A=Ext.define(null,{extend:J,foo:"bleh"});expect((new A()).getFoo()).toBe("bleh")})});describe("$configStrict",function(){describe("initial config",function(){it("should copy non-configs to the instance when true",function(){J=Ext.define(null,{$configStrict:true,config:{foo:"bar"},constructor:F});D=new J({baz:1});expect(D.baz).toBe(1)});it("should not copy non-configs to the instance when true if the class has a non-$nullFn method by the same name",function(){Ext.define("spec.MyClass",{$configStrict:true,config:{foo:"bar"},constructor:F,baz:function(){}});expect(function(){D=new spec.MyClass({baz:1})}).toThrow("Cannot override method baz on spec.MyClass instance.");Ext.undefine("spec.MyClass")});it("should copy non-configs to the instance when false if the class has a non-$nullFn method by the same name",function(){J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F,baz:function(){}});D=new J({baz:1});expect(D.baz).toBe(1)});it("should copy non-configs to the instance when false",function(){J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F});D=new J({baz:1});expect(D.baz).toBe(1)});it("should not copy if the subclass sets the property to true",function(){J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F});A=Ext.define(null,{extend:A,$configStrict:true});D=new A({baz:1});expect(D.baz).not.toBeDefined()});it("should copy non-configs to the instance when true if the class has a emptyFn by the same name",function(){J=Ext.define(null,{$configStrict:true,config:{foo:"bar"},constructor:F,baz:Ext.emptyFn});D=new J({baz:1});expect(D.baz).toBe(1)});it("should copy non-configs to the instance when true if the class has a identityFn by the same name",function(){J=Ext.define(null,{$configStrict:true,config:{foo:"bar"},constructor:F,baz:Ext.identityFn});D=new J({baz:1});expect(D.baz).toBe(1)});it("should copy non-configs to the instance when false if the class has a emptyFn by the same name",function(){J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F,baz:Ext.emptyFn});D=new J({baz:1});expect(D.baz).toBe(1)});it("should copy non-configs to the instance when false if the class has a identityFn by the same name",function(){J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F,baz:Ext.identityFn});D=new J({baz:1});expect(D.baz).toBe(1)})});describe("reconfigure",function(){it("should copy non-configs to the instance with warning when true",function(){spyOn(Ext.log,"warn");Ext.define("spec.MyClass",{$configStrict:true,config:{foo:"bar"},constructor:F});D=new spec.MyClass();D.setConfig({baz:1});expect(D.baz).toBe(1);expect(Ext.log.warn).toHaveBeenCalledWith('No such config "baz" for class spec.MyClass');Ext.undefine("spec.MyClass")});it("should copy non-configs to the instance without warning when false",function(){spyOn(Ext.log,"warn");J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F});D=new J();D.setConfig({baz:1});expect(D.baz).toBe(1);expect(Ext.log.warn).not.toHaveBeenCalled()});it("should not copy non-configs to the instance when true if the class has a non-$nullFn method by the same name",function(){Ext.define("spec.MyClass",{$configStrict:true,config:{foo:"bar"},constructor:F,baz:function(){}});D=new spec.MyClass();expect(function(){D.setConfig({baz:1})}).toThrow("Cannot override method baz on spec.MyClass instance.");Ext.undefine("spec.MyClass")});it("should copy non-configs to the instance without warning when false if the class has a non-$nullFn method by the same name",function(){spyOn(Ext.log,"warn");J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F,baz:function(){}});D=new J();D.setConfig({baz:1});expect(D.baz).toBe(1);expect(Ext.log.warn).not.toHaveBeenCalled()});it("should copy non-configs to the instance with warning when true if the class has a emptyFn by the same name",function(){spyOn(Ext.log,"warn");Ext.define("spec.MyClass",{$configStrict:true,config:{foo:"bar"},constructor:F,baz:Ext.emptyFn});D=new spec.MyClass();D.setConfig({baz:1});expect(D.baz).toBe(1);expect(Ext.log.warn).toHaveBeenCalledWith('No such config "baz" for class spec.MyClass');Ext.undefine("spec.MyClass")});it("should copy non-configs to the instance with warning when true if the class has a identityFn by the same name",function(){spyOn(Ext.log,"warn");Ext.define("spec.MyClass",{$configStrict:true,config:{foo:"bar"},constructor:F,baz:Ext.identityFn});D=new spec.MyClass();D.setConfig({baz:1});expect(D.baz).toBe(1);expect(Ext.log.warn).toHaveBeenCalledWith('No such config "baz" for class spec.MyClass');Ext.undefine("spec.MyClass")});it("should copy non-configs to the instance without warning when false if the class has a emptyFn by the same name",function(){spyOn(Ext.log,"warn");J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F,baz:Ext.emptyFn});D=new J();D.setConfig({baz:1});expect(D.baz).toBe(1);expect(Ext.log.warn).not.toHaveBeenCalled()});it("should copy non-configs to the instance without warning when false if the class has a identityFn by the same name",function(){spyOn(Ext.log,"warn");J=Ext.define(null,{$configStrict:false,config:{foo:"bar"},constructor:F,baz:Ext.identityFn});D=new J();D.setConfig({baz:1});expect(D.baz).toBe(1);expect(Ext.log.warn).not.toHaveBeenCalled()});it('should copy a "type" property without warning when true',function(){spyOn(Ext.log,"warn");J=Ext.define(null,{$configStrict:true,config:{foo:"bar"},constructor:F,baz:Ext.emptyFn});D=new J();D.setConfig({type:1});expect(D.type).toBe(1);expect(Ext.log.warn).not.toHaveBeenCalled()})})});describe("$configPrefixed",function(){var K=function(M,L){J=Ext.define(null,{$configPrefixed:!!M,config:{foo:L||"bar"},constructor:F})};it("should use the config name as the instance property when false",function(){K();D=new J();expect(D.foo).toBe("bar")});it("should use _config name as the instance property when true",function(){K(true);D=new J();expect(D._foo).toBe("bar")});it("should allow a subclass to have a different prefix",function(){K(false,{});A=Ext.define(null,{extend:J,$configPrefixed:true});var M=new J(),L=new A();expect(M.foo).toEqual({});expect(L._foo).toEqual({});expect(L.foo).not.toBeDefined()})});describe("meta configs",function(){describe("mixins",function(){it("should inherit meta configs from mixins",function(){var M=0;var K=Ext.define(null,{config:{foo:{lazy:true,$value:42}}});var N=Ext.define(null,{mixins:{mix:K},constructor:function(O){this.initConfig(O)},applyFoo:function(P,O){++M;return P}});D=new N();expect(M).toBe(0);var L=D.getFoo();expect(L).toBe(42);expect(M).toBe(1)});it("should not allow mixins to modify meta configs",function(){var M=0;var K=Ext.define(null,{config:{foo:{lazy:false,$value:1}}});var N=Ext.define(null,{mixins:{mix:K},config:{foo:{lazy:true,$value:2}},constructor:function(O){this.initConfig(O)},applyFoo:function(P,O){++M;return P}});D=new N();expect(M).toBe(0);var L=D.getFoo();expect(L).toBe(2);expect(M).toBe(1)})});describe("cached",function(){describe("caching",function(){it("should not attempt to initialize until the first instance",function(){J=Ext.define(null,{config:{foo:{cached:true,$value:"bar"}}});expect(J.prototype.foo).not.toBeDefined()});it("should not attempt to cache the config if we don't call initConfig",function(){J=Ext.define(null,{config:{foo:{cached:true,$value:"bar"}}});new J();expect(J.prototype.foo).not.toBeDefined()});it("should stamp the value on the prototype after the first instance is created",function(){J=Ext.define(null,{constructor:F,cachedConfig:{foo:"bar"}});D=new J();expect(J.prototype._foo).toBe("bar");expect(D.hasOwnProperty("_foo")).toBe(false)});it("should stamp all values on the prototype after the first instance is created",function(){var K=0;J=Ext.define(null,{constructor:F,cachedConfig:{foo:21,bar:1,baz:3},applyFoo:function(L){++K;return L*this.getBar()},applyBar:function(L){++K;return L*2},applyBaz:function(L){++K;return L*this.getFoo()}});D=new J();expect(J.prototype._foo).toBe(42);expect(J.prototype._bar).toBe(2);expect(J.prototype._baz).toBe(3*42);expect(K).toBe(3);expect(D.hasOwnProperty("_foo")).toBe(false);expect(D.hasOwnProperty("_bar")).toBe(false);expect(D.hasOwnProperty("_baz")).toBe(false);D=new J();expect(K).toBe(3);expect(D.hasOwnProperty("_foo")).toBe(false);expect(D.hasOwnProperty("_bar")).toBe(false);expect(D.hasOwnProperty("_baz")).toBe(false)});it("should work with the cachedConfig notification",function(){J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}}});D=new J();expect(J.prototype._foo).toBe("bar");expect(D.hasOwnProperty("_foo")).toBe(false)});it("should call an applier only once",function(){var M=0;D={};J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}},applyFoo:function(O){++M;D.foo=O;return D}});var L=new J(),K=new J(),N=new J();expect(M).toBe(1);expect(L.getFoo()).toBe(D);expect(K.getFoo()).toBe(D);expect(N.getFoo()).toBe(D)});it("should call the updater only once",function(){var M=0;J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}},updateFoo:function(O){++M}});var L=new J(),K=new J(),N=new J();expect(M).toBe(1)});it("should allow the value to be updated from the config",function(){J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}}});D=new J({foo:"baz"});expect(J.prototype._foo).toBe("bar");expect(D.getFoo()).toBe("baz")});it("should allow the value to be updated from the setter",function(){J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}}});D=new J();D.setFoo("baz");expect(J.prototype._foo).toBe("bar");expect(D.getFoo()).toBe("baz")})});describe("subclassing",function(){it("should initialize the value on the subclass prototype",function(){J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}}});A=Ext.define(null,{extend:J});D=new A();expect(A.prototype._foo).toBe("bar");expect(D.getFoo()).toBe("bar")});it("should be able to override the default value",function(){J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}}});A=Ext.define(null,{extend:J,config:{foo:{cached:true,$value:"baz"}}});D=new A();expect(A.prototype._foo).toBe("baz");expect(D.getFoo()).toBe("baz")});it("should call the applier only once per instance",function(){var L=0,K=0;J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}},applyFoo:function(M){if(this.self===J){++L}else{if(this.self===A){++K}}return M}});A=Ext.define(null,{extend:J});new J();new A();new J();new A();new J();new A();expect(L).toBe(1);expect(K).toBe(1)});it("should retain cached-ness even when overridden in a subclass config",function(){J=Ext.define(null,{constructor:F,config:{foo:{cached:true,$value:"bar"}}});A=Ext.define(null,{config:{foo:"baz"}})});it("should not allow an initially uncached config to be declared as cached",function(){J=Ext.define(null,{config:{foo:1}});spyOn(Ext,"log");expect(function(){Ext.define(null,{extend:J,config:{foo:{cached:true,$value:2}}})}).toThrow()});describe("nulls",function(){it("should allow null overrides in child classes",function(){J=Ext.define(null,{config:{foo:{cached:true,$value:1}},constructor:F});A=Ext.define(null,{extend:J,config:{foo:{cached:true,$value:null}}});new J();new A();expect(J.prototype._foo).toBe(1);expect(A.prototype._foo).not.toBeDefined()});it("should allow null in the base class and value overrides in child classes",function(){J=Ext.define(null,{config:{foo:{cached:true,$value:null}},constructor:F});A=Ext.define(null,{extend:J,config:{foo:{cached:true,$value:1}}});new J();new A();expect(J.prototype._foo).toBe(null);expect(A.prototype._foo).toBe(1)});it("should be able to return to being cached after being nulled out",function(){var K=Ext.define(null,{config:{foo:{cached:true,$value:1}},constructor:F});var M=Ext.define(null,{extend:K,config:{foo:{cached:true,$value:null}}});var L=Ext.define(null,{extend:M,config:{foo:{cached:true,$value:2}}});new K();expect(K.prototype._foo).toBe(1);new M();expect(M.prototype._foo).not.toBeDefined();new L();expect(L.prototype._foo).toBe(2)})})})});describe("lazy",function(){function K(L){return{foo:{lazy:true,$value:L}}}describe("basic construction",function(){it("should not call the applier when instantiated without a config value",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),applyFoo:L});new M();expect(L).not.toHaveBeenCalled()});it("should not call the applier when instantiated with a config value",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),applyFoo:L});new M({foo:100});expect(L).not.toHaveBeenCalled()});it("should not call the updater when instantiated without a config value",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),updateFoo:L});new M();expect(L).not.toHaveBeenCalled()});it("should not call the updater when instantiated with a config value",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),updateFoo:L});new M({foo:100});expect(L).not.toHaveBeenCalled()})});describe("during construction",function(){it("should allow the getter to be called during initConfig by another method",function(){var L=Ext.define(null,{constructor:F,config:Ext.apply({bar:0},K(1)),applyBar:function(){return this.getFoo()+100}});D=new L();expect(D.getBar()).toBe(101)});it("should not call the applier on subsequent get calls",function(){var L=jasmine.createSpy().andReturn(1);var M=Ext.define(null,{constructor:F,config:Ext.apply({bar:0},K(1)),applyFoo:L,applyBar:function(){return this.getFoo()+100}});D=new M();expect(L.callCount).toBe(1);D.getFoo();expect(L.callCount).toBe(1)});it("should not call the updater on subsequent get calls",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:Ext.apply({bar:0},K(1)),updateFoo:L,applyBar:function(){return this.getFoo()+100}});D=new M();expect(L.callCount).toBe(1);D.getFoo();expect(L.callCount).toBe(1)})});describe("value before first get call",function(){describe("from the prototype",function(){it("should have primitives defined on the instance",function(){var L=Ext.define(null,{constructor:F,config:K(1)});var M=new L();expect(M._foo).toBe(1)});it("should not have objects on the instance",function(){var L=Ext.define(null,{constructor:F,config:K({})});var M=new L();expect(M._foo).not.toBeDefined()})});describe("from the instance config",function(){it("should not set the value on the underlying property",function(){var L=Ext.define(null,{constructor:F,config:K({})});var M=new L({foo:{}});expect(M._foo).not.toBeDefined()})});it("should not have configs with a custom setter on the instance",function(){var L=Ext.define(null,{constructor:F,config:K(1),setFoo:function(){this.callParent(arguments);return this}});var M=new L();expect(M._foo).not.toBeDefined()});it("should not have configs with a custom applier on the instance",function(){var L=Ext.define(null,{constructor:F,config:K(1),applyFoo:Ext.identityFn});var M=new L();expect(M._foo).not.toBeDefined()});it("should not have configs with a custom updater on the instance",function(){var L=Ext.define(null,{constructor:F,config:K(1),updateFoo:Ext.emptyFn});var M=new L();expect(M._foo).not.toBeDefined()});it("should not call the getter if set is called",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),getFoo:L});var N=new M();N.setFoo(2);expect(L).not.toHaveBeenCalled()})});describe("first call to get",function(){it("should call the applier on the first get call",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),applyFoo:L});D=new M({});D.getFoo();expect(L).toHaveBeenCalled()});it("should not call the applier on subsequent get calls",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),applyFoo:L});D=new M({});D.getFoo();D.getFoo();D.getFoo();expect(L.callCount).toBe(1)});it("should call the updater on the first get call",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),updateFoo:L});D=new M({});D.getFoo();expect(L).toHaveBeenCalled()});it("should not call the updater on subsequent get calls",function(){var L=jasmine.createSpy();var M=Ext.define(null,{constructor:F,config:K(1),updateFoo:L});D=new M({});D.getFoo();D.getFoo();D.getFoo();expect(L.callCount).toBe(1)});it("should merge any values for objects",function(){var L=Ext.define(null,{constructor:F,config:{foo:{lazy:true,$value:{z:1}}}});D=new L({foo:{y:2}});expect(D.getFoo()).toEqual({y:2,z:1})})});describe("subclassing",function(){it("should inherit laziness from the parent",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:F,config:K(1),applyFoo:M});var N=Ext.define(null,{extend:L});D=new N();expect(M).not.toHaveBeenCalled();D.getFoo();expect(M).toHaveBeenCalled()});it("should inherit laziness from the parent and allow the value to change",function(){var M=jasmine.createSpy().andCallFake(function(O){return O});var L=Ext.define(null,{constructor:F,config:K(1),applyFoo:M});var N=Ext.define(null,{extend:L,config:{foo:9876}});D=new N();expect(M).not.toHaveBeenCalled();expect(D.getFoo()).toBe(9876)});it("should be able to go from lazy -> !lazy",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:F,config:K(1),applyFoo:M});var N=Ext.define(null,{extend:L,config:{foo:{lazy:false,$value:1}}});D=new N();expect(M).toHaveBeenCalled()});it("should be able to go from !lazy -> lazy",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:F,config:{foo:1},applyFoo:M});var N=Ext.define(null,{extend:L,config:K(1)});D=new N();expect(M).not.toHaveBeenCalled();D.getFoo();expect(M).toHaveBeenCalled()});it("should retain laziness on the superclass",function(){var M=jasmine.createSpy();var L=Ext.define(null,{constructor:F,config:K(1),applyFoo:M});var N=Ext.define(null,{extend:L,config:{foo:{lazy:false,$value:2}}});D=new L();expect(M).not.toHaveBeenCalled();D.getFoo();expect(M).toHaveBeenCalled()})})});describe("merge",function(){var L,K,M;beforeEach(function(){L=jasmine.createSpy()});afterEach(function(){K=M=null});describe("during class definition",function(){function N(P,R,Q){K=Ext.define(null,{constructor:F,config:{foo:{merge:L,$value:P}}});if(!Q){M=Ext.define(null,{extend:K,config:{foo:R}})}}function O(P,Q){Ext.undefine("spec.B");M=Ext.define("spec.B",{config:{foo:Q}});K=Ext.define(null,{constructor:F,mixins:[M],config:{foo:{merge:L,$value:P}}})}afterEach(function(){Ext.undefine("spec.B")});it("should not call the merge fn when defining the config",function(){N({},undefined,true);expect(L).not.toHaveBeenCalled()});describe("merge values",function(){var P=[undefined,null,true,"aString",1,new Date(),{},[]];describe("for subclasses",function(){it("should call the merge function for all value combinations",function(){Ext.Array.forEach(P,function(Q){Ext.Array.forEach(P,function(R){L.reset();N(Q,R);expect(L).toHaveBeenCalled()})})})});describe("for mixins",function(){it("should call the merge function for all value combinations",function(){Ext.Array.forEach(P,function(Q){Ext.Array.forEach(P,function(R){L.reset();O(Q,R,false,true);expect(L).toHaveBeenCalled()})})})})});describe("merging",function(){it("should pass the sub value, then super value and whether it is from a mixin",function(){var S={},R={};N(S,R);var Q=L.mostRecentCall;var P=Q.args;expect(Q.object).toBe(M.$config.configs.foo);expect(P[0]).toBe(R);expect(P[1]).toBe(S);expect(P[2]).toBe(M);expect(P[3]).toBeFalsy()});describe("with a mixin",function(){it("should pass the mixinClass",function(){O({},{});var P=L.mostRecentCall.args;expect(P[2]).toBe(K);expect(P[3]).toBe(M)})});it("should pass the scope as the Config instance",function(){N({},{});expect(L.mostRecentCall.object).toBe(M.$config.configs.foo)});it("should set the returned value",function(){L=jasmine.createSpy().andReturn({merged:"ok!"});N({},{});D=new M();expect(D.getFoo()).toEqual({merged:"ok!"})})})});describe("instance values",function(){var N;function O(P,Q){N=Ext.define(null,{constructor:F,config:{foo:{merge:L,$value:P}}});D=new N({foo:Q})}afterEach(function(){N=null});describe("merge values",function(){it("should call the merge function for all value combinations",function(){var P=[undefined,null,true,"aString",1,new Date(),{},[]];Ext.Array.forEach(P,function(Q){Ext.Array.forEach(P,function(R){L.reset();O(Q,R);expect(L).toHaveBeenCalled()})})})});describe("merging",function(){it("should pass the instance value, then class value",function(){var P;O({foo:1},{bar:1});P=L.mostRecentCall.args;expect(P[0]).toEqual({bar:1});expect(P[1]).toEqual({foo:1})});it("should pass the instance",function(){O({},{});expect(L.mostRecentCall.args[2]).toBe(D)});it("should set the returned value",function(){L=jasmine.createSpy().andReturn({merged:"ok!"});O({},{});expect(D.getFoo()).toEqual({merged:"ok!"})})})});describe("subclassing",function(){it("should inherit the merge from the parent",function(){K=Ext.define(null,{constructor:F,config:{foo:{merge:L,$value:null}}});M=Ext.define(null,{extend:K,config:{foo:{}}});L.reset();D=new M({foo:{}});expect(L).toHaveBeenCalled()});it("should be able to set a merge on a subclass",function(){K=Ext.define(null,{constructor:F,config:{foo:1}});M=Ext.define(null,{extend:K,config:{foo:{merge:L,$value:{}}}});L.reset();D=new M({foo:{}});expect(L).toHaveBeenCalled()});it("should be able to override the merge on a superclass",function(){var N=jasmine.createSpy();L=jasmine.createSpy().andReturn({});K=Ext.define(null,{constructor:F,config:{foo:{merge:N,$value:{}}}});M=Ext.define(null,{extend:K,config:{foo:{merge:L,$value:{}}}});N.reset();L.reset();D=new M({foo:{}});expect(N).not.toHaveBeenCalled();expect(L).toHaveBeenCalled()});it("should retain the merge on the superclass",function(){var N=jasmine.createSpy().andReturn({});K=Ext.define(null,{constructor:F,config:{foo:{merge:N,$value:{}}}});M=Ext.define(null,{extend:K,config:{foo:{merge:L,$value:{}}}});N.reset();L.reset();D=new K({foo:{}});expect(N).toHaveBeenCalled();expect(L).not.toHaveBeenCalled()})})})})});describe("statics",function(){beforeEach(function(){G=function(){}});it("should copy static properties to the class",function(){J=Ext.define(null,{statics:{someName:"someValue",someMethod:G}});expect(J.someName).toBe("someValue");expect(J.someMethod).toBe(G)});it("should not copy statics to subclasses",function(){J=Ext.define(null,{statics:{someName:"someValue",someMethod:G}});A=Ext.define(null,{extend:A});expect(A.someName).not.toBeDefined();expect(A.someMethod).not.toBeDefined()})});describe("inheritableStatics",function(){beforeEach(function(){G=function(){}});it("should store names of inheritable static properties",function(){J=Ext.define(null,{inheritableStatics:{someName:"someValue",someMethod:G}});expect((new J()).inheritableStatics).not.toBeDefined();expect(J.someName).toBe("someValue");expect(J.prototype.$inheritableStatics).toEqual(["someName","someMethod"]);expect(J.someMethod).toBe(G)});it("should inherit inheritable statics",function(){J=Ext.define(null,{inheritableStatics:{someName:"someValue",someMethod:G}});A=Ext.define(null,{extend:J});expect(A.someName).toBe("someValue");expect(A.someMethod).toBe(G)});it("should NOT inherit inheritable statics if the class already has it",function(){J=Ext.define(null,{inheritableStatics:{someName:"someValue",someMethod:G}});A=Ext.define(null,{extend:J,statics:{someName:"someOtherValue",someMethod:function(){}}});expect(A.someName).toBe("someOtherValue");expect(A.someMethod).not.toBe(G)})});describe("addStatics",function(){it("single with name - value arguments",function(){var K=false;B.addStatics({staticMethod:function(){K=true}});expect(B.staticMethod).toBeDefined();B.staticMethod();expect(K).toBeTruthy()});it("multiple with object map argument",function(){B.addStatics({staticProperty:"something",staticMethod:function(){}});expect(B.staticProperty).toBe("something");expect(B.staticMethod).toBeDefined()})});describe("override",function(){it("should override",function(){B.override({myOwnMethod:function(){this.isOverridden=true;this.callOverridden(arguments)}});var K=new B;K.myOwnMethod();expect(K.isOverridden).toBe(true);expect(K.myOwnMethodCalled).toBe(true)});it("should override a default config",function(){J=Ext.define(null,{constructor:F,config:{foo:1}});J.override({config:{foo:2}});expect((new J()).getFoo()).toBe(2)});it("should be able to add a new config",function(){J=Ext.define(null,{constructor:F,config:{foo:1}});J.override({config:{bar:2}});expect((new J()).getBar()).toBe(2)})});describe("private methods",function(){var K;beforeEach(function(){spyOn(Ext,"log");K=Ext.define(null,{bar:function(){},privates:{foo:function(){}}})});describe("extend",function(){it("should allow derived class to override a private method w/a private method",function(){expect(function(){Ext.define(null,{extend:K,privates:{foo:function(){}}})}).not.toThrow()});it("should allow derived class to override a public method w/a private method",function(){expect(function(){Ext.define(null,{extend:K,privates:{bar:function(){}}})}).not.toThrow()});it("should throw when derived class overrides a private method",function(){expect(function(){Ext.define(null,{extend:K,foo:function(){}})}).toThrow()});it("should throw when derived class overrides a private method w/a foreign private method",function(){expect(function(){Ext.define(null,{extend:K,privates:{privacy:"user",foo:function(){}}})}).toThrow()})});describe("override",function(){it("should throw when overriding a private method",function(){expect(function(){K.override({foo:function(){}})}).toThrow()});it("should allow overriding a public method w/a private method",function(){expect(function(){K.override({privates:{bar:function(){}}})}).not.toThrow()});it("should allow overriding a private method w/a private method",function(){expect(function(){K.override({privates:{foo:function(){}}})}).not.toThrow()});it("should throw when derived class overrides a private method w/a foreign private method",function(){expect(function(){K.override({privates:{privacy:"user",foo:function(){}}})}).toThrow()})})});describe("define override",function(){var L,K;beforeEach(function(){K=[];function M(){K.push(this.$className)}Ext.define("Foo.UnusedOverride",{override:"Foo.Nothing",foo:function(N){return this.callParent([N*2])}},M);Ext.define("Foo.SingletonOverride",{override:"Foo.Singleton",foo:function(N){return this.callParent([N*2])}},M);Ext.define("Foo.Singleton",{singleton:true,foo:function(N){return N}});Ext.define("Foo.SomeBase",{patchedMethod:function(N){return N+"A"},statics:{patchedStaticMethod:function(N){return N+"a"},staticMethod:function(N){return"A"+N}}});Ext.define("Foo.SomeClass",{extend:"Foo.SomeBase",prop:1,constructor:function(){this.prop=2},method1:function(N){return"b"+N},patchedMethod:function(){return this.callParent()+"B"},statics:{patchedStaticMethod:function(N){return this.callParent(arguments)+"b"},staticMethod:function(N){return"B"+this.callParent(arguments)}}});Ext.define("Foo.SomeClassOverride",{override:"Foo.SomeClass",constructor:function(){this.callParent(arguments);this.prop*=21},method1:function(N){return"a"+this.callParent([N*2])+"c"},method2:function(){return"two"},patchedMethod:function(N){return this.callSuper(arguments)+"C"},statics:{newStatic:function(){return"boo"},patchedStaticMethod:function(N){return this.callSuper(arguments)+"c"},staticMethod:function(N){return"Z"+this.callParent([N*2])+"!"}}},M);L=Ext.create("Foo.SomeClass")});afterEach(function(){Ext.each(["Foo.SingletonOverride","Foo.Singleton","Foo.SomeClassOverride","Foo.SomeBase","Foo.SomeClass"],function(M){Ext.undefine(M)});Ext.undefine("Foo");delete Ext.ClassManager.nameCreatedListeners["Foo.Nothing"];L=K=null});it("should call the createdFn",function(){expect(K.length).toBe(2);expect(K[0]).toBe("Foo.Singleton");expect(K[1]).toBe("Foo.SomeClass")});it("can override constructor",function(){expect(L.prop).toBe(42)});it("can add new methods",function(){expect(L.method2()).toBe("two")});it("can add new static methods",function(){expect(Foo.SomeClass.newStatic()).toBe("boo")});it("callParent should work for instance methods",function(){expect(L.method1(21)).toBe("ab42c")});it("callParent should work for static methods",function(){expect(Foo.SomeClass.staticMethod(21)).toBe("ZBA42!")});it("callSuper should work for instance methods",function(){expect(L.patchedMethod("x")).toBe("xAC")});it("callSuper should work for static methods",function(){expect(Foo.SomeClass.patchedStaticMethod("X")).toBe("Xac")});it("works with singletons",function(){expect(Foo.Singleton.foo(21)).toBe(42)})});describe("mixin",function(){it("should have all properties of mixins",function(){var K=new B;expect(K.mixinProperty1).toBe("mixinProperty1");expect(K.mixinProperty2).toBe("mixinProperty2");expect(K.mixinMethod1).toBeDefined();expect(K.mixinMethod2).toBeDefined();expect(K.getMixinConfig()).toBe("mixinConfig")});it("should not overwrite a config if it exists on the class",function(){var K=Ext.define("spec.Mixin",{config:{foo:1}});var L=Ext.define(null,{constructor:F,mixins:[K],config:{foo:2}});D=new L();expect(D.getFoo()).toBe(2);Ext.undefine("spec.Mixin")})});describe("hooks",function(){var L,K;beforeEach(function(){L="";K=[];Ext.define("Foo.M1",{extend:"Ext.Mixin",mixinConfig:{extended:function(O,N,M){K.push(N.$className+" extends "+O.$className)}},foo:function(M){L+="M1.foo"+M},doBar:function(M){L+="M1.bar"+M}});Ext.define("Foo.M2",{extend:"Foo.M1",mixinConfig:{on:{foo:function(M){this.callParent(arguments);L+="M2.foo"+M},bar:"doBar"}},doBar:function(M){this.callParent(arguments);L+="M2.bar"+M}});Ext.define("Foo.A",{foo:function(M){L+="A.foo"+M},bar:function(M){L+="A.bar"+M}});Ext.define("Foo.B",{extend:"Foo.A",foo:function(M){this.callParent(arguments);L+="B.foo"+M},bar:function(M){this.callParent(arguments);L+="B.bar"+M}});Ext.define("Foo.C",{extend:"Foo.A",mixins:{m2:"Foo.M2"},foo:function(M){this.callParent(arguments);L+="C.foo"+M;return"C.foo"},bar:function(M){this.callParent(arguments);L+="C.bar"+M}});Ext.define("Foo.D",{extend:"Foo.B",mixins:{m2:"Foo.M2"},foo:function(M){this.callParent(arguments);L+="D.foo"+M;return"D.foo"},bar:function(M){this.callParent(arguments);L+="D.bar"+M;return 42}});Ext.define("Foo.E",{extend:"Foo.C",foo:function(M){this.callParent(arguments);L+="B.foo"+M},bar:function(M){this.callParent(arguments);L+="B.bar"+M}})});afterEach(function(){Ext.undefine("Foo.M1");Ext.undefine("Foo.M2");Ext.undefine("Foo.A");Ext.undefine("Foo.B");Ext.undefine("Foo.C");Ext.undefine("Foo.D");Ext.undefine("Foo.E");Ext.undefine("Foo")});it("should call A then M2 then C",function(){var N=new Foo.C(),M=N.foo(" ");expect(L).toBe("A.foo M2.foo C.foo ");expect(M).toBe("C.foo")});it("function hook should call A then B then M2 then C",function(){var N=new Foo.D(),M=N.foo(" ");expect(L).toBe("A.foo B.foo M2.foo D.foo ");expect(M).toBe("D.foo")});it("named hook should call A then B then M2 then C",function(){var N=new Foo.D(),M=N.bar(" - ");expect(L).toBe("A.bar - B.bar - M1.bar - M2.bar - D.bar - ");expect(M).toBe(42)});it("should process extended option",function(){var M=K.join("/");expect(M).toBe("Foo.E extends Foo.C")})});describe("overriden methods",function(){it("should call self constructor",function(){var K=new B;expect(K.subConstructorCalled).toBeTruthy()});it("should call parent constructor",function(){var K=new B;expect(K.parentConstructorCalled).toBeTruthy()});it("should call mixins constructors",function(){var K=new B;expect(K.mixinConstructor1Called).toBeTruthy();expect(K.mixinConstructor2Called).toBeTruthy()})});describe("callbacks",function(){describe("extend",function(){afterEach(function(){Ext.undefine("spec.Extend")});it("should set the scope to the created class",function(){var K=function(){},L;Ext.define("spec.Extend",{extend:"Ext.Base",foo:K},function(){L=this.prototype.foo});expect(L).toBe(K)});it("should pass the created class",function(){var K=function(){},L;Ext.define("spec.Extend",{extend:"Ext.Base",foo:K},function(M){L=M.prototype.foo});expect(L).toBe(K)})});describe("override",function(){var K;beforeEach(function(){K=Ext.define("spec.Base",{})});afterEach(function(){Ext.undefine("spec.Base")});it("should set the scope to the overridden class",function(){var L;Ext.define("spec.Override",{override:"spec.Base"},function(){L=this});expect(L).toBe(K)});it("should pass the overridden class",function(){var L;Ext.define("spec.Override",{override:"spec.Base"},function(M){L=M});expect(L).toBe(K)})})});describe("platformConfig",function(){var N,M=[],L,K;beforeEach(function(){M.length=0;N=Ext.platformTags;Ext.platformTags={desktop:true,chrome:true};L=Ext.define(null,{constructor:function(O){this.initConfig(O)},config:{foo:"abc"},updateFoo:function(O){M.push("updateFoo: "+O)}});K=Ext.define(null,{extend:L,config:{bar:"xyz"},jaz:13,updateBar:function(O){this.getFoo();M.push("updateBar: "+O)},updateJaz:function(O){this.getBar();M.push("updateJaz: "+O)},platformConfig:{"chrome && desktop":{bar:"aaa"},desktop:{foo:"ABC",bar:"XYZ",jaz:427},"!desktop":{foo:"DEF",bar:"UVW",jaz:42}}})});afterEach(function(){Ext.platformTags=N});describe("derivation",function(){var O;beforeEach(function(){O=new K({herp:"derp"})});it("should set the old-school config on the prototype",function(){expect(K.prototype.jaz).toBe(427)});it("should set the old-school config for the instance",function(){expect(O.jaz).toBe(427)});it("should set a new Proper config to longest rules value",function(){var P=O.getBar();expect(P).toBe("aaa")});it("should set an inherited Proper config",function(){var P=O.getFoo();expect(P).toBe("ABC")});it("should apply initial values in one pass",function(){expect(M).toEqual(["updateFoo: ABC","updateBar: aaa"])});it("should only call updateJaz manually",function(){O.updateJaz(10);expect(M).toEqual(["updateFoo: ABC","updateBar: aaa","updateJaz: 10"])})});describe("instances",function(){var O;beforeEach(function(){O=new K({platformConfig:{"chrome && desktop":{bar:"bbb"},desktop:{foo:321},"!desktop":{jaz:123}}})});it("should set the old-school config for the instance",function(){expect(O.jaz).toBe(427)});it("should set a new Proper config to longest rules value",function(){var P=O.getBar();expect(P).toBe("bbb")});it("should set an inherited Proper config",function(){var P=O.getFoo();expect(P).toBe(321)});it("should apply initial values in one pass",function(){expect(M).toEqual(["updateFoo: 321","updateBar: bbb"])});it("should only call updateJaz manually",function(){O.updateJaz(10);expect(M).toEqual(["updateFoo: 321","updateBar: bbb","updateJaz: 10"])})})});describe("deprecated config",function(){var K=[],M=Ext.log.warn;beforeEach(function(){K.length=0;Ext.log.warn=function(N){K.push(N)}});afterEach(function(){Ext.log.warn=M});var L=Ext.define(null,{constructor:function(N){this.initConfig(N)},deprecated:{1:{configs:{dead:null,renamed:"newName",removed:{message:"This config was replaced by pixie dust"}}}}});it("should warn about dead configs",function(){var N=new L({dead:42});expect(K.length).toBe(1);expect(K[0].indexOf("#dead")).toBeGE(0);expect("dead" in N).toBe(false)});it("should warn about renamed configs",function(){var N=new L({renamed:42});expect(K.length).toBe(1);expect(K[0].indexOf("#renamed")).toBeGE(0);expect(K[0].indexOf("newName")).toBeGE(0);expect("renamed" in N).toBe(false)});it("should warn about removed configs",function(){var N=new L({removed:42});expect(K.length).toBe(1);expect(K[0].indexOf("pixie dust")).toBeGE(0);expect("removed" in N).toBe(false)});it("should warn about all deprecated configs",function(){var N=new L({dead:42,renamed:42,removed:42});expect(K.length).toBe(3);expect("dead" in N).toBe(false);expect("renamed" in N).toBe(false);expect("removed" in N).toBe(false)})})})