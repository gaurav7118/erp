describe("Ext.data.Model",function(){beforeEach(function(){Ext.ClassManager.enableNamespaceParseCache=false;Ext.data.Model.schema.setNamespace("spec")});afterEach(function(){Ext.ClassManager.enableNamespaceParseCache=true;Ext.data.Model.schema.clear(true)});describe("use of raw Model class",function(){it("should be able to use Ext.data.Model directly on a store",function(){var B=[{forename:"Nige",surname:"White"},{forename:"Don",surname:"Griffin"},{forename:"Phil",surname:"Guerrant"},{forename:"Kevin",surname:"Krohe"},{forename:"Evan",surname:"Trimboli"}];var A=new Ext.data.Store({model:Ext.data.Model,data:B});expect(A.getAt(0).data).toEqual(B[0]);expect(A.getAt(1).data).toEqual(B[1]);expect(A.getAt(2).data).toEqual(B[2]);expect(A.getAt(3).data).toEqual(B[3]);expect(A.getAt(4).data).toEqual(B[4]);A.getAt(0).set("forename","Nigel");expect(A.getAt(0).get("forename")).toBe("Nigel")})});describe("getField/getFields",function(){var B;beforeEach(function(){B=Ext.define("spec.A",{extend:Ext.data.Model,fields:["id","name","key"]})});afterEach(function(){Ext.undefine("spec.A");B=null});describe("getFields",function(){it("should return an array",function(){expect(Ext.isArray(B.getFields())).toBe(true)});it("should return all fields in the model",function(){expect(B.getFields().length).toBe(3)});it("should be able to be called on an instance",function(){var A=new B();expect(A.getFields().length).toBe(3)})});describe("getField",function(){it("should return null if no field with a matching name is found",function(){expect(B.getField("foo")).toBeNull()});it("should return the field",function(){expect(B.getField("key").isField).toBe(true)});it("should be able to be called on an instance",function(){var A=new B();expect(A.getField("name").isField).toBe(true)})})});describe("defining models",function(){var C,D;afterEach(function(){Ext.undefine("specModel");Ext.undefine("spec.A");Ext.undefine("spec.B");Ext.undefine("spec.model.sub.C");C=D=null});describe("entityName",function(){beforeEach(function(){Ext.define("specModel",{extend:"Ext.data.Model"});Ext.define("spec.A",{extend:"Ext.data.Model"});Ext.define("spec.B",{extend:"Ext.data.Model"});Ext.define("spec.model.sub.C",{extend:"Ext.data.Model"})});it("should generate proper default entityName for top-level",function(){expect(specModel.entityName).toBe("specModel")});it("should generate proper default entityName for namespaced entity",function(){expect(spec.A.entityName).toBe("A");expect(spec.B.entityName).toBe("B")});it("should generate proper default entityName for a deep namespaced entity",function(){expect(spec.model.sub.C.entityName).toBe("model.sub.C")})});describe("fields",function(){afterEach(function(){Ext.undefine("spec.A");Ext.undefine("spec.B");C=D=null});function A(E,F){F=Ext.apply({extend:Ext.data.Model,fields:E},F);C=Ext.define("spec.A",F)}function B(E,F){F=Ext.apply({extend:C,fields:E},F);spyOn(Ext.log,"warn");D=Ext.define("spec.B",F)}it("should be able to define a string name field and default the type to auto",function(){A(["id"]);var E=C.getField("id");expect(E.isField).toBe(true);expect(E.getType()).toBe("auto");expect(C.getFields().length).toBe(1)});it("should be able to define an object field and default the type to auto",function(){A([{name:"id"}]);var E=C.getField("id");expect(E.isField).toBe(true);expect(E.getType()).toBe("auto");expect(C.getFields().length).toBe(1)});it("should read the type parameter from the field",function(){A([{name:"id",type:"int"}]);expect(C.getField("id").getType()).toBe("int")});it("should retain the field definition order",function(){A(["id","d","a","c","b"]);var E=C.getFields(),F=[];Ext.Array.forEach(E,function(G){F.push(G.getName())});expect(F).toEqual(["id","d","a","c","b"]);expect(E.length).toBe(5)});it("should be able to define a field with a - in the name",function(){A(["the-field"]);var E=C.getField("the-field");expect(E.isField)});describe("id field",function(){it("should create a field matching the idProperty if it doesn't exist",function(){A([]);var E=C.getFields();expect(E.length).toBe(1);expect(E[0].getName()).toBe(C.prototype.idProperty)});it("should append the id field to the end if it doesn't exist",function(){A(["a","b"]);var E=C.getFields();expect(E[2].getName()).toBe("id")});it("should not create an extra field if the idProperty field is already defined",function(){A([{name:"id",type:"int"}]);var E=C.getField("id");expect(E.getType()).toBe("int")});it("should create an idField when the name isn't the default",function(){A([],{idProperty:"name"});expect(C.getField("name").isField).toBe(true)});it("should clear any defaultValue on the idField",function(){A([{name:"id",type:"int"}]);expect(C.getField("id").defaultValue).toBeNull()});it("should set allowNull on the idField",function(){A([{name:"id",type:"int"}]);expect(C.getField("id").allowNull).toBe(true)})});describe("subclassing",function(){it("should inherit the fields from the superclass",function(){A(["id","name"]);B([]);expect(D.getFields().length).toBe(2)});it("should append new fields to the end",function(){A(["id","name"]);B(["foo","bar"]);var E=D.getFields();expect(E.length).toBe(4);expect(E[2].getName()).toBe("foo");expect(E[3].getName()).toBe("bar")});it("should not modify the fields in the superclass",function(){A(["id","name"]);B(["foo","bar"]);var E=C.getFields();expect(E.length).toBe(2);expect(E[0].getName()).toBe("id");expect(E[1].getName()).toBe("name")});it("should be able to override a field in the base",function(){A(["id"]);B([{name:"id",type:"int"}]);expect(C.getField("id").getType()).toBe("auto");expect(D.getField("id").getType()).toBe("int")});it("should copy fields for deep subclasses",function(){A(["id"]);B(["bField"]);Ext.define("spec.C",{extend:D,fields:["cField"]});Ext.define("spec.D",{extend:spec.C,fields:["dField"]});var E=spec.C.getFields();expect(E.length).toBe(3);expect(E[2].getName()).toBe("cField");E=spec.D.getFields();expect(E.length).toBe(4);expect(E[2].getName()).toBe("cField");expect(E[3].getName()).toBe("dField");Ext.undefine("spec.C");Ext.undefine("spec.D")});describe("id field",function(){describe("not changing the idProperty",function(){it("should inherit the idProperty & keep the generated idField in position",function(){A(["foo","bar"]);B(["baz"]);var E=spec.A.getFields();expect(E.length).toBe(3);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("bar");expect(E[2].name).toBe("id");expect(spec.A.getField("id")).toBe(E[2]);E=spec.B.getFields();expect(E.length).toBe(4);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("bar");expect(E[2].name).toBe("id");expect(E[3].name).toBe("baz");expect(spec.B.getField("id")).toBe(E[2]);expect(spec.A.idField.name).toBe("id");expect(spec.B.idField.name).toBe("id")});it("should inherit the idProperty & keep a defined idField in position",function(){A(["foo","id","bar"]);B(["baz"]);var E=spec.A.getFields();expect(E.length).toBe(3);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("id");expect(E[2].name).toBe("bar");expect(spec.A.getField("id")).toBe(E[1]);E=spec.B.getFields();expect(E.length).toBe(4);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("id");expect(E[2].name).toBe("bar");expect(E[3].name).toBe("baz");expect(spec.B.getField("id")).toBe(E[1]);expect(spec.A.idField.name).toBe("id");expect(spec.B.idField.name).toBe("id")})});describe("changing the idProperty",function(){describe("id declared as a field in superclass & subclass",function(){it("should keep both idFields in the defined order",function(){A(["foo","id","bar"]);B(["customId","baz"],{idProperty:"customId"});var E=spec.A.getFields();expect(E.length).toBe(3);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("id");expect(E[2].name).toBe("bar");expect(spec.A.getField("id")).toBe(E[1]);E=spec.B.getFields();expect(E.length).toBe(5);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("id");expect(E[2].name).toBe("bar");expect(E[3].name).toBe("customId");expect(E[4].name).toBe("baz");expect(spec.B.getField("id")).toBe(E[1]);expect(spec.B.getField("customId")).toBe(E[3]);expect(spec.A.idField.name).toBe("id");expect(spec.B.idField.name).toBe("customId")})});describe("id declared as field only in superclass",function(){it("should keep a defined idField from the parent, but it should not be the idField",function(){A(["foo","id","bar"]);B(["baz"],{idProperty:"customId"});var E=spec.A.getFields();expect(E.length).toBe(3);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("id");expect(E[2].name).toBe("bar");expect(spec.A.getField("id")).toBe(E[1]);E=spec.B.getFields();expect(E.length).toBe(5);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("id");expect(E[2].name).toBe("bar");expect(E[3].name).toBe("baz");expect(E[4].name).toBe("customId");expect(spec.B.getField("id")).toBe(E[1]);expect(spec.B.getField("customId")).toBe(E[4]);expect(spec.A.idField.name).toBe("id");expect(spec.B.idField.name).toBe("customId")})});describe("id declared as a field only in subclass",function(){it("should remove the generated id field and leave the declared idField in place",function(){A(["foo"]);B(["bar","customId","baz"],{idProperty:"customId"});var E=spec.A.getFields();expect(E.length).toBe(2);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("id");E=spec.B.getFields();expect(E.length).toBe(4);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("bar");expect(E[2].name).toBe("customId");expect(E[3].name).toBe("baz");expect(spec.B.getField("id")).toBeNull();expect(spec.A.idField.name).toBe("id");expect(spec.B.idField.name).toBe("customId")})});describe("id not declared as a field",function(){it("should replace a generated idField from the parent",function(){A(["foo","bar"]);B(["baz"],{idProperty:"customId"});var E=spec.A.getFields();expect(E.length).toBe(3);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("bar");expect(E[2].name).toBe("id");E=spec.B.getFields();expect(E.length).toBe(4);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("bar");expect(E[2].name).toBe("customId");expect(E[3].name).toBe("baz");expect(spec.B.getField("id")).toBeNull();expect(spec.A.idField.name).toBe("id");expect(spec.B.idField.name).toBe("customId")})})})});describe("versionProperty",function(){it("should append versionProperty if it's not declared as a field",function(){A(["foo"],{versionProperty:"version"});var E=spec.A.getFields(),F=E[2];expect(E.length).toBe(3);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("id");expect(E[2].name).toBe("version");expect(F.critical).toBe(true);expect(F.defaultValue).toBe(1)});it("should leave a declared versionProperty in position",function(){A(["foo",{name:"version",type:"int"},"bar"],{versionProperty:"version"});var E=spec.A.getFields(),F=E[1];expect(E.length).toBe(4);expect(E[0].name).toBe("foo");expect(E[1].name).toBe("version");expect(E[2].name).toBe("bar");expect(E[3].name).toBe("id");expect(F.critical).toBe(true);expect(F.defaultValue).toBe(1)})})});describe("configs the model sets on the field",function(){describe("ordinal",function(){function E(H,F,G){G=G||C;var I=G.getField(H);expect(I.ordinal).toBe(F)}it("should set the ordinal for each field in order",function(){A(["foo","bar","baz"]);var F=C.getFields();E("foo",0);E("bar",1);E("baz",2)});it("should append the id field to the end",function(){A(["foo","bar","baz"]);E("id",3)});it("should not move the id field if it exists",function(){A(["id","foo","bar","baz"]);E("id",0)});describe("subclassing",function(){it("should append field to the end",function(){A(["id","foo"]);B(["bar","baz"]);E("bar",2,D);E("baz",3,D)});it("should not move a field if redefined",function(){A(["id","foo"]);B(["bar","baz",{name:"foo",type:"int"}]);E("foo",1,D)});it("should append a custom id field to the end",function(){A(["id","foo"]);B(["bar"],{idProperty:"customId"});E("customId",3,D)})})});describe("definedBy",function(){it("should set the defined class on all fields",function(){A(["foo","bar"]);expect(C.getField("foo").definedBy).toBe(C);expect(C.getField("bar").definedBy).toBe(C)});it("should set the defined class on an id field",function(){A(["foo","bar"]);expect(C.getField("id").definedBy).toBe(C)});describe("subclassing",function(){it("should set the subclass on the field",function(){A(["foo"]);B(["bar"]);expect(D.getField("bar").definedBy).toBe(D)});it("should retain the superclass on the field",function(){A(["foo"]);B(["bar"]);expect(D.getField("foo").definedBy).toBe(C)});it("should set the if the field is redefined",function(){A(["foo"]);B(["bar",{name:"foo",type:"int"}]);expect(D.getField("foo").definedBy).toBe(D)})})})});describe("calculated fields",function(){describe("subclassing",function(){it("should inherit calculated fields",function(){A(["foo",{name:"bar",calculate:function(F){return F.foo*2}}]);B();var E=new D({foo:10});expect(E.get("bar")).toBe(20)});it("should inherit calculated fields when the parent has been instanced first",function(){A(["foo",{name:"bar",calculate:function(F){return F.foo*2}}]);B();var E=new C({foo:10});expect(E.get("bar")).toBe(20);E=new D({foo:20});expect(E.get("bar")).toBe(40)})})})});describe("proxy",function(){function A(E,B){B=Ext.apply({extend:Ext.data.Model,fields:["id"],proxy:E},B);C=Ext.define("spec.A",B)}it("should ask the schema to construct a proxy by default",function(){A();var E=C.schema,F=E.constructProxy(C),B=C.getProxy();expect(B.alias).toEqual(["proxy."+F.type]);expect(B.getUrl()).toBe(F.url)});it("should use the defaultProxy instead of the schema proxy",function(){A(null,{statics:{defaultProxy:{type:"memory"}}});var E=C.schema,F=E.constructProxy(C),B=C.getProxy();expect(B.alias).toEqual(["proxy.memory"]);expect(B.alias).not.toEqual(["proxy."+F.type])});it("should create a proxy type string",function(){A("jsonp");expect(C.getProxy() instanceof Ext.data.proxy.JsonP).toBe(true)});it("should create a proxy from a config",function(){A({type:"ajax",url:"/foo"});expect(C.getProxy().getUrl()).toBe("/foo")});it("should infer the reader type from the proxy",function(){Ext.define("spec.CustomReader",{extend:"Ext.data.reader.Json",alias:"reader.custom"});Ext.define("spec.CustomProxy",{extend:"Ext.data.proxy.Ajax",alias:"proxy.custom",reader:"custom"});A("custom");expect(C.getProxy().getReader().$className).toBe("spec.CustomReader");Ext.undefine("spec.CustomReader");Ext.undefine("spec.CustomProxy")});it("should use a passed instance",function(){var B=new Ext.data.proxy.Ajax();A(B);expect(C.getProxy()).toBe(B);B=null});describe("subclassing",function(){function B(F,E){E=Ext.apply({extend:C},E);if(F){E.proxy=F}D=Ext.define("spec.B",E)}it("should inherit a config from the parent",function(){A({type:"ajax",url:"/foo"});B();expect(D.getProxy().getUrl()).toBe("/foo")});it("should override anything on the parent",function(){A({type:"ajax",url:"/foo"});B({type:"ajax",url:"/bar"});expect(D.getProxy().getUrl()).toBe("/bar")});it("should clone an existing instance",function(){A({type:"ajax",url:"/foo"});C.getProxy();B();expect(D.getProxy()).not.toBe(C.getProxy());expect(D.getProxy().getUrl()).toBe("/foo")});it("should not modify the super instance",function(){A({type:"ajax",url:"/foo"});B();D.getProxy().setUrl("/bar");expect(C.getProxy().getUrl()).toBe("/foo")});it("should not use the defaultProxy when defaultProxy is defined on parent",function(){A(null,{statics:{defaultProxy:{type:"memory"}}});B();var F=D.schema,G=F.constructProxy(D),E=D.getProxy();expect(E.alias).toEqual(["proxy."+G.type]);expect(E.getUrl()).toBe(G.url)})});it("should use a memory proxy for direct instances of Ext.data.Model",function(){var B=new Ext.data.Model();expect(B.getProxy().isMemoryProxy).toBe(true)});it("should use a memory proxy for direct instances of Ext.data.TreeModel",function(){var B=new Ext.data.TreeModel();expect(B.getProxy().isMemoryProxy).toBe(true)})});describe("associations",function(){});describe("identifier",function(){var B;function A(G,E,F){F=Ext.apply({extend:Ext.data.Model,fields:E||["id","name"],identifier:G},F);C=Ext.define("spec.A",F)}afterEach(function(){B=null;var E=Ext.data.identifier.Generator;E.all={uuid:E.all.uuid}});it("should default to identifier.Sequential",function(){A();var E=new C();expect(E.getId()).toBe("A-1");E=new C();expect(E.getId()).toBe("A-2")});it("should create an identifier from a type string",function(){A("negative");var E=new C();expect(E.getId()).toBe(-1);E=new C();expect(E.getId()).toBe(-2)});it("should create an identifier from a config object",function(){A({type:"sequential",prefix:"foo"});var E=new C();expect(E.getId()).toBe("foo1");E=new C();expect(E.getId()).toBe("foo2")});it("should share an instance across models using an id",function(){var G=Ext.define("spec.B",{extend:Ext.data.Model,identifier:{id:"x",prefix:"ID_",seed:1000}});A("x");var F=new C();var E=new G();expect(F.id).toBe("ID_1000");expect(E.id).toBe("ID_1001")});describe("subclassing",function(){function E(G,F){F=Ext.apply({extend:C,identifier:G},F);D=Ext.define("spec.B",F)}describe("defined on the subclass",function(){it("should use a string type",function(){A({type:"negative"});E("sequential");var G=new C();var F=new D();expect(G.id).toBe(-1);expect(F.id).toBe(1)});it("should use an object type",function(){A({type:"negative"});E({type:"sequential"});var G=new C();var F=new D();expect(G.id).toBe(-1);expect(F.id).toBe(1)});it("should use an instance",function(){B=new Ext.data.identifier.Sequential();A({type:"sequential"});E(B);expect(D.identifier).toBe(B)})});describe("inheriting from parent",function(){it("should clone an instance if it's cloneable",function(){A({type:"sequential",prefix:"foo"});E();B=D.identifier;expect(B).not.toBe(C.identifier);expect(B.getPrefix()).toBe("foo")});it("should not clone the instance if it's not cloneable",function(){A("uuid");E();expect(D.identifier).toBe(C.identifier)});it("should not clone if an id is specified",function(){A({type:"sequential",prefix:"ID_",seed:1000,id:"xxx"});E();expect(D.identifier).toBe(C.identifier);var G=new C();var F=new D();expect(G.id).toBe("ID_1000");expect(F.id).toBe("ID_1001")})})})});describe("validators",function(){function F(H,K,I){var J=H.getField(K);return J.validate(I,"|")}function G(H,L,J,I){var K=F(H,L,J);if(K===true){K=[]}else{K=K.split("|")}expect(K).toEqual(I)}var E="Must be present",A="Is in the wrong format",B="Is not a valid email address";describe("on the field",function(){function H(K,I,J){J=Ext.apply({extend:Ext.data.Model,fields:I||[{name:"name",validators:K}]},J);C=Ext.define("spec.A",J)}it("should accept a validator string name",function(){H("presence");G(C,"name",null,[E])});it("should accept an object configuration",function(){H({type:"format",matcher:/foo/});G(C,"name",null,[A])});it("should accept a function",function(){H(function(){return"Fail"});G(C,"name",null,["Fail"])});it("should accept an array of strings",function(){H(["presence","email"]);G(C,"name",null,[E,B])});it("should accept an array of configs",function(){H([{type:"presence"},{type:"format",matcher:/foo/}]);G(C,"name",null,[E,A])});it("should accept an array of functions",function(){H([function(){return"Fail1"},function(){return"Fail2"}]);G(C,"name",null,["Fail1","Fail2"])});it("should be able to define multiple fields",function(){H(null,[{name:"name",validators:"presence"},{name:"email",validators:"email"}]);G(C,"name",null,[E]);G(C,"email",null,[B])})});describe("on the model",function(){function H(K,I,J){J=Ext.apply({extend:Ext.data.Model,fields:I||["id","name","rank","email"],validators:K},J);C=Ext.define("spec.A",J)}describe("array style",function(){it("should accept an array of validators",function(){H([{field:"name",type:"presence"}]);G(C,"name",null,[E])});it("should accept multiple validators for a single field",function(){H([{field:"name",type:"presence"},{field:"name",type:"format",matcher:/foo/}]);G(C,"name",null,[E,A])});it("should be able to pass validators for multiple fields",function(){H([{field:"name",type:"presence"},{field:"email",type:"email"}]);G(C,"name",null,[E]);G(C,"email",null,[B])});it("should accept a function validator",function(){var I=function(){return"Failed"};H([{field:"name",fn:I}]);G(C,"name",null,["Failed"])})});describe("object style",function(){it("should accept a string",function(){H({name:"presence"});G(C,"name",null,[E])});it("should accept a function",function(){var I=function(){return"Failed"};H({name:I});G(C,"name",null,["Failed"])});it("should accept config object",function(){H({name:{type:"format",matcher:/foo/}});G(C,"name",null,[A])});it("should accept an array of strings",function(){H({name:["presence","email"]});G(C,"name",null,[E,B])});it("should accept an array of functions",function(){var J=function(){return"Fail1"},I=function(){return"Fail2"};H({name:[J,I]});G(C,"name",null,["Fail1","Fail2"])});it("should accept an array of objects",function(){H({name:[{type:"format",matcher:/foo/},{type:"length",min:3}]});G(C,"name","x",[A,"Length must be at least 3"])});it("should accept a mixed array",function(){var I=function(){return"Fail"};H({name:["email",{type:"length",min:3},I]});G(C,"name","x",[B,"Length must be at least 3","Fail"])});it("should be able to declare multiple fields at once",function(){H({name:"presence",email:"email"});G(C,"name",null,[E]);G(C,"email",null,[B])})})});describe("on both the field and model",function(){function H(K,I,J){J=Ext.apply({extend:Ext.data.Model,fields:I,validators:K},J);C=Ext.define("spec.A",J)}describe("model array style",function(){it("should merge with a string",function(){H([{field:"name",type:"presence"}],[{name:"name",validators:"email"}]);G(C,"name",null,[E,B])});it("should merge with an object",function(){H([{field:"name",type:"presence"}],[{name:"name",validators:{type:"format",matcher:/foo/}}]);G(C,"name",null,[E,A])});it("should merge with an array",function(){H([{field:"name",type:"presence"}],[{name:"name",validators:["email",function(){return"Fail"}]}]);G(C,"name",null,[E,B,"Fail"])})});describe("model object style",function(){describe("model object with string",function(){it("should merge with a string",function(){H({name:"presence"},[{name:"name",validators:"email"}]);G(C,"name",null,[E,B])});it("should merge with an object",function(){H({name:"presence"},[{name:"name",validators:{type:"format",matcher:/foo/}}]);G(C,"name",null,[E,A])});it("should merge with an array",function(){H({name:"presence"},[{name:"name",validators:["email"]}]);G(C,"name",null,[E,B])})});describe("model object with object",function(){it("should merge with a string",function(){H({name:{type:"presence"}},[{name:"name",validators:"email"}]);G(C,"name",null,[E,B])});it("should merge with an object",function(){H({name:{type:"presence"}},[{name:"name",validators:{type:"format",matcher:/foo/}}]);G(C,"name",null,[E,A])});it("should merge with an array",function(){H({name:{type:"presence"}},[{name:"name",validators:["email"]}]);G(C,"name",null,[E,B])})});describe("model object with array",function(){it("should merge with a string",function(){H({name:["presence"]},[{name:"name",validators:"email"}]);G(C,"name",null,[E,B])});it("should merge with an object",function(){H({name:["presence"]},[{name:"name",validators:{type:"format",matcher:/foo/}}]);G(C,"name",null,[E,A])});it("should merge with an array",function(){H({name:["presence"]},[{name:"name",validators:["email"]}]);G(C,"name",null,[E,B])})})})});describe("subclassing",function(){function H(L,J,K){K=Ext.apply({extend:Ext.data.Model,fields:J||["name","email"],validators:L},K);C=Ext.define("spec.A",K)}function I(L,J,K){K=Ext.apply({extend:C,fields:J||[],validators:L},K);D=Ext.define("spec.B",K)}describe("not redefining the field",function(){it("should use the field validator",function(){H(null,[{name:"name",validators:"presence"}]);I();G(D,"name",null,[E])});it("should use the superclass model validator",function(){H({name:"presence"});I();G(D,"name",null,[E])});it("should use the subclass model validator",function(){H();I({name:"presence"});G(D,"name",null,[E])});it("should combine a field validator & a superclass model validator",function(){H({name:"email"},[{name:"name",validators:"presence"}]);I();G(D,"name",null,[B,E])});it("should combine a field validator & a subclass model validator",function(){H(null,[{name:"name",validators:"presence"}]);I({name:"email"});G(D,"name",null,[B,E])});it("should combine a superclass model validator & subclass model validator",function(){H({name:"presence"});I({name:"email"});G(D,"name",null,[E,B])});it("should combine a field validator, superclass model validator & subclass model validator",function(){H({name:"presence"},[{name:"name",validators:{type:"format",matcher:/foo/}}]);I({name:"email"});G(D,"name",null,[E,B,A])});describe("not modifying the superclass",function(){it("should not push subclass validators onto the superclass",function(){H();I({name:"presence"});G(C,"name",null,[]);G(D,"name",null,[E])});it("should retain superclass validators",function(){H({name:"presence"});I({name:"email"});G(C,"name",null,[E]);G(D,"name",null,[E,B])})})});describe("redefining the field",function(){beforeEach(function(){spyOn(Ext.log,"warn")});it("should not inherit a field validator",function(){H(null,[{name:"name",validators:"presence"}]);I(null,["name"]);G(D,"name",null,[])});it("should overwrite a field validator",function(){H(null,[{name:"name",validators:"presence"}]);I(null,[{name:"name",validators:"email"}]);G(D,"name",null,[B])});it("should inherit a superclass model validator",function(){H({name:"presence"});I(["name"]);G(D,"name",null,[E])});it("should use a subclass model validator",function(){H();I({name:"presence"},["name"]);G(D,"name",null,[E])});it("should combine a field validator & a superclass model validator",function(){H({name:"presence"});I(null,[{name:"name",validators:"email"}]);G(D,"name",null,[E,B])});it("should combine a field validator & a subclass model validator",function(){H();I({name:"presence"},[{name:"name",validators:"email"}]);G(D,"name",null,[E,B])});it("should combine a superclass model validator & a subclass model validator",function(){H({name:"presence"});I({name:"email"},["name"]);G(D,"name",null,[E,B])});it("should combine a field validator, superclass model validator & subclass model validator",function(){H({name:"presence"});I({name:"email"},[{name:"name",validators:{type:"format",matcher:/foo/}}]);G(D,"name",null,[E,B,A])});describe("not modifying the superclass",function(){it("should not add a subclass field validator to the parent",function(){H();I(null,[{name:"name",validators:"presence"}]);G(C,"name",null,[]);G(D,"name",null,[E])});it("should not modify the superclass when overwriting a field validator",function(){H(null,[{name:"name",validators:"presence"}]);I(null,[{name:"name",validators:"email"}]);G(C,"name",null,[E]);G(D,"name",null,[B])});it("should not push subclass validators into the superclass",function(){H();I({name:"presence"},["name"]);G(C,"name",null,[]);G(D,"name",null,[E])});it("should retain superclass validators",function(){H({name:"presence"});I({name:"email"},["name"]);G(C,"name",null,[E]);G(D,"name",null,[E,B])})})})})})});describe("get/setProxy",function(){var C;afterEach(function(){C=null;Ext.undefine("spec.A")});function B(D,A){A=Ext.apply({extend:Ext.data.Model,fields:["id"],proxy:D},A);C=Ext.define("spec.A",A)}it("should be able to set a string type",function(){B();C.setProxy("ajax");expect(C.getProxy() instanceof Ext.data.proxy.Ajax).toBe(true)});it("should be able to set a config",function(){B();C.setProxy({type:"ajax",url:"/foo"});expect(C.getProxy().getUrl()).toBe("/foo")});it("should be able to set an instance",function(){var A=new Ext.data.proxy.Ajax({url:"/foo"});B();C.setProxy(A);expect(C.getProxy()).toBe(A);A=null});it("should have the instance method call the static method",function(){B({type:"ajax",url:"/foo"});var A=C.getProxy();var D=new C();expect(D.getProxy()).toBe(A);A=null})});describe("remote calls",function(){var C,E,F;function B(G,A){A=Ext.apply({extend:Ext.data.Model,fields:["id","name","age"],proxy:G||{type:"ajax",url:"/foo"}},A);C=Ext.define("spec.A",A)}function D(H,A,G){F=new C({id:H},G);if(A){F.load(A)}return F}beforeEach(function(){MockAjaxManager.addMethods()});afterEach(function(){MockAjaxManager.removeMethods();E=C=null;Ext.undefine("spec.A")});describe("load",function(){var A;beforeEach(function(){B();A=spyOn(C.getProxy(),"read").andCallFake(function(H){E=H;return A.originalValue.apply(this,arguments)})});function G(I,H){Ext.Ajax.mockComplete({status:H||200,responseText:Ext.JSON.encode(I)})}it("should throw if the returned id is different",function(){D(3,{});expect(function(){G({id:100})}).toThrow()});it("should pass the id as part of the operation",function(){D(3,{});expect(E.getId()).toBe(3)});it("should return the operation",function(){D(3);expect(F.load().isOperation).toBe(true)});describe("with phantoms",function(){it("should not be a phantom after loading",function(){D();expect(F.phantom).toBe(true);F.load();G({id:1});expect(F.phantom).toBe(false)});it("should set the id on the new record",function(){D();F.load();G({id:200});expect(F.getId()).toBe(200)})});describe("while loading",function(){it("should return the operation",function(){var H=F.load();expect(F.load()).toBe(H)});it("should not trigger a second load",function(){D(3,{});A.reset();F.load();expect(A).not.toHaveBeenCalled()});describe("callbacks",function(){it("should call success & callback if successful",function(){var I=jasmine.createSpy(),H=jasmine.createSpy();D(3,{});F.load({success:I,callback:H});G({});expect(I).toHaveBeenCalled();expect(H).toHaveBeenCalled()});it("should be able to call success/callback multiple times",function(){var J=jasmine.createSpy(),H=jasmine.createSpy(),I=0;D(3,{});for(I=0;I<3;++I){F.load({success:J,callback:H})}G({});expect(J.callCount).toBe(3);expect(H.callCount).toBe(3)});it("should be able to call success/callback in conjunction with the original callbacks",function(){var K=jasmine.createSpy(),J=jasmine.createSpy(),I=jasmine.createSpy(),H=jasmine.createSpy();D(3,{success:K,callback:J});F.load({success:I,callback:H});G({});expect(K).toHaveBeenCalled();expect(J).toHaveBeenCalled();expect(I).toHaveBeenCalled();expect(H).toHaveBeenCalled()});it("should call failure & callback if failed",function(){var H=jasmine.createSpy(),I=jasmine.createSpy();D(3,{});F.load({failure:H,callback:I});G(null,500);expect(H).toHaveBeenCalled();expect(I).toHaveBeenCalled()});it("should be able to call failure/callback multiple times",function(){var H=jasmine.createSpy(),I=jasmine.createSpy(),J=0;D(3,{});for(J=0;J<3;++J){F.load({failure:H,callback:I})}G(null,500);expect(H.callCount).toBe(3);expect(I.callCount).toBe(3)})})});describe("setting data",function(){it("should set the data on the model",function(){D(3,{});G({name:"foo",age:20});expect(F.get("name")).toBe("foo");expect(F.get("age")).toBe(20)});it("should only set returned data",function(){D(2,{});G({name:"foo"});expect(F.get("name")).toBe("foo");expect(F.get("age")).toBeUndefined()});it("should overwrite local data",function(){D(2);F.set("name","bar");F.load();G({name:"foo",age:20});expect(F.get("name")).toBe("foo");expect(F.get("age")).toBe(20)});it("should commit the data",function(){D(3,{});G({name:"foo",age:20});expect(F.dirty).toBe(false)});describe("associations",function(){beforeEach(function(){Ext.define("spec.Post",{extend:"Ext.data.Model",entityName:"Post",fields:["id","content",{name:"aId",reference:"A"}]})});afterEach(function(){Ext.undefine("spec.Post")});it("should be able to load associations",function(){D(3,{});G({posts:[{id:1},{id:2},{id:3}]});var H=F.posts();expect(H.getCount()).toBe(3);expect(H.getAt(0).getId()).toBe(1);expect(H.getAt(1).getId()).toBe(2);expect(H.getAt(2).getId()).toBe(3)});describe("with a session",function(){it("should ensure the session is consulted when constructing nested records",function(){Ext.define("spec.Comment",{extend:"Ext.data.Model",entityName:"Comment",fields:["id","content",{name:"postId",reference:"Post"}]});var J=new Ext.data.Session(),H=J.createRecord("Post",{id:2,aId:3,content:"Foo"}),K=J.createRecord("Comment",{id:132,postId:3,content:"Bar"});D(3,{},J);G({posts:[{id:1,aId:3},{id:2,aId:3},{id:3,aId:3,comments:[{id:132}]}]});var I=F.posts();expect(I.getAt(1)).toBe(H);expect(I.getAt(2).comments().first()).toBe(K);J.destroy();Ext.undefine("spec.Comment")})})})});describe("via the static load call",function(){it("should return the created model instance",function(){F=C.load(1);expect(F.getId()).toBe(1);expect(F.self).toBe(C)});it("should call the instance load method and pass options",function(){var H={},I=spyOn(C.prototype,"load");C.load(1,H);expect(I).toHaveBeenCalledWith(H)});it("should create the record in the session if passed",function(){var H=new Ext.data.Session();F=C.load(12,null,H);expect(F.session).toBe(H);expect(H.getRecord("A",12)).toBe(F);H.destroy()});it("should set a custom idProperty",function(){var H=Ext.define("spec.CustomId",{extend:"Ext.data.Model",idProperty:"foo"});F=H.load(1);expect(F.get("foo")).toBe(1);Ext.undefine("spec.CustomId")})});describe("isLoading",function(){it("should not be loading by default",function(){D(100);expect(F.isLoading()).toBe(false)});it("should be loading when a load is initiated",function(){D(100,{});expect(F.isLoading()).toBe(true)});it("should not be loading when a load has completed",function(){D(100,{});G({});expect(F.isLoading()).toBe(false)});it("should not be loading when a load is aborted",function(){D(100,{});F.abort();expect(F.isLoading()).toBe(false)})});describe("abort",function(){it("should do nothing if not loading",function(){D(100);expect(function(){F.abort()}).not.toThrow()});it("should abort a load operation",function(){D(100,{});var H=F.loadOperation;spyOn(H,"abort");F.abort();expect(H.abort).toHaveBeenCalled()})});describe("operation successful",function(){it("should trigger the success callback",function(){var H=jasmine.createSpy();D(17,{success:H});G({id:17,name:"TheName"});expect(H).toHaveBeenCalled()});it("should pass a record and the operation",function(){var I=jasmine.createSpy();D(17,{success:I});G({id:17,name:"TheName"});var H=I.mostRecentCall.args;expect(H[0]).toBe(F);expect(H[1]).toBe(E)});it("should only pass the first record if the server returns multiple",function(){var H=jasmine.createSpy();D(17,{success:H});G([{id:17,name:"Foo"},{id:107,name:"Bar"}]);expect(H.mostRecentCall.args[0]).toBe(F);expect(H.callCount).toBe(1)});it("should default the scope to the instance",function(){var H=jasmine.createSpy();D(100,{success:H});G({});expect(H.mostRecentCall.object).toBe(F)});it("should use a passed scope",function(){var I={},H=jasmine.createSpy();D(100,{scope:I,success:H});G({});expect(H.mostRecentCall.object).toBe(I)});it("should also fire the callback",function(){var H=jasmine.createSpy(),I=jasmine.createSpy();D(100,{success:I,callback:H});G({});expect(I).toHaveBeenCalled();expect(H).toHaveBeenCalled()});describe("with no record returned",function(){it("should fire the failure callback, not success",function(){var I=jasmine.createSpy(),H=jasmine.createSpy();D(100,{failure:H,success:I});G([]);expect(I).not.toHaveBeenCalled();expect(H).toHaveBeenCalled()})})});describe("operation failure",function(){it("should trigger the failure callback",function(){var H=jasmine.createSpy();D(17,{failure:H});G(null,500);expect(H).toHaveBeenCalled()});it("should pass the record and the operation",function(){var I=jasmine.createSpy();D(17,{failure:I});G(null,500);var H=I.mostRecentCall.args;expect(H[0]).toBe(F);expect(H[1]).toBe(E)});it("should default the scope to the instance",function(){var H=jasmine.createSpy();D(100,{failure:H});G(null,500);expect(H.mostRecentCall.object).toBe(F)});it("should use a passed scope",function(){var I={},H=jasmine.createSpy();D(100,{scope:I,failure:H});G(null,500);expect(H.mostRecentCall.object).toBe(I)});it("should also fire the callback",function(){var I=jasmine.createSpy(),H=jasmine.createSpy();D(100,{failure:H,callback:I});G(null,500);expect(H).toHaveBeenCalled();expect(I).toHaveBeenCalled()})});describe("callback",function(){it("should default the scope to the instance",function(){var H=jasmine.createSpy();D(100,{callback:H});G({});expect(H.mostRecentCall.object).toBe(F)});it("should use a passed scope",function(){var I={},H=jasmine.createSpy();D(100,{scope:I,callback:H});G({});expect(H.mostRecentCall.object).toBe(I)});it("should receive the model, operation & success=true when successful",function(){var I=jasmine.createSpy();D(17,{callback:I});G({});var H=I.mostRecentCall.args;expect(H[0]).toBe(F);expect(H[1]).toBe(E);expect(H[2]).toBe(true)});it("should receive rec, operation & success=false when failed",function(){var I=jasmine.createSpy();D(17,{callback:I});G(null,500);var H=I.mostRecentCall.args;expect(H[0]).toBe(F);expect(H[1]).toBe(E);expect(H[2]).toBe(false)});it("should be called last when successful",function(){var H=[];D(17,{success:function(){H.push("success")},callback:function(){H.push("callback")}});G({});expect(H).toEqual(["success","callback"])});it("should be called last when failed",function(){var H=[];D(17,{failure:function(){H.push("fail")},callback:function(){H.push("callback")}});G(null,500);expect(H).toEqual(["fail","callback"])})})});describe("save",function(){var H,G;function A(I){spyOn(C.getProxy(),"doRequest").andCallFake(function(J){E=J;if(I){J.process(new Ext.data.ResultSet({success:true}))}else{J.setException("Failed")}})}beforeEach(function(){B();H=new C({id:17});G=jasmine.createSpy()});describe("operation types",function(){it("should create a destroy operation if the record is dropped",function(){H=new C();H.drop();var I=H.save();expect(I instanceof Ext.data.operation.Destroy).toBe(true)});it("should create a create operation if the record is a phantom",function(){H=new C();var I=H.save();expect(I instanceof Ext.data.operation.Create).toBe(true)});it("should create an update operation if the record is not phantom and not dropped",function(){var I=H.save();expect(I instanceof Ext.data.operation.Update).toBe(true)})});describe("callbacks",function(){describe("success",function(){beforeEach(function(){A(true)});it("should pass the record and the operation",function(){H.save({success:G});var I=G.mostRecentCall.args;expect(I[0]).toBe(H);expect(I[1]).toBe(E);expect(E.wasSuccessful()).toBe(true)});it("should default the scope to the model",function(){H.save({success:G});expect(G.mostRecentCall.object).toBe(H)});it("should use the passed scope",function(){var I={};H.save({success:G,scope:I});expect(G.mostRecentCall.object).toBe(I)});it("should not call failure",function(){H.save({failure:G});expect(G).not.toHaveBeenCalled()})});describe("failure",function(){beforeEach(function(){A(false)});it("should pass the record and the operation",function(){H.save({failure:G});var I=G.mostRecentCall.args;expect(I[0]).toBe(H);expect(I[1]).toBe(E);expect(E.wasSuccessful()).toBe(false)});it("should default the scope to the model",function(){H.save({failure:G});expect(G.mostRecentCall.object).toBe(H)});it("should use the passed scope",function(){var I={};H.save({failure:G,scope:I});expect(G.mostRecentCall.object).toBe(I)});it("should not call success",function(){H.save({success:G});expect(G).not.toHaveBeenCalled()})});describe("callback",function(){describe("on success",function(){it("should pass the record, operation & success",function(){A(true);H.save({callback:G});var I=G.mostRecentCall.args;expect(I[0]).toBe(H);expect(I[1]).toBe(E);expect(E.wasSuccessful()).toBe(true);expect(I[2]).toBe(true)})});describe("on failure",function(){it("should pass the record, operation & success",function(){A(false);H.save({callback:G});var I=G.mostRecentCall.args;expect(I[0]).toBe(H);expect(I[1]).toBe(E);expect(E.wasSuccessful()).toBe(false);expect(I[2]).toBe(false)})});it("should default the scope to the model",function(){A(true);H.save({callback:G});expect(G.mostRecentCall.object).toBe(H)});it("should use the passed scope",function(){A(true);var I={};H.save({callback:G,scope:I});expect(G.mostRecentCall.object).toBe(I)})})})});describe("erase",function(){var A,G;beforeEach(function(){B();A=jasmine.createSpy()});describe("phantom",function(){beforeEach(function(){G=new C()});it("should not make a call to the proxy",function(){var H=C.getProxy();spyOn(H,"erase");G.erase();expect(H.erase).not.toHaveBeenCalled()});it("should return an operation, it should be completed",function(){var H=G.erase();expect(H.isOperation).toBe(true);expect(H.isComplete()).toBe(true)});it("should call afterErase",function(){spyOn(G,"callJoined");G.erase();expect(G.callJoined).toHaveBeenCalled();expect(G.callJoined.mostRecentCall.args[0]).toBe("afterErase")});it("should set the erased property",function(){G.erase();expect(G.erased).toBe(true)});describe("callbacks",function(){describe("success",function(){it("should fire before the function returns",function(){var I=false,H;G.erase({success:function(){H=I}});I=true;expect(H).toBe(false)});it("should pass the record and the operation",function(){G.erase({success:A});var H=A.mostRecentCall.args,I=H[1];expect(H[0]).toBe(G);expect(I instanceof Ext.data.operation.Destroy).toBe(true);expect(I.getRecords()).toEqual([G]);expect(I.wasSuccessful()).toBe(true)});it("should default the scope to the model",function(){G.erase({success:A});expect(A.mostRecentCall.object).toBe(G)});it("should use the passed scope",function(){var H={};G.erase({success:A,scope:H});expect(A.mostRecentCall.object).toBe(H)})});describe("failure",function(){it("should never call this",function(){G.erase({failure:A});expect(A).not.toHaveBeenCalled()})});describe("callback",function(){it("should fire before the function returns",function(){var I=false,H;G.erase({callback:function(){H=I}});I=true;expect(H).toBe(false)});it("should pass the record, operation & success",function(){G.erase({callback:A});var H=A.mostRecentCall.args,I=H[1];expect(H[0]).toBe(G);expect(I instanceof Ext.data.operation.Destroy).toBe(true);expect(I.getRecords()).toEqual([G]);expect(I.wasSuccessful()).toBe(true);expect(H[2]).toBe(true)});it("should default the scope to the model",function(){G.erase({callback:A});expect(A.mostRecentCall.object).toBe(G)});it("should use the passed scope",function(){var H={};G.erase({callback:A,scope:H});expect(A.mostRecentCall.object).toBe(H)})})})});describe("non-phantom",function(){function H(I){spyOn(C.getProxy(),"erase").andCallFake(function(J){E=J;if(I){J.process(new Ext.data.ResultSet({success:true}))}else{J.setException("Failed")}})}beforeEach(function(){G=new C({id:17})});it("should call the proxy erase method",function(){A=spyOn(C.getProxy(),"erase").andReturn();G.erase();expect(A).toHaveBeenCalled()});it("should return an operation, it should not be completed",function(){var I=G.erase();expect(I.isOperation).toBe(true);expect(I.isComplete()).toBe(false)});describe("when successful",function(){it("should call afterErase",function(){spyOn(G,"callJoined");H(true);G.erase();expect(G.callJoined).toHaveBeenCalled();expect(G.callJoined.mostRecentCall.args[0]).toBe("afterErase")});it("should set the erased property",function(){H(true);G.erase();expect(G.erased).toBe(true)})});describe("when not successful",function(){it("should not call afterErase",function(){spyOn(G,"callJoined");H(false);G.erase();expect(G.callJoined).not.toHaveBeenCalledWith("afterErase")});it("should not set the erased property",function(){H(false);G.erase();expect(G.erased).toBe(false)})});describe("callbacks",function(){describe("success",function(){beforeEach(function(){H(true)});it("should pass the record and the operation",function(){G.erase({success:A});var I=A.mostRecentCall.args;expect(I[0]).toBe(G);expect(I[1]).toBe(E);expect(E.wasSuccessful()).toBe(true)});it("should default the scope to the model",function(){G.erase({success:A});expect(A.mostRecentCall.object).toBe(G)});it("should use the passed scope",function(){var I={};G.erase({success:A,scope:I});expect(A.mostRecentCall.object).toBe(I)});it("should not call failure",function(){G.erase({failure:A});expect(A).not.toHaveBeenCalled()})});describe("failure",function(){beforeEach(function(){H(false)});it("should pass the record and the operation",function(){G.erase({failure:A});var I=A.mostRecentCall.args;expect(I[0]).toBe(G);expect(I[1]).toBe(E);expect(E.wasSuccessful()).toBe(false)});it("should default the scope to the model",function(){G.erase({failure:A});expect(A.mostRecentCall.object).toBe(G)});it("should use the passed scope",function(){var I={};G.erase({failure:A,scope:I});expect(A.mostRecentCall.object).toBe(I)});it("should not call success",function(){G.erase({success:A});expect(A).not.toHaveBeenCalled()})});describe("callback",function(){describe("on success",function(){it("should pass the record, operation & success",function(){H(true);G.erase({callback:A});var I=A.mostRecentCall.args;expect(I[0]).toBe(G);expect(I[1]).toBe(E);expect(E.wasSuccessful()).toBe(true);expect(I[2]).toBe(true)})});describe("on failure",function(){it("should pass the record, operation & success",function(){H(false);G.erase({callback:A});var I=A.mostRecentCall.args;expect(I[0]).toBe(G);expect(I[1]).toBe(E);expect(E.wasSuccessful()).toBe(false);expect(I[2]).toBe(false)})});it("should default the scope to the model",function(){H(true);G.erase({callback:A});expect(A.mostRecentCall.object).toBe(G)});it("should use the passed scope",function(){H(true);var I={};G.erase({callback:A,scope:I});expect(A.mostRecentCall.object).toBe(I)})})})})})});describe("the initial id",function(){var C,D;function B(E,A){C=Ext.define(null,{extend:"Ext.data.Model",fields:[{name:"id",type:E||"auto",dateFormat:A}]})}afterEach(function(){C=null});describe("auto",function(){beforeEach(function(){B()});it("should auto generate an id when not specified and be phantom",function(){D=new C();var A=D.self.identifier.getPrefix();expect(D.id).toBe(A+"1");expect(D.phantom).toBe(true)});it("should use a specified idand not be phantom",function(){D=new C({id:"foo"});expect(D.id).toBe("foo");expect(D.phantom).toBe(false)})});describe("string",function(){beforeEach(function(){B("string")});it("should auto generate an id when not specified and be phantom",function(){D=new C();var A=D.self.identifier.getPrefix();expect(D.id).toBe(A+"1");expect(D.phantom).toBe(true)});it("should use a specified id and not be phantom",function(){D=new C({id:"foo"});expect(D.id).toBe("foo");expect(D.phantom).toBe(false)});it("should run the converter and not be phantom",function(){D=new C({id:2});expect(D.id).toBe("2");expect(D.phantom).toBe(false)})});describe("int",function(){beforeEach(function(){B("int")});it("should auto generate an id when not specified and be phantom",function(){D=new C();var A=D.self.identifier.getPrefix();expect(D.id).toBe(A+"1");expect(D.phantom).toBe(true)});it("should use a specified id and not be phantom",function(){D=new C({id:32});expect(D.id).toBe(32);expect(D.phantom).toBe(false)});it("should run the converter and not be phantom",function(){D=new C({id:"600"});expect(D.id).toBe(600);expect(D.phantom).toBe(false)})});describe("date",function(){beforeEach(function(){B("date","Y-m-d")});it("should auto generate an id when not specified and be phantom",function(){D=new C();var A=D.self.identifier.getPrefix();expect(D.id).toBe(A+"1");expect(D.phantom).toBe(true)});it("should use a specified id and not be phantom",function(){var A=new Date();D=new C({id:A});expect(D.id).toBe(A);expect(D.phantom).toBe(false)});it("should run the converter and not be phantom",function(){var A=new Date().getTime();D=new C({id:"2012-01-01"});expect(Ext.Date.format(D.id,"Y-m-d")).toBe("2012-01-01");expect(D.phantom).toBe(false)})})});describe("constructing",function(){var D=new Date(),J=[],H={},F,C,E,I,L,K,G;beforeEach(function(){G=false;F=Ext.define("spec.A",{extend:Ext.data.Model,fields:["nothing",{name:"convertOnly",convert:function(A){I=true;if(G){return K}else{return A}}},{name:"convertAndDefaultValue",convert:function(A){L=true;if(G){return K}else{return A}},defaultValue:16},{name:"defaultOnly",defaultValue:"foo"},{name:"objField",defaultValue:{}},{name:"arrField",defaultValue:[]},{name:"dateField",defaultValue:D}]});L=I=false});afterEach(function(){Ext.undefine("spec.A");F=C=E=null;K=undefined});it("should accept no params",function(){expect(function(){E=new F()}).not.toThrow()});it("should assign an underlying data object",function(){E=new F({nothing:"Foo"});expect(E.get("nothing")).toBe("Foo")});it("should read the field if it has a hyphen in the name",function(){var A=Ext.define(null,{extend:"Ext.data.Model",fields:[{name:"the-field",convert:Ext.identityFn}]});E=new A({"the-field":"foo"});expect(E.get("the-field")).toBe("foo")});describe("id",function(){describe("with no value",function(){describe("with no identifier config",function(){it("should generate a new id",function(){spyOn(F.identifier,"generate").andReturn("x");E=new F();expect(E.id).toBe("x")});it("should set phantom: true",function(){E=new F();expect(E.phantom).toBe(true)});it("should put the id on the idProperty field",function(){spyOn(F.identifier,"generate").andReturn("x");E=new F();expect(E.get("id")).toBe("x")})});describe("with identifier config",function(){it("should generate an id",function(){spyOn(F.identifier,"generate").andReturn("Foo");E=new F();expect(E.id).toBe("Foo")});it("should set phantom: true",function(){spyOn(F.identifier,"generate").andReturn("Foo");E=new F();expect(E.phantom).toBe(true)});it("should put the id on the idProperty field",function(){spyOn(F.identifier,"generate").andReturn("Foo");E=new F();expect(E.get("id")).toBe("Foo")})})});describe("with a value",function(){it("should set the id",function(){E=new F({id:3});expect(E.id).toBe(3)});it("should set phantom: false",function(){E=new F({id:3});expect(E.phantom).toBe(false)});it("should modify the idProperty field",function(){E=new F({id:3});expect(E.get("id")).toBe(3)});it("should not call the id generator",function(){spyOn(F.identifier,"generate");E=new F({id:1});expect(F.identifier.generate).not.toHaveBeenCalled()})});it("should convert the ID according to the idField's convert function",function(){var A=Ext.define(null,{extend:"Ext.data.Model",fields:[{name:"pageId"},{name:"browserId"},{name:"id",convert:function(M,N){return N.get("pageId")+N.get("browserId")}}]});var B=new A({pageId:"foo",browserId:"bar",id:"xx"});expect(B.getId()).toBe("foobar")})});describe("convert",function(){it("should call the convert method",function(){G=true;K=10;E=new F({});expect(I).toBe(true);expect(E.get("convertOnly")).toBe(10)});it("should ignore the value from convert if it returns undefined",function(){G=true;K=undefined;E=new F({convertOnly:"foo"});expect(I).toBe(true);expect(E.get("convertOnly")).toBe("foo")})});describe("defaultValue",function(){it("should assign the defaultValue",function(){E=new F({});expect(E.get("defaultOnly")).toBe("foo")});it("should only assign the defaultValue if the value is undefined",function(){E=new F({defaultOnly:null});expect(E.get("defaultOnly")).toBeNull();E=new F({defaultOnly:""});expect(E.get("defaultOnly")).toBe("");E=new F({defaultOnly:false});expect(E.get("defaultOnly")).toBe(false);E=new F({defaultOnly:0});expect(E.get("defaultOnly")).toBe(0)});describe("object types",function(){it("should copy objects",function(){E=new F({});var A=E.get("objField");expect(A).not.toBe(H);expect(A).toEqual(H)});it("should copy dates",function(){E=new F({});var A=E.get("dateField");expect(A).not.toBe(D);expect(A).toEqual(D)});it("should copy arrays",function(){E=new F({});var A=E.get("arrField");expect(A).not.toBe(J);expect(A).toEqual(J)})})});describe("both",function(){it("should call convert if the value is defined",function(){E=new F({convertAndDefaultValue:11});expect(L).toBe(true);expect(E.get("convertAndDefaultValue")).toBe(11)});it("should not call convert if the value is undefined",function(){E=new F({});expect(L).toBe(false)});it("should assign the default if the value is undefined",function(){E=new F({});expect(E.get("convertAndDefaultValue")).toBe(16)});it("should assign the defaultValue if convert returns null",function(){G=true;K=undefined;E=new F({convertAndDefaultValue:11});expect(L).toBe(true);expect(E.get("convertAndDefaultValue")).toBe(16)})})});describe("getting values",function(){var B,C;beforeEach(function(){B=Ext.define("spec.A",{extend:Ext.data.Model,fields:["aField"]})});afterEach(function(){Ext.undefine("spec.A");B=C=null});it("should return a value that was in the fields collection",function(){C=new B({aField:"foo"});expect(C.get("foo"))});it("should return a value not in the fields collection",function(){C=new B({other:"foo"});expect(C.get("other"))});it("should return the value unchanged",function(){var A={};C=new B({aField:A});expect(C.get("aField")).toBe(A)})});describe("setting values",function(){var A,C;var B=function(D){D=Ext.apply({extend:Ext.data.Model,fields:[{name:"id",type:"int"},"name",{name:"dob",type:"date"},{name:"rank",type:"int"}]},D);A=Ext.define("spec.Person",D)};afterEach(function(){Ext.undefine("spec.Person");A=C=null});describe("without dependencies",function(){it("should set a single key/value",function(){B();C=new A();var D=C.set("rank",3);expect(C.get("rank")).toBe(3);expect(D).toEqual(["rank"])});it("should set a key value pairs",function(){B();C=new A();var D=C.set({name:"Foo",rank:4});expect(C.get("name")).toBe("Foo");expect(C.get("rank")).toBe(4);expect(D).toEqual(["name","rank"])});it("should set a value not in the fields collection",function(){B();C=new A();var D=C.set("other",1);expect(C.get("other")).toBe(1);expect(D).toEqual(["other"])});it("should only return fields that were modified",function(){B();C=new A({name:"Foo",rank:3});var D=C.set({name:"Bar",rank:3});expect(D).toEqual(["name"])})});describe("with dependencies",function(){var E;var D=function(F,G){G=Ext.apply({extend:Ext.data.Model,fields:F},G);E=Ext.define("spec.A",G)};afterEach(function(){Ext.undefine("spec.A");E=null});it("should not trigger any dependencies if setting a field that doesn't require it",function(){var G=jasmine.createSpy();D(["name","age",{name:"doubleAge",depends:"age",convert:G}]);C=new E();G.reset();var F=C.set("name","foo");expect(G).not.toHaveBeenCalled();expect(F).toEqual(["name"])});it("should not trigger the dependency if the value doesn't change",function(){var F=jasmine.createSpy();D(["a",{name:"b",depends:"a",convert:F}]);C=new E({a:1});F.reset();C.set("a",1);expect(F).not.toHaveBeenCalled()});it("should trigger a simple dependency",function(){var G=false;D(["name","age",{name:"doubleAge",depends:"age",convert:function(H,I){G=true;return I.get("age")*2}}]);C=new E();var F=C.set("age",10);expect(G).toBe(true);expect(C.get("doubleAge")).toBe(20);expect(F).toEqual(["age","doubleAge"])});it("should not trigger the convert until all dependent fields are set",function(){D(["a","b",{name:"c",depends:["a","b"],convert:function(G,H){return H.get("a")+H.get("b")}}]);C=new E();var F=C.set({a:1,b:3});expect(C.get("c")).toBe(4);expect(F).toEqual(["a","b","c"])});it("should trigger the convert function if either of the dependent fields are set",function(){D(["a","b",{name:"c",depends:["a","b"],convert:function(G,H){return H.get("a")+H.get("b")}}]);C=new E({a:1,b:1});var F=C.set("a",2);expect(C.get("c")).toBe(3);expect(F).toEqual(["a","c"]);F=C.set("b",2);expect(C.get("c")).toBe(4);expect(F).toEqual(["b","c"])});it("should trigger cascading converts",function(){D(["a",{name:"b",depends:"a",convert:function(G,H){return H.get("a")+1}},{name:"c",depends:"b",convert:function(G,H){return H.get("b")+1}},{name:"d",depends:"c",convert:function(G,H){return H.get("c")+1}}]);C=new E();var F=C.set("a",1);expect(C.get("b")).toBe(2);expect(C.get("c")).toBe(3);expect(C.get("d")).toBe(4);expect(F).toEqual(["a","b","c","d"])});it("should allow setting a calculated value",function(){D(["a",{name:"b",depends:"a",convert:function(G,H){return H.get("a")+1}},{name:"c",depends:"b",convert:function(G,H){return H.get("b")+1}}]);C=new E();var F=C.set("b",3,{convert:false});expect(C.get("c")).toBe(4);expect(F).toEqual(["b","c"])});it("should be able to set independent calculated fields at once",function(){D(["a",{name:"b",depends:"a",convert:function(G,H){return H.get("a")+1}},"c",{name:"d",depends:"c",convert:function(G,H){return H.get("c")+1}}]);C=new E();var F=C.set({a:1,c:1});expect(C.get("b")).toBe(2);expect(C.get("d")).toBe(2);expect(F).toEqual(["a","c","b","d"])});it("should allow setting a value its calculated dependent",function(){D(["a",{name:"b",depends:"a",convert:function(F,G){return G.get("a")+1}},{name:"c",depends:"b",convert:function(F,G){return G.get("b")+1}}]);C=new E();C.set({a:1,b:100});expect(C.get("b")).toBe(2);expect(C.get("c")).toBe(3)})});describe("associations",function(){it("should be able to set a foreign key value for a not-loaded association",function(){B({fields:[{name:"addressId",reference:"Address",unique:true}]});C=new A();expect(function(){C.set("addressId",1)}).not.toThrow()})});it("should update the id property if the id changes",function(){B();C=new A();C.set("id",1);expect(C.id).toBe(1)});it("should not call the store while the editing flag is set",function(){B();C=new A();spyOn(C,"callJoined");C.beginEdit();C.set("rank",1);expect(C.callJoined).not.toHaveBeenCalled()});it("should not call the store if there are no modified fields",function(){B();C=new A({rank:1});spyOn(C,"callJoined");C.set("rank",1);expect(C.callJoined).not.toHaveBeenCalled()});describe("options",function(){describe("convert",function(){it("should convert by default",function(){B();C=new A();C.set("rank","1");expect(C.get("rank")).toBe(1)});it("should be convert when passed into the method",function(){B();C=new A();C.set("rank","1",{convert:true});expect(C.get("rank")).toBe(1)});it("should not convert when passed false",function(){B();C=new A();C.set("rank","1",{convert:false});expect(C.get("rank")).toBe("1")});it("should accept options when using the object form",function(){B();C=new A();C.set({rank:"1"},{convert:true});expect(C.get("rank")).toBe(1)})});describe("commit",function(){beforeEach(function(){B()});var D={commit:true};it("should default to false",function(){C=new A();C.set("rank",1);expect(C.dirty).toBe(true)});it("should have no modified fields",function(){C=new A({rank:1});C.set("rank",2,D);expect(C.isModified("rank")).toBe(false)});it("should not be dirty",function(){C=new A({rank:1});C.set("rank",2,D);expect(C.dirty).toBe(false)});it("should call commit even if no fields were modified",function(){C=new A({rank:1});spyOn(C,"commit");C.set("rank",1,D);expect(C.commit).toHaveBeenCalled()});it("should pass the modified fields to commit",function(){C=new A({rank:1});spyOn(C,"commit");C.set({name:"Foo",rank:2},D);expect(C.commit.mostRecentCall.args[1]).toEqual(["name","rank"])});it("should call commit with silent: true if the silent option is passed",function(){C=new A({rank:1});spyOn(C,"commit");C.set("rank",2,{commit:true,silent:true});expect(C.commit.mostRecentCall.args[0]).toBe(true)});it("should not trigger the normal after edit call",function(){C=new A({rank:1});spyOn(C,"callJoined");C.set("rank",2,D);expect(C.callJoined).not.toHaveBeenCalledWith("afterEdit")})});describe("dirty",function(){it("should still return fields in the modified collection with dirty: false",function(){B();C=new A();var D=C.set("rank",1,{dirty:false});expect(D).toEqual(["rank"])})});describe("silent",function(){it("should not trigger the store if the silent flag is set",function(){B();C=new A();spyOn(C,"callJoined");C.set("rank",1,{silent:true});expect(C.callJoined).not.toHaveBeenCalled()})})})});describe("calculated fields",function(){var A,B,C;beforeEach(function(){A=Ext.define(null,{extend:"Ext.data.Model",fields:["name","rank","serialNumber",{name:"calc",calculate:function(D){return D.name+D.rank+D.serialNumber}}]});B=A.getField("calc");C=new A({name:"Don",rank:"Peon",serialNumber:"1234"})});it("should determine the depends by parsing the method",function(){expect(B.depends).toEqual(["name","rank","serialNumber"]);expect(C.data.calc).toBe("DonPeon1234")});it("should react to changes in dependent fields",function(){var D,E;C.join({afterEdit:function(G,F){D=G;E=F;F.sort()}});C.set({name:"Evan",serialNumber:"4321"});expect(D).toBe(C);expect(E).toEqual(["calc","name","serialNumber"]);expect(C.data.calc).toBe("EvanPeon4321");expect(C.getPrevious("name")).toBe("Don");expect(C.getPrevious("calc")).toBe("DonPeon1234")})});describe("value tracking",function(){var A,B;beforeEach(function(){A=Ext.define("spec.Person",{extend:Ext.data.Model,fields:[{name:"id",type:"int"},"name",{name:"dob",type:"date"},{name:"rank",type:"int"},{name:"active",persist:false}]})});afterEach(function(){Ext.undefine("spec.Person");A=B=null});describe("simple modifications",function(){describe("dirty",function(){it("should not be dirty when constructed",function(){B=new A();expect(B.dirty).toBe(false)});it("should not be dirty when constructed with values",function(){B=new A({id:1,name:"Foo",rank:3});expect(B.dirty).toBe(false)});it("should not be dirty when setting a value and it doesn't change",function(){B=new A({rank:1});B.set("rank",1);expect(B.dirty).toBe(false)});it("should not be dirty if setting a non-persistent field",function(){B=new A();B.set("active",false);expect(B.dirty).toBe(false)});it("should be dirty if a field changes value",function(){B=new A();B.set("rank",1);expect(B.dirty).toBe(true)});it("should be dirty if a non-field changes value",function(){B=new A();B.set("notField",2);expect(B.dirty).toBe(true)});it("should be dirty when setting multiple fields",function(){B=new A();B.set({name:"X",rank:17});expect(B.dirty).toBe(true)});it("should be dirty when reverting only a single modified field",function(){B=new A({rank:1,name:"Foo"});B.set({rank:2,name:"Bar"});B.set("rank",1);expect(B.dirty).toBe(true)});it("should be not dirty when reverting all modified fields",function(){B=new A({rank:1,name:"Foo"});B.set({rank:2,name:"Bar"});B.set("rank",1);B.set("name","Foo");expect(B.dirty).toBe(false)});it("should not set dirty if the dirty: false option is passed",function(){B=new A();B.set("rank",1,{dirty:false});expect(B.dirty).toBe(false)})});describe("modified",function(){describe("isModified",function(){it("should not have modified fields when constructed with no vales",function(){B=new A();expect(B.isModified("name")).toBe(false);expect(B.isModified("rank")).toBe(false)});it("should not have modified fields when constructed with data",function(){B=new A({name:"Foo",rank:1});expect(B.isModified("name")).toBe(false);expect(B.isModified("rank")).toBe(false)});it("should not have a modified field if the value doesn't change",function(){B=new A({name:"Foo",rank:1});B.set("name","Foo");expect(B.isModified("name")).toBe(false)});it("should not have a modified field if it's persist: false",function(){B=new A();B.set("active","true");expect(B.isModified("active")).toBe(false)});it("should have a modified field if a field changes value",function(){B=new A();B.set("rank",1);expect(B.isModified("rank")).toBe(true)});it("should have modified fields if multiple fields change",function(){B=new A();B.set({name:"Foo",rank:3});expect(B.isModified("name")).toBe(true);expect(B.isModified("rank")).toBe(true)});it("should have a modified field if a non-field changes",function(){B=new A();B.set("other","foo");expect(B.isModified("other")).toBe(true)});it("should not be modified when reverting a field",function(){B=new A({name:"Foo",rank:1});B.set({name:"Bar",rank:3});B.set("name","Foo");expect(B.isModified("name")).toBe(false);expect(B.isModified("rank")).toBe(true)});it("should not be modified when passing dirty: false",function(){B=new A();B.set("rank",1,{dirty:false});expect(B.isModified("rank")).toBe(false)})});describe("getModified",function(){it("should return undefined if there's no modified value",function(){B=new A();expect(B.getModified("name")).toBeUndefined()});it("should return the previous value when modified",function(){B=new A({rank:1});B.set("rank",2);expect(B.getModified("rank")).toBe(1)});it("should return the original value when modified",function(){B=new A({rank:1});B.set("rank",2);B.set("rank",3);B.set("rank",4);expect(B.getModified("rank")).toBe(1)});it("should return undefined if the modified value is set back to the original",function(){B=new A({rank:1});B.set("rank",2);B.set("rank",1);expect(B.getModified("rank")).toBeUndefined()})})});describe("previousValue",function(){it("should return undefined if there's no previous value",function(){B=new A();expect(B.getPrevious("name")).toBeUndefined()});it("should return the previous value when the value changes",function(){B=new A({name:"Foo"});B.set("name","Bar");expect(B.getPrevious("name")).toBe("Foo")});it("should return the most recent previous value when the value changes",function(){B=new A({name:"Foo"});B.set("name","Bar");B.set("name","Baz");expect(B.getPrevious("name")).toBe("Bar");B.set("name","Blah");expect(B.getPrevious("name")).toBe("Baz")});it("should not update the previousValue if the value doesn't change",function(){B=new A({name:"Foo"});B.set("name","Bar");B.set("name","Bar");expect(B.getPrevious("name")).toBe("Foo")})})});describe("editing",function(){it("should set the editing flag when beginEdit is called",function(){B=new A();B.beginEdit();expect(B.editing).toBe(true)});it("should update the modified values during editing",function(){B=new A({name:"Foo",rank:1});B.beginEdit();B.set("name","Bar");expect(B.getModified("name")).toBe("Foo")});it("should update the previous values during editing",function(){B=new A({name:"Foo",rank:1});B.beginEdit();B.set("name","Bar");expect(B.getPrevious("name")).toBe("Foo")});it("should update the dirty state during editing",function(){B=new A();B.beginEdit();B.set("name","Foo");expect(B.dirty).toBe(true)});describe("cancelEdit",function(){it("should clear the editing flag when cancelEdit is called",function(){B=new A();B.beginEdit();B.cancelEdit();expect(B.editing).toBe(false)});it("should restore data values to the previous state",function(){B=new A({name:"Name1",rank:1});B.beginEdit();B.set({name:"Name2",rank:2});B.cancelEdit();expect(B.get("name")).toBe("Name1");expect(B.get("rank")).toBe(1)});it("should restore modified values to the previous state",function(){B=new A({name:"Name1",rank:1});B.set("name","Name2");B.beginEdit();B.set("rank",2);B.cancelEdit();expect(B.getModified("name")).toBe("Name1");expect(B.isModified("rank")).toBe(false)});it("should restore the previousValues state",function(){B=new A({name:"Name1",rank:1});B.set("name","Name2");B.set({name:"Name3",rank:3});B.beginEdit();B.set({name:"Name4",rank:4});B.set({name:"Name5",rank:5});B.cancelEdit();expect(B.getPrevious("Name2"));expect(B.getPrevious("rank")).toBe(1)});it("should restore the dirty state",function(){B=new A();B.beginEdit();B.set("name","Foo");B.cancelEdit();expect(B.dirty).toBe(false)})});describe("endEdit",function(){it("should clear the editing flag when endEdit is called",function(){B=new A();B.beginEdit();B.endEdit();expect(B.editing).toBe(false)});it("should not modify the data values",function(){B=new A({name:"Name1",rank:1});B.beginEdit();B.set({name:"Name2",rank:2});B.endEdit();expect(B.get("name")).toBe("Name2");expect(B.get("rank")).toBe(2)});it("should not modify the modified values",function(){B=new A({name:"Name1",rank:1});B.set("name","Name2");B.beginEdit();B.set("rank",2);B.endEdit();expect(B.getModified("name")).toBe("Name1");expect(B.getModified("rank")).toBe(1)});it("should restore the previousValues",function(){B=new A({name:"Name1",rank:1});B.set("name","Name2");B.beginEdit();B.set({name:"Name3",rank:3});B.set({name:"Name4",rank:4});B.endEdit();expect(B.getPrevious("name")).toBe("Name1");expect(B.getPrevious("rank")).toBeUndefined()});it("should not modify the dirty state",function(){B=new A({name:"Name1",rank:1});B.beginEdit();B.set("rank",2);B.endEdit();expect(B.dirty).toBe(true)});it("should call the store if the record is dirty with the modified fields",function(){var C,D;B=new A();B.join({afterEdit:function(F,E){C=F;D=E;E.sort()}});B.beginEdit();B.set("name","Foo");B.set("rank",1);B.endEdit();expect(C).toBe(B);expect(D).toEqual(["name","rank"])});it("should not call the store if the record is not dirty",function(){B=new A();B.beginEdit();spyOn(B,"callJoined");B.endEdit();expect(B.callJoined).not.toHaveBeenCalled()});describe("options",function(){it("should not call the store if silent is passed & it's dirty",function(){B=new A();B.beginEdit();B.set("name","Foo");spyOn(B,"callJoined");B.endEdit(true);expect(B.callJoined).not.toHaveBeenCalled()});it("should not call the store if silent is modified fields are passed",function(){B=new A();B.beginEdit();B.set("name","Foo");spyOn(B,"callJoined");B.endEdit(true,["foo"]);expect(B.callJoined).not.toHaveBeenCalled()});it("should call the store even if not dirty if modified fields are passed",function(){var C,D;B=new A();B.join({afterEdit:function(F,E){C=F;D=E}});B.beginEdit();B.endEdit(false,["foo"]);expect(C).toBe(B);expect(D).toEqual(["foo"])})})})});describe("commit",function(){it("should clear the dirty state",function(){B=new A();B.set("rank",1);B.commit();expect(B.dirty).toBe(false)});it("should clear the editing flag",function(){B=new A();B.beginEdit();B.set("rank",1);B.commit();expect(B.editing).toBe(false)});it("should have no modified fields",function(){B=new A({name:"Name1",rank:1});B.set({name:"Name2",rank:2});B.commit();expect(B.isModified("name")).toBe(false);expect(B.isModified("rank")).toBe(false)});it("should have no effect on previous values",function(){B=new A({name:"Name1",rank:1});expect(B.getPrevious("name")).toBeUndefined();expect(B.getPrevious("rank")).toBeUndefined();B.set({name:"Name2",rank:2});expect(B.getPrevious("name")).toBe("Name1");expect(B.getPrevious("rank")).toBe(1);B.commit();expect(B.getPrevious("name")).toBe("Name1");expect(B.getPrevious("rank")).toBe(1)});describe("calling the store with afterCommit",function(){it("should be called",function(){B=new A();spyOn(B,"callJoined");B.commit();expect(B.callJoined).toHaveBeenCalled();expect(B.callJoined.mostRecentCall.args[0]).toBe("afterCommit")});it("should not be called if silent is passed",function(){B=new A();spyOn(B,"callJoined");B.commit(true);expect(B.callJoined).not.toHaveBeenCalled()});it("should pass the modified fields if passed",function(){var C,D;B=new A();B.join({afterCommit:function(F,E){C=F;D=E}});B.commit(false,["foo"]);expect(C).toBe(B);expect(D).toEqual(["foo"])})})});describe("reject",function(){it("should clear the dirty state",function(){B=new A();B.set("rank",1);B.reject();expect(B.dirty).toBe(false)});it("should clear the editing flag",function(){B=new A();B.beginEdit();B.set("rank",1);B.reject();expect(B.editing).toBe(false)});it("should have no modified fields",function(){B=new A({name:"Name1",rank:1});B.set({name:"Name2",rank:2});B.reject();expect(B.isModified("name")).toBe(false);expect(B.isModified("rank")).toBe(false)});it("should update previous values",function(){B=new A({name:"Name1",rank:1});expect(B.getPrevious("name")).toBeUndefined();expect(B.getPrevious("rank")).toBeUndefined();B.set({name:"Name2",rank:2});expect(B.getPrevious("name")).toBe("Name1");expect(B.getPrevious("rank")).toBe(1);B.reject();expect(B.getPrevious("name")).toBe("Name2");expect(B.getPrevious("rank")).toBe(2)});it("should retain the phantom state",function(){B=new A();B.set("name","Foo");B.reject();expect(B.phantom).toBe(true);B=new A({id:1});B.set("name","Foo");B.reject();expect(B.phantom).toBe(false)});describe("after reject",function(){it("should be called",function(){B=new A();spyOn(B,"callJoined");B.reject();expect(B.callJoined).toHaveBeenCalled();expect(B.callJoined.mostRecentCall.args[0]).toBe("afterReject")});it("should not be called if silent is passed",function(){B=new A();spyOn(B,"callJoined");B.reject(true);expect(B.callJoined).not.toHaveBeenCalled()})});describe("other callbacks",function(){it("should not call afterEdit/afterCommit",function(){B=new A();B.set("name","Foo");spyOn(B,"callJoined");B.reject();expect(B.callJoined.callCount).toBe(1);expect(B.callJoined.mostRecentCall.args[0]).toBe("afterReject")})})})});describe("model state",function(){var B,A;beforeEach(function(){A=jasmine.createSpy();B=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name","age",{name:"withConvert",convert:A}]})});afterEach(function(){Ext.undefine("spec.User");A=B=null});describe("commit",function(){it("should clear the dirty state",function(){var C=new B();C.set("name","Foo");expect(C.dirty).toBe(true);C.commit();expect(C.dirty).toBe(false)});it("should not modify any field values",function(){var C=new B();C.set("name","Foo");C.set("age",100);C.commit();expect(C.get("name")).toBe("Foo");expect(C.get("age")).toBe(100)});it("should clear the modified state",function(){var C=new B();C.set("name","Foo");expect(C.isModified("name")).toBe(true);C.commit();expect(C.isModified("name")).toBe(false)});it("should clear any editing state",function(){var C=new B();C.beginEdit();expect(C.editing).toBe(true);C.commit();expect(C.editing).toBe(false)});it("should clear the phantom state",function(){var C=new B();expect(C.phantom).toBe(true);C.commit();expect(C.phantom).toBe(false)});it("should set dropped records to be erased",function(){var C=new B({id:1});C.drop();expect(C.erased).toBe(false);C.commit();expect(C.erased).toBe(true)});describe("notifying joined parties",function(){describe("data commits",function(){it("should notify after a commit",function(){var D=new B(),C=spyOn(D,"callJoined");D.commit();expect(C.callCount).toBe(1);expect(C.mostRecentCall.args[0]).toBe("afterCommit")});it("should pass along any modified fields",function(){var D=new B(),C=spyOn(D,"callJoined");D.commit(false,["foo","bar"]);expect(C.callCount).toBe(1);expect(C.mostRecentCall.args[1]).toEqual([["foo","bar"]])});it("should not notify with silent: true",function(){var D=new B(),C=spyOn(D,"callJoined");D.commit(true);expect(C).not.toHaveBeenCalled()})});describe("via an erase",function(){it("should notify after an erase",function(){var D=new B(),C;D.drop();C=spyOn(D,"callJoined");D.commit();expect(C.callCount).toBe(1);expect(C.mostRecentCall.args[0]).toBe("afterErase")});it("should not notify with silent: true",function(){var D=new B(),C;D.drop();C=spyOn(D,"callJoined");D.commit(true);expect(C).not.toHaveBeenCalled()})})})});describe("reject",function(){it("should clear the dirty state",function(){var C=new B();C.set("name","Foo");expect(C.dirty).toBe(true);C.reject();expect(C.dirty).toBe(false)});it("should return field values to their original states",function(){var C=new B({name:"Foo",age:1});C.set("name","Bar");C.set("age",100);C.reject();expect(C.get("name")).toBe("Foo");expect(C.get("age")).toBe(1)});it("should not run converters when restoring data",function(){var C=new B({name:"Foo",age:1});C.set("name","Bar");C.set("age",100);A.reset();C.reject();expect(A).not.toHaveBeenCalled()});it("should clear the modified state",function(){var C=new B();C.set("name","Foo");expect(C.isModified("name")).toBe(true);C.reject();expect(C.isModified("name")).toBe(false)});it("should clear any editing state",function(){var C=new B();C.beginEdit();expect(C.editing).toBe(true);C.reject();expect(C.editing).toBe(false)});it("should clear the dropped state",function(){var C=new B({id:1});C.drop();C.reject();expect(C.dropped).toBe(false)});describe("notifying joined parties",function(){it("should not call afterEdit when restoring values",function(){var D=new B({name:"Foo"}),C;D.set("name","Bar");C=spyOn(D,"callJoined");D.reject();expect(C.callCount).toBe(1);expect(C.mostRecentCall.args[0]).not.toBe("afterEdit")});it("should call afterReject",function(){var D=new B({name:"Foo"}),C;D.set("name","Bar");C=spyOn(D,"callJoined");D.reject();expect(C.callCount).toBe(1);expect(C.mostRecentCall.args[0]).toBe("afterReject")});it("should not call afterReject with silent: true",function(){var D=new B({name:"Foo"}),C;D.set("name","Bar");C=spyOn(D,"callJoined");D.reject(true);expect(C).not.toHaveBeenCalled()})})})});describe("getData",function(){var B;beforeEach(function(){B=Ext.define(null,{extend:"Ext.data.Model",fields:["id","name"]})});afterEach(function(){B=null});it("should return all the fields in the model",function(){var A=new B({id:1,name:"Foo"});expect(A.getData()).toEqual({id:1,name:"Foo"})});it("should include non-field data",function(){var A=new B({id:1,other:"val"});expect(A.getData().other).toBe("val")});describe("options",function(){var C,A;beforeEach(function(){C=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name",{name:"age",persist:false},{name:"created",serialize:function(D){return Ext.Date.format(D,"Y-m-d")}},{name:"addressId",reference:"Address"}]});A=new C({id:1,age:100,created:new Date(2000,6,15),name:"Foo"})});afterEach(function(){Ext.undefine("spec.User");A=C=null});describe("associated",function(){var D,E;beforeEach(function(){D=Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["id","title",{name:"content",persist:false},{name:"userId",reference:"User"},{name:"created",serialize:function(F){return Ext.Date.format(F,"Y-m-d")}}]});E=Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["id",{name:"street",persist:false},"city",{name:"created",serialize:function(F){return Ext.Date.format(F,"Y-m-d")}}]})});afterEach(function(){Ext.undefine("spec.Address");Ext.undefine("spec.Post");E=D=null});it("should not include associated data by default",function(){expect(A.getData({})).toEqual({id:1,age:100,created:new Date(2000,6,15),name:"Foo"})});it("should not include associated data with associated: false",function(){expect(A.getData({associated:false})).toEqual({id:1,age:100,created:new Date(2000,6,15),name:"Foo"})});it("should include associated data with associated: true",function(){A.posts().add({id:101,content:"X"});expect(A.getData({associated:true})).toEqual({id:1,age:100,created:new Date(2000,6,15),name:"Foo",posts:[{id:101,content:"X",userId:1}]})});describe("passing options down to associated records",function(){describe("changes",function(){it("should only include changes with changes: true",function(){A.posts().add({id:1001,content:"A",title:"B",userId:1,created:new Date(2005,3,22)});A.posts().first().set("title","X");A.setAddress(new E({id:2001,street:"B",city:"C",created:new Date(2008,10,3)}));A.getAddress().set("city","Q");expect(A.getData({associated:true,changes:true})).toEqual({addressId:2001,address:{city:"Q"},posts:[{title:"X"}]})})});describe("critical",function(){it("should include critical fields with critical: true",function(){A.posts().add({id:1001,content:"A",title:"B",userId:1,created:new Date(2005,3,22)});A.posts().first().set("title","X");A.setAddress(new E({id:2001,street:"B",city:"C",created:new Date(2008,10,3)}));A.getAddress().set("city","Q");expect(A.getData({associated:true,changes:true,critical:true})).toEqual({id:1,addressId:2001,address:{id:2001,city:"Q"},posts:[{id:1001,title:"X"}]})})});describe("persist",function(){it("should only include persist fields with persist: true",function(){A.posts().add({id:1001,content:"A",title:"B",userId:1,created:new Date(2005,3,22)});A.posts().first().set("title","X");A.posts().first().set("content","Y");A.setAddress(new E({id:2001,street:"B",city:"C",created:new Date(2008,10,3)}));A.getAddress().set("city","Q");A.getAddress().set("street","Z");expect(A.getData({associated:true,changes:true,critical:true})).toEqual({id:1,addressId:2001,address:{id:2001,city:"Q"},posts:[{id:1001,title:"X"}]})})});describe("serialize",function(){it("should serialize with serialize: true",function(){A.posts().add({id:1001,content:"A",title:"B",userId:1,created:new Date(2005,3,22)});A.setAddress(new E({id:2001,street:"B",city:"C",created:new Date(2008,10,3)}));expect(A.getData({associated:true,serialize:true})).toEqual({id:1,age:100,created:"2000-07-15",name:"Foo",addressId:2001,address:{id:2001,street:"B",city:"C",created:"2008-11-03"},posts:[{id:1001,content:"A",title:"B",userId:1,created:"2005-04-22"}]})})})})});describe("changes",function(){it("should include all fields by default",function(){A.set("age",20);expect(A.getData({})).toEqual({id:1,age:20,created:new Date(2000,6,15),name:"Foo"})});it("should include all fields with changes: false",function(){A.set("age",20);expect(A.getData({changes:false})).toEqual({id:1,age:20,created:new Date(2000,6,15),name:"Foo"})});it("should include all fields with changes: true",function(){A.set("name","Bar");expect(A.getData({changes:true})).toEqual({name:"Bar"})})});describe("critical",function(){it("should not include critical fields by default",function(){A.set("name","Bar");expect(A.getData({changes:true})).toEqual({name:"Bar"})});it("should not include critical fields with critical: false",function(){A.set("name","Bar");expect(A.getData({changes:true,critical:false})).toEqual({name:"Bar"})});it("should include critical fields with critical: true",function(){A.set("name","Bar");expect(A.getData({changes:true,critical:true})).toEqual({id:1,name:"Bar"})})});describe("persist",function(){it("should include all fields by default",function(){expect(A.getData({})).toEqual({id:1,age:100,created:new Date(2000,6,15),name:"Foo"})});it("should include all fields with persist: false",function(){expect(A.getData({persist:false})).toEqual({id:1,age:100,created:new Date(2000,6,15),name:"Foo"})});it("should include only persist fields with persist: true",function(){expect(A.getData({persist:true})).toEqual({id:1,name:"Foo",created:new Date(2000,6,15)})})});describe("serialize",function(){it("should not serialize by default",function(){expect(A.getData({})).toEqual({id:1,name:"Foo",age:100,created:new Date(2000,6,15)})});it("should not serialize with serialize: false",function(){expect(A.getData({serialize:false})).toEqual({id:1,name:"Foo",age:100,created:new Date(2000,6,15)})});it("should serialize with serialize: true",function(){expect(A.getData({serialize:true})).toEqual({id:1,name:"Foo",age:100,created:"2000-07-15"})})})});describe("with associations",function(){var C;function A(F,E){var D=new Ext.data.reader.Json({model:F});return D.read(E).getRecords()[0]}describe("basic many to one",function(){var E,F,D;beforeEach(function(){F=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name"]});D=Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["id","content",{name:"userId",reference:"User"}]});E=Ext.define("spec.Comment",{extend:"Ext.data.Model",fields:["id","content",{name:"postId",reference:"Post"}]})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Post");Ext.undefine("spec.Comment");E=F=D=null});describe("the one",function(){it("should not include the key if the item does not exist",function(){C=A(D,{id:1});var G=C.getAssociatedData();expect(G).toEqual({})});it("should not trigger the item to load",function(){C=A(D,{id:1});C.getAssociatedData();var G=C.getAssociatedData();expect(G).toEqual({})});it("should include the single record",function(){C=A(D,{id:1,user:{id:17,name:"Foo"}});var G=C.getAssociatedData();expect(G).toEqual({user:{id:17,name:"Foo"}})});it("should not include the many on each item",function(){C=A(D,{id:1,user:{id:17,name:"Foo"}});expect(C.getAssociatedData().user.posts).toBeUndefined()})});describe("the many",function(){it("should not include the key if the store does not exist",function(){C=A(F,{id:1});var G=C.getAssociatedData();expect(G).toEqual({})});it("should not trigger the item to load",function(){C=A(F,{id:1});C.getAssociatedData();var G=C.getAssociatedData();expect(G).toEqual({})});it("should include the key if the store exists but is empty",function(){C=A(F,{id:1,posts:[]});var G=C.getAssociatedData();expect(G).toEqual({posts:[]})});it("should include the many records",function(){C=A(F,{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17},{id:3,content:"PostC",userId:17}]});var G=C.getAssociatedData();expect(G).toEqual({posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17},{id:3,content:"PostC",userId:17}]})});it("should not include the one on each many",function(){C=A(F,{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17}]});var K=C.posts(),I=K.getAt(0),G=K.getAt(1),J=D.associations.user.getInstanceName();expect(I[J]).toBe(C);expect(G[J]).toBe(C);var H=C.getAssociatedData().posts;expect(H[0].user).toBeUndefined();expect(H[1].user).toBeUndefined()});it("should not recurse from many to one to many",function(){C=A(F,{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17}]});var I=C.posts();var G=I.getAt(0);var H=G.getData({associated:true});expect(H).toEqual({id:1,content:"PostA",userId:17,user:{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17}]}})})});describe("deeply nested",function(){var G={id:17,posts:[{id:1,content:"PostA",userId:17,comments:[{id:42,content:"This is wrong!"},{id:427,content:"No, you are wrong!"}]},{id:2,content:"PostB",comments:[{id:420,content:"This is wrong too!"},{id:4270,content:"No, you are wrong again!"},{id:4271,content:"Yeah, you are wrong again!"}]}]};beforeEach(function(){C=A(F,Ext.clone(G))});it("should not include associations in data object",function(){expect(C.data).toEqual({id:17})});it("should include the first level of child records",function(){var H=C.posts();expect(H.getCount()).toBe(G.posts.length)});it("should produce all levels in getData(true)",function(){var H=C.getData(true);expect(H).toEqual({id:17,posts:[{id:1,content:"PostA",userId:17,comments:[{id:42,content:"This is wrong!",postId:1},{id:427,content:"No, you are wrong!",postId:1}]},{id:2,content:"PostB",userId:17,comments:[{id:420,content:"This is wrong too!",postId:2},{id:4270,content:"No, you are wrong again!",postId:2},{id:4271,content:"Yeah, you are wrong again!",postId:2}]}]})});it("should have PostA first",function(){var H=C.posts();expect(H.getAt(0).data).toEqual({id:1,content:"PostA",userId:17})});it("should return the proper data for PostA.getData(true)",function(){var H=C.posts().getAt(0);var I=H.getData(true);expect(I).toEqual({id:1,content:"PostA",userId:17,user:{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17,comments:[{id:420,content:"This is wrong too!",postId:2},{id:4270,content:"No, you are wrong again!",postId:2},{id:4271,content:"Yeah, you are wrong again!",postId:2}]}]},comments:[{id:42,content:"This is wrong!",postId:1,post:{id:1,content:"PostA",userId:17,user:{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17,comments:[{id:420,content:"This is wrong too!",postId:2},{id:4270,content:"No, you are wrong again!",postId:2},{id:4271,content:"Yeah, you are wrong again!",postId:2}]}]}}},{id:427,content:"No, you are wrong!",postId:1,post:{id:1,content:"PostA",userId:17,user:{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17,comments:[{id:420,content:"This is wrong too!",postId:2},{id:4270,content:"No, you are wrong again!",postId:2},{id:4271,content:"Yeah, you are wrong again!",postId:2}]}]}}}]})});it("should return the proper data for PostA.comments[0].getData(true)",function(){var H=C.posts().getAt(0);var J=H.comments().getAt(0);var I=J.getData(true);expect(I).toEqual({id:42,content:"This is wrong!",postId:1,post:{id:1,content:"PostA",userId:17,user:{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17,comments:[{id:420,content:"This is wrong too!",postId:2},{id:4270,content:"No, you are wrong again!",postId:2},{id:4271,content:"Yeah, you are wrong again!",postId:2}]}]},comments:[{id:42,content:"This is wrong!",postId:1},{id:427,content:"No, you are wrong!",postId:1,post:{id:1,content:"PostA",userId:17,user:{id:17,posts:[{id:1,content:"PostA",userId:17},{id:2,content:"PostB",userId:17,comments:[{id:420,content:"This is wrong too!",postId:2},{id:4270,content:"No, you are wrong again!",postId:2},{id:4271,content:"Yeah, you are wrong again!",postId:2}]}]}}}]}})});it("should link PostA to the proper user",function(){var H=C.posts().getAt(0);expect(H.getUser()).toBe(C)});it("should load comments for PostA",function(){var H=C.posts().getAt(0);var I=H.comments();expect(I.getCount()).toBe(G.posts[0].comments.length)});it("should load proper first comment for PostA",function(){var H=C.posts().getAt(0);var I=H.comments();expect(I.getAt(0).data).toEqual({id:42,content:"This is wrong!",postId:1})});it("should load proper second comment for PostA",function(){var H=C.posts().getAt(0);var I=H.comments();expect(I.getAt(1).data).toEqual({id:427,content:"No, you are wrong!",postId:1})});it("should link the first comment for PostA to its Post",function(){var H=C.posts().getAt(0);var I=H.comments();expect(I.getAt(0).getPost()).toBe(H)});it("should link the second comment for PostA to its Post",function(){var H=C.posts().getAt(0);var I=H.comments();expect(I.getAt(1).getPost()).toBe(H)});it("should have PostB second",function(){var H=C.posts();expect(H.getAt(1).data).toEqual({id:2,content:"PostB",userId:17})});it("should link PostA to the proper user",function(){var H=C.posts().getAt(0);expect(H.getUser()).toBe(C)});it("should load comments for PostB",function(){var H=C.posts().getAt(1);var I=H.comments();expect(I.getCount()).toBe(G.posts[1].comments.length)});it("should load proper first comment for PostB",function(){var H=C.posts().getAt(1);var I=H.comments();expect(I.getAt(0).data).toEqual({id:420,content:"This is wrong too!",postId:2})});it("should load proper second comment for PostB",function(){var H=C.posts().getAt(1);var I=H.comments();expect(I.getAt(1).data).toEqual({id:4270,content:"No, you are wrong again!",postId:2})});it("should load proper third comment for PostB",function(){var H=C.posts().getAt(1);var I=H.comments();expect(I.getAt(2).data).toEqual({id:4271,content:"Yeah, you are wrong again!",postId:2})});it("should link the first comment for PostB to its Post",function(){var H=C.posts().getAt(1);var I=H.comments();expect(I.getAt(0).getPost()).toBe(H)});it("should link the second comment for PostB to its Post",function(){var H=C.posts().getAt(1);var I=H.comments();expect(I.getAt(1).getPost()).toBe(H)});it("should link the third comment for PostA to its Post",function(){var H=C.posts().getAt(1);var I=H.comments();expect(I.getAt(2).getPost()).toBe(H)})})});describe("basic one to one",function(){var D,E;beforeEach(function(){D=Ext.define("spec.Person",{extend:"Ext.data.Model",fields:["id","name",{name:"passportId",unique:true,reference:"Passport"}]});E=Ext.define("spec.Passport",{extend:"Ext.data.Model",fields:["id","expires"]})});afterEach(function(){Ext.undefine("spec.Person");Ext.undefine("spec.Passport");D=E=null});describe("the key holder",function(){it("should not include the key if the item does not exist",function(){C=A(D,{id:1});var F=C.getAssociatedData();expect(F).toEqual({})});it("should not trigger the item to load",function(){C=A(D,{id:1});C.getAssociatedData();var F=C.getAssociatedData();expect(F).toEqual({})});it("should include the single record",function(){C=A(D,{id:1,passport:{id:22,expires:"2000-01-01"}});expect(C.data.passport).toBeUndefined();var G=C.getPassport();expect(G.getPerson()).toBe(C);var F=C.getData(true);expect(F).toEqual({id:1,passportId:22,passport:{id:22,expires:"2000-01-01"}})});it("should not include the key holder on each non-key holder",function(){C=A(D,{id:1,passport:{id:22,expires:"2000-01-01"}});var F=C.getAssociatedData();expect(F.passport.user).toBeUndefined()})});describe("the non key holder",function(){it("should not include the key if the item does not exist",function(){C=A(E,{id:1});var F=C.getAssociatedData();expect(F).toEqual({})});it("should not trigger the item to load",function(){C=A(E,{id:1});C.getAssociatedData();var F=C.getAssociatedData();expect(F).toEqual({})});it("should include the single record",function(){C=A(E,{id:1,person:{id:45,name:"Foo"}});var F=C.getAssociatedData();expect(F).toEqual({person:{id:45,name:"Foo"}})});it("should not include the non-key holder on each key holder",function(){C=A(E,{id:1,person:{id:45,name:"Foo"}});var H=E.associations.person.getInstanceName(),F=D.associations.passport.getInstanceName();C.getPerson().setPassport(C);var G=C.getAssociatedData();expect(G.person.passport).toBeUndefined()})})});describe("basic many to many",function(){var F,E,D;beforeEach(function(){F=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name",{name:"profileId",reference:"Profile",unique:true}],manyToMany:"Group"});E=Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["id","name",{name:"profileId",reference:"Profile",unique:true}]});D=Ext.define("spec.Profile",{extend:"Ext.data.Model",fields:["id","content"]})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Group");Ext.undefine("spec.Profile");D=F=E=null});describe("the left",function(){it("should not include the key if the item is not loaded",function(){C=A(F,{id:1});var G=C.getAssociatedData();expect(G).toEqual({})});it("should not trigger the item to load",function(){C=A(F,{id:1});C.getAssociatedData();var G=C.getAssociatedData();expect(G).toEqual({})});it("should include the key if the store exists but is empty",function(){C=A(F,{id:1,groups:[]});var G=C.getAssociatedData();expect(G).toEqual({groups:[]})});it("should include the child records",function(){C=A(F,{id:100,groups:[{id:1,name:"GroupA"},{id:2,name:"GroupB"},{id:3,name:"GroupC"}]});var G=C.getAssociatedData();expect(G).toEqual({groups:[{id:1,name:"GroupA"},{id:2,name:"GroupB"},{id:3,name:"GroupC"}]})});it("should not include the inverse on each child",function(){C=A(F,{id:100,groups:[{id:1,name:"GroupA"},{id:2,name:"GroupB"}]});expect(C.data.groups).toBeUndefined();var G=C.groups(),I=G.first().users(),H=G.last().users();I.add(C);H.add(C);G=C.getAssociatedData().groups;expect(G[0].users.length).toBe(1);expect(G[0].users[0].id).toBe(C.id);expect(G[0].users[0].groups).toBeUndefined();expect(G[1].users.length).toBe(1);expect(G[1].users[0].id).toBe(C.id);expect(G[1].users[0].groups).toBeUndefined()});it("should include other associations on the children",function(){C=A(F,{id:100,groups:[{id:1,name:"GroupA",profile:{id:22,content:"Foo"}},{id:2,name:"GroupB",profile:{id:33,content:"Bar"}}]});var G=C.getAssociatedData();expect(G).toEqual({groups:[{id:1,name:"GroupA",profileId:22,profile:{id:22,content:"Foo"}},{id:2,name:"GroupB",profileId:33,profile:{id:33,content:"Bar"}}]})})});describe("the right",function(){it("should not include the key if the item is not loaded",function(){C=A(E,{id:1});var G=C.getAssociatedData();expect(G).toEqual({})});it("should not trigger the item to load",function(){C=A(E,{id:1});C.getAssociatedData();var G=C.getAssociatedData();expect(G).toEqual({})});it("should include the key if the store exists but is empty",function(){C=A(E,{id:1,users:[]});var G=C.getAssociatedData();expect(G).toEqual({users:[]})});it("should include the child records",function(){C=A(E,{id:100,users:[{id:1,name:"UserA"},{id:2,name:"UserB"},{id:3,name:"UserC"}]});var G=C.getAssociatedData();expect(G).toEqual({users:[{id:1,name:"UserA"},{id:2,name:"UserB"},{id:3,name:"UserC"}]})});it("should not include the inverse on each child",function(){C=A(E,{id:100,users:[{id:1,name:"UserA"},{id:2,name:"UserB"}]});expect(C.data.users).toBeUndefined();var I=C.users(),G=I.first().groups(),H=I.last().groups();G.add(C);H.add(C);I=C.getAssociatedData().users;expect(I[0].groups.length).toBe(1);expect(I[0].groups[0].id).toBe(C.id);expect(I[0].groups[0].users).toBeUndefined();expect(I[1].groups.length).toBe(1);expect(I[1].groups[0].id).toBe(C.id);expect(I[1].groups[0].users).toBeUndefined()});it("should include other associations on the children",function(){C=A(E,{id:100,users:[{id:1,name:"UserA",profile:{id:22,content:"Foo"}},{id:2,name:"UserB",profile:{id:33,content:"Bar"}}]});var G=C.getAssociatedData();expect(G).toEqual({users:[{id:1,name:"UserA",profileId:22,profile:{id:22,content:"Foo"}},{id:2,name:"UserB",profileId:33,profile:{id:33,content:"Bar"}}]})})})});describe("complex cases",function(){describe("nested data",function(){var D;beforeEach(function(){D=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name"]});Ext.define("spec.Order",{extend:"Ext.data.Model",fields:["id","date",{name:"userId",reference:"User"}]});Ext.define("spec.OrderItem",{extend:"Ext.data.Model",fields:["id","price",{name:"orderId",reference:"Order"},{name:"productId",unique:true,reference:"Product"}]});Ext.define("spec.Product",{extend:"Ext.data.Model",fields:["id","name"]})});afterEach(function(){D=null;Ext.undefine("spec.User");Ext.undefine("spec.Order");Ext.undefine("spec.OrderItem");Ext.undefine("spec.Product")});it("should load nested associations",function(){C=A(D,{id:1,orders:[{id:1,date:"2010-01-01",orderItems:[{id:1,price:20,productId:1,product:{id:1,name:"Product1"}},{id:2,price:30,productId:2,product:{id:2,name:"Product2"}},{id:3,price:40,productId:1,product:{id:1,name:"Product1"}}]},{id:2,date:"2008-01-01",orderItems:[{id:4,price:50,productId:2,product:{id:2,name:"Product2"}},{id:5,price:60,productId:3,product:{id:3,name:"Product3"}},{id:6,price:70,productId:1,product:{id:1,name:"Product1"}}]}]});var E=C.getAssociatedData();expect(E).toEqual({orders:[{id:1,date:"2010-01-01",userId:1,orderItems:[{id:1,price:20,productId:1,orderId:1,product:{id:1,name:"Product1"}},{id:2,price:30,productId:2,orderId:1,product:{id:2,name:"Product2"}},{id:3,price:40,productId:1,orderId:1,product:{id:1,name:"Product1"}}]},{id:2,date:"2008-01-01",userId:1,orderItems:[{id:4,price:50,productId:2,orderId:2,product:{id:2,name:"Product2"}},{id:5,price:60,productId:3,orderId:2,product:{id:3,name:"Product3"}},{id:6,price:70,productId:1,orderId:2,product:{id:1,name:"Product1"}}]}]})})});describe("multiple associations of the same type",function(){var D;beforeEach(function(){Ext.define("spec.User",{extend:"Ext.data.Model"});D=Ext.define("spec.Ticket",{extend:"Ext.data.Model",fields:["id",{name:"creatorId",unique:true,reference:{type:"User",role:"creator"}},{name:"ownerId",unique:true,reference:{type:"User",role:"owner"}}]})});afterEach(function(){D=null;Ext.undefine("spec.User");Ext.undefine("spec.Ticket")});it("should be able to have multiple associations of the same type",function(){C=A(D,{id:1,creator:{id:1,name:"Foo"},owner:{id:2,name:"Bar"}});var E=C.getAssociatedData();expect(E).toEqual({creator:{id:1,name:"Foo"},owner:{id:2,name:"Bar"}})})});describe("recursive associations",function(){var D;beforeEach(function(){D=Ext.define("spec.Node",{extend:"Ext.data.Model",fields:["id","text",{name:"parentId",reference:{type:"Node",role:"parent",inverse:{role:"children"}}}]})});it("should read recursive associations",function(){C=A(D,{id:1,text:"Root",children:[{id:2,text:"Child1",children:[{id:5,text:"Child1.1"},{id:6,text:"Child1.2"}]},{id:3,text:"Child2",children:[{id:7,text:"Child2.1"}]},{id:4,text:"Child3",children:[{id:8,text:"Child3.1"},{id:9,text:"Child3.2"},{id:10,text:"Child3.3"}]}]});var E=C.getAssociatedData();expect(E).toEqual({children:[{id:2,parentId:1,text:"Child1",children:[{id:5,parentId:2,text:"Child1.1"},{id:6,parentId:2,text:"Child1.2"}]},{id:3,parentId:1,text:"Child2",children:[{id:7,parentId:3,text:"Child2.1"}]},{id:4,parentId:1,text:"Child3",children:[{id:8,parentId:4,text:"Child3.1"},{id:9,parentId:4,text:"Child3.2"},{id:10,parentId:4,text:"Child3.3"}]}]})})});describe("repeating records",function(){var D;beforeEach(function(){D=Ext.define("spec.Organization",{extend:"Ext.data.Model",fields:["id","name"]});Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["id","name",{name:"organizationId",reference:"Organization"}]});Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name",{name:"groupId",reference:"Group"}]})});afterEach(function(){D=null;Ext.undefine("spec.Organization");Ext.undefine("spec.Group");Ext.undefine("spec.User")});it("should be able to repeat records with the same id",function(){C=A(D,{id:1,name:"Org",groups:[{id:1,name:"Group1",users:[{id:1,name:"Foo"}]},{id:2,name:"Group2",users:[{id:1,name:"Foo"}]},{id:3,name:"Group3",users:[{id:1,name:"Foo"}]}]});var E=C.getAssociatedData().groups;expect(E[0].users[0]).toEqual({id:1,groupId:1,name:"Foo"});expect(E[1].users[0]).toEqual({id:1,groupId:2,name:"Foo"});expect(E[2].users[0]).toEqual({id:1,groupId:3,name:"Foo"})})})})})});describe("validation",function(){var C,G;function B(I,A,H){H=Ext.apply({extend:Ext.data.Model,fields:A||["id","name","rank"],validators:I},H);C=Ext.define("spec.A",H)}afterEach(function(){C=G=null;Ext.undefine("spec.A")});var F="Must be present",D="Is in the wrong format",E="Is not a valid email address";describe("validate",function(){it("should call the validate method for each field and pass the current value",function(){B();G=new C({id:100,name:"Foo",rank:1234});var A=spyOn(G.getField("id"),"validate"),I=spyOn(G.getField("name"),"validate"),H=spyOn(G.getField("rank"),"validate");G.validate();expect(A.mostRecentCall.args[0]).toBe(100);expect(I.mostRecentCall.args[0]).toBe("Foo");expect(H.mostRecentCall.args[0]).toBe(1234)});describe("when valid",function(){beforeEach(function(){B({name:"presence"});G=new C({name:"x"})});it("should return an ErrorCollection",function(){var A=G.validate();expect(A instanceof Ext.data.ErrorCollection).toBe(true)});it("should have no items in the error collection",function(){var A=G.validate();expect(A.getCount()).toBe(0);expect(A.isValid()).toBe(true)})});describe("when not valid",function(){it("should return an ErrorCollection",function(){B({name:"presence"});G=new C();var A=G.validate();expect(A instanceof Ext.data.ErrorCollection).toBe(true)});it("should put an error for each invalid field",function(){B(null,[{name:"name",validators:"presence"},{name:"rank",validators:{type:"format",matcher:/\d+/}},{name:"email",validators:"email"}]);G=new C({name:"X"});var I=G.validate(),H=I.get("rank"),A=I.get("email");expect(I.getCount()).toBe(2);expect(I.isValid()).toBe(false);expect(H.field).toBe("rank");expect(H.message).toBe(D);expect(A.field).toBe("email");expect(A.message).toBe(E)});it("should return multiple errors for a field",function(){B(null,[{name:"name",validators:["presence","email"]}]);G=new C();var H=G.validate(),A=H.get("name");expect(H.getCount()).toBe(1);expect(H.isValid()).toBe(false);expect(A[0].field).toBe("name");expect(A[0].message).toBe(F);expect(A[1].field).toBe("name");expect(A[1].message).toBe(E)})})});describe("isValid",function(){it("should return true if all fields in the model are valid",function(){B({name:"presence"});var A=new C({name:"Foo"});expect(A.isValid()).toBe(true)});it("should return false if only some fields are valid",function(){B({name:"presence",rank:"presence"});var A=new C({name:"foo",rank:null});expect(A.isValid()).toBe(false)});it("should return false if all fields in the model are not valid",function(){B({name:"presence"});var A=new C({name:null});expect(A.isValid()).toBe(false)})});describe("validation via getValidation",function(){it("should return true if all fields in the model are valid",function(){B({name:"presence"});var A=new C({name:"Foo"});expect(A.getValidation().isValid()).toBe(true)});it("should return false if only some fields are valid",function(){B({name:"presence",rank:"presence"});var A=new C({name:"foo",rank:null});expect(A.getValidation().isValid()).toBe(false)});it("should return false if all fields in the model are not valid",function(){B({name:"presence"});var A=new C({name:null});expect(A.getValidation().isValid()).toBe(false)})})});describe("synchronize validators with the Validation record",function(){var B,A;beforeEach(function(){B=Ext.define(null,{extend:Ext.data.Model,fields:[{name:"first",type:"string"},{name:"last",type:"string",convert:null},{name:"email",type:"string"},{name:"formatField",type:"string"},{name:"phone",type:"string",convert:null},{name:"color",type:"string"},{name:"description",type:"string"},{name:"initial",type:"string"}],validators:{last:"presence",description:{type:"length",min:10,max:200},color:{type:"inclusion",list:["red","white","blue"]},first:{type:"exclusion",list:["Ed"]},formatField:{type:"format",matcher:/123/},email:"email",phone:{type:"presence",message:"Phone number required"}},doValidate:function(){}})});describe("the legacy Errors object",function(){var C=Ext.data.validator.Validator.all,D;beforeEach(function(){A=new B({description:"too short",color:"not a valid color",first:"Ed",formatField:"abc",email:"abc"});D=A.validate()});it("should report valid object as having no errors",function(){A=new B({description:"long enough",color:"red",first:"Don",last:"Griffin",formatField:"123",email:"don@sencha.com",phone:"555-1212"});D=A.validate();expect(D.length).toEqual(0)});it("should collect failing validations into an Errors object",function(){expect(D instanceof Ext.data.Errors).toBe(true)});it("should produce ErrorCollection as an alias for Errors",function(){expect(D instanceof Ext.data.ErrorCollection).toBe(true)});it("should have the correct number of error messages",function(){expect(D.length).toEqual(7)});it("should hold Errors in an items array",function(){expect(D.items.length).toEqual(7)});it("should have the correct non-presence message",function(){var E=D.getByField("last")[0];expect(E.message).toEqual(C.presence.config.message)});it("should have the correct bad length message",function(){var E=D.getByField("description")[0];expect(E.message).toEqual("Length must be between 10 and 200")});it("should have the correct bad format message",function(){var E=D.getByField("formatField")[0];expect(E.message).toEqual(C.format.config.message)});it("should have the correct non-inclusion message",function(){var E=D.getByField("color")[0];expect(E.message).toEqual(C.inclusion.config.message)});it("should have the correct non-exclusion message",function(){var E=D.getByField("first")[0];expect(E.message).toEqual(C.exclusion.config.message)});it("should have the correct bad email format message",function(){var E=D.getByField("email")[0];expect(E.message).toEqual(C.email.config.message)});it("should allow user-defined error messages",function(){var E=D.getByField("phone")[0];expect(E.message).toEqual("Phone number required")})})});describe("support for legacy validations",function(){var F,B,D=function(G){return G},C=function(G){return G},A=function(G){return G},E=function(G){return G?G.toUpperCase():""};beforeEach(function(){spyOn(Ext.log,"warn");F=Ext.define(null,{extend:Ext.data.Model,fields:[{name:"id"},{name:"first",type:"string",convert:D},{name:"last",type:"string",convert:null},{name:"email",type:"string"},{name:"formatField",type:"string"},{name:"phone",type:"string",convert:C},{name:"color",type:"string"},{name:"description",type:"string",convert:A},{name:"nopersist",type:"string",persist:false},{name:"initial",type:"string",convert:E}],validations:[{type:"presence",field:"last"},{type:"length",field:"description",min:10,max:200},{type:"inclusion",field:"color",list:["red","white","blue"]},{type:"exclusion",field:"first",list:["Ed"]},{type:"format",field:"formatField",matcher:/123/},{type:"email",field:"email"},{type:"presence",field:"phone",message:"Phone number required"}],doValidate:function(){}})});describe("the Errors object",function(){var G=Ext.data.validator.Validator.all,H;beforeEach(function(){B=new F({description:"too short",color:"not a valid color",first:"Ed",formatField:"abc",email:"abc"});H=B.validate()});it("should report valid object as having no errors",function(){B=new F({description:"long enough",color:"red",first:"Don",last:"Griffin",formatField:"123",email:"don@sencha.com",phone:"555-1212"});H=B.validate();expect(H.length).toEqual(0)});it("should collect failing validations into an Errors object",function(){expect(H instanceof Ext.data.Errors).toBe(true)});it("should produce ErrorCollection as an alias for Errors",function(){expect(H instanceof Ext.data.ErrorCollection).toBe(true)});it("should have the correct number of error messages",function(){expect(H.length).toEqual(7)});it("should hold Errors in an items array",function(){expect(H.items.length).toEqual(7)});it("should have the correct non-presence message",function(){var I=H.getByField("last")[0];expect(I.message).toEqual(G.presence.config.message)});it("should have the correct bad length message",function(){var I=H.getByField("description")[0];expect(I.message).toEqual("Length must be between 10 and 200")});it("should have the correct bad format message",function(){var I=H.getByField("formatField")[0];expect(I.message).toEqual(G.format.config.message)});it("should have the correct non-inclusion message",function(){var I=H.getByField("color")[0];expect(I.message).toEqual(G.inclusion.config.message)});it("should have the correct non-exclusion message",function(){var I=H.getByField("first")[0];expect(I.message).toEqual(G.exclusion.config.message)});it("should have the correct bad email format message",function(){var I=H.getByField("email")[0];expect(I.message).toEqual(G.email.config.message)});it("should allow user-defined error messages",function(){var I=H.getByField("phone")[0];expect(I.message).toEqual("Phone number required")})})});describe("copy/clone",function(){var D,B,A,C;beforeEach(function(){D=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name","age","startDate"]})});afterEach(function(){Ext.destroy(C);Ext.undefine("spec.User");D=B=A=C=null});describe("copy",function(){it("should return a model of the same type",function(){B=new D();A=B.copy();expect(A.self).toBe(B.self)});it("should copy data across and retain types, but the data object should be different",function(){var E=new Date();B=new D({name:"Foo",age:12,startDate:E});A=B.copy();expect(A.get("name")).toBe("Foo");expect(A.get("age")).toBe(12);expect(A.get("startDate")).toBe(E);expect(A.data).not.toBe(B.data)});it("should copy across non-fields",function(){B=new D({nonField:100});A=B.copy();expect(A.get("nonField")).toBe(100)});it("should not be dirty/phantom/modified",function(){B=new D({name:"Foo"});B.set("name","Bar");A=B.copy();expect(A.phantom).toBe(false);expect(A.dirty).toBe(false);expect(A.isModified("name")).toBe(false)});describe("the id",function(){it("should copy the id",function(){B=new D({id:1});A=B.copy();expect(A.id).toBe(1)});it("should generate a new id when null is passed",function(){B=new D();A=B.copy(null);expect(A.id).not.toBe(B.id)});it("should use a passed id",function(){B=new D({id:10});A=B.copy(20);expect(A.id).toBe(20)});it("should allow an id of 0",function(){B=new D({id:1});A=B.copy(0);expect(A.id).toBe(0)})});describe("session",function(){beforeEach(function(){C=new Ext.data.Session()});it("should add the record to the passed session",function(){B=new D();A=B.copy(null,C);expect(C.peekRecord("User",A.id)).toBe(A)});it("should not copy a session by default",function(){B=new D({id:1},C);A=B.copy();expect(A.session).toBeNull()})})});describe("clone",function(){it("should return a model of the same type",function(){B=new D();A=B.clone();expect(A.self).toBe(B.self)});it("should copy data across and retain types, but the data object should be different",function(){var E=new Date();B=new D({name:"Foo",age:12,startDate:E});A=B.clone();expect(A.get("name")).toBe("Foo");expect(A.get("age")).toBe(12);expect(A.get("startDate")).toBe(E);expect(A.data).not.toBe(B.data)});it("should copy across non-fields",function(){B=new D({nonField:100});A=B.clone();expect(A.get("nonField")).toBe(100)});describe("model states",function(){it("should copy across phantom state",function(){B=new D();A=B.clone();expect(A.phantom).toBe(true)});it("should copy across the modified state",function(){B=new D({name:"Foo"});B.set("name","Bar");A=B.clone();expect(A.isModified("name")).toBe(true)});it("should copy across the dirty state",function(){B=new D({name:"Foo"});B.set("name","Bar");A=B.clone();expect(A.dirty).toBe(true)});it("should copy the dropped state",function(){B=new D();B.drop();A=B.clone();expect(A.dropped).toBe(true)})});describe("session",function(){beforeEach(function(){C=new Ext.data.Session()});it("should add the record to the passed session",function(){B=new D();A=B.clone(C);expect(C.peekRecord("User",A.id)).toBe(A)});it("should not copy a session by default",function(){B=new D({id:1},C);A=B.clone();expect(A.session).toBeNull()})})})});describe("drop",function(){var B;beforeEach(function(){B=Ext.define("spec.A",{extend:"Ext.data.Model",fields:["id","name"]})});afterEach(function(){Ext.undefine("spec.A");B=null});it("should mark the record as dropped",function(){var A=new B({id:1});A.drop();expect(A.dropped).toBe(true)});it("should not erase the record if it is not a phantom",function(){var A=new B({id:1});A.drop();expect(A.dropped).toBe(true);expect(A.erased).toBe(false)});it("should erase the record if it is a phantom",function(){var A=new B();A.drop();expect(A.dropped).toBe(true);expect(A.erased).toBe(true)});it("should call afterDrop",function(){var A=new B({id:1});spyOn(A,"callJoined");A.drop();expect(A.callJoined).toHaveBeenCalled();expect(A.callJoined.mostRecentCall.args[0]).toBe("afterDrop")});describe("associations",function(){var A,C,E,D;beforeEach(function(){Ext.define("spec.Order",{extend:"Ext.data.Model",fields:["id","date",{name:"addressId",unique:true,reference:{child:"Address"}}]});Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["id","city"]});Ext.define("spec.OrderItem",{extend:"Ext.data.Model",fields:["id","price","qty",{name:"orderId",reference:{parent:"Order"}}]});A=new spec.Order({id:1});C=new spec.Address({id:201});A.setAddress(C);E=A.orderItems();D=E.add({id:101,orderId:1})[0]});afterEach(function(){Ext.undefine("spec.Order");Ext.undefine("spec.Address");Ext.undefine("spec.OrderItem");A=C=E=D=null});it("should cascade by default",function(){A.drop();Ext.data.Model.schema.processKeyChecks(true);expect(C.dropped).toBe(true);expect(D.dropped).toBe(true)});it("should cascade with cascade: true",function(){A.drop(true);Ext.data.Model.schema.processKeyChecks(true);expect(C.dropped).toBe(true);expect(D.dropped).toBe(true)});it("should not cascade with cascade: false",function(){A.drop(false);Ext.data.Model.schema.processKeyChecks(true);expect(C.dropped).toBe(false);expect(D.dropped).toBe(false)})})});describe("versionProperty",function(){var A;beforeEach(function(){A=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name"],versionProperty:"version"})});afterEach(function(){Ext.undefine("spec.User");A=null});it("should increment the versionProperty when commiting",function(){var B=new A({id:1,name:"Foo",version:5});B.set("name","Bar");B.commit();expect(B.get("version")).toBe(6)});it("should not increment the versionProperty when committing a phantom",function(){var B=new A({name:"Foo"});expect(B.get("version")).toBe(1);B.set("name","Bar");B.commit();expect(B.get("version")).toBe(1)});it("should not increment the versionProperty when rejecting",function(){var B=new A({id:1,name:"X"});B.set("name","Bar");B.reject();expect(B.get("version")).toBe(1)})})})