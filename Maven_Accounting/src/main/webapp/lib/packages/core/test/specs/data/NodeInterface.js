describe("Ext.data.NodeInterface",function(){function A(C,B,E){var F={fn:E||Ext.emptyFn},D=spyOn(F,"fn");C.addListener(B,F.fn);return D}beforeEach(function(){Ext.define("spec.TreeNode",{extend:"Ext.data.TreeModel",fields:[{name:"text",type:"string"}],proxy:{type:"memory"}})});afterEach(function(){Ext.undefine("spec.TreeNode");Ext.data.Model.schema.clear()});describe("decorating",function(){var B;beforeEach(function(){B=spec.TreeNode.prototype.fieldsMap});it("should decorate the Model with a parentId field that has the same type as the idProperty",function(){var D=B.parentId,C=B[spec.TreeNode.idProperty].getType();expect(D.getPersist()).toBe(true);expect(D.getType()).toBe(C);expect(D.getDefaultValue()).toBeNull()});it("should decorate the Model with an index field",function(){var C=B.index;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("int");expect(C.getDefaultValue()).toBe(-1)});it("should decorate the Model with a depth field",function(){var C=B.depth;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("int");expect(C.getDefaultValue()).toBe(0)});it("should decorate the Model with an expanded field",function(){var C=B.expanded;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an expandable field",function(){var C=B.expandable;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(true)});it("should decorate the Model with a checked field",function(){var C=B.checked;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("auto");expect(C.getDefaultValue()).toBe(null)});it("should decorate the Model with a leaf field",function(){var C=B.leaf;expect(C.getPersist()).toBe(true);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with a cls field",function(){var C=B.cls;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with an iconCls field",function(){var C=B.iconCls;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with an icon field",function(){var C=B.icon;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with a root field",function(){var C=B.root;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an isLast field",function(){var C=B.isLast;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an isFirst field",function(){var C=B.isFirst;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an allowDrop field",function(){var C=B.allowDrop;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(true)});it("should decorate the Model with an allowDrag field",function(){var C=B.allowDrag;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(true)});it("should decorate the Model with a loaded field",function(){var C=B.loaded;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with a loading field",function(){var C=B.loading;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("bool");expect(C.getDefaultValue()).toBe(false)});it("should decorate the Model with an href field",function(){var C=B.href;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with an hrefTarget field",function(){var C=B.hrefTarget;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with a qtip field",function(){var C=B.qtip;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with a qtitle field",function(){var C=B.qtitle;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("string");expect(C.getDefaultValue()).toBe("")});it("should decorate the Model with a children field",function(){var C=B.children;expect(C.getPersist()).toBe(false);expect(C.getType()).toBe("auto");expect(C.getDefaultValue()).toBe(null)});it("should decorate Model class of a given record",function(){var E,D,C;E=Ext.define("spec.MyModel",{extend:"Ext.data.Model",fields:[{name:"text",type:"string"}],proxy:{type:"memory"}});D=E.create({text:"record1"});C=E.create({text:"record2"});expect(E.prototype.isNode).toBeUndefined();expect(D.isNode).toBeUndefined();expect(C.isNode).toBeUndefined();Ext.data.NodeInterface.decorate(D);expect(E.prototype.isNode).toBeTruthy();expect(D.isNode).toBeTruthy();expect(C.isNode).toBeTruthy();Ext.undefine("spec.MyModel")})});describe("methods",function(){var C,F,E,B,G;function D(){E.appendChild(C);E.appendChild(F);E.updateInfo(false,{isFirst:true,isLast:true,depth:0,index:0,parentId:null})}beforeEach(function(){C=new spec.TreeNode({id:"left"});F=new spec.TreeNode({id:"right"});E=new spec.TreeNode({id:"root"});B=new spec.TreeNode({id:"spare"})});describe("isFirst",function(){beforeEach(function(){D.call(this)});it("should have rootNode which is first",function(){expect(E.isFirst()).toBe(true)});it("should have leftChild which is first",function(){expect(C.isFirst()).toBe(true)});it("should have rightChild which is not first",function(){expect(F.isFirst()).toBe(false)})});describe("isLast",function(){beforeEach(function(){D.call(this)});it("should have rootNode which is last",function(){expect(E.isLast()).toBe(true)});it("should have leftChild which is not last",function(){expect(C.isLast()).toBe(false)});it("should have rightChild which is last",function(){expect(F.isLast()).toBe(true)})});describe("hasChildNodes",function(){beforeEach(function(){E.appendChild(C)});it("should have rootNode with children",function(){expect(E.hasChildNodes()).toBe(true)});it("should have leftChild whithout children",function(){expect(C.hasChildNodes()).toBe(false)})});describe("isExpandable",function(){it("should have node expandable if it has children",function(){B.appendChild(C);expect(B.isExpandable()).toBe(true)});it("should have node expandable if has no children",function(){expect(B.isExpandable()).toBe(true)});it("should have node not expandable if it is a leaf node",function(){B.set("leaf",true);expect(B.isExpandable()).toBe(false)})});describe("append",function(){describe("appending children",function(){it("should fire beforeappend",function(){G=A(E,"beforeappend").andCallThrough();E.appendChild(C);expect(G).toHaveBeenCalledWith(E,C)});it("should cancel append if beforeappend return false",function(){G=A(E,"beforeappend").andReturn(false);expect(E.appendChild(C)).toBe(false);expect(G.callCount).toEqual(1)});it("should set firstChild",function(){E.appendChild(C);expect(E.firstChild).toEqual(C)});it("should set lastChild",function(){E.appendChild(C);expect(E.lastChild).toEqual(C)});it("should add node to childnodes",function(){var H;E.appendChild(C);H=E.childNodes;expect(H.length).toEqual(1);expect(H[0]).toEqual(C)});it("should fire append event",function(){G=A(E,"append").andCallThrough();E.appendChild(C);expect(G).toHaveBeenCalledWith(E,C,0)});it("should return node",function(){var H=E.appendChild(C);expect(H).toEqual(C)});it("should append array of nodes",function(){E.appendChild([C,F]);var H=E.childNodes;expect(H[0]).toEqual(C);expect(H[1]).toEqual(F);expect(H.length).toEqual(2)})});describe("appending with existing siblings",function(){beforeEach(function(){D.call(this)});it("should set next sibling",function(){expect(C.nextSibling).toEqual(F);expect(F.nextSibling).toBeNull()});it("should set previous sibling",function(){expect(F.previousSibling).toEqual(C);expect(C.previousSibling).toBeNull()})});describe("appending children from an existing node",function(){var H,I;beforeEach(function(){H=new spec.TreeNode({id:"oldparent"});H.appendChild(B)});it("should remove from existing node",function(){I=spyOn(H,"removeChild").andCallThrough();E.appendChild(B);expect(I).toHaveBeenCalledWith(B,false,undefined,true)});it("should fire beforeremove event",function(){I=A(H,"beforeremove").andCallThrough();E.appendChild(B);expect(I).toHaveBeenCalledWith(H,B,true)});it("should fire remove event",function(){I=A(H,"remove").andCallThrough();E.appendChild(B);expect(I).toHaveBeenCalledWith(H,B,true,I.mostRecentCall.args[3])});it("should fire beforemove event",function(){I=A(B,"beforemove").andCallThrough();E.appendChild(B);expect(I).toHaveBeenCalledWith(B,H,E,0)});it("should fire move event",function(){I=A(B,"move").andCallThrough();E.appendChild(B);expect(I).toHaveBeenCalledWith(B,H,E,0)})})});describe("insert",function(){beforeEach(function(){E.appendChild(F)});describe("inserting children",function(){it("should call appendChild if the node to insert before is null",function(){G=spyOn(E,"appendChild");E.insertBefore(C);expect(G).toHaveBeenCalledWith(C)});it("should do nothing if the node to insert before is equal to the node to insert",function(){expect(E.insertBefore(C,C)).toBe(false)});it("should fire beforeinsert",function(){G=A(E,"beforeinsert").andCallThrough();E.insertBefore(C,F);expect(G).toHaveBeenCalledWith(E,C,F)});it("should cancel insert if beforeinsert return false",function(){G=A(E,"beforeinsert").andReturn(false);expect(E.insertBefore(C,F)).toBe(false);expect(G.callCount).toEqual(1)});it("should set firstChild",function(){E.insertBefore(C,F);expect(E.firstChild).toEqual(C)});it("should set lastChild",function(){E.insertBefore(C,F);expect(E.lastChild).toEqual(F)});it("should fire insert",function(){G=A(E,"insert").andCallThrough();E.insertBefore(C,F);expect(G).toHaveBeenCalledWith(E,C,F)});it("should update indexes for all siblings after the position where the node was inserted",function(){E.insertBefore(B,F);E.insertBefore(C,B);expect(B.get("index")).toEqual(1);expect(F.get("index")).toEqual(2)});it("should handle siblings",function(){expect(C.previousSibling).toBeNull();expect(C.nextSibling).toBeNull();expect(F.previousSibling).toBeNull();expect(F.nextSibling).toBeNull();E.insertBefore(C,F);expect(C.previousSibling).toBeNull();expect(C.nextSibling).toEqual(F);expect(F.previousSibling).toEqual(C);expect(F.nextSibling).toBeNull()});describe("move",function(){beforeEach(function(){E.appendChild(C)});it("should fire beforemove",function(){G=A(C,"beforemove").andCallThrough();E.insertBefore(C,F);expect(G).toHaveBeenCalledWith(C,E,E,0,F)});it("should cancel insert if beforemove return false",function(){G=A(C,"beforemove").andReturn(false);expect(E.insertBefore(C,F)).toBe(false);expect(G.callCount).toEqual(1)});it("should fire move",function(){G=A(C,"move").andCallThrough();E.insertBefore(C,F);expect(G).toHaveBeenCalledWith(C,E,E,0,F)})})})});describe("removing children",function(){it("should return false when removing bad node",function(){expect(E.removeChild(C)).toBe(false)});it("should fire beforeremove event",function(){D.call(this);G=A(E,"beforeremove").andCallThrough();E.removeChild(C);expect(G).toHaveBeenCalledWith(E,C,false)});it("should cancel remove if beforeremove returns false",function(){D.call(this);G=A(E,"beforeremove").andReturn(false);expect(E.removeChild(C)).toBe(false);expect(G.callCount).toEqual(1)});it("should fire remove event",function(){D.call(this);G=A(E,"remove").andCallThrough();E.removeChild(C);expect(G).toHaveBeenCalledWith(E,C,false,G.mostRecentCall.args[3])});it("should remove child from childNodes",function(){var I,H;D.call(this);I=E.childNodes;H=I.length;E.removeChild(C);expect(I.length).toEqual(H-1);expect(I[0]).toEqual(F)});it("should manage siblings",function(){D.call(this);E.appendChild(B);E.removeChild(F);expect(C.nextSibling,B);expect(B.previousSibling,C)});it("should erase node if asked",function(){D.call(this);G=spyOn(C,"erase").andCallThrough();E.removeChild(C,true);expect(G).toHaveBeenCalled()});it("should clear node if asked",function(){D.call(this);G=spyOn(C,"clear").andCallThrough();E.removeChild(C,false);expect(G).toHaveBeenCalled()});it("should update indexes for all siblings after the node's old position",function(){D.call(this);E.appendChild(B);E.removeChild(C);expect(F.get("index")).toEqual(0);expect(B.get("index")).toEqual(1)})});describe("clearing references",function(){beforeEach(function(){D.call(this);E.appendChild(B)});it("should nullify parentNode",function(){expect(F.parentNode).not.toBeNull();F.clear();expect(F.parentNode).toBeNull()});it("should nullifies nextSibling",function(){expect(F.nextSibling).not.toBeNull();F.clear();expect(F.nextSibling).toBeNull()});it("should nullifies previousSibling",function(){expect(F.previousSibling).not.toBeNull();F.clear();expect(F.previousSibling).toBeNull()});it("should remove lastChild and firstChild references",function(){F.clear(true);expect(F.firstChild).toBeNull();expect(F.lastChild).toBeNull()})});describe("item",function(){it("should return the child node at the specified index",function(){E.appendChild(C);E.appendChild(F);E.appendChild(B);expect(E.getChildAt(0)).toEqual(C);expect(E.getChildAt(1)).toEqual(F);expect(E.getChildAt(2)).toEqual(B)})});describe("silent destroy",function(){it("should purge node listeners",function(){G=spyOn(C.mixins.observable,"clearListeners").andCallThrough();C.destroy(true);expect(G).toHaveBeenCalled()});it("should erase children",function(){var H;D.call(this);G=spyOn(C,"erase").andCallThrough();H=spyOn(F,"erase").andCallThrough();E.erase();expect(G).toHaveBeenCalled();expect(H).toHaveBeenCalled()});it("should nullify childNodes",function(){D.call(this);expect(E.childNodes).not.toBeNull();E.erase(true);expect(E.childNodes).toBeNull()})});describe("non-silent destroy",function(){it("should remove node",function(){D.call(this);G=spyOn(C,"remove").andCallThrough();C.erase(false);expect(G).toHaveBeenCalled()})});describe("remove",function(){it("should remove from parent",function(){G=spyOn(E,"removeChild").andCallThrough();E.appendChild(C);C.remove();expect(G).toHaveBeenCalledWith(C,undefined,undefined)});it("should return node",function(){expect(C.remove()).toEqual(C)})});describe("removeAll",function(){it("should remove all children",function(){E.appendChild([C,F,B]);E.removeAll();expect(E.childNodes.length).toBe(0)})});describe("replacing children",function(){beforeEach(function(){D.call(this)});it("should keep the same childNodes length",function(){var H=E.childNodes.length;E.replaceChild(B,C);expect(E.childNodes.length).toEqual(H)});it("should replace node",function(){E.replaceChild(B,C);expect(E.childNodes[0],B)})});describe("getting depth",function(){beforeEach(function(){D.call(this);C.appendChild(B)});it("should have a depth of 0 for rootNode",function(){expect(E.getDepth()).toEqual(0)});it("should have a depth of 1 for leftChild and rightChild",function(){expect(F.getDepth()).toEqual(1);expect(C.getDepth()).toEqual(1)});it("should have a depth of 2 for spareNode",function(){expect(B.getDepth()).toEqual(2)})});describe("getting path",function(){beforeEach(function(){D.call(this);C.appendChild(B)});it("should set root path",function(){expect(E.getPath()).toEqual("/root")});it("should set middle path",function(){expect(C.getPath()).toEqual("/root/left");expect(F.getPath()).toEqual("/root/right")});it("should set leaf path",function(){expect(B.getPath()).toEqual("/root/left/spare")})});describe("indexOf",function(){it("should always return -1 when the node is empty",function(){expect(E.indexOf(B)).toBe(-1)});it("should return -1 when the passed node is not a child",function(){E.appendChild(C);expect(E.indexOf(B)).toBe(-1)});it("should return the correct index when the node exists",function(){E.appendChild([C,B,F]);expect(E.indexOf(B)).toBe(1)})});describe("indexOfId",function(){it("should always return -1 when the node is empty",function(){expect(E.indexOfId("spare")).toBe(-1)});it("should return -1 when the passed node is not a child",function(){E.appendChild(C);expect(E.indexOfId("spare")).toBe(-1)});it("should return the correct index when the node exists",function(){E.appendChild([C,B,F]);expect(E.indexOfId("spare")).toBe(1)})});describe("bubbling",function(){var H;beforeEach(function(){D.call(this);C.appendChild(B);H=jasmine.createSpy()});it("should call bubbleFn 3 times",function(){B.bubble(H);expect(H.callCount).toEqual(3)});it("should call bubbleFn with node spare, left, root",function(){B.bubble(H);expect(H.calls[0].args).toEqual([B]);expect(H.calls[1].args).toEqual([C]);expect(H.calls[2].args).toEqual([E])});it("should call bubbleFn with a defined scope",function(){B.bubble(H,fakeScope);expect(H.calls[0].object).toBe(fakeScope);expect(H.calls[1].object).toBe(fakeScope);expect(H.calls[2].object).toBe(fakeScope)});it("should call bubbleFn with customs arguments",function(){var I=["some","args"];B.bubble(H,B,I);expect(H.calls[0].args).toEqual(I);expect(H.calls[1].args).toEqual(I);expect(H.calls[2].args).toEqual(I)});it("should stop when bubbleFn return false",function(){H.andCallFake(function(I){if(I.getId()=="left"){return false}});B.bubble(H);expect(H.callCount).toEqual(2)})});describe("cascading",function(){var H;beforeEach(function(){D.call(this);C.appendChild(B);H=jasmine.createSpy()});it("should call cascadeFn 4 times",function(){E.cascadeBy(H);expect(H.callCount).toEqual(4)});it("should call cascadeFn with node root, leftChild, spareNode, rightChild",function(){E.cascadeBy(H);expect(H.calls[0].args).toEqual([E]);expect(H.calls[1].args).toEqual([C]);expect(H.calls[2].args).toEqual([B]);expect(H.calls[3].args).toEqual([F])});it("should call cascadeFn with a defined scope",function(){E.cascadeBy(H,fakeScope);expect(H.calls[0].object).toBe(fakeScope);expect(H.calls[1].object).toBe(fakeScope);expect(H.calls[2].object).toBe(fakeScope);expect(H.calls[3].object).toBe(fakeScope)});it("should call cascadeFn with customs arguments",function(){var I=["some","args"];E.cascadeBy(H,E,I);expect(H.calls[0].args).toEqual(I);expect(H.calls[1].args).toEqual(I);expect(H.calls[2].args).toEqual(I);expect(H.calls[3].args).toEqual(I)});it("should stop at end of branch when cascadeFn return false",function(){H.andCallFake(function(I){if(I.getId()=="left"){return false}});E.cascadeBy(H);expect(H.callCount).toEqual(3)})});describe("each child",function(){var H;beforeEach(function(){D.call(this);H=jasmine.createSpy()});it("should be called 2 times",function(){E.eachChild(H);expect(H.callCount).toEqual(2)});it("should call eachFn with node root, leftChild, rightChild",function(){E.eachChild(H);expect(H.calls[0].args).toEqual([C]);expect(H.calls[1].args).toEqual([F])});it("should call eachFn with a defined scope",function(){E.eachChild(H,fakeScope);expect(H.calls[0].object).toBe(fakeScope);expect(H.calls[1].object).toBe(fakeScope)});it("should call eachFn with customs arguments",function(){var I=["some","args"];E.eachChild(H,E,I);expect(H.calls[0].args).toEqual(I);expect(H.calls[1].args).toEqual(I)});it("should stop when eachFn return false",function(){H.andCallFake(function(I){if(I.getId()=="left"){return false}});E.eachChild(H);expect(H.callCount).toEqual(1)})});describe("ancestors",function(){beforeEach(function(){D.call(this);C.appendChild(B)});it("should have parent as ancestor",function(){expect(B.isAncestor(C)).toBe(true)});it("should have root as ancestor",function(){expect(B.isAncestor(E)).toBe(true)});it("should not have uncle as ancestor",function(){expect(B.isAncestor(F)).toBe(false)})});describe("contains",function(){beforeEach(function(){D.call(this);C.appendChild(B)});it("should contain child",function(){expect(E.contains(C)).toBe(true)});it("should contain grand child",function(){expect(E.contains(B)).toBe(true)});it("should not contain parent",function(){expect(B.contains(C)).toBe(false)})});describe("finding children",function(){beforeEach(function(){D.call(this);C.appendChild(B)});describe("findChild",function(){it("should find shallow children",function(){expect(E.findChild("id","left")).toEqual(C)});it("should not find deep children if deep is not specified",function(){expect(E.findChild("id","spare")).toBeNull()});it("should not find deep children if deep is false",function(){expect(E.findChild("id","spare",false)).toBeNull()});it("should find deep children if deep is true",function(){expect(E.findChild("id","spare",true)).toEqual(B)})});describe("findChildBy",function(){var H;it("should find shallow children",function(){H=E.findChildBy(function(I){return I.getId()=="right"});expect(H).toEqual(F)});it("should not find deep children if deep is not specified",function(){H=E.findChildBy(function(I){return I.getId()=="spare"});expect(H).toBeNull()});it("should not find deep children if deep is false",function(){H=E.findChildBy(function(I){return I.getId()=="spare"},this,false);expect(H).toBeNull()});it("should find deep children if deep is true",function(){H=E.findChildBy(function(I){return I.getId()=="spare"},this,true);expect(H).toEqual(B)});it("should call function with good scope",function(){var I=jasmine.createSpy().andReturn(false);H=E.findChildBy(I,fakeScope,true);expect(I.calls[0].object).toBe(fakeScope);expect(I.calls[1].object).toBe(fakeScope);expect(I.calls[2].object).toBe(fakeScope)})})});describe("sort",function(){var J,I,H,L,K;beforeEach(function(){Ext.define("spec.EmployeeTreeNode",{extend:"Ext.data.Model",fields:[{name:"lastname",type:"string"},{name:"firstname",type:"string"}]});Ext.data.NodeInterface.decorate(spec.EmployeeTreeNode);J=new spec.EmployeeTreeNode({lastname:"Avins",firstname:"Jamie"});I=new spec.EmployeeTreeNode({lastname:"Dougan",firstname:"Robert"});H=new spec.EmployeeTreeNode({lastname:"Ferrero",firstname:"Nicolas"});L=new spec.EmployeeTreeNode({lastname:"Spencer",firstname:"Edward"});E.appendChild([L,I,H,J]);K=jasmine.createSpy();K.andCallFake(function(N,M){if(N.get("lastname")===M.get("lastname")){return 0}return(N.get("lastname")<M.get("lastname"))?-1:1});E.sort(K)});afterEach(function(){Ext.undefine("spec.EmployeeTreeNode")});it("should sort the child by lastname with the correct function",function(){expect(E.childNodes[0]).toEqual(J);expect(E.childNodes[1]).toEqual(I);expect(E.childNodes[2]).toEqual(H);expect(E.childNodes[3]).toEqual(L)})});describe("copy",function(){it("should not copy childNodes by default",function(){var I=new spec.TreeNode({text:"Text",id:1});var H=I.copy();expect(H.getData()).toEqual({allowDrag:true,allowDrop:true,checked:null,children:null,cls:"",depth:0,expandable:true,expanded:false,href:"",hrefTarget:"",icon:"",iconCls:"",id:1,index:-1,isFirst:false,isLast:false,leaf:false,loaded:false,loading:false,parentId:null,qtip:"",qtitle:"",qshowDelay:0,root:false,text:"Text",visible:true})});it("should accept a new id",function(){var I=new spec.TreeNode({text:"Text",id:1});var H=I.copy(2);expect(H.getData()).toEqual({allowDrag:true,allowDrop:true,checked:null,children:null,cls:"",depth:0,expandable:true,expanded:false,href:"",hrefTarget:"",icon:"",iconCls:"",id:2,index:-1,isFirst:false,isLast:false,leaf:false,loaded:false,loading:false,parentId:null,qtip:"",qtitle:"",qshowDelay:0,root:false,text:"Text",visible:true})});it("should clone children if deep: true is specified",function(){var H=new spec.TreeNode({id:1,text:"Root"});var K=H.appendChild(new spec.TreeNode({id:2,text:"Child1"}));var J=K.appendChild(new spec.TreeNode({id:3,text:"Child2"}));J.appendChild(new spec.TreeNode({id:4,text:"Child3"}));var I=H.copy(undefined,true);expect(I.childNodes[0].getId()).toBe(2);expect(I.childNodes[0].get("text")).toBe("Child1");I=I.childNodes[0];expect(I.childNodes[0].getId()).toBe(3);expect(I.childNodes[0].get("text")).toBe("Child2");I=I.childNodes[0];expect(I.childNodes[0].getId()).toBe(4);expect(I.childNodes[0].get("text")).toBe("Child3")})})});describe("serialize",function(){it("should create an object representation of the node",function(){var D=new spec.TreeNode({text:"Root",id:1}),C=D.appendChild(new spec.TreeNode({text:"C1",id:2})),B=D.appendChild(new spec.TreeNode({text:"C1",id:3}));C.appendChild(new spec.TreeNode({text:"c1.1",id:4}));B.appendChild(new spec.TreeNode({text:"c2.1",id:5}));expect(D.serialize()).toEqual({"text":"Root","id":1,"parentId":null,"leaf":false,"children":[{"text":"C1","id":2,"parentId":1,"leaf":false,"children":[{"text":"c1.1","id":4,"parentId":2,"leaf":false}]},{"text":"C1","id":3,"parentId":1,"leaf":false,"children":[{"text":"c2.1","id":5,"parentId":3,"leaf":false}]}]})});it("should not include children if there are none",function(){var C=new spec.TreeNode({text:"foo"}),B=C.serialize();expect(B.text).toBe("foo");expect(B.children).toBeUndefined()});it("should include children if they exist",function(){var C=new spec.TreeNode({text:"foo"}),B;C.appendChild(new spec.TreeNode({text:"bar"}));B=C.serialize();expect(B.text).toBe("foo");expect(B.children[0].text).toBe("bar")})});describe("collapse",function(){it("should fire the collapse callback when there are no child nodes",function(){var B=new spec.TreeNode(),C;B.collapseChildren(false,function(){C=true});expect(C).toBe(true);B=null})});describe("modified property tracking",function(){it("should track modifications of fields set as a result of node movement",function(){Ext.define("spec.PersistentIndexTreeNode",{extend:"Ext.data.TreeModel",fields:[{name:"text",type:"string"},{name:"index",type:"int",persist:true,defaultValue:-1}],proxy:{type:"memory"}});var C=new spec.PersistentIndexTreeNode({id:"TestRoot"}),B=new spec.PersistentIndexTreeNode({id:"OtherTestRoot"}),E=new spec.PersistentIndexTreeNode({id:"node"}),D;C.appendChild(E);expect(E.modified).toEqual({index:-1,parentId:null});E.commit();expect(E.modified).toBeNull();B.appendChild(E);expect(E.modified).toEqual({parentId:"TestRoot",index:0});E.commit();B.removeChild(E);expect(E.modified).toEqual({lastParentId:undefined,parentId:"OtherTestRoot"});E=new spec.PersistentIndexTreeNode({id:"node"});D=new spec.PersistentIndexTreeNode({id:"node1"});C.clear();C.appendChild([E,D]);expect([E.get("index"),D.get("index")]).toEqual([0,1]);E.commit();D.commit();C.insertBefore(D,E);expect([D.get("index"),E.get("index")]).toEqual([0,1]);expect(D.modified).toEqual({index:1});expect(E.modified).toEqual({index:0});B.appendChild(D);Ext.undefine("spec.PersistentIndexTreeNode")})})})