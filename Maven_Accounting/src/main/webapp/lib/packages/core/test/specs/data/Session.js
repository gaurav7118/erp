describe("Ext.data.Session",function(){function E(O,P){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode(O)},P)}var L;function H(P,O){if(Ext.isObject(P)){P=P.id;O=O.id}return P-O}var N,A;var B,C,I;var F,G;var J,K,M;function D(P,S,O,Q){O=O||L;Q=Q||{};var R=O.getRecord(P,S);Q.id=Q.id||S;E(Q);return R}beforeEach(function(){MockAjaxManager.addMethods();N={id:42,name:"Admins"};A={id:427,name:"Peons"};J={id:10,name:"Rufus"};K={id:20,name:"Bill"};M={id:30,name:"Ted"};B=[N,A];C=[A];I=[A];F=[J];G=[K,M,J]});afterEach(function(){MockAjaxManager.removeMethods();Ext.destroy(L);L=null});describe("record access",function(){var Q,O,P;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");Q=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name",{name:"addressId",reference:"Address",unique:true}],manyToMany:"Group"});O=new Ext.data.Session();L=new Ext.data.Session()});afterEach(function(){O.destroy();Q=P=O=null;Ext.undefine("spec.User");Ext.data.Model.schema.clear(true)});describe("adopt",function(){it("should cache the record into the session",function(){P=new Q({id:1});L.adopt(P);expect(L.peekRecord("User",1)).toBe(P)});it("should put the session on the record",function(){P=new Q({id:1});L.adopt(P);expect(P.session).toBe(L)});it("should not throw an error if a record already in the session is adopted",function(){P=D("User",1);expect(function(){L.adopt(P)}).not.toThrow()});describe("invalid conditions",function(){it("should not allow a record attached to another session",function(){var R=new Ext.data.Session(),S=D("User",1,R);expect(function(){L.adopt(S)}).toThrow();R.destroy()});it("should raise an error if add a model the schema does not know about",function(){var R=new Ext.data.schema.Schema();Ext.define("spec.CustomModel",{extend:"Ext.data.Model",schema:R});P=new spec.CustomModel({id:1});expect(function(){L.adopt(P)}).toThrow()});it("should raise an error if adding an existing record",function(){P=D("User",1);expect(function(){L.adopt(new Q({id:1}))}).toThrow()})});describe("associations",function(){describe("many to one",function(){var R;beforeEach(function(){Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["content",{name:"userId",reference:"User"}]})});afterEach(function(){Ext.undefine("spec.Post");R=null});function S(T){R=new Q({id:T})}describe("the many",function(){it("should not attempt to load the owner",function(){var T=new spec.Post({id:101,userId:1});var U=spyOn(Q.getProxy(),"read");L.adopt(T);expect(U).not.toHaveBeenCalled()});it("should also adopt the owner",function(){var T=new spec.Post({id:101,userId:1});S(1);T.setUser(R);L.adopt(T);expect(R.session).toBe(L)})});describe("the one",function(){it("should not load the store",function(){S(1);R.posts();var T=spyOn(Q.getProxy(),"read");L.adopt(R);expect(T).not.toHaveBeenCalled()});it("should set the session onto the store",function(){S(1);var T=R.posts();L.adopt(R);expect(T.getSession()).toBe(L)});it("should adopt existing children",function(){S(1);var T=R.posts();T.add({id:101},{id:102},{id:103});L.adopt(R);expect(T.getAt(0).session).toBe(L);expect(T.getAt(1).session).toBe(L);expect(T.getAt(2).session).toBe(L)});it("should adopt any newly loaded items after adopting",function(){S(1);var T=R.posts();L.adopt(R);T.load();E([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);expect(T.getAt(0).session).toBe(L);expect(T.getAt(1).session).toBe(L);expect(T.getAt(2).session).toBe(L)})})});describe("one to one",function(){beforeEach(function(){Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["city"]})});afterEach(function(){Ext.undefine("spec.Address")});describe("the key holder",function(){it("should not attempt to load the non key holder",function(){var R=new Q({id:1,addressId:101});var S=spyOn(spec.Address.getProxy(),"read");L.adopt(R);expect(S).not.toHaveBeenCalled()});it("should adopt the non key holder",function(){var R=new spec.Address({id:101});var S=new Q({id:1});S.setAddress(R);L.adopt(S);expect(R.session).toBe(L)})});describe("the non key holder",function(){it("should not attempt to load the key holder",function(){var R=new spec.Address({id:101});var S=spyOn(Q.getProxy(),"read");L.adopt(R);expect(S).not.toHaveBeenCalled()});it("should also adopt the key holder",function(){var R=new spec.Address({id:101});var S=new Q({id:1});R.setUser(S);L.adopt(R);expect(S.session).toBe(L)})})});describe("many to many",function(){var R;beforeEach(function(){R=Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["name"]})});afterEach(function(){Ext.undefine("spec.Group");R=null});describe("the left",function(){it("should not load the store",function(){var T=new R({id:1});T.users();var S=spyOn(R.getProxy(),"read");L.adopt(T);expect(S).not.toHaveBeenCalled()});it("should set the session onto the store",function(){var S=new R({id:1}),T=S.users();L.adopt(S);expect(T.getSession()).toBe(L)});it("should adopt existing children",function(){var S=new R({id:1}),T=S.users();T.add({id:101},{id:102},{id:103});L.adopt(S);expect(T.getAt(0).session).toBe(L);expect(T.getAt(1).session).toBe(L);expect(T.getAt(2).session).toBe(L)});it("should adopt any newly loaded items after adopting",function(){var S=new R({id:1}),T=S.users();L.adopt(S);T.load();E([{id:101},{id:102},{id:103}]);expect(T.getAt(0).session).toBe(L);expect(T.getAt(1).session).toBe(L);expect(T.getAt(2).session).toBe(L)})});describe("the right",function(){it("should not load the store",function(){var S=new Q({id:1});S.groups();var T=spyOn(R.getProxy(),"read");L.adopt(S);expect(T).not.toHaveBeenCalled()});it("should set the session onto the store",function(){var T=new Q({id:1}),S=T.groups();L.adopt(T);expect(S.getSession()).toBe(L)});it("should adopt existing children",function(){var T=new Q({id:1}),S=T.groups();S.add({id:101},{id:102},{id:103});L.adopt(T);expect(S.getAt(0).session).toBe(L);expect(S.getAt(1).session).toBe(L);expect(S.getAt(2).session).toBe(L)});it("should adopt any newly loaded items after adopting",function(){var T=new Q({id:1}),S=T.groups();L.adopt(T);S.load();E([{id:101},{id:102},{id:103}]);expect(S.getAt(0).session).toBe(L);expect(S.getAt(1).session).toBe(L);expect(S.getAt(2).session).toBe(L)})})});describe("nested",function(){beforeEach(function(){Ext.define("spec.Order",{extend:"Ext.data.Model",fields:[{name:"userId",reference:"User"},{name:"addressId",reference:"Address",unique:true}]});Ext.define("spec.OrderItem",{extend:"Ext.data.Model",fields:[{name:"orderId",reference:"Order"}]});Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["city"]})});afterEach(function(){Ext.undefine("spec.Address");Ext.undefine("spec.OrderItem");Ext.undefine("spec.Order")});it("should adopt data deeply",function(){var S=Q.load(1);E({id:1,orders:[{id:101,userId:1,address:{id:201},orderItems:[{id:301,orderId:101},{id:302,orderId:101}]},{id:102,userId:1,address:{id:202},orderItems:[{id:303,orderId:102},{id:304,orderId:102}]}]});L.adopt(S);var R=S.orders().getAt(0);expect(R.session).toBe(L);expect(R.getAddress().session).toBe(L);expect(R.orderItems().getAt(0).session).toBe(L);expect(R.orderItems().getAt(1).session).toBe(L);R=S.orders().getAt(1);expect(R.session).toBe(L);expect(R.getAddress().session).toBe(L);expect(R.orderItems().getAt(0).session).toBe(L);expect(R.orderItems().getAt(1).session).toBe(L)})})})});describe("createRecord",function(){it("should accept the entity name",function(){P=L.createRecord("User",{name:"Foo"});expect(P.$className).toBe("spec.User");expect(P.get("name")).toBe("Foo")});it("should accept the entity class",function(){P=L.createRecord(spec.User,{name:"Foo"});expect(P.$className).toBe("spec.User");expect(P.get("name")).toBe("Foo")});it("should throw an exception with an unrecognized model name",function(){expect(function(){L.createRecord("Luser",{})}).toThrow()});it("should throw an exception creating an anonymous model",function(){var R=Ext.define(null,{extend:"Ext.data.Model",fields:["name"]});expect(function(){L.createRecord(R,{})}).toThrow()});it("should cache the record in the session",function(){P=L.createRecord("User",{});expect(L.getRecord("User",P.getId())).toBe(P)});it("should set the session on the instance",function(){P=L.createRecord("User",{});expect(P.session).toBe(L)});it("should throw an exception if the record exists in the session",function(){D("User",1);expect(function(){P=L.createRecord("User",{id:1}).toThrow()})});it("should be able to create a phantom with no data",function(){var R;expect(function(){R=L.createRecord("User")}).not.toThrow();expect(R.phantom).toBe(true)});describe("with a parent",function(){beforeEach(function(){L.setParent(O)});it("should not create the record in the parent session",function(){D("User",1);expect(O.peekRecord("User",1)).toBeNull()});it("should raise an exception if the record exists in the parent",function(){D("User",1,O);expect(function(){L.createRecord("User",{id:1})}).toThrow()});it("should be able to create a phantom with no data",function(){var R;expect(function(){R=L.createRecord("User")}).not.toThrow();expect(R.phantom).toBe(true)})})});describe("getRecord",function(){it("should throw an exception with an unrecognized model name",function(){expect(function(){L.getRecord("Luser",1)}).toThrow()});it("should throw an exception creating an anonymous model",function(){var R=Ext.define(null,{extend:"Ext.data.Model",fields:["name"]});expect(function(){L.getRecord(R,1)}).toThrow()});describe("with no record",function(){it("should accept the entity name",function(){P=L.getRecord("User",1);expect(P.getId()).toBe(1);expect(P.$className).toBe("spec.User")});it("should accept the entity class",function(){P=L.getRecord(spec.User,1);expect(P.getId()).toBe(1);expect(P.$className).toBe("spec.User")});it("should accept an existing record and adopt it",function(){P=new spec.User({id:1});expect(L.getRecord(P)).toBe(P);expect(P.session).toBe(L)});it("should create a new record and track it in the session",function(){P=L.getRecord("User",1);expect(L.peekRecord("User",1)).toBe(P)});it("should set the session on the record",function(){P=L.getRecord("User",1);expect(P.session).toBe(L)});describe("autoLoad",function(){it("should autoLoad by default",function(){var R=spyOn(spec.User.getProxy(),"read");L.getRecord("User",1);expect(R).toHaveBeenCalled()});it("should not autoLoad when passed: false",function(){var R=spyOn(spec.User.getProxy(),"read");L.getRecord("User",1,false);expect(R).not.toHaveBeenCalled()});it("should pass parameters to load",function(){var R=spyOn(spec.User.getProxy(),"read");L.getRecord("User",1,{params:{someId:1}});expect(R.mostRecentCall.args[0].getParams()).toEqual({someId:1})})});describe("with parent session",function(){beforeEach(function(){L.setParent(O)});describe("record exists in the parent",function(){beforeEach(function(){P=D("User",1,O,{name:"Foo"})});describe("with type/id",function(){it("should return an existing record from the parent",function(){var R=L.getRecord("User",1);expect(R.get("name")).toBe("Foo");expect(R.$className).toBe("spec.User")});it("should return a copy, not the same instance",function(){var R=L.getRecord("User",1);expect(R).not.toBe(P)});it("should set the session to be the child session",function(){var R=L.getRecord("User",1);expect(R.session).toBe(L)});it("should not trigger a load",function(){var R=spyOn(spec.User.getProxy(),"read");L.getRecord("User",1);expect(R).not.toHaveBeenCalled()});it("should not update the parent record when the child changes",function(){var R=L.getRecord("User",1);R.set("name","Bar");expect(P.get("name")).toBe("Foo")});it("should not update the child record when the parent changes",function(){var R=L.getRecord("User",1);P.set("name","Bar");expect(R.get("name")).toBe("Foo")});it("should not copy the record if the parent is loading",function(){P=O.getRecord("User",2);var R=L.getRecord("User",2);E({name:"Foo"});expect(P.get("name")).toBe("Foo");expect(R.isLoading()).toBe(true);expect(R.get("name")).toBeUndefined()})});describe("with parent instance",function(){it("should return an existing record from the parent",function(){var R=L.getRecord(P);expect(R.get("name")).toBe("Foo");expect(R.$className).toBe("spec.User")});it("should return a copy, not the same instance",function(){var R=L.getRecord(P);expect(R).not.toBe(P)});it("should set the session to be the child session",function(){var R=L.getRecord(P);expect(R.session).toBe(L)});it("should not trigger a load",function(){var R=spyOn(spec.User.getProxy(),"read");L.getRecord(P);expect(R).not.toHaveBeenCalled()});it("should not update the parent record when the child changes",function(){var R=L.getRecord(P);R.set("name","Bar");expect(P.get("name")).toBe("Foo")});it("should not update the child record when the parent changes",function(){var R=L.getRecord(P);P.set("name","Bar");expect(R.get("name")).toBe("Foo")});it("should not copy the record if the parent is loading",function(){P=O.getRecord("User",2);var R=L.getRecord(P);E({name:"Foo"});expect(P.get("name")).toBe("Foo");expect(R.isLoading()).toBe(true);expect(R.get("name")).toBeUndefined()})})});describe("record does not exist in the parent",function(){describe("with type/id",function(){it("should create an instance",function(){P=L.getRecord("User",1);expect(P.getId()).toBe(1);expect(P.$className).toBe("spec.User")});it("not push the instance into the parent",function(){L.getRecord("User",1);expect(O.peekRecord("User",1)).toBeNull()})});describe("with an instance",function(){it("should use the passed instance",function(){P=new spec.User({id:1});expect(L.getRecord(P)).toBe(P);expect(P.session).toBe(L)});it("not push the instance into the parent",function(){P=new spec.User({id:1});L.getRecord(P);expect(O.peekRecord("User",1)).toBeNull()})})})})});describe("with an existing record",function(){beforeEach(function(){P=D("User",1)});it("should accept the entity name",function(){expect(L.getRecord("User",1)).toBe(P)});it("should accept the entity class",function(){expect(L.getRecord(spec.User,1)).toBe(P)});it("should return the same instance",function(){expect(L.getRecord(P)).toBe(P)});it("should return the existing record",function(){expect(L.getRecord("User",1)).toBe(P)});it("should not attempt to load the record",function(){var R=spyOn(spec.User.getProxy(),"read");L.getRecord("User",1);expect(R).not.toHaveBeenCalled()})})});describe("peekRecord",function(){beforeEach(function(){P=D("User",1)});it("should accept the entity name",function(){expect(L.peekRecord("User",1)).toBe(P)});it("should accept the entity class",function(){expect(L.peekRecord(spec.User,1)).toBe(P)});it("should throw an exception with an unrecognized model name",function(){expect(function(){L.peekRecord("Luser",1)}).toThrow()});it("should throw an exception creating an anonymous model",function(){var R=Ext.define(null,{extend:"Ext.data.Model",fields:["name"]});expect(function(){L.peekRecord(R,1)}).toThrow()});it("should return the model instance",function(){var R=L.peekRecord("User",1);expect(R.isModel).toBe(true);expect(R).toBe(P)});it("should return null if the record does not exist",function(){expect(L.peekRecord("User",12)).toBeNull()});describe("parent",function(){it("should not return a record from a parent without deep=true",function(){L.setParent(O);D("User",2,O);expect(L.peekRecord("User",2)).toBeNull()});it("should find a record in the parent session if we pass deep=true",function(){L.setParent(O);P=D("User",2,O);expect(L.peekRecord("User",2,true)).toBe(P)});it("should favour a record in the child",function(){L.setParent(O);D("User",2,O);P=L.getRecord("User",2);expect(L.peekRecord("User",2,true)).toBe(P)});it("should not consider a parent if we pass deep=true and there is no parent",function(){expect(L.peekRecord("User",1000,true)).toBeNull()})})});describe("associations",function(){describe("many to one",function(){beforeEach(function(){Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["content",{name:"userId",reference:"User"}]})});function S(V,T,U){U=U||{};U.id=V;U.userId=T;return D("Post",V,L,U)}function R(U,T){T=T||{};T.id=U;return D("User",U,L,T)}afterEach(function(){Ext.undefine("spec.Post")});describe("the one",function(){it("should use an existing record instance from the session",function(){var T=R(1),U=S(17,1);expect(U.getUser()).toBe(T)});it("should not trigger a load when the record instance exists",function(){var T=R(1),U=S(17,1),V=spyOn(spec.User.getProxy(),"read");U.getUser();expect(V).not.toHaveBeenCalled()});it("should request an instance it needs and put it in the session",function(){var U=S(17,1),T=U.getUser();E({id:1});expect(L.getRecord("User",1)).toBe(T)})});describe("the many",function(){var T;beforeEach(function(){T=R(1)});afterEach(function(){T=null});it("should be empty by default and not complete",function(){var U=T.posts();expect(U.getCount()).toBe(0);expect(U.complete).toBe(false)});it("should not trigger a load",function(){var U=spyOn(spec.Post.getProxy(),"read");T.posts();expect(U).not.toHaveBeenCalled()});it("should create records on loading",function(){var U=T.posts();U.load();E([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);expect(U.getAt(0)).toBe(L.peekRecord("Post",101));expect(U.getAt(1)).toBe(L.peekRecord("Post",102));expect(U.getAt(2)).toBe(L.peekRecord("Post",103))});it("should set the complete flag on loading",function(){var U=T.posts();U.load();E([]);expect(U.complete).toBe(true)});describe("local modifications",function(){it("should add items with a matching foreign key on creation, but not be complete",function(){var W=S(101,1),U=S(103,1),V=T.posts();expect(V.getCount()).toBe(2);expect(V.getAt(0)).toBe(W);expect(V.getAt(1)).toBe(U);expect(V.complete).toBe(false)});it("should respect the server order when loading with existing items",function(){var X=S(101,1),V=S(102,1),U=S(103,1),W=T.posts();W.load();E([{id:103,userId:1},{id:102,userId:1},{id:101,userId:1}]);expect(W.getAt(0)).toBe(U);expect(W.getAt(1)).toBe(V);expect(W.getAt(2)).toBe(X)});it("should add matching FK items to the end when loading",function(){var U=S(102,1),V=T.posts();V.load();E([{id:103,userId:1},{id:101,userId:1}]);expect(V.getAt(0)).toBe(L.peekRecord("Post",103));expect(V.getAt(1)).toBe(L.peekRecord("Post",101));expect(V.getAt(2)).toBe(L.peekRecord("Post",102))});it("should remove no-longer matching FK items when loading",function(){var U=S(102,1);U.set("userId",null);var V=T.posts();V.load();E([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);expect(V.getCount()).toBe(2);expect(V.getAt(0)).toBe(L.peekRecord("Post",101));expect(V.getAt(1)).toBe(L.peekRecord("Post",103))})})})});describe("one to one",function(){beforeEach(function(){Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["city"]})});function R(U,T){T=T||{};T.id=U;return D("Address",U,L,T)}function S(V,T,U){U=U||{};U.id=V;U.addressId=T;return D("User",V,L,U)}afterEach(function(){Ext.undefine("spec.Address")});describe("the key holder",function(){it("should use an existing record instance from the session",function(){var T=R(1),U=S(17,1);expect(U.getAddress()).toBe(T)});it("should not trigger a load when the record instance exists",function(){var T=R(1),U=S(17,1),V=spyOn(spec.User.getProxy(),"read");U.getAddress();expect(V).not.toHaveBeenCalled()});it("should request an instance it needs and put it in the session",function(){var U=S(17,1),T=U.getAddress();E({id:1});expect(L.getRecord("Address",1)).toBe(T)})})});describe("many to many",function(){beforeEach(function(){Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["name"]})});function S(T){return D("User",T,L)}function R(T){return D("Group",T,L)}afterEach(function(){Ext.undefine("spec.Group")});describe("the left",function(){var T;beforeEach(function(){T=S(1)});afterEach(function(){T=null});it("should be empty by default and not complete",function(){var U=T.groups();expect(U.getCount()).toBe(0);expect(U.complete).toBe(false)});it("should not trigger a load",function(){var U=spyOn(spec.Group.getProxy(),"read");T.groups();expect(U).not.toHaveBeenCalled()});it("should create records on loading",function(){var U=T.groups();U.load();E([{id:101},{id:102},{id:103}]);expect(U.getAt(0)).toBe(L.peekRecord("Group",101));expect(U.getAt(1)).toBe(L.peekRecord("Group",102));expect(U.getAt(2)).toBe(L.peekRecord("Group",103))});it("should set the complete flag on loading",function(){var U=T.groups();U.load();E([]);expect(U.complete).toBe(true)});describe("local modifications",function(){it("should respect the load order when loading with existing items",function(){var V=R(102),U=T.groups();U.add(V);U.load();E([{id:103},{id:102},{id:101}]);expect(U.getAt(0)).toBe(L.peekRecord("Group",103));expect(U.getAt(1)).toBe(V);expect(U.getAt(2)).toBe(L.peekRecord("Group",101))});it("should add matching FK items to the end when loading",function(){var V=R(102),U=T.groups();U.add(V);U.load();E([{id:103},{id:101}]);expect(U.getAt(0)).toBe(L.peekRecord("Group",103));expect(U.getAt(1)).toBe(L.peekRecord("Group",101));expect(U.getAt(2)).toBe(V)})})});describe("the right",function(){var T;beforeEach(function(){T=R(1)});afterEach(function(){T=null});it("should be empty by default and not complete",function(){var U=T.users();expect(U.getCount()).toBe(0);expect(U.complete).toBe(false)});it("should not trigger a load",function(){var U=spyOn(spec.User.getProxy(),"read");T.users();expect(U).not.toHaveBeenCalled()});it("should create records on loading",function(){var U=T.users();U.load();E([{id:101},{id:102},{id:103}]);expect(U.getAt(0)).toBe(L.peekRecord("User",101));expect(U.getAt(1)).toBe(L.peekRecord("User",102));expect(U.getAt(2)).toBe(L.peekRecord("User",103))});it("should set the complete flag on loading",function(){var U=T.users();U.load();E([]);expect(U.complete).toBe(true)});describe("local modifications",function(){it("should respect the load order when loading with existing items",function(){var U=S(102),V=T.users();V.add(U);V.load();E([{id:103},{id:102},{id:101}]);expect(V.getAt(0)).toBe(L.peekRecord("User",103));expect(V.getAt(1)).toBe(U);expect(V.getAt(2)).toBe(L.peekRecord("User",101))});it("should add matching FK items to the end when loading",function(){var U=S(102),V=T.users();V.add(U);V.load();E([{id:103},{id:101}]);expect(V.getAt(0)).toBe(L.peekRecord("User",103));expect(V.getAt(1)).toBe(L.peekRecord("User",101));expect(V.getAt(2)).toBe(U)})})})})})});describe("getChanges",function(){var O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");L=new Ext.data.Session();O=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age",{name:"addressId",reference:"Address",unique:true},{name:"serializeField",serialize:function(P){return P.toString()}}],manyToMany:"#Group"});Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["name"]});Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["city"]});Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["content",{name:"userId",reference:"User"}]})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Address");Ext.undefine("spec.Post");Ext.undefine("spec.Group");Ext.data.Model.schema.clear(true);O=null});describe("serialization options",function(){it("should serialize field data",function(){var P=L.createRecord("User",{serializeField:1000});expect(L.getChanges()).toEqual({User:{C:[{id:P.getId(),serializeField:"1000"}]}})})});describe("basic operations",function(){describe("create",function(){it("should include a phantom record",function(){var P=L.createRecord("User",{name:"Foo",age:34});expect(L.getChanges()).toEqual({User:{C:[{id:P.getId(),name:"Foo",age:34}]}})});it("should include the updated record state",function(){var P=L.createRecord("User",{name:"Foo",age:34});P.set("name","Bar");P.set("age",5000);expect(L.getChanges()).toEqual({User:{C:[{id:P.getId(),name:"Bar",age:5000}]}})});it("should be able to create multiple records",function(){var R=L.createRecord("User"),Q=L.createRecord("User"),P=L.createRecord("User");expect(L.getChanges()).toEqual({User:{C:[{id:R.getId()},{id:Q.getId()},{id:P.getId()}]}})});it("should not include non-phantoms",function(){var P=D("User",1);expect(L.getChanges()).toBeNull()});it("should not include phantom records that are dropped",function(){var P=L.createRecord("User");P.drop();expect(L.getChanges()).toBeNull()})});describe("update",function(){it("should include the updated record",function(){var P=D("User",1);P.set("name","Foo");expect(L.getChanges()).toEqual({User:{U:[{id:1,name:"Foo"}]}})});it("should include the most recently updated state",function(){var P=D("User",1);P.set("name","Foo");P.set("name","Bar");P.set("name","Baz");expect(L.getChanges()).toEqual({User:{U:[{id:1,name:"Baz"}]}})});it("should be able to update many records",function(){var R=D("User",1),Q=D("User",2),P=D("User",3);R.set("name","Foo");Q.set("name","Bar");P.set("name","Baz");expect(L.getChanges()).toEqual({User:{U:[{id:1,name:"Foo"},{id:2,name:"Bar"},{id:3,name:"Baz"}]}})});it("should not include a non-dirty record",function(){var P=D("User",1);P.set("name","Foo");P.commit();expect(L.getChanges()).toBeNull()});it("should not include a dropped record",function(){var P=D("User",1);P.set("name","Foo");P.drop();expect(L.getChanges().User.U).toBeUndefined()});it("should not include changes to phantoms",function(){var P=L.createRecord("User");P.set("name","Foo");expect(L.getChanges().User.U).toBeUndefined()})});describe("drop",function(){it("should include dropped records",function(){var P=D("User",1);P.drop();expect(L.getChanges()).toEqual({User:{D:[1]}})});it("should drop multiple records",function(){var R=D("User",1),Q=D("User",2),P=D("User",3);R.drop();Q.drop();P.drop();expect(L.getChanges()).toEqual({User:{D:[1,2,3]}})});it("should not include phantom records",function(){var P=L.createRecord("User");P.drop();expect(L.getChanges()).toBeNull()})})});describe("associations",function(){describe("pending drops",function(){beforeEach(function(){Ext.define("spec.Order",{extend:"Ext.data.Model",fields:["id","date",{name:"addressId",unique:true,reference:{child:"Address"}}]});Ext.define("spec.OrderItem",{extend:"Ext.data.Model",fields:["id","price","qty",{name:"orderId",reference:{parent:"Order"}}]})});afterEach(function(){Ext.undefine("spec.Order");Ext.undefine("spec.OrderItem")});it("should resolve any pending drops",function(){var P=D("Order",1,L,{addressId:101});var Q=P.getAddress();D("Address",101);var S=P.orderItems();S.load();E([{id:201,orderId:1},{id:202,orderId:1}]);var R=S.getAt(0);P.setAddress(null);S.removeAt(0);expect(Q.dropped).toBe(false);expect(R.dropped).toBe(false);expect(L.getChanges()).toEqual({Address:{D:[101]},Order:{U:[{id:1,addressId:null}]},OrderItem:{D:[201]}})})});describe("one to one",function(){var Q,P;afterEach(function(){Q=P=null});describe("basic operations",function(){beforeEach(function(){Q=D("User",1,L,{addressId:17});P=Q.getAddress();D("Address",17)});it("should not include any changes when loading an association",function(){expect(L.getChanges()).toBeNull()});it("should not include extraneous records when changing the key",function(){Q.setAddress(3);expect(L.getChanges()).toEqual({User:{U:[{id:1,addressId:3}]}})});it("should read the non key holder when nulling out a reference",function(){Q.setAddress(null);expect(L.getChanges()).toEqual({User:{U:[{id:1,addressId:null}]}})})});describe("changing id",function(){it("should update when changing the id of the non key holder",function(){P=L.createRecord("spec.Address");Q=L.createRecord("spec.User");Q.setAddress(P);P.setId(1000);expect(L.getChanges()).toEqual({Address:{C:[{id:1000}]},User:{C:[{id:Q.getId(),addressId:1000}]}})})})});describe("many to one",function(){var P,Q;afterEach(function(){P=Q=null});describe("basic operations",function(){beforeEach(function(){P=D("User",1);Q=P.posts();Q.load();E([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}])});it("should not include any read records",function(){expect(L.getChanges()).toBeNull()});it("should push store removals as updates",function(){Q.removeAt(0);expect(L.getChanges()).toEqual({Post:{U:[{id:101,userId:null}]}})});it("should push store adds as updates",function(){var R=D("Post",104);Q.add(R);expect(L.getChanges()).toEqual({Post:{U:[{id:104,userId:1}]}})});it("should push store adds of phantoms as creates",function(){var R=L.createRecord("Post");Q.add(R);expect(L.getChanges()).toEqual({Post:{C:[{id:R.getId(),userId:1}]}})})});describe("changing id",function(){it("should update when changing the id of the non key holder",function(){P=L.createRecord("User");var R=L.createRecord("Post");P.posts().add(R);P.setId(1000);expect(L.getChanges()).toEqual({User:{C:[{id:1000}]},Post:{C:[{id:R.getId(),userId:1000}]}})})})});describe("many to many",function(){describe("via store modifications",function(){var Q,P;beforeEach(function(){Q=D("User",1);P=Q.groups()});afterEach(function(){Q=P=null});describe("store not loaded",function(){it("should include local adds",function(){var R=D("Group",101);P.add(R);expect(L.getChanges()).toEqual({User:{groups:{C:{1:[101]}}}})});it("should include local phantom adds and a create",function(){var R=L.createRecord("Group"),S=R.getId();P.add(R);expect(L.getChanges()).toEqual({User:{groups:{C:{1:[S]}}},Group:{C:[{id:R.getId()}]}})});it("should ignore adds & cancelling removes",function(){var R=D("Group",101);P.add(R);P.removeAt(0);expect(L.getChanges()).toBeNull()})});describe("store loaded",function(){beforeEach(function(){P.load();E([{id:101},{id:102},{id:103}])});it("should not include any records loaded into the store",function(){expect(L.getChanges()).toBeNull()});it("should include a local add to existing records",function(){var R=D("Group",104);P.add(R);expect(L.getChanges()).toEqual({User:{groups:{C:{1:[104]}}}})});it("should include local phantom adds and a create",function(){var R=L.createRecord("Group"),S=R.getId();P.add(R);expect(L.getChanges()).toEqual({User:{groups:{C:{1:[S]}}},Group:{C:[{id:R.getId()}]}})});it("should ignore adds & cancelling removes",function(){var R=D("Group",104);P.add(R);P.remove(R);expect(L.getChanges()).toBeNull()});it("should drop records removed from the store",function(){P.removeAt(0);expect(L.getChanges()).toEqual({User:{groups:{D:{1:[101]}}}})})})});describe("via updates",function(){it("should process creates without records",function(){L.update({User:{groups:{C:{1:[101,102]}}}});expect(L.getChanges()).toEqual({User:{groups:{C:{1:[101,102]}}}})});it("should process drops without records",function(){L.update({User:{groups:{D:{1:[103,104]}}}});expect(L.getChanges()).toEqual({User:{groups:{D:{1:[103,104]}}}})})});describe("changing id",function(){it("should update when changing the id of the left",function(){var Q=L.createRecord("Group"),P=L.createRecord("User");P.groups().add(Q);P.setId(1000);expect(L.getChanges()).toEqual({User:{C:[{id:1000}],groups:{C:{1000:[Q.getId()]}}},Group:{C:[{id:Q.getId()}]}})});it("should update when changing the id of the right",function(){var Q=L.createRecord("Group"),P=L.createRecord("User");Q.users().add(P);Q.setId(1000);var R={};R[P.getId()]=[1000];expect(L.getChanges()).toEqual({User:{C:[{id:P.getId()}],groups:{C:R}},Group:{C:[{id:1000}]}})})})})})});describe("update",function(){beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");L=new Ext.data.Session()});afterEach(function(){Ext.data.Model.schema.clear(true)});describe("basic operations",function(){var P;function O(R,Q){var S={User:{}};S.User[R]=Q;return S}beforeEach(function(){P=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age"]})});afterEach(function(){Ext.undefine("spec.User");P=null});it("should throw an exception for an unrecognized entity",function(){expect(function(){L.update({Luser:{}})}).toThrow()});describe("read",function(){it("should add the record to the session",function(){L.update(O("R",[{id:17}]));expect(L.peekRecord("User",17)).not.toBeNull()});it("should have the data on the record",function(){L.update(O("R",[{id:17,name:"Foo",age:32}]));var Q=L.getRecord("User",17);expect(Q.get("name")).toBe("Foo");expect(Q.get("age")).toBe(32)});it("should not be dirty",function(){L.update(O("R",[{id:17,name:"Foo",age:32}]));var Q=L.getRecord("User",17);expect(Q.dirty).toBe(false)});it("should not be phantom even if we don't have an id",function(){L.update(O("R",[{name:"Foo",age:32}]));var Q=L.getRecord("User","User-1");expect(Q.phantom).toBe(false)});it("should be able to read multiple records",function(){L.update(O("R",[{id:1,name:"Foo"},{id:2,name:"Bar"},{id:3,name:"Baz"}]));expect(L.peekRecord("User",1)).not.toBeNull();expect(L.peekRecord("User",2)).not.toBeNull();expect(L.peekRecord("User",3)).not.toBeNull()});it("should throw an exception if the record is in the session",function(){D("User",1);expect(function(){L.update(O("R",[{id:1}]))}).toThrow()})});describe("create",function(){it("should add the record to the session",function(){L.update(O("C",[{id:17}]));expect(L.peekRecord("User",17)).not.toBeNull()});it("should have the data on the record",function(){L.update(O("C",[{id:17,name:"Foo",age:32}]));var Q=L.getRecord("User",17);expect(Q.get("name")).toBe("Foo");expect(Q.get("age")).toBe(32)});it("should be a phantom",function(){L.update(O("C",[{name:"Foo",age:32}]));var Q=L.getRecord("User","User-1");expect(Q.phantom).toBe(true)});it("should be able to create multiple records",function(){L.update(O("C",[{name:"Foo"},{name:"Bar"},{name:"Baz"}]));expect(L.peekRecord("User","User-1")).not.toBeNull();expect(L.peekRecord("User","User-2")).not.toBeNull();expect(L.peekRecord("User","User-3")).not.toBeNull()});it("should throw an exception if the record is in the session",function(){D("User",17);expect(function(){L.update(O("C",[{id:17}]))}).toThrow()})});describe("drop",function(){it("should drop the record",function(){var Q=D("User",100);L.update(O("D",[100]));expect(Q.dropped).toBe(true)});it("should be able to drop multiple records",function(){var Q=D("User",100),S=D("User",200),R=D("User",300);L.update(O("D",[100,200,300]));expect(Q.dropped).toBe(true);expect(S.dropped).toBe(true);expect(R.dropped).toBe(true)});it("should throw an exception if the record does not exist",function(){expect(function(){L.update(O("D",[100]))}).toThrow()});it("should handle a writer with writeAllFields: true",function(){P.getProxy().getWriter().setWriteAllFields(true);var Q=D("User",100,L,{name:"Foo",age:100});L.update(O("D",[{id:100,name:"Foo",age:100}]));expect(Q.dropped).toBe(true)})});describe("update",function(){it("should update the record data",function(){var Q=L.createRecord("User",{id:100,name:"Foo"});L.update(O("U",[{id:100,name:"Bar"}]));expect(Q.get("name")).toBe("Bar")});it("should not commit the record",function(){var Q=L.createRecord("User",{id:100,name:"Foo",age:10});L.update(O("U",[{id:100,name:"Bar",age:11}]));expect(Q.dirty).toBe(true);expect(Q.isModified("name")).toBe(true);expect(Q.isModified("age")).toBe(true)});it("should not be dirty if the data does not change",function(){var Q=L.createRecord("User",{id:100,name:"Foo",age:23});L.update(O("U",[{id:100,name:"Foo",age:23}]));expect(Q.dirty).toBe(false)});it("should handle multiple updates",function(){var R=L.createRecord("User",{id:101,name:"Foo"});var Q=L.createRecord("User",{id:102,name:"Bar"});var S=L.createRecord("User",{id:103,name:"Baz"});L.update(O("U",[{id:101,name:"A"},{id:102,name:"B"},{id:103,name:"C"}]));expect(R.get("name")).toBe("A");expect(Q.get("name")).toBe("B");expect(S.get("name")).toBe("C")});it("should handle object syntax",function(){var R=L.createRecord("User",{id:101,name:"Foo"});var Q=L.createRecord("User",{id:102,name:"Bar"});var S=L.createRecord("User",{id:103,name:"Baz"});L.update(O("U",{101:{name:"A"},102:{name:"B"},103:{name:"C"}}));expect(R.get("name")).toBe("A");expect(Q.get("name")).toBe("B");expect(S.get("name")).toBe("C")});it("should throw an exception if the record does not exist in the store",function(){expect(function(){L.update(O("U",[{id:100,name:"Bar"}]))}).toThrow()});it("should throw an exception if the record is dropped",function(){var Q=D("User",1);Q.drop();expect(function(){L.update(O("U",[{id:100,name:"Bar"}]))}).toThrow()})});describe("associations",function(){var Q,R;beforeEach(function(){Q=Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["id","content",{name:"userId",reference:"User"}]});R=Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["id","name"],manyToMany:"User"})});afterEach(function(){Q=R=null;Ext.undefine("spec.Post");Ext.undefine("spec.Group")});describe("pending drops",function(){beforeEach(function(){Ext.define("spec.Order",{extend:"Ext.data.Model",fields:["id","date",{name:"addressId",unique:true,reference:{child:"Address"}}]});Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["id","city"]});Ext.define("spec.OrderItem",{extend:"Ext.data.Model",fields:["id","price","qty",{name:"orderId",reference:{parent:"Order"}}]})});afterEach(function(){Ext.undefine("spec.Order");Ext.undefine("spec.Address");Ext.undefine("spec.OrderItem")});it("should resolve any pending",function(){var S=D("Order",1,L,{addressId:101});var T=S.getAddress();D("Address",101);var V=S.orderItems();V.load();E([{id:201,orderId:1},{id:202,orderId:1}]);var U=V.getAt(0);S.setAddress(null);V.removeAt(0);expect(T.dropped).toBe(false);expect(U.dropped).toBe(false);L.update({Order:{U:[{id:1,date:new Date()}]}});expect(T.dropped).toBe(true);expect(U.dropped).toBe(true)})});describe("many to one",function(){it("should process any CRUD operations before associations",function(){L.update({User:{R:[{id:1}],posts:{R:{1:[101]}}},Post:{R:[{id:101,userId:1}]}});var S=L.getRecord("User",1);expect(S.posts().indexOfId(101)).toBe(0)});describe("without an entity CRUD block",function(){it("should throw an exception if the owner model does not exist",function(){D("Post",101);expect(function(){L.update({User:{posts:{R:{1:[101]}}}})}).toThrow()});it("should throw an exception if the child model does not exist",function(){D("User",1);expect(function(){L.update({User:{posts:{R:{1:[101]}}}})}).toThrow()})});describe("with an entity CRUD block",function(){it("should throw an exception if the owner model does not exist and wasn't read",function(){expect(function(){L.update({User:{posts:{R:{1:[101]}}},Post:{R:[{id:101,userId:1}]}})}).toThrow()});it("should throw an exception if the child model does not exist and wasn't read",function(){expect(function(){L.update({User:{R:[{id:1}],posts:{R:{1:[101]}}}})}).toThrow()})});describe("with the store not created",function(){it("should create the store with data",function(){var S=D("User",1);L.update({User:{posts:{R:{1:[101,102,103]}}},Post:{R:[{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]}});var T=S.posts();expect(T.getCount()).toBe(3);expect(T.getAt(0)).toBe(L.peekRecord("Post",101));expect(T.getAt(1)).toBe(L.peekRecord("Post",102));expect(T.getAt(2)).toBe(L.peekRecord("Post",103))});it("should create the store and not trigger a load, should set loadCount & complete",function(){var S=D("User",1),T=spyOn(Q.getProxy(),"read");L.update({User:{posts:{R:{1:[101]}}},Post:{R:[{id:101,userId:1}]}});var U=S.posts();expect(U.getCount()).toBe(1);expect(U.loadCount).toBe(1);expect(U.complete).toBe(true);expect(T).not.toHaveBeenCalled()});it("should include local records with matching FK",function(){var S=D("User",1),U=D("Post",101);U.set("userId",1);L.update({User:{posts:{R:{1:[102]}}},Post:{R:[{id:102,userId:1}]}});var T=S.posts();expect(T.getCount()).toBe(2)});it("should infer the key when one is not specified",function(){var S=D("User",1),U=D("Post",101);L.update({User:{posts:{R:{1:[101]}}}});var T=S.posts();expect(T.getCount()).toBe(1);expect(T.getAt(0)).toBe(U)});it("should exclude local records where the FK does not match",function(){var S=D("User",1),U=D("Post",101,null,{userId:2});L.update({User:{posts:{R:{1:[101]}}}});var T=S.posts();expect(T.getCount()).toBe(0)})});describe("with the store created",function(){it("should fill an empty store",function(){var S=D("User",1),T=S.posts();L.update({User:{posts:{R:{1:[101,102,103]}}},Post:{R:[{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]}});expect(T.getCount()).toBe(3);expect(T.getAt(0)).toBe(L.peekRecord("Post",101));expect(T.getAt(1)).toBe(L.peekRecord("Post",102));expect(T.getAt(2)).toBe(L.peekRecord("Post",103));expect(T.complete).toBe(true)});describe("store not loaded",function(){it("should include locally added records",function(){var S=D("User",1),U=D("Post",101),T=S.posts();T.add(U);L.update({User:{posts:{R:{1:[102]}}},Post:{R:[{id:102,userId:1}]}});expect(T.getCount()).toBe(2);expect(T.indexOf(U)).toBe(1)});it("should include records with local foreign key modifications",function(){var S=D("User",1),U=D("Post",101),T=S.posts();U.set("userId",1);L.update({User:{posts:{R:{1:[102]}}},Post:{R:[{id:102,userId:1}]}});expect(T.getCount()).toBe(2);expect(T.indexOf(L.peekRecord("Post",102))).toBe(0);expect(T.indexOf(U)).toBe(1)});it("should exclude locally removed records",function(){var S=D("User",1),V=D("Post",101,L,{userId:1}),T=D("Post",102,L,{userId:1}),U=S.posts();U.removeAt(0);L.update({User:{posts:{R:{1:[101,102]}}}});expect(U.getCount()).toBe(1);expect(U.indexOf(T)).toBe(0);expect(U.indexOf(V)).toBe(-1)});it("should exclude records with local foreign key modifications",function(){var S=D("User",1),V=D("Post",101,L,{userId:1}),T=D("Post",102,L,{userId:1}),U=S.posts();V.set("userId",null);L.update({User:{posts:{R:{1:[101,102]}}}});expect(U.getCount()).toBe(1);expect(U.indexOf(T)).toBe(0);expect(U.indexOf(V)).toBe(-1)})});describe("store already loaded",function(){it("should include added items",function(){var S=D("User",1),U=D("Post",101),T=S.posts();T.load();E([]);T.add(U);L.update({User:{posts:{R:{1:[102]}}},Post:{R:[{id:102,userId:1}]}});expect(T.getCount()).toBe(2);expect(T.getAt(0)).toBe(L.peekRecord("Post",102));expect(T.getAt(1)).toBe(U)});it("should exclude removed items",function(){var S=D("User",1),T=S.posts();T.load();E([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);T.removeAt(0);L.update({User:{posts:{R:{1:[101,102,103]}}}});expect(T.getCount()).toBe(2);expect(T.getAt(0)).toBe(L.peekRecord("Post",102));expect(T.getAt(1)).toBe(L.peekRecord("Post",103))})})})});describe("many to many",function(){describe("read",function(){it("should read CRUD records before processing",function(){L.update({User:{R:[{id:1}],groups:{R:{1:[101,102]}}},Group:{R:[{id:101},{id:102}]}});var T=L.getRecord("User",1),S=T.groups();expect(S.getCount()).toBe(2);expect(S.getAt(0)).toBe(L.peekRecord("Group",101));expect(S.getAt(1)).toBe(L.peekRecord("Group",102))});it("should require the child records being read to be present",function(){expect(function(){L.update({User:{R:[{id:1}],groups:{R:{1:[101,102]}}}})}).toThrow()});it("should require the parent record being read to be present",function(){expect(function(){L.update({User:{groups:{R:{1:[101]}}},Post:{R:[{id:101}]}})}).toThrow()});describe("with the store not created",function(){it("should create a store with the items",function(){var T=D("User",1);L.update({User:{groups:{R:{1:[101]}}},Group:{R:[{id:101}]}});var S=T.groups();expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(L.peekRecord("Group",101))});it("should not trigger a load",function(){var S=D("User",1),T=spyOn(R.getProxy(),"read");L.update({User:{groups:{R:{1:[101]}}},Group:{R:[{id:101}]}});expect(T).not.toHaveBeenCalled()});it("should set the complete flag",function(){var S=D("User",1);L.update({User:{groups:{R:{1:[101]}}},Group:{R:[{id:101}]}});expect(S.groups().complete).toBe(true)});it("should include locally created records",function(){var T=D("User",1);L.update({User:{groups:{C:{1:[101]}}}});L.update({User:{groups:{R:{1:[102]}}},Group:{R:[{id:102}]}});D("Group",101);var S=T.groups();expect(S.getCount()).toBe(2);expect(S.indexOfId(102)).toBe(0);expect(S.indexOfId(101)).toBe(1)});it("should exclude locally dropped records",function(){var T=D("User",1);L.update({User:{groups:{D:{1:[101]}}}});L.update({User:{groups:{R:{1:[101,102]}}},Group:{R:[{id:101},{id:102}]}});var S=T.groups();expect(S.getCount()).toBe(1);expect(S.indexOfId(102)).toBe(0)})});describe("with the store created",function(){describe("store not loaded",function(){it("should fill an empty store",function(){var T=D("User",1),S=T.groups();L.update({User:{groups:{R:{1:[101]}}},Group:{R:[{id:101}]}});expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(L.peekRecord("Group",101))});it("should include local store adds",function(){var U=D("User",1),T=D("Group",101),S=U.groups();S.add(T);L.update({User:{groups:{R:{1:[102]}}},Group:{R:[{id:102}]}});expect(S.getCount()).toBe(2);expect(S.getAt(0)).toBe(L.peekRecord("Group",102));expect(S.getAt(1)).toBe(T)});it("should exclude local drops",function(){var T=D("User",1),S=T.groups();L.update({User:{groups:{D:{1:[101]}}}});L.update({User:{groups:{R:{1:[101,102]}}},Group:{R:[{id:101},{id:102}]}});expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(L.peekRecord("Group",102))})});describe("store already loaded",function(){it("should include local store adds",function(){var T=D("User",1),S=T.groups(),U=D("Group",104);S.load();E([{id:101},{id:102},{id:103}]);S.add(U);L.update({User:{groups:{R:{1:[101,102,103]}}}});expect(S.getCount()).toBe(4);expect(S.indexOf(U)).toBe(3)});it("should exclude local store removes",function(){var T=D("User",1),S=T.groups();S.load();E([{id:101},{id:102}]);S.removeAt(0);L.update({User:{groups:{R:{1:[101,102]}}}});expect(S.getCount()).toBe(1)})})})});describe("create",function(){describe("with the store not created",function(){describe("with the record created",function(){it("should have the record present in the store when the store is created",function(){var U=D("User",1),T=D("Group",101);L.update({User:{groups:{C:{1:[101]}}}});var S=U.groups();expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(T)})});describe("with the record not created",function(){it("should have the record in the store when the record is created",function(){var U=D("User",1);L.update({User:{groups:{C:{1:[101]}}}});var T=U.groups();expect(T.getCount()).toBe(0);var S=D("Group",101);expect(T.getCount()).toBe(1);expect(T.getAt(0)).toBe(S)})})});describe("with the store created",function(){describe("store not loaded",function(){describe("with the record created",function(){it("should add the record to the store",function(){var U=D("User",1),T=D("Group",101),S=U.groups();L.update({User:{groups:{C:{1:[101]}}}});expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(T)})});describe("with the record not created",function(){it("should have the record in the store when the record is created",function(){var U=D("User",1),T=U.groups();L.update({User:{groups:{C:{1:[101]}}}});expect(T.getCount()).toBe(0);var S=D("Group",101);expect(T.getAt(0)).toBe(S)})})});describe("store already loaded",function(){describe("with the record created",function(){it("should add the record to the store",function(){var T=D("User",1),S=T.groups(),U=D("Group",103);S.load();E([{id:101},{id:102}]);expect(S.getCount()).toBe(2);L.update({User:{groups:{C:{1:[103]}}}});expect(S.getCount()).toBe(3);expect(S.getAt(2)).toBe(U)})});describe("with the record not created",function(){it("should have the record in the store when the record is created",function(){var T=D("User",1),S=T.groups();S.load();E([{id:101},{id:102}]);L.update({User:{groups:{C:{1:[103]}}}});expect(S.getCount()).toBe(2);var U=D("Group",103);expect(S.getCount()).toBe(3);expect(S.getAt(2)).toBe(U)})})})})});describe("drop",function(){describe("with the store not created",function(){it("should exclude the record when it is loaded",function(){var T=D("User",1);L.update({User:{groups:{D:{1:[101]}}}});var S=T.groups();S.load();E([{id:101},{id:102}]);expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(L.peekRecord("Group",102))})});describe("with the store created",function(){describe("store not loaded",function(){it("should exclude the record when it is loaded",function(){var T=D("User",1),S=T.groups();L.update({User:{groups:{D:{1:[101]}}}});S.load();E([{id:101},{id:102}]);expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(L.peekRecord("Group",102))})});describe("store already loaded",function(){it("should exclude the record from the store",function(){var T=D("User",1),S=T.groups();S.load();E([{id:101},{id:102}]);L.update({User:{groups:{D:{1:[101]}}}});expect(S.getCount()).toBe(1);expect(S.getAt(0)).toBe(L.peekRecord("Group",102))})})})})})})})});describe("drop/erase records",function(){beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name"]});L=new Ext.data.Session()});afterEach(function(){Ext.undefine("spec.User");Ext.data.Model.schema.clear(true)});it("should evict a phantom when it is dropped",function(){var O=new spec.User({},L),P=O.id;O.drop();expect(L.peekRecord("User",P)).toBeNull()});it("should not evict a non-phantom when it is dropped",function(){var O=new spec.User({id:1},L);O.drop();expect(L.peekRecord("User",1)).toBe(O)});it("should evict a non-phantom when it is erased",function(){var O=new spec.User({id:1},L);O.erase();expect(L.peekRecord("User",1)).toBe(O);E({});expect(L.peekRecord("User",1)).toBeNull()})});describe("commit",function(){var O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");O=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name"]});L=new Ext.data.Session()});afterEach(function(){O=null;Ext.undefine("spec.User");Ext.data.Model.schema.clear(true)});it("should call commit on created records",function(){var P=new spec.User({},L);expect(L.getChanges()).toEqual({User:{C:[{id:P.getId()}]}});L.commit();expect(L.getChanges()).toBeNull()});it("should call commit on updated records",function(){var P=new spec.User({id:1,name:"Foo"},L);P.set("name","Bar");expect(L.getChanges()).toEqual({User:{U:[{id:1,name:"Bar"}]}});L.commit();expect(L.getChanges()).toBeNull()});it("should call commit on dropped records",function(){var P=new spec.User({id:1},L);P.drop();expect(L.getChanges()).toEqual({User:{D:[1]}});L.commit();expect(L.getChanges()).toBeNull()});describe("associations",function(){describe("many to many",function(){var P;beforeEach(function(){P=Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["name"],manyToMany:"User"})});afterEach(function(){P=null;Ext.undefine("spec.Group")});it("should commit adds",function(){var Q=D(O,1),R=D(P,100);Q.groups().add(R);expect(L.getChanges()).toEqual({Group:{users:{C:{100:[1]}}}});L.commit();expect(L.getChanges()).toBeNull()});it("should commit deletes",function(){var R=D(O,1),Q=R.groups();Q.load();E([{id:101},{id:102},{id:103}]);expect(L.getChanges()).toBeNull();Q.removeAt(0);expect(L.getChanges()).toEqual({Group:{users:{D:{101:[1]}}}});L.commit();expect(L.getChanges()).toBeNull()})})})});describe("spawn",function(){var O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");Ext.define("spec.User",{extend:"Ext.data.Model",fields:["name"]})});afterEach(function(){Ext.destroy(O);O=null;Ext.undefine("spec.User");Ext.data.Model.schema.clear(true)});it("should set the schema from the parent",function(){var P=new Ext.data.schema.Schema();O=new Ext.data.Session({schema:P});L=O.spawn();expect(L.getSchema()).toBe(P)});it("should set the parent reference",function(){O=new Ext.data.Session();L=O.spawn();expect(L.getParent()).toBe(O)});describe("stores",function(){it("should use the data from parent records if they exist",function(){O=new Ext.data.Session();var Q=D("User",1,O);Q.set("name","Foo");L=O.spawn();var P=new Ext.data.Store({asynchronousLoad:false,model:spec.User,session:L,proxy:{type:"ajax",url:"fakeUrl"}});P.load();E([{id:1,name:"Bar"}]);expect(L.peekRecord("User",1).get("name")).toBe("Foo")})});describe("id generation",function(){it("should generate ids in sequence from parent to child",function(){O=new Ext.data.Session();expect(O.createRecord("User",{}).id).toBe("User-1");expect(O.createRecord("User",{}).id).toBe("User-2");L=O.spawn();expect(L.createRecord("User",{}).id).toBe("User-3");expect(L.createRecord("User",{}).id).toBe("User-4");L.save();expect(O.createRecord("User",{}).id).toBe("User-5");expect(O.createRecord("User",{}).id).toBe("User-6")});it("should generate in sequence when sharing multiple children",function(){O=new Ext.data.Session();var R=O.spawn(),Q=O.spawn(),P=O.spawn();expect(R.createRecord("User",{}).id).toBe("User-1");expect(Q.createRecord("User",{}).id).toBe("User-2");expect(P.createRecord("User",{}).id).toBe("User-3");expect(R.createRecord("User",{}).id).toBe("User-4");expect(Q.createRecord("User",{}).id).toBe("User-5");expect(P.createRecord("User",{}).id).toBe("User-6");expect(R.createRecord("User",{}).id).toBe("User-7");expect(R.createRecord("User",{}).id).toBe("User-8");expect(Q.createRecord("User",{}).id).toBe("User-9");expect(P.createRecord("User",{}).id).toBe("User-10");Ext.destroy(R,Q,P)})});describe("associations",function(){beforeEach(function(){Ext.define("spec.Post",{extend:"Ext.data.Model",fields:[{name:"userId",reference:"User"}]})});afterEach(function(){Ext.undefine("spec.Post")});describe("record copying",function(){it("should copy any phantom records used in associations, when needed",function(){O=new Ext.data.Session();D("User",1,O);var P=O.createRecord("Post",{userId:1});L=O.spawn();var Q=L.getRecord("User",1).posts();expect(Q.getAt(0).id).toBe(P.id);expect(Q.getAt(0)).not.toBe(P)});it("should copy any records added to the association, when needed",function(){O=new Ext.data.Session();D("User",1,O);var P=D("Post",101,O,{userId:1});L=O.spawn();var Q=L.getRecord("User",1).posts();expect(Q.getAt(0).id).toBe(101);expect(Q.getAt(0)).not.toBe(P)})});describe("stores",function(){it("should mark loaded stores as complete",function(){O=new Ext.data.Session();D("User",1,O,{id:1,posts:[{id:101,userId:1},{id:102,userId:1}]});L=O.spawn();var Q=O.getRecord("User",1).posts(),P=L.getRecord("User",1).posts();expect(P.complete).toBe(true);expect(P.getAt(0)).not.toBe(Q.getAt(0));expect(P.getAt(0).getId()).toBe(Q.getAt(0).getId());expect(P.getAt(1)).not.toBe(Q.getAt(1));expect(P.getAt(1).getId()).toBe(Q.getAt(1).getId())});it("should not mark stores as complete if not loaded",function(){O=new Ext.data.Session();D("User",1,O);D("Post",101,O,{userId:1});L=O.spawn();var Q=O.getRecord("User",1).posts(),P=L.getRecord("User",1).posts();expect(P.complete).toBe(false);expect(P.getAt(0)).not.toBe(Q.getAt(0));expect(P.getAt(0).getId()).toBe(Q.getAt(0).getId())})})})});describe("updating from child to parent sessions",function(){var P,O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name","age",{name:"serializeField",serialize:function(Q){return Q.toString()}}]});L=new Ext.data.Session()});afterEach(function(){Ext.undefine("spec.User");Ext.data.Model.schema.clear(true);Ext.destroy(P);P=null});it("should handle when there are no changes",function(){P=L.spawn();expect(P.getChangesForParent()).toBeNull();P.save();expect(L.getChanges()).toBeNull()});it("should not attempt to serialize values when pushing up to a parent",function(){P=L.spawn();O=P.createRecord("User",{serializeField:1000});var Q=spyOn(O.getField("serializeField"),"serialize");P.save();expect(Q).not.toHaveBeenCalled();expect(L.getRecord("User",O.id).get("serializeField")).toBe(1000)});describe("create",function(){it("should push up creates to the parent",function(){P=L.spawn();O=P.createRecord("User",{name:"Foo"});P.save();expect(L.getChanges()).toEqual({User:{C:[{id:O.getId(),name:"Foo"}]}})})});describe("update",function(){it("should reflect update changes in the parent",function(){D("User",1);P=L.spawn();P.getRecord("User",1).set("name","Foo");P.save();expect(L.getChanges()).toEqual({User:{U:[{id:1,name:"Foo"}]}})});it("should use a record that is a phantom in the parent as an update from the child",function(){var Q=L.createRecord("User",{name:"Foo"}),R=Q.getId();P=L.spawn();P.getRecord("User",R).set("name","Bar");P.save();expect(L.getChanges()).toEqual({User:{C:[{id:R,name:"Bar"}]}})})});describe("drop",function(){it("should propagate a drop to the parent",function(){D("User",1);P=L.spawn();P.getRecord("User",1).drop();P.save();expect(L.getChanges()).toEqual({User:{D:[1]}})});it("should propagate a drop of a parent phantom, meaning we have no changes",function(){var Q=L.createRecord("User"),R=Q.getId();P=L.spawn();P.getRecord("User",R).drop();P.save();expect(L.getChanges()).toBeNull()})});describe("associations",function(){describe("pending drops",function(){beforeEach(function(){Ext.define("spec.Order",{extend:"Ext.data.Model",fields:["id","date",{name:"addressId",unique:true,reference:{child:"Address"}}]});Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["id","city"]});Ext.define("spec.OrderItem",{extend:"Ext.data.Model",fields:["id","price","qty",{name:"orderId",reference:{parent:"Order"}}]})});afterEach(function(){Ext.undefine("spec.Order");Ext.undefine("spec.Address");Ext.undefine("spec.OrderItem")});it("should resolve any pending drops",function(){var U=L.spawn();var Q=D("Order",1,U,{addressId:101});var R=Q.getAddress();D("Address",101,U);var T=Q.orderItems();T.load();E([{id:201,orderId:1},{id:202,orderId:1}]);var S=T.getAt(0);Q.setAddress(null);T.removeAt(0);expect(R.dropped).toBe(false);expect(S.dropped).toBe(false);U.save();expect(L.getChanges()).toEqual({Address:{D:[101]},Order:{U:[{id:1,addressId:null}]},OrderItem:{D:[201]}})})});describe("many to one",function(){beforeEach(function(){Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["content",{name:"userId",reference:"User"}]})});afterEach(function(){Ext.undefine("spec.Post")});describe("store loaded in the parent",function(){var Q,R;beforeEach(function(){Q=D("User",1);R=Q.posts();R.load();E([{id:101,userId:1},{id:102,userId:1}]);P=L.spawn();R=P.getRecord("User",1).posts()});afterEach(function(){Q=R=null});it("should push up a store removal as an update to the FK",function(){R.removeAt(0);P.save();expect(L.getChanges()).toEqual({Post:{U:[{userId:null,id:101}]}});expect(L.peekRecord("Post",101).dirty).toBe(true)});it("should push up a drop",function(){R.getAt(0).drop();P.save();expect(L.getChanges()).toEqual({Post:{D:[101]}});expect(L.peekRecord("Post",101).dropped).toBe(true)});it("should push a new phantom record as a creation",function(){var S=R.add({})[0].getId();P.save();expect(L.getChanges()).toEqual({Post:{C:[{id:S,userId:1}]}});expect(L.peekRecord("Post",S).phantom).toBe(true)});it("should push an added record as an update to the FK",function(){var S=D("Post",105,P);R.add(S);P.save();expect(L.getChanges()).toEqual({Post:{U:[{id:105,userId:1}]}});expect(L.peekRecord("Post",105).dirty).toBe(true)})});describe("store not loaded in the parent",function(){var R,S,Q;beforeEach(function(){R=D("User",1);P=L.spawn();Q=P.getRecord("User",1);S=Q.posts()});afterEach(function(){R=S=Q=null});it("should read & update for a foreign key change",function(){S.load();E([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);S.removeAt(1);P.save();expect(L.getChanges()).toEqual({Post:{U:[{id:102,userId:null}]}});expect(L.peekRecord("Post",102).dirty).toBe(true)});it("should read and update for a drop",function(){S.load();E([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);S.getAt(1).drop();P.save();expect(L.getChanges()).toEqual({Post:{D:[102]}});expect(L.peekRecord("Post",102).dropped).toBe(true)});it("should push up phantom records as creates",function(){var T=S.add({content:"Foo"})[0].getId();P.save();expect(L.getChanges()).toEqual({Post:{C:[{id:T,userId:1,content:"Foo"}]}});expect(L.peekRecord("Post",T).phantom).toBe(true)});it("should have no changes if the store is loaded",function(){S.load();E([{id:101,userId:1},{id:102,userId:1},{id:103,userId:1}]);P.save();expect(L.getChanges()).toBeNull()})})});describe("many to many",function(){var S,T,Q,R;beforeEach(function(){Ext.define("spec.Group",{extend:"Ext.data.Model",fields:["name"],manyToMany:"User"})});afterEach(function(){Ext.undefine("spec.Group");S=T=Q=R});describe("store loaded in the parent",function(){beforeEach(function(){S=D("Group",1);T=S.users();T.load();E([{id:101},{id:102},{id:103}]);P=L.spawn();Q=P.getRecord("Group",1);R=Q.users()});it("should copy the store from the parent",function(){expect(R.getCount()).toBe(3)});it("should add an existing record to the parent collection",function(){var U=D("User",104);R.add(P.getRecord("User",104));P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[104]}}}});expect(T.getCount()).toBe(4);expect(T.getAt(3)).toBe(U)});it("should have a pending add in the parent, not read the record up",function(){var U=D("User",104,P);R.add(U);P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[104]}}}});expect(L.peekRecord("User",104)).toBeNull();expect(T.getCount()).toBe(3);U=D("User",104);expect(T.getCount()).toBe(4);expect(T.indexOf(U)).toBe(3)});it("should push up a removal",function(){R.removeAt(0);P.save();expect(L.getChanges()).toEqual({Group:{users:{D:{1:[101]}}}});expect(T.getCount()).toBe(2)})});describe("store not loaded, created in the parent",function(){var V,U;beforeEach(function(){S=D("Group",1);T=S.users();V=D("User",101);U=D("User",102);T.add(V,U);P=L.spawn();Q=P.getRecord("Group",1);R=Q.users()});afterEach(function(){V=U=null});it("should copy the store from the parent",function(){expect(R.getCount()).toBe(2)});it("should add an existing record to the parent collection",function(){var W=D("User",104);R.add(P.getRecord("User",104));P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[101,102,104]}}}});expect(T.getCount()).toBe(3);expect(T.getAt(2)).toBe(W)});it("should have a pending add in the parent, not read the record up",function(){var W=D("User",104,P);R.add(W);P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[101,102,104]}}}});expect(T.getCount()).toBe(2);W=D("User",104);expect(T.getCount()).toBe(3);expect(T.indexOf(W)).toBe(2)});it("should push up a removal",function(){R.removeAt(0);P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[102]}}}});expect(T.getCount()).toBe(1)})});describe("store loaded in the child",function(){beforeEach(function(){S=D("Group",1);P=L.spawn();Q=P.getRecord("Group",1);R=Q.users();R.load();E([{id:101},{id:102},{id:103}])});it("should add an existing record to the parent collection",function(){var U=D("User",104);R.add(P.getRecord("User",104));P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[104]}}}});T=S.users();expect(T.getCount()).toBe(1);expect(T.getAt(0)).toBe(U)});it("should have a pending add in the parent, not read the record up",function(){var U=D("User",104,P);R.add(U);P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[104]}}}});T=S.users();expect(T.getCount()).toBe(0);U=D("User",104);expect(T.getCount()).toBe(1);expect(T.indexOf(U)).toBe(0)});it("should have a pending removal",function(){R.removeAt(0);P.save();expect(L.getChanges()).toEqual({Group:{users:{D:{1:[101]}}}});T=S.users();expect(T.getCount()).toBe(0);T.load();E([{id:101},{id:102},{id:103}]);expect(T.getCount()).toBe(2)})});describe("store not loaded, created in the child",function(){var V,U;beforeEach(function(){S=D("Group",1);P=L.spawn();Q=P.getRecord("Group",1);R=Q.users();V=D("User",101,P);U=D("User",102,P);R.add(V,U)});afterEach(function(){V=U=null});it("should add an existing record to the parent collection",function(){var W=D("User",104);R.add(P.getRecord("User",104));P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[101,102,104]}}}});T=S.users();expect(T.getCount()).toBe(1);expect(T.getAt(0)).toBe(W)});it("should have a pending add in the parent, not read the record up",function(){P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[101,102]}}}});T=S.users();expect(T.getCount()).toBe(0);V=D("User",101);U=D("User",102);expect(T.getCount()).toBe(2);expect(T.indexOf(V)).toBe(0);expect(T.indexOf(U)).toBe(1)})});describe("empty parent",function(){it("should not push up the owning record if it was loaded in the child",function(){P=L.spawn();var V=D("Group",1,P),U=P.createRecord("User");V.users().add(U);P.save();expect(L.peekRecord("Group",1)).toBeNull()});it("should allow a create",function(){P=L.spawn();var V=D("Group",1,P),U=D("User",101,P);V.users().add(U);P.save();expect(L.getChanges()).toEqual({Group:{users:{C:{1:[101]}}}})});it("should establish a relationship when both parties load",function(){P=L.spawn();var V=D("Group",1,P),U=D("User",101,P);V.users().add(U);P.save();V=D("Group",1);U=D("User",101);expect(U.groups().indexOf(V)).toBe(0)})})})})});describe("Provisional identifiers",function(){function O(R,P,Q){describe("Schema with "+R,function(){var T,S;beforeEach(function(){P.setNamespace("spec");T=Ext.define("spec.Base",{extend:Ext.data.Model,schema:P,fields:["id","name","key"]});S=Ext.define("spec.Derived",{extend:T});L=new Ext.data.Session({schema:T.schema})});afterEach(function(){Ext.undefine("spec.Base");Ext.undefine("spec.Derived");T.schema.clear(true);T=S=null});describe("record creation",function(){it("should isolate id generation to the session",function(){var V=new T();var U=L.createRecord("Base",{name:"Don"});expect(V).not.toBe(U);expect(U.id).toBe(V.id)});it("should track all created records",function(){var V=L.createRecord("Base",{name:"Don"});expect(V.id).toBe(Q["B-1"]);var U=L.createRecord("Derived",{name:"Evan"});expect(U.id).toBe(Q["D-1"]);var W=L.getChanges();expect(W).toEqual({Base:{C:[{id:V.id,name:"Don"}]},Derived:{C:[{id:U.id,name:"Evan"}]}})})})})}O("default identities",Ext.data.Model.schema,{"B-1":"Base-1","D-1":"Derived-1"});O("negative identities",new Ext.data.schema.Schema({defaultIdentifier:"negative"}),{"B-1":-1,"D-1":-1});O("sequential identities",new Ext.data.schema.Schema({defaultIdentifier:"sequential"}),{"B-1":1,"D-1":1})});describe("Random UUID's",function(){var P,O;var Q;beforeEach(function(){if(!Q){Q=new Ext.data.schema.Schema({defaultIdentifier:"uuid"})}Q.setNamespace("spec");P=Ext.define("spec.Base",{extend:Ext.data.Model,schema:Q,fields:["id","name","key"]});L=new Ext.data.Session({schema:P.schema})});afterEach(function(){Ext.undefine("spec.Base");Ext.undefine("spec.Derived");P.schema.clear(true);P=O=null});describe("record creation",function(){it("should copy identifier reference into the session",function(){var U=new P();var S=L.createRecord("Base",{name:"Don"});expect(U).not.toBe(S);expect(S.id).not.toBe(U.id);var R=L.getSchema().getDefaultIdentifier();var T=L.getIdentifier(P);expect(T).toBe(P.identifier);expect(T).toBe(R);expect(T).toBe(Ext.data.identifier.Uuid.Global)})})});describe("Sequential UUID's",function(){var P,O;var Q;beforeEach(function(){if(!Q){Q=new Ext.data.schema.Schema({defaultIdentifier:{type:"uuid",version:1,timestamp:233811181,salt:3203395597,clockSeq:2989}})}Q.setNamespace("spec");P=Ext.define("spec.Base",{extend:Ext.data.Model,schema:Q,fields:["id","name","key"]});L=new Ext.data.Session({schema:P.schema})});afterEach(function(){Ext.undefine("spec.Base");Ext.undefine("spec.Derived");P.schema.clear(true);P=O=null});describe("record creation",function(){it("should copy identifier reference into the session",function(){var T=new P();var S=L.createRecord("Base",{name:"Don"});expect(T.id).toBe("0defaced-0000-1000-8bad-0100beeff00d");expect(S.id).toBe("0defacee-0000-1000-8bad-0100beeff00d");var R=L.getSchema().getDefaultIdentifier();var U=L.getIdentifier(P);expect(U).toBe(P.identifier);expect(U).toBe(R);expect(U).not.toBe(Ext.data.identifier.Uuid.Global)})})});describe("Many-to-many associations",function(){var P,O;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");P=Ext.define("spec.User",{extend:Ext.data.Model,fields:["name","key"],manyToMany:"#Group"});O=Ext.define("spec.Group",{extend:Ext.data.Model,fields:["name","key"]});L=new Ext.data.Session({schema:P.schema})});afterEach(function(){Ext.undefine("spec.User");Ext.undefine("spec.Group");P.schema.clear(true);P=O=null});describe("loading a many-to-many",function(){it("should load groups for a user",function(){var Q=L.getRecord("User",J.id,false).groups();Q.load();E(B);expect(Q.isStore).toBe(true);expect(Q.getCount()).toBe(2);expect(Q.getById(N.id)).toBeTruthy();expect(Q.getById(A.id)).toBeTruthy();var R=L.matrices.UserGroups;expect(R.left.slices[10].members[42]).toEqual([10,42,0]);expect(R.left.slices[10].members[427]).toEqual([10,427,0]);expect(R.right.slices[42].members[10]).toEqual([10,42,0]);expect(R.right.slices[427].members[10]).toEqual([10,427,0])});it("should load both sides of a matrix",function(){var Q=L.getRecord("User",J.id,false).groups(),U=L.getRecord("Group",N.id,false).users(),R=L.getRecord("Group",A.id,false).users();Q.load();R.load();U.load();E(B,1);E(G,2);E(F,3);expect(Q.isStore).toBe(true);expect(Q.getCount()).toBe(2);expect(Q.getById(N.id)).toBeTruthy();expect(Q.getById(A.id)).toBeTruthy();var T,S;expect(U.isStore).toBe(true);expect(U.getCount()).toBe(1);expect(T=U.getById(J.id)).toBeTruthy();expect(R.isStore).toBe(true);expect(R.getCount()).toBe(3);expect(R.getById(K.id)).toBeTruthy();expect(R.getById(M.id)).toBeTruthy();expect(S=R.getById(J.id)).toBeTruthy();expect(T).toBe(S)});it("should allow editing on both sides of a matrix",function(){var T=L.getRecord("User",K.id,false).groups(),R=L.getRecord("User",J.id,false).groups(),W=L.getRecord("Group",N.id,false).users(),S=L.getRecord("Group",A.id,false).users();R.load();T.load();S.load();W.load();E(B,1);E(C,2);E(G,3);E(F,4);expect(R.getCount()).toBe(2);expect(R.getById(N.id)).toBeTruthy();var Q=W.getById(J.id);W.remove(Q);expect(R.getCount()).toBe(1);expect(R.getById(N.id)).toBe(null);expect(T.getCount()).toBe(1);expect(T.getById(N.id)).toBe(null);var V=S.getById(K.id);W.add(V);expect(T.getCount()).toBe(2);expect(T.getById(N.id)).toBeTruthy();var U=L.getChanges();expect(U).toEqual({User:{groups:{C:{20:[42]},D:{10:[42]}}}})})})});describe("transactions",function(){var S,O,W,R,T,V;var U,P,Q;beforeEach(function(){Ext.data.Model.schema.setNamespace("spec");U=[{id:1,name:"parent1",code:"abc",foo:42},{id:2,name:"parent2",code:"def",foo:427}];P=[{id:10,name:"child1",parentId:1},{id:20,name:"child2",parentId:2}];Q=[{id:100,name:"grand1",childId:10},{id:200,name:"grand2",childId:20}];S=Ext.define("spec.Base",{extend:Ext.data.Model});V=Ext.define("spec.User",{extend:Ext.data.Model,fields:["name","key"],manyToMany:"#Group"});T=Ext.define("spec.Group",{extend:Ext.data.Model,fields:["name","key"]});O=Ext.define("spec.Parent",{extend:S,identifier:{type:"negative"},fields:["name","code",{name:"foo",critical:true}]});W=Ext.define("spec.Child",{extend:S,identifier:{type:"negative",seed:-10},fields:["name",{name:"parentId",reference:"Parent"}]});R=Ext.define("spec.GrandChild",{extend:S,identifier:{type:"negative",seed:-100},clientIdProperty:"cid",fields:["name",{name:"childId",reference:"Child"}]});L=new Ext.data.Session({schema:S.schema})});afterEach(function(){Ext.undefine("spec.Base");Ext.undefine("spec.Parent");Ext.undefine("spec.Child");Ext.undefine("spec.GrandChild");Ext.undefine("spec.Group");Ext.undefine("spec.User");Ext.data.Model.schema.clear(true);L=null;S=O=W=R=T=V=null});describe("complex transaction",function(){var X;beforeEach(function(){X={parentRecs:[],childRecs:[],grandChildRecs:[]};Ext.each([0,1],function(Y){X.grandChildRecs.push(L.createRecord("GrandChild",Q[Y]));X.childRecs.push(L.createRecord("Child",P[Y]));X.parentRecs.push(L.createRecord("Parent",U[Y]))});X.parentRecs[0].set("code","xyz");X.childRecs[0].set("name","child1a");X.grandChildRecs[0].set("name","grand1a");X.parentRecs[1].drop();X.childRecs[1].drop();X.grandChildRecs[1].drop();X.newParent=L.createRecord("Parent",{name:"newParent",foo:-42});X.newChild=L.createRecord("Child",{name:"newChild"});X.newGrandChild=L.createRecord("GrandChild");X.newChild.setParent(X.newParent);X.newGrandChild.setChild(X.newChild)});afterEach(function(){X=null});it("should describe the transaction via getChanges",function(){var Y=L.getChanges();expect(Y).toEqual({Parent:{C:[{id:-1,name:"newParent",foo:-42}],U:[{id:1,code:"xyz",foo:42}],D:[2]},Child:{C:[{id:-10,name:"newChild",parentId:-1}],U:[{id:10,name:"child1a"}],D:[20]},GrandChild:{C:[{id:-100,childId:-10}],U:[{id:100,name:"grand1a"}],D:[200]}})});it("should produce a Batch via getSaveBatch",function(){var Y=L.getSaveBatch();expect(Y.operations.length).toBe(9);Ext.each([["create","Parent",[X.newParent]],["create","Child",[X.newChild]],["create","GrandChild",[X.newGrandChild]],["update","Parent",[X.parentRecs[0]]],["update","Child",[X.childRecs[0]]],["update","GrandChild",[X.grandChildRecs[0]]],["destroy","GrandChild",[X.grandChildRecs[1]]],["destroy","Child",[X.childRecs[1]]],["destroy","Parent",[X.parentRecs[1]]]],function(c,a){var Z=Y.operations[a],d;d="operation["+a+"].action=";expect(d+Z.action).toBe(d+c[0]);d="operation["+a+"].type=";expect(d+Z.entityType.entityName).toBe(d+c[1]);d="operation["+a+"].records=";var e=Ext.Array.pluck(Z.getRecords(),"id");e=Ext.encode(e);var b=Ext.Array.pluck(c[2],"id");b=Ext.encode(b);expect(d+e).toBe(d+b)})});it("should progress save batch to completion",function(){var a=L.createRecord("GrandChild");a.setChild(X.newChild);expect(a.id).toBe(-101);expect(a.data.childId).toBe(-10);var Z=L.getSaveBatch();expect(Z.operations.length).toBe(9);var Y=Z.operations[2].getRecords();expect(Y[0]).toBe(X.newGrandChild);expect(Y[1]).toBe(a);Z.start();E({id:1000});expect(X.newParent.id).toBe(1000);expect(X.newChild.data.parentId).toBe(1000);E({id:2000});expect(X.newChild.id).toBe(2000);expect(X.newGrandChild.data.childId).toBe(2000);expect(a.data.childId).toBe(2000);Z.pause();E([{cid:a.id,id:3001},{cid:X.newGrandChild.id,id:3000}]);expect(X.newGrandChild.id).toBe(3000);expect(a.id).toBe(3001)})});describe("matrix updates",function(){it("should be able to create matrix for new record",function(){var Y=L.getRecord("User",J.id,false).groups();Y.load();E(B);var Z=L.createRecord("User");var X=Z.groups();X.add(Y.getAt(0));var a=L.getSaveBatch();var b=L.getChanges();expect(a.operations.length).toBe(1);expect(b).toEqual({User:{C:[{id:"User-1"}],groups:{C:{"User-1":[42]}}}});a.start();E({id:500});var c=L.getChanges();expect(c).toEqual({User:{groups:{C:{500:[42]}}}})})})})})