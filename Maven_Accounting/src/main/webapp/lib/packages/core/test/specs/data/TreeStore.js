describe("Ext.data.TreeStore",function(){var K,H,A,D=Ext.define(null,{extend:"Ext.data.Model",fields:["name"],proxy:{type:"ajax",url:"foo.json",reader:{type:"json"}}}),G=Ext.define(null,{extend:"Ext.data.Model",idProperty:"id",fields:[{name:"id",type:"int",allowNull:true},{name:"task",type:"string"},{name:"duration",type:"string"}]});function E(N,M,P){var Q={fn:P||Ext.emptyFn},O=spyOn(Q,"fn");N.addListener(M,Q.fn);return O}function B(M){if(Ext.isNumber(M[0])){M=Ext.Array.map(M,function(N){return{id:N,leaf:true}})}Ext.Array.forEach(M,function(N){if(N.children||N.leaf===false){N.expanded=true;if(N.children){N.children=B(N.children)}else{N.children=[]}}else{N.leaf=true}});return M}function C(N,M){K=new Ext.data.TreeStore(Ext.apply({asynchronousLoad:false,root:{expanded:true,children:B(N)}},M))}function F(P,O){var Q=P.childNodes,N,M;expect((Q||[]).length).toBe(O.length);if(Q){for(N=0,M=Q.length;N<M;++N){expect(Q[N].id).toBe(O[N])}}}beforeEach(function(){A={success:true,children:[{id:1,name:"aaa"},{id:2,name:"bbb",children:[{id:3,name:"ccc"},{id:4,name:"ddd",children:[{id:5,name:"eee",leaf:true}]}]},{id:6,name:"fff",children:[{id:7,name:"ggg"}]}]};MockAjaxManager.addMethods();H=function(M,N){M.load(N);J(A)}});afterEach(function(){K=Ext.destroy(K);MockAjaxManager.removeMethods()});function J(M){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode(M)})}function I(){Ext.Ajax.mockComplete({status:200,responseText:Ext.encode({success:false})})}function L(M){return K.getNodeById(M)}describe("success: false in return packet",function(){var M=true;it("should fire the load event with the success parameter false",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true},listeners:{load:function(P,O,R,N,Q){M=R}}});I();expect(M).toBe(false)})});describe("the model",function(){it("should be able to use a non TreeModel",function(){var M=Ext.define(null,{extend:"Ext.data.Model",fields:["foo"]});K=new Ext.data.TreeStore({proxy:{type:"ajax",url:"fake"},model:M});expect(K.getModel()).toBe(M);expect(M.prototype.isNode).toBe(true)});describe("using an implicit model",function(){it("should use the model's memory proxy when no proxy is defined on the store",function(){K=new Ext.data.TreeStore({fields:["id","height","width"]});expect(K.getProxy().isMemoryProxy).toBe(true);expect(K.getProxy()).toBe(K.getModel().getProxy())});it("should set the store's proxy on the model",function(){K=new Ext.data.TreeStore({fields:["id","height","width"],proxy:{type:"ajax",url:"foo"}});expect(K.getProxy().isAjaxProxy).toBe(true);expect(K.getProxy().url).toBe("foo");expect(K.getProxy()).toBe(K.getModel().getProxy())});it("should have the model set on the proxy & the reader",function(){K=new Ext.data.TreeStore({fields:["id","height","width"],proxy:{type:"ajax",url:"foo"}});expect(K.getProxy().getModel()).toBe(K.getModel());expect(K.getProxy().getReader().getModel()).toBe(K.getModel())});it("should extend Ext.data.Model",function(){K=new Ext.data.TreeStore({fields:["id","height","width"]});expect(K.getModel().superclass.self).toBe(Ext.data.TreeModel)})})});describe("sorting",function(){function M(P){var N=P.length,O;expect(K.getCount()).toBe(N);for(O=0;O<N;++O){expect(K.getAt(O).id).toBe(P[O])}}describe("with local data",function(){describe("with folderSort: true",function(){it("should sort when setting folderSort dynamically",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,children:[{id:"l1",leaf:true},{id:"f1"},{id:"l2",leaf:true},{id:"f2"}]}});K.setFolderSort(true);F(K.getRoot(),["f1","f2","l1","l2"])});it("should leave the original sort order if there are no other sorters",function(){K=new Ext.data.TreeStore({model:D,folderSort:true,root:{expanded:true,children:[{id:"l3",leaf:true},{id:"l2",leaf:true},{id:"f3"},{id:"l1",leaf:true},{id:"f2"},{id:"f1"}]}});F(K.getRoot(),["f3","f2","f1","l3","l2","l1"])});it("should do a deep sort",function(){K=new Ext.data.TreeStore({model:D,folderSort:true,root:{expanded:true,children:[{id:"p1",children:[{id:"l1",leaf:true},{id:"f1"}]},{id:"p2",children:[{id:"l2",leaf:true},{id:"f2"}]}]}});F(L("p1"),["f1","l1"]);F(L("p2"),["f2","l2"])});it("should sort folder/non folder groups by any additional sorters",function(){K=new Ext.data.TreeStore({model:D,folderSort:true,sorters:["id"],root:{expanded:true,children:[{id:"f4"},{id:"l3"},{id:"f1"},{id:"l1"},{id:"l2"},{id:"f3"},{id:"l4"},{id:"f2"}]}});F(K.getRoot(),["f1","f2","f3","f4","l1","l2","l3","l4"])})});describe("with folderSort: false",function(){it("should sort by existing sorters when setting folderSort: false",function(){K=new Ext.data.TreeStore({model:D,folderSort:false,sorters:["id"],root:{expanded:true,children:[{id:"a",leaf:true},{id:"b"},{id:"c",leaf:true},{id:"d"}]}});K.setFolderSort(false);F(K.getRoot(),["a","b","c","d"])});it("should do a deep sort",function(){K=new Ext.data.TreeStore({model:D,folderSort:false,sorters:["id"],root:{expanded:true,children:[{id:"p1",expanded:true,children:[{id:"b",leaf:true},{id:"c",leaf:true},{id:"a",leaf:true},{id:"d",leaf:true}]},{id:"p2",expanded:true,children:[{id:"g",leaf:true},{id:"e",leaf:true},{id:"h",leaf:true},{id:"f",leaf:true}]}]}});K.setFolderSort(false);F(L("p1"),["a","b","c","d"]);F(L("p2"),["e","f","g","h"])})})});describe("with remote data",function(){describe("with folderSort: true",function(){it("should sort when setting folderSort dynamically",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true}});J([{id:"l1",leaf:true},{id:"f1"},{id:"l2",leaf:true},{id:"f2"}]);K.setFolderSort(true);F(K.getRoot(),["f1","f2","l1","l2"])});it("should leave the original sort order if there are no other sorters",function(){K=new Ext.data.TreeStore({model:D,folderSort:true,root:{expanded:true}});J([{id:"l3",leaf:true},{id:"l2",leaf:true},{id:"f3"},{id:"l1",leaf:true},{id:"f2"},{id:"f1"}]);F(K.getRoot(),["f3","f2","f1","l3","l2","l1"])});it("should do a deep sort",function(){K=new Ext.data.TreeStore({model:D,folderSort:true,root:{expanded:true}});J([{id:"p1",children:[{id:"l1",leaf:true},{id:"f1"}]},{id:"p2",children:[{id:"l2",leaf:true},{id:"f2"}]}]);F(L("p1"),["f1","l1"]);F(L("p2"),["f2","l2"])});it("should sort folder/non folder groups by any additional sorters",function(){K=new Ext.data.TreeStore({model:D,folderSort:true,sorters:["id"],root:{expanded:true}});J([{id:"f4"},{id:"l3"},{id:"f1"},{id:"l1"},{id:"l2"},{id:"f3"},{id:"l4"},{id:"f2"}]);F(K.getRoot(),["f1","f2","f3","f4","l1","l2","l3","l4"])})});describe("with folderSort: false",function(){it("should sort by existing sorters when setting folderSort: false",function(){K=new Ext.data.TreeStore({model:D,folderSort:false,sorters:["id"],root:{expanded:true}});J([{id:"a",leaf:true},{id:"b"},{id:"c",leaf:true},{id:"d"}]);K.setFolderSort(false);F(K.getRoot(),["a","b","c","d"])});it("should do a deep sort",function(){K=new Ext.data.TreeStore({model:D,folderSort:false,sorters:["id"],root:{expanded:true}});J([{id:"p1",expanded:true,children:[{id:"b",leaf:true},{id:"c",leaf:true},{id:"a",leaf:true},{id:"d",leaf:true}]},{id:"p2",expanded:true,children:[{id:"g",leaf:true},{id:"e",leaf:true},{id:"h",leaf:true},{id:"f",leaf:true}]}]);K.setFolderSort(false);F(L("p1"),["a","b","c","d"]);F(L("p2"),["e","f","g","h"])})})});describe("adding/expanding nodes",function(){it("should sort nodes correctly on expand",function(){K=new Ext.data.TreeStore({model:D,sorters:["id"],root:{expanded:true,children:[{id:"a",children:[{id:"z"},{id:"y"}]},{id:"b",children:[{id:"x"},{id:"w"}]},{id:"c",children:[{id:"v"},{id:"u"}]}]}});L("a").expand();F(L("a"),["y","z"]);M(["a","y","z","b","c"]);L("b").expand();F(L("b"),["w","x"]);M(["a","y","z","b","w","x","c"]);L("c").expand();F(L("c"),["u","v"]);M(["a","y","z","b","w","x","c","u","v"])});it("should sort nodes correctly on add",function(){K=new Ext.data.TreeStore({model:D,sorters:["id"],root:{expanded:true,children:[{id:"a",expanded:true,children:[]},{id:"b",expanded:true,children:[]},{id:"c",expanded:true,children:[]}]}});L("a").appendChild([{id:"y"},{id:"z"}]);F(L("a"),["y","z"]);M(["a","y","z","b","c"]);L("b").appendChild([{id:"w"},{id:"x"}]);F(L("b"),["w","x"]);M(["a","y","z","b","w","x","c"]);L("c").appendChild([{id:"u"},{id:"v"}]);F(L("c"),["u","v"]);M(["a","y","z","b","w","x","c","u","v"])})})});describe("getNodeById",function(){it("should return null if there is no matching id",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,text:"Root"}});expect(K.getNodeById("foo")).toBeNull()});it("should be able to return the root",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,id:"root"}});expect(K.getNodeById("root")).toBe(K.getRoot())});it("should be able to return a deep node",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,children:[{expanded:true,children:[{expanded:true,children:[{expanded:true,children:[{id:"deep"}]}]}]}]}});var M;K.getRoot().cascadeBy(function(N){if(N.id==="deep"){M=N}});expect(K.getNodeById("deep")).toBe(M)});it("should be usable during nodeappend event",function(){var M=[];K=new Ext.data.TreeStore({model:D,listeners:{nodeappend:function(O,R,N){M.push(R.id);var P=R.getTreeStore();var Q=P.getNodeById(R.id);expect(Q&&Q.id).toBe(R.id);expect(Q===R).toBe(true)}},root:{expanded:true,id:"root",children:[{id:"child",expanded:false,children:[{id:"leaf"}]}]}});expect(M.join(" ")).toBe("root child leaf")});it("should find loaded children of collapsed nodes",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,children:[{expanded:false,children:[{id:"leaf"}]}]}});expect(K.getNodeById("leaf")).toBe(K.getRoot().firstChild.firstChild)});it("should find nodes that are filtered out",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,children:[{text:"A"},{text:"A"},{text:"A"},{id:"bNode",text:"B"}]}});expect(K.getCount()).toBe(4);K.filter("text","A");expect(K.getCount()).toBe(3);expect(K.getNodeById("bNode")).toBe(K.getRoot().lastChild)})});describe("loading data",function(){describe("isLoaded",function(){it("should be false by default",function(){K=new Ext.data.TreeStore({root:{text:"Root"}});expect(K.isLoaded()).toBe(false)});it("should be true after a load",function(){K=new Ext.data.TreeStore({root:{text:"Root"}});K.load();expect(K.isLoaded()).toBe(true)})});describe("when loading asynchronously from a url",function(){describe("if the root node is expanded",function(){it("should load the TreeStore automatically",function(){spyOn(Ext.data.TreeStore.prototype,"load").andCallThrough();K=new Ext.data.TreeStore({model:D,asynchronousLoad:true,root:{expanded:true,id:0,name:"Root Node"}});expect(K.load.callCount).toBe(1)});describe("with autoLoad: true",function(){it("should not load twice with a root defined",function(){spyOn(Ext.data.TreeStore.prototype,"flushLoad").andCallThrough();runs(function(){K=Ext.create("Ext.data.TreeStore",{model:D,autoLoad:true,asynchronousLoad:true,root:{expanded:true,id:0,name:"Root Node"}})});waits(10);runs(function(){expect(K.flushLoad.callCount).toBe(1)})});it("should not load twice without a root defined",function(){spyOn(Ext.data.TreeStore.prototype,"flushLoad").andCallThrough();runs(function(){K=Ext.create("Ext.data.TreeStore",{model:D,autoLoad:true,asynchronousLoad:true})});waits(10);runs(function(){expect(K.flushLoad.callCount).toBe(1)})})})});describe("if the root node is not expanded",function(){beforeEach(function(){K=new Ext.data.TreeStore({model:D,autoLoad:false,asynchronousLoad:true,root:{expanded:false,id:0,name:"Root Node"}})});it("should not be loading before load is called",function(){expect(K.isLoading()).toBe(false)});it("should be loading while the request is still in progress",function(){K.load();K.flushLoad();expect(K.isLoading()).toBe(true)});it("should not be loading after the request has finished",function(){H(K);expect(K.isLoading()).toBe(false)});describe("if autoLoad is set to true",function(){beforeEach(function(){spyOn(Ext.data.TreeStore.prototype,"load").andCallThrough();K=new Ext.data.TreeStore({model:D,autoLoad:true,asynchronousLoad:true,root:{expanded:false,id:0,name:"Root Node"}})});it("should load the TreeStore automatically",function(){expect(K.load).toHaveBeenCalled()})})});describe("when reloading a store that already contains records",function(){beforeEach(function(){K=new Ext.data.TreeStore({model:D,autoLoad:false,asynchronousLoad:false,root:{expanded:false,id:0,name:"Root Node"}});K.fillNode(K.getRootNode(),K.getProxy().getReader().readRecords(A.children).getRecords())});describe("if records have been removed from the store",function(){beforeEach(function(){K.getNodeById(1).remove();K.getNodeById(5).remove();K.getNodeById(4).remove()});describe("if the node being loaded is the root node",function(){beforeEach(function(){H(K)});it("should reset the store's removed array",function(){expect(K.getRemovedRecords().length).toBe(0)})});describe("if the node being loaded is not the root node",function(){var M;beforeEach(function(){H(K,{node:K.getNodeById(2)})});it("should only remove records from the removed array that were previously descendants of the node being reloaded",function(){M=K.getRemovedRecords();expect(M.length).toBe(1);expect(M[0].getId()).toBe(1)})});describe("if clearRemovedOnLoad is false",function(){var M;beforeEach(function(){K.clearRemovedOnLoad=false;H(K)});afterEach(function(){K.clearRemovedOnLoad=true});it("should not alter the store's removed array",function(){M=K.getRemovedRecords();expect(M.length).toBe(3);expect(M[0].getId()).toBe(1);expect(M[1].getId()).toBe(5);expect(M[2].getId()).toBe(4)})})})});describe("when the records in the response data have an index field",function(){beforeEach(function(){A={success:true,children:[{id:1,name:"aaa",index:2},{id:2,name:"bbb",index:0,children:[{id:3,name:"ccc",index:1},{id:4,name:"ddd",index:0}],expanded:true},{id:5,name:"eee",index:1}]};K=new Ext.data.TreeStore({model:D,root:{expanded:true,id:0,name:"Root Node"}});H(K)});it("should sort the root level nodes by index",function(){expect(K.getRootNode().childNodes[0].getId()).toBe(2);expect(K.getRootNode().childNodes[1].getId()).toBe(5);expect(K.getRootNode().childNodes[2].getId()).toBe(1)});it("should sort descendants by index",function(){expect(K.getNodeById(2).firstChild.getId()).toBe(4);expect(K.getNodeById(2).lastChild.getId()).toBe(3)});it("should sort folders first, then in index order",function(){expect(K.getAt(0).getId()).toBe(2);expect(K.getAt(1).getId()).toBe(4);expect(K.getAt(2).getId()).toBe(3);expect(K.getAt(3).getId()).toBe(5);expect(K.getAt(4).getId()).toBe(1)})})});describe("clearOnLoad",function(){beforeEach(function(){K=new Ext.data.TreeStore({model:D,asynchronousLoad:false,root:{expanded:true,id:0,name:"Root Node"}});J({children:[]})});it("should remove existing nodes with clearOnLoad: true",function(){A={children:[]};var M=K.getRootNode();M.appendChild({id:"node1",text:"A"});M.appendChild({id:"node2",text:"B"});H(K);expect(K.getRootNode().childNodes.length).toBe(0);expect(K.getNodeById("node1")).toBeNull();expect(K.getNodeById("node2")).toBeNull()});it("should leave existing nodes with clearOnLoad: false",function(){K.clearOnLoad=false;A={children:[]};var N=K.getRootNode(),P=N.childNodes,O,M;N.appendChild({id:"node1",text:"A"});O=P[0];N.appendChild({id:"node2",text:"B"});M=P[1];H(K);expect(P.length).toBe(2);expect(K.getNodeById("node1")).toBe(O);expect(K.getNodeById("node2")).toBe(M)});it("should ignore dupes with clearOnLoad: false",function(){K.clearOnLoad=false;A={children:[{id:"node1",text:"A"},{id:"node3",text:"C"}]};var M=K.getRootNode();M.appendChild({id:"node1",text:"A"});M.appendChild({id:"node2",text:"B"});H(K);expect(K.getRootNode().childNodes.length).toBe(3)})})});describe("adding data",function(){var M,N;afterEach(function(){Ext.destroy(K);M=N=null});describe("adding non-leaf nodes with children",function(){var P,R;function O(S,T){describe(S+" an existing node",function(){Q(T,false);Q(T,true)})}function Q(T,S){describe("expanded: "+S.toString(),function(){it("should add the node and create its child nodes",function(){P[T]({text:"child",expanded:S,children:[{text:"detention",expanded:S,children:[{text:"ben",leaf:true},{text:"bill",leaf:true}]}]});R=K.getNewRecords()[0];expect(R.childNodes.length).toBe(1);expect(R.firstChild.childNodes.length).toBe(2);expect(K.getNewRecords().length).toBe(4)});it('should mark the new nodes as "loaded"',function(){expect(R.get("loaded")).toBe(true);expect(R.firstChild.get("loaded")).toBe(true)})})}beforeEach(function(){K=new Ext.data.TreeStore({root:{name:"Root Node"}});P=K.getRootNode()});O("appending to","appendChild");O("inserting before","insertBefore")});describe("adding childless non-leaf nodes",function(){beforeEach(function(){spyOn(Ext.data.TreeStore.prototype,"load").andCallThrough();K=new Ext.data.TreeStore({model:D,root:{name:"Root Node"}});M=K.getRootNode();M.appendChild({text:"child2",expanded:false})});it("should not make a request for data when expanded",function(){M.firstChild.expand();expect(K.load).not.toHaveBeenCalled()})})});describe("modifying records",function(){it("should fire the update event and pass the store, record, type & modified fields",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,text:"Root",children:[{text:"A child",someProp:"a"}]}});var O=K.getRoot().firstChild,N=jasmine.createSpy();K.on("update",N);O.set("someProp","b");expect(N).toHaveBeenCalled();var M=N.mostRecentCall.args;expect(M[0]).toBe(K);expect(M[1]).toBe(O);expect(M[2]).toBe(Ext.data.Model.EDIT);expect(M[3]).toEqual(["someProp"])});it("should fire the update event and pass the store, record, type & modified fields when attached to another store",function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,text:"Root",children:[{text:"A child",someProp:"a"}]}});var P=K.getRoot().firstChild,O=jasmine.createSpy();var M=new Ext.data.Store({model:D,data:[P]});K.on("update",O);P.set("someProp","b");expect(O).toHaveBeenCalled();var N=O.mostRecentCall.args;expect(N[0]).toBe(K);expect(N[1]).toBe(P);expect(N[2]).toBe(Ext.data.Model.EDIT);expect(N[3]).toEqual(["someProp"])})});describe("saving data",function(){var M,N,O;beforeEach(function(){K=new Ext.data.TreeStore({model:D,asynchronousLoad:false,root:{expanded:true,name:"Root Node"}});H(K);O=spyOn(K,"sync").andCallFake(function(){this.needsSync=false})});describe("creating records",function(){describe("appending a single node",function(){beforeEach(function(){M=new D({name:"Phil"});K.getRootNode().appendChild(M)});it("should add the node to getNewRecords",function(){N=K.getNewRecords();expect(N.length).toBe(1);expect(N[0]).toBe(M)});it("should not add anything to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()})});describe("inserting a single node",function(){beforeEach(function(){M=new D({name:"Phil"});K.getNodeById(2).insertBefore(M,K.getNodeById(4))});it("should add the node to getNewRecords",function(){N=K.getNewRecords();expect(N.length).toBe(1);expect(N[0]).toBe(M)});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()})});describe("appending and inserting multiple nodes",function(){var R,Q,P;beforeEach(function(){R=new D({name:"1"});Q=new D({name:"2"});P=new D({name:"3"});K.getRootNode().appendChild(R);K.getNodeById(2).insertBefore(Q,K.getNodeById(4));Q.appendChild(P)});it("should add the nodes to getNewRecords",function(){var S=K.getNewRecords();expect(S.length).toBe(3);expect(Ext.Array.contains(S,R)).toBe(true);expect(Ext.Array.contains(S,Q)).toBe(true);expect(Ext.Array.contains(S,P)).toBe(true)});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()})});describe("when the index field is persistent",function(){beforeEach(function(){D.getField("index").persist=true});afterEach(function(){D.getField("index").persist=false});describe("appending a single node",function(){beforeEach(function(){M=new D({name:"Phil"});K.getRootNode().appendChild(M)});it("should add the node to getNewRecords",function(){N=K.getNewRecords();expect(N.length).toBe(1);expect(N[0]).toBe(M)});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)})});describe("inserting a single node",function(){beforeEach(function(){M=new D({name:"Phil"});K.getNodeById(2).insertBefore(M,K.getNodeById(3))});it("should add the node to getNewRecords",function(){N=K.getNewRecords();expect(N.length).toBe(1);expect(N[0]).toBe(M)});it("should add all of its sibling nodes that come after the insertion point to getUpdatedRecords",function(){N=K.getUpdatedRecords();expect(N.length).toBe(2);expect(Ext.Array.contains(N,K.getNodeById(3))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(4))).toBe(true)})})});describe("when autoSync is true",function(){beforeEach(function(){K.autoSync=true});describe("appending a single node",function(){beforeEach(function(){M=new D({name:"Phil"});K.getRootNode().appendChild(M)});it("should sync the store",function(){expect(O.callCount).toBe(1)})});describe("inserting a single node",function(){beforeEach(function(){M=new D({name:"Phil"});K.getNodeById(2).insertBefore(M,K.getNodeById(4))});it("should sync the store",function(){expect(O.callCount).toBe(1)})})})});describe("updating records",function(){describe("updating multiple records",function(){beforeEach(function(){K.getNodeById(2).set("name","222");K.getNodeById(3).set("name","333")});it("should add the nodes to getUpdatedRecords",function(){N=K.getUpdatedRecords();expect(N.length).toBe(2);expect(Ext.Array.contains(N,K.getNodeById(2))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(3))).toBe(true)});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()})});describe("moving records",function(){describe("within the same parent node",function(){beforeEach(function(){K.getRootNode().insertBefore(K.getNodeById(6),K.getNodeById(1))});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()})});describe("to a different parent node",function(){beforeEach(function(){K.getNodeById(4).insertBefore(K.getNodeById(1),K.getNodeById(5))});it("should add the node to getUpdatedRecords",function(){N=K.getUpdatedRecords();expect(N.length).toBe(1);expect(N[0]).toBe(K.getNodeById(1))});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()})})});describe("moving records when the index field is persistent",function(){beforeEach(function(){D.getField("index").persist=true});afterEach(function(){D.getField("index").persist=false});describe("within the same parent node",function(){beforeEach(function(){K.getRootNode().insertBefore(K.getNodeById(6),K.getNodeById(1))});it("should add the node and all sibling nodes after it to getUpdatedRecords",function(){N=K.getUpdatedRecords();expect(N.length).toBe(3);expect(Ext.Array.contains(N,K.getNodeById(1))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(2))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(6))).toBe(true)})});describe("to a different parent node",function(){beforeEach(function(){K.getNodeById(4).insertBefore(K.getNodeById(1),K.getNodeById(5))});it("should add the node, all sibling nodes after it's insertion point, and all siblings after its removal point to getUpdatedRecords",function(){N=K.getUpdatedRecords();expect(N.length).toBe(4);expect(Ext.Array.contains(N,K.getNodeById(1))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(2))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(5))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(6))).toBe(true)})})});describe("moving records when autoSync is true",function(){beforeEach(function(){K.autoSync=true});describe("within the same parent node",function(){beforeEach(function(){K.getRootNode().insertBefore(K.getNodeById(6),K.getNodeById(1))});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()})});describe("to a different parent node",function(){beforeEach(function(){K.getNodeById(4).insertBefore(K.getNodeById(1),K.getNodeById(5))});it("should sync the store",function(){expect(O.callCount).toBe(1)})});describe("to a different TreeStore",function(){var Q,P;beforeEach(function(){Q=new Ext.data.TreeStore({model:D,root:{expanded:true,name:"Root Node"},autoSync:true});P=spyOn(Q,"sync").andCallFake(function(){this.needsSync=false});Q.getRootNode().appendChild(K.getNodeById(1))});afterEach(function(){Q.destroy()});it("should sync both the stores",function(){expect(O.callCount).toBe(1);expect(P.callCount).toBe(1)})})})});describe("removing records",function(){describe("removing a single record",function(){beforeEach(function(){M=K.getNodeById(1).remove()});it("should add the node to getRemovedRecords",function(){N=K.getRemovedRecords();expect(N.length).toBe(1);expect(N[0]).toBe(M)});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()});it("should not add phantom records to the removed collection",function(){var Q=new D(),P=K.getRootNode();P.appendChild(Q);P.removeChild(Q);expect(Ext.Array.contains(K.getRemovedRecords(),Q)).toBe(false)})});describe("removing multiple records",function(){var P;beforeEach(function(){M=K.getNodeById(1).remove();P=K.getNodeById(4).remove()});it("should add the nodes to getRemovedRecords",function(){N=K.getRemovedRecords();expect(N.length).toBe(3);expect(Ext.Array.contains(N,M)).toBe(true);expect(Ext.Array.contains(N,P)).toBe(true)});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)});it("should not sync the store",function(){expect(O).not.toHaveBeenCalled()})});describe("when the index field is persistent",function(){beforeEach(function(){D.getField("index").persist=true});afterEach(function(){D.getField("index").persist=false});describe("removing a single record",function(){beforeEach(function(){M=K.getNodeById(1).remove()});it("should add the node to getRemovedRecords",function(){N=K.getRemovedRecords();expect(N.length).toBe(1);expect(N[0]).toBe(M)});it("should add all siblings after the node's removal point to getUpdatedRecords",function(){N=K.getUpdatedRecords();expect(N.length).toBe(2);expect(Ext.Array.contains(N,K.getNodeById(2))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(6))).toBe(true)})})});describe("when autoSync is true",function(){beforeEach(function(){K.autoSync=true});describe("removing a single record",function(){beforeEach(function(){K.getNodeById(1).remove()});it("should sync the store",function(){expect(O.callCount).toBe(1)})})})});describe("sorting",function(){var P=function(R,Q){var T=R.data.name,S=Q.data.name;return T<S?1:R===Q?0:-1};describe("when sorting the TreeStore",function(){var R,Q;beforeEach(function(){R=E(K,"beforesort");Q=E(K,"sort");K.sort(P)});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0);expect(R.callCount).toBe(1);expect(Q.callCount).toBe(1)})});describe("when sorting recursively",function(){beforeEach(function(){K.getRootNode().sort(P,true)});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)})});describe("when sorting non-recursively",function(){beforeEach(function(){K.getRootNode().sort(P)});it("should not add any records to getUpdatedRecords",function(){expect(K.getUpdatedRecords().length).toBe(0)})});describe("when the index field is persistent and autoSync is true",function(){beforeEach(function(){D.getField("index").persist=true;K.autoSync=true});afterEach(function(){D.getField("index").persist=false});describe("when sorting recursively",function(){beforeEach(function(){K.getRootNode().sort(P,true)});it("should add all nodes at all levels that had an index change to getUpdatedRecords",function(){N=K.getUpdatedRecords();expect(N.length).toBe(4);expect(Ext.Array.contains(N,K.getNodeById(1))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(3))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(4))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(6))).toBe(true)});it("should sync the store",function(){expect(O.callCount).toBe(1)})});describe("when sorting non-recursively",function(){beforeEach(function(){K.getRootNode().sort(P)});it("should add all nodes at depth 1 that had an index change to getUpdatedRecords",function(){N=K.getUpdatedRecords();expect(N.length).toBe(2);expect(Ext.Array.contains(N,K.getNodeById(1))).toBe(true);expect(Ext.Array.contains(N,K.getNodeById(6))).toBe(true)});it("should sync the store",function(){expect(O.callCount).toBe(1)})})})})});describe("Loading TreeStore using root config",function(){it('should load the root nodes children using Proxy\'s "root" config',function(){spyOn(Ext.log,"error");var M=new Ext.data.TreeStore({root:{expanded:true,CHILDREN:[{text:"detention",leaf:true},{text:"homework",expanded:true,CHILDREN:[{text:"book report",leaf:true},{text:"alegrbra",leaf:true}]},{text:"buy lottery tickets",leaf:true}]},proxy:{type:"memory",reader:{type:"json",rootProperty:"CHILDREN"}}});var N=M.getRootNode().childNodes;expect(N.length).toBe(3);expect(N[0].childNodes.length).toBe(0);expect(N[1].childNodes.length).toBe(2);expect(N[2].childNodes.length).toBe(0)})});describe("default node id",function(){it("Should use generate an ID if the idProperty is null in the incoming data",function(){K=new Ext.data.TreeStore({model:G,defaultRootId:null,root:{}});expect(K.getRootNode().getId()).not.toBeNull()});it('Should use "root" as the defaultRootId, and parse that according to the idProperty field type',function(){expect(function(){K=new Ext.data.TreeStore({model:G,root:{}})}).toRaiseExtError()});it("Should use the configured defaultRootId, and parse that according to the idProperty field type",function(){K=new Ext.data.TreeStore({model:G,defaultRootId:-1,root:{}});expect(K.getRootNode().getId()).toBe(-1)})});describe("moving root node between trees",function(){it("should move root and all descendants from source tree into destination tree",function(){K=new Ext.data.TreeStore({root:{expanded:true,children:[{text:"Test",leaf:true,id:"testId"}]},listeners:{rootchange:function(X,W){R=[X,W]},refresh:function(){O++},add:function(){U++},remove:function(){S++}}});var Q=K.getRootNode(),M=Q.firstChild,T=new Ext.data.TreeStore({listeners:{rootchange:function(X,W){P=[X,W]},refresh:function(){V++},add:function(){U++},remove:function(){S++}},root:{}}),O=0,V=0,U=0,S=0,N=T.getRootNode(),R=[],P=[];expect(Q.rootOf===K.tree).toBe(true);expect(K.getNodeById("testId")===M).toBe(true);T.setRootNode(Q);expect(R[0]).toEqual(null);expect(R[1]).toEqual(Q);expect(P[0]).toEqual(Q);expect(P[1]).toEqual(N);expect(O).toBe(1);expect(V).toBe(1);expect(U).toBe(0);expect(S).toBe(0);expect(Q.rootOf===T.tree).toBe(true);expect(T.getRootNode()===Q).toBe(true);expect(T.getNodeById("testId")===M).toBe(true);expect(K.getNodeById("testId")).toBeFalsy();expect(K.getRootNode()).toBeFalsy();T.destroy()})});describe("Node events bubbled to the root node",function(){var P,M,N,O,R,Q;beforeEach(function(){K=new Ext.data.TreeStore({root:{text:"Root 1",expanded:true,children:[{text:"Child 1",leaf:true},{text:"Child 2",leaf:true},{text:"Child 3",leaf:true},{text:"Child 4",leaf:true}]}});M=K.getRootNode()});it("should fire insert event",function(){P=E(M,"insert").andCallThrough();R=M.firstChild;N=M.insertBefore({text:"New First"},R);Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q[0]).toBe(M);expect(Q[1]).toBe(N);expect(Q[2]).toBe(R)});it("should fire append event",function(){P=E(M,"append").andCallThrough();N=M.appendChild({text:"New Last"});Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q[0]).toBe(M);expect(Q[1]).toBe(N);expect(Q[2]).toBe(4)});it("should fire remove event",function(){var S;P=E(M,"remove").andCallThrough();O=M.removeChild(M.childNodes[1]);Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q[0]).toBe(M);expect(Q[1]).toBe(O);expect(Q[2]).toBe(false);S=Q[3];expect(S.parentNode).toBe(M);expect(S.previousSibling).toBe(M.childNodes[0]);expect(S.nextSibling).toBe(M.childNodes[1])});it("should fire update event",function(){P=E(K,"update").andCallThrough();M.firstChild.set("text","New Text");Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q[0]).toBe(K);expect(Q[1]).toBe(M.firstChild);expect(Q[2]).toBe("edit");expect(Q[3]).toEqual(["text"])});it('should fire "load" event with valid 5-argument signature',function(){P=E(K,"load").andCallThrough();K.load();Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q.length).toBe(5);expect(Q[0]).toBe(K);expect(Ext.isArray(Q[1])).toBe(true);expect(typeof Q[2]).toBe("boolean");expect(Q[3].isReadOperation).toBe(true);expect(Q[4]).toBe(M)});it('should fire "beforeload" event with valid 2-argument signature',function(){P=E(K,"beforeload").andCallThrough();K.load();Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q.length).toBe(2);expect(Q[0]).toBe(K);expect(Q[1]&&Q[1].isReadOperation).toBe(true)});describe("event ordering",function(){it("should fire events in the correct order",function(){K=new Ext.data.TreeStore({root:{text:"Root 1",expanded:true,children:[]}});M=K.getRoot();var S=[],T={id:"A",leaf:false,expanded:true,children:[{id:"A.A",leaf:true},{id:"A.B",leaf:true},{id:"A.C",leaf:false,expanded:true,children:[{id:"A.C.A",leaf:true},{id:"A.C.B",leaf:true}]},{id:"A.D",leaf:true}]};M.on("append",function(W,U,V){S.push(U.getPath()+" | "+W.getPath())});M.appendChild(T);S=S.join(", ");expect(S).toBe("/root/A | /root, /root/A/A.A | /root/A, /root/A/A.B | /root/A, /root/A/A.C | /root/A, /root/A/A.C/A.C.A | /root/A/A.C, /root/A/A.C/A.C.B | /root/A/A.C, /root/A/A.D | /root/A");K.destroy()})})});describe("Node events bubbled to the TreeStore",function(){var P,M,N,O,R,Q;beforeEach(function(){K=new Ext.data.TreeStore({root:{text:"Root 1",expanded:true,children:[{text:"Child 1",leaf:true},{text:"Child 2",leaf:true},{text:"Child 3",leaf:true},{text:"Child 4",leaf:true}]}});M=K.getRootNode()});it("should fire insert event",function(){P=E(K,"nodeinsert").andCallThrough();R=M.firstChild;N=M.insertBefore({text:"New First"},R);Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q[0]).toBe(M);expect(Q[1]).toBe(N);expect(Q[2]).toBe(R)});it("should fire append event",function(){P=E(K,"nodeappend").andCallThrough();N=M.appendChild({text:"New Last"});Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q[0]).toBe(M);expect(Q[1]).toBe(N);expect(Q[2]).toBe(4)});it("should fire remove event",function(){P=E(K,"noderemove").andCallThrough();O=M.removeChild(M.firstChild);Q=P.calls[0].args;expect(P.calls.length).toBe(1);expect(Q[0]).toBe(M);expect(Q[1]).toBe(O);expect(Q[2]).toBe(false)});describe("event ordering",function(){it("should fire events in the correct order",function(){K=new Ext.data.TreeStore({root:{text:"Root 1",expanded:true,children:[]}});M=K.getRoot();var S=[],T={id:"A",leaf:false,expanded:true,children:[{id:"A.A",leaf:true},{id:"A.B",leaf:true},{id:"A.C",leaf:false,expanded:true,children:[{id:"A.C.A",leaf:true},{id:"A.C.B",leaf:true}]},{id:"A.D",leaf:true}]};K.on("nodeappend",function(W,U,V){S.push(U.getPath()+" | "+W.getPath())});M.appendChild(T);S=S.join(", ");expect(S).toBe("/root/A | /root, /root/A/A.A | /root/A, /root/A/A.B | /root/A, /root/A/A.C | /root/A, /root/A/A.C/A.C.A | /root/A/A.C, /root/A/A.C/A.C.B | /root/A/A.C, /root/A/A.D | /root/A");K.destroy()})})});describe("events from descendants of collapsed nodes",function(){beforeEach(function(){K=new Ext.data.TreeStore({model:D,autoLoad:true,root:{expanded:false,id:0,name:"Root Node",autoLoad:true,children:A.children}})});it("should fire update events from descendants of collapsed nodes",function(){var M=E(K,"update");waitsFor(function(){return !!K.getNodeById(5)});runs(function(){K.getNodeById(5).set("name","modified");expect(M).toHaveBeenCalled()})})});describe("beforeload",function(){it("should not clear node descendants if a function bound to beforeload returns false",function(){var M=false;K=new Ext.data.TreeStore({model:D,autoLoad:false,root:{expanded:false,id:0,name:"Root Node",children:[{id:1}]}});K.on("beforeload",function(N){expect(N.getRootNode().firstChild).not.toBeNull();M=true;return false});K.load();waitsFor(function(){return M})})});describe("appending to leaf nodes",function(){beforeEach(function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,id:0,name:"Root Node"}});K.fillNode(K.getRootNode(),K.getProxy().getReader().readRecords(A.children).records)});it("should convert leaf nodes to branch nodes.",function(){var M=K.getNodeById(5);expect(M.isLeaf()).toBe(true);M.appendChild({name:"eee-child"});expect(M.isLeaf()).toBe(false)})});describe("filtering",function(){function N(O){if(Ext.isNumber(O)){O=L(O)}return K.isVisible(O)}function M(O){K.filter({filterFn:function(P){return Ext.Array.indexOf(O,P.id)>-1}})}describe("basic filtering",function(){it("should be able to provide a filter in the constructor",function(){C([{id:1},{id:2}],{filters:[{fn:function(O){return O.get("id")===1}}]});expect(N(1)).toBe(true);expect(N(2)).toBe(false)});it("should not show children of non matching nodes",function(){C([{id:1,children:[2,3]},{id:4,children:[5,6]}]);M([2,3,4,5,6]);expect(N(1)).toBe(false);expect(N(2)).toBe(false);expect(N(3)).toBe(false);expect(N(4)).toBe(true);expect(N(5)).toBe(true);expect(N(6)).toBe(true)});it("should hide non-matching leaves",function(){C([{id:1,children:[2,3]},{id:4,children:[5,6]}]);M([1,4]);expect(N(1)).toBe(true);expect(N(2)).toBe(false);expect(N(3)).toBe(false);expect(N(4)).toBe(true);expect(N(5)).toBe(false);expect(N(6)).toBe(false)});it("should hide non-matching nodes at all levels",function(){C([{id:1,children:[{id:2,children:[{id:3,children:[{id:4,children:[{id:5}]}]}]}]}]);M([1,2]);expect(N(1)).toBe(true);expect(N(2)).toBe(true);expect(N(3)).toBe(false);expect(N(4)).toBe(false);expect(N(5)).toBe(false)});it("should run the filters on all nodes (even if the parent is not visible) bottom up",function(){C([{id:"n",children:[{id:"h",children:[{id:"c",children:[{id:"a"},{id:"b"}]},{id:"f",children:[{id:"d"},{id:"e"}]},{id:"g"}]},{id:"m",children:[{id:"i"},{id:"l",children:[{id:"j"},{id:"k"}]}]}]},{id:"v",children:[{id:"r",children:[{id:"p",children:[{id:"o"}]},{id:"q"}]},{id:"u",children:[{id:"s"},{id:"t"}]}]},{id:"z",children:[{id:"x",children:[{id:"w"}]},{id:"y"}]}]);var O=[];K.getFilters().add({filterFn:function(P){if(!P.isRoot()){O.push(P.id)}return P.id!=="h"}});expect(O.join("")).toBe("abcdefghijklmnopqrstuvwxyz")})});describe("clearing filters",function(){it("should reset node visibility after clearing filters",function(){C([{id:1,children:[{id:2,children:[3,4]},{id:5},{id:6,children:[{id:7,children:[8,9]}]}]}]);M([1,6]);expect(N(1)).toBe(true);expect(N(2)).toBe(false);expect(N(3)).toBe(false);expect(N(4)).toBe(false);expect(N(5)).toBe(false);expect(N(6)).toBe(true);expect(N(7)).toBe(false);expect(N(8)).toBe(false);expect(N(9)).toBe(false);K.getFilters().removeAll();expect(N(1)).toBe(true);expect(N(2)).toBe(true);expect(N(3)).toBe(true);expect(N(4)).toBe(true);expect(N(5)).toBe(true);expect(N(6)).toBe(true);expect(N(7)).toBe(true);expect(N(8)).toBe(true);expect(N(9)).toBe(true)});it("should not fire refresh or datachanged when passing suppressEvent",function(){C([{id:1,children:[{id:2,children:[3,4]},{id:5},{id:6,children:[{id:7,children:[8,9]}]}]}]);M([1,6]);var O=jasmine.createSpy();K.on("refresh",O);K.on("datachanged",O);K.clearFilter(true);expect(O).not.toHaveBeenCalled()})});describe("root visibility",function(){describe("with rootVisible: true",function(){it("should show the root if any root childNodes are visible",function(){C([{id:1},{id:2},{id:3}],{rootVisible:true});M([2]);expect(N(K.getRoot())).toBe(true)});it("should not show the root if no children match",function(){C([{id:1},{id:2}],{rootVisible:true});M([3]);expect(N(K.getRoot())).toBe(false)})})});describe("dynamic manipulation",function(){describe("adding",function(){it("should not show nodes that are added to a filtered out node",function(){C([{id:1,leaf:false}]);M([2]);L(1).appendChild({id:2});expect(N(2)).toBe(false)});it("should not show a node that does match the filter",function(){C([{id:1,leaf:false}]);M([1]);L(1).appendChild({id:2});expect(N(2)).toBe(false)});it("should show if the added node matches the filter",function(){C([{id:1,leaf:false}]);M([1,2]);L(1).appendChild({id:2});expect(N(2)).toBe(true)});it("should filter out deep nodes that do not match",function(){C([{id:1,leaf:false}]);M([1,2,3,4]);var O=new Ext.data.TreeModel({id:2,leaf:false,expanded:true,children:[]});O.appendChild({id:3,leaf:false,expanded:true,children:[]}).appendChild({id:4,leaf:false,expanded:true,children:[]}).appendChild({id:5,leaf:true});L(1).appendChild(O);expect(N(2)).toBe(true);expect(N(3)).toBe(true);expect(N(4)).toBe(true);expect(N(5)).toBe(false)})});describe("updating",function(){it("should exclude a node when modifying it to not match the filter",function(){C([{id:1,text:"Foo"}]);K.getFilters().add({property:"text",value:"Foo"});L(1).set("text","Bar");expect(N(1)).toBe(false)});it("should exclude children when the parent is filtered out",function(){C([{id:1,text:"Foo",children:[{id:2,text:"Leaf"}]}]);K.getFilters().add({filterFn:function(O){if(O.isLeaf()){return true}else{return O.data.text==="Foo"}}});L(1).set("text","Bar");expect(N(1)).toBe(false);expect(N(2)).toBe(false)});it("should include a node when modifying it to match the filter",function(){C([{id:1,text:"Foo"}]);K.getFilters().add({property:"text",value:"Bar"});L(1).set("text","Bar");expect(N(1)).toBe(true)});it("should include children when the parent is filtered in",function(){C([{id:1,text:"Bar",children:[{id:2,text:"Leaf"}]}]);K.getFilters().add({filterFn:function(O){if(O.isLeaf()){return true}else{return O.data.text==="Foo"}}});L(1).set("text","Foo");expect(N(1)).toBe(true);expect(N(2)).toBe(true)})})})});describe("heterogeneous TreeStores",function(){var N,M;beforeEach(function(){M=Ext.data.Model.schema;M.setNamespace("spec");Ext.define("spec.Territory",{extend:"Ext.data.TreeModel",idProperty:"territoryName",fields:[{name:"territoryName",mapping:"territoryName",convert:undefined}]});Ext.define("spec.Country",{extend:"Ext.data.TreeModel",idProperty:"countryName",fields:[{name:"countryName",mapping:"countryName",convert:undefined}]});Ext.define("spec.City",{extend:"Ext.data.TreeModel",idProperty:"cityName",fields:[{name:"cityName",mapping:"cityName",convert:undefined}]});N={children:[{mtype:"Territory",territoryName:"North America",children:[{mtype:"Country",countryName:"USA",children:[{mtype:"spec.City",cityName:"Redwood City",leaf:true},{mtype:"City",cityName:"Frederick, MD",leaf:true}]},{mtype:"Country",countryName:"Canada",children:[{mtype:"spec.City",cityName:"Vancouver",leaf:true},{mtype:"City",cityName:"Toronto",leaf:true}]}]},{mtype:"Territory",territoryName:"Europe, ME, Africa",expanded:true,children:[{mtype:"Country",countryName:"England",children:[{mtype:"spec.City",cityName:"Nottingham",leaf:true},{mtype:"City",cityName:"London",leaf:true}]},{mtype:"Country",countryName:"Netherlands",children:[{mtype:"spec.City",cityName:"Amsterdam",leaf:true},{mtype:"City",cityName:"Haaksbergen",leaf:true}]}]}]}});afterEach(function(){Ext.undefine("spec.Territory");Ext.undefine("spec.Country");Ext.undefine("spec.City");M.clear(true)});it("should use the parentNode's childType to resolve child node models if no typeProperty is used on Reader",function(){Ext.define("spec.World",{extend:"Ext.data.TreeModel",childType:"Territory"});spec.Territory.prototype.childType="Country";spec.Country.prototype.childType="City";K=new Ext.data.TreeStore({root:N,model:"spec.World",proxy:{type:"memory"}});var V=K.getRootNode(),T=V.childNodes[0],Z=V.childNodes[1],U,W,Q=T.childNodes[0],O=Q.childNodes[0],R=Q.childNodes[1],S=T.childNodes[1],P=S.childNodes[0],X=S.childNodes[1],Y=Q.appendChild({cityName:"Sacramento",leaf:true});expect(T instanceof spec.Territory).toBe(true);expect(Z instanceof spec.Territory).toBe(true);expect(T.get("territoryName")).toBe("North America");expect(Z.get("territoryName")).toBe("Europe, ME, Africa");expect(Q instanceof spec.Country).toBe(true);expect(S instanceof spec.Country).toBe(true);expect(Q.get("countryName")).toBe("USA");expect(S.get("countryName")).toBe("Canada");expect(O instanceof spec.City).toBe(true);expect(R instanceof spec.City).toBe(true);expect(Y instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(X instanceof spec.City).toBe(true);expect(O.get("cityName")).toBe("Redwood City");expect(R.get("cityName")).toBe("Frederick, MD");expect(Y.get("cityName")).toBe("Sacramento");expect(P.get("cityName")).toBe("Vancouver");expect(X.get("cityName")).toBe("Toronto");U=Z.appendChild({mtype:"Country",countryName:"Spain"});expect(U instanceof spec.Country).toBe(true);expect(U.get("countryName")).toBe("Spain");W=U.appendChild({mtype:"City",cityName:"Madrid"});expect(W instanceof spec.City).toBe(true);expect(W.get("cityName")).toBe("Madrid")});it("should use the store's model namespace to resolve child node models if short form typeProperty is used",function(){K=new Ext.data.TreeStore({model:"spec.Territory",root:N,proxy:{type:"memory",reader:{typeProperty:"mtype"}}});var V=K.getRootNode(),T=V.childNodes[0],Y=V.childNodes[1],U,W,Q=T.childNodes[0],O=Q.childNodes[0],R=Q.childNodes[1],S=T.childNodes[1],P=S.childNodes[0],X=S.childNodes[1];expect(T instanceof spec.Territory).toBe(true);expect(Y instanceof spec.Territory).toBe(true);expect(T.get("territoryName")).toBe("North America");expect(Y.get("territoryName")).toBe("Europe, ME, Africa");expect(Q instanceof spec.Country).toBe(true);expect(S instanceof spec.Country).toBe(true);expect(Q.get("countryName")).toBe("USA");expect(S.get("countryName")).toBe("Canada");expect(O instanceof spec.City).toBe(true);expect(R instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(X instanceof spec.City).toBe(true);expect(O.get("cityName")).toBe("Redwood City");expect(R.get("cityName")).toBe("Frederick, MD");expect(P.get("cityName")).toBe("Vancouver");expect(X.get("cityName")).toBe("Toronto");U=Y.appendChild({mtype:"Country",countryName:"Spain"});expect(U instanceof spec.Country).toBe(true);expect(U.get("countryName")).toBe("Spain");W=U.appendChild({mtype:"City",cityName:"Madrid"});expect(W instanceof spec.City).toBe(true);expect(W.get("cityName")).toBe("Madrid")});it("should use the typeProperty's namespace property to resolve model class names",function(){var T=Ext.clone(N);T.children[0].children[0].children[0].mtype="City";T.children[0].children[1].children[0].mtype="City";T.children[1].children[0].children[0].mtype="City";T.children[1].children[1].children[0].mtype="City";K=new Ext.data.TreeStore({root:T,proxy:{type:"memory",reader:{typeProperty:{name:"mtype",namespace:"spec"}}}});var W=K.getRootNode(),U=W.childNodes[0],Z=W.childNodes[1],V,X,Q=U.childNodes[0],O=Q.childNodes[0],R=Q.childNodes[1],S=U.childNodes[1],P=S.childNodes[0],Y=S.childNodes[1];expect(U instanceof spec.Territory).toBe(true);expect(Z instanceof spec.Territory).toBe(true);expect(U.get("territoryName")).toBe("North America");expect(Z.get("territoryName")).toBe("Europe, ME, Africa");expect(Q instanceof spec.Country).toBe(true);expect(S instanceof spec.Country).toBe(true);expect(Q.get("countryName")).toBe("USA");expect(S.get("countryName")).toBe("Canada");expect(O instanceof spec.City).toBe(true);expect(R instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(Y instanceof spec.City).toBe(true);expect(O.get("cityName")).toBe("Redwood City");expect(R.get("cityName")).toBe("Frederick, MD");expect(P.get("cityName")).toBe("Vancouver");expect(Y.get("cityName")).toBe("Toronto");V=Z.appendChild({mtype:"Country",countryName:"Spain"});expect(V instanceof spec.Country).toBe(true);expect(V.get("countryName")).toBe("Spain");X=V.appendChild({mtype:"City",cityName:"Madrid"});expect(X instanceof spec.City).toBe(true);expect(X.get("cityName")).toBe("Madrid")});it("should use the typeProperty's map property to resolve model class names",function(){K=new Ext.data.TreeStore({root:N,proxy:{type:"memory",reader:{typeProperty:{name:"mtype",map:{Territory:"Territory",Country:"Country",City:"City"}}}}});var V=K.getRootNode(),T=V.childNodes[0],Y=V.childNodes[1],U,W,Q=T.childNodes[0],O=Q.childNodes[0],R=Q.childNodes[1],S=T.childNodes[1],P=S.childNodes[0],X=S.childNodes[1];expect(T instanceof spec.Territory).toBe(true);expect(Y instanceof spec.Territory).toBe(true);expect(T.get("territoryName")).toBe("North America");expect(Y.get("territoryName")).toBe("Europe, ME, Africa");expect(Q instanceof spec.Country).toBe(true);expect(S instanceof spec.Country).toBe(true);expect(Q.get("countryName")).toBe("USA");expect(S.get("countryName")).toBe("Canada");expect(O instanceof spec.City).toBe(true);expect(R instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(X instanceof spec.City).toBe(true);expect(O.get("cityName")).toBe("Redwood City");expect(R.get("cityName")).toBe("Frederick, MD");expect(P.get("cityName")).toBe("Vancouver");expect(X.get("cityName")).toBe("Toronto");U=Y.appendChild({mtype:"Country",countryName:"Spain"});expect(U instanceof spec.Country).toBe(true);expect(U.get("countryName")).toBe("Spain");W=U.appendChild({mtype:"City",cityName:"Madrid"});expect(W instanceof spec.City).toBe(true);expect(W.get("cityName")).toBe("Madrid")});it("should CALL the typeProperty to resolve model class names if it is a function",function(){var U;K=new Ext.data.TreeStore({root:N,proxy:{type:"memory",reader:{typeProperty:function(a){U=this;return Ext.String.startsWith(a.mtype,"spec.")?a.mtype:"spec."+a.mtype}}}});var W=K.getRootNode(),T=W.childNodes[0],Z=W.childNodes[1],V,X,Q=T.childNodes[0],O=Q.childNodes[0],R=Q.childNodes[1],S=T.childNodes[1],P=S.childNodes[0],Y=S.childNodes[1];expect(U===K.getProxy().getReader());expect(T instanceof spec.Territory).toBe(true);expect(Z instanceof spec.Territory).toBe(true);expect(T.get("territoryName")).toBe("North America");expect(Z.get("territoryName")).toBe("Europe, ME, Africa");expect(Q instanceof spec.Country).toBe(true);expect(S instanceof spec.Country).toBe(true);expect(Q.get("countryName")).toBe("USA");expect(S.get("countryName")).toBe("Canada");expect(O instanceof spec.City).toBe(true);expect(R instanceof spec.City).toBe(true);expect(P instanceof spec.City).toBe(true);expect(Y instanceof spec.City).toBe(true);expect(O.get("cityName")).toBe("Redwood City");expect(R.get("cityName")).toBe("Frederick, MD");expect(P.get("cityName")).toBe("Vancouver");expect(Y.get("cityName")).toBe("Toronto");V=Z.appendChild({mtype:"Country",countryName:"Spain"});expect(V instanceof spec.Country).toBe(true);expect(V.get("countryName")).toBe("Spain");X=V.appendChild({mtype:"City",cityName:"Madrid"});expect(X instanceof spec.City).toBe(true);expect(X.get("cityName")).toBe("Madrid")})});describe("Filtering, and isLastVisible status",function(){var O,N,M;beforeEach(function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,id:0,name:"Root Node",children:[{name:"Foo"},{name:"Bar"},{name:"Bletch"}]}});O=K.getAt(0);N=K.getAt(1);M=K.getAt(2)});it("should correctly ascertain whether a node is the last visible node.",function(){expect(K.getCount()).toEqual(3);expect(O.isLastVisible()).toBe(false);expect(N.isLastVisible()).toBe(false);expect(M.isLastVisible()).toBe(true);K.filter({property:"name",value:"Foo"});expect(K.getCount()).toEqual(1);expect(O.isLastVisible()).toBe(true)})});describe("TreeNode drop with locally created (phantom) nodes",function(){var O,N,M;beforeEach(function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,id:0,name:"Root Node",children:[{name:"Foo",expanded:true,children:[]},{name:"Bar"},{name:"Bletch"}]}});O=K.getAt(0)});it("should remove all descendants. All nodes are phantom, so there should be an empty removed list",function(){var P;expect(K.getCount()).toBe(3);N=O.appendChild({name:"Zarg",expanded:true});M=N.appendChild({name:"Blivit",leaf:true});expect(K.getCount()).toBe(5);O.drop();P=K.getRemovedRecords();expect(P.length).toBe(0);expect(K.getCount()).toBe(2)})});describe("TreeNode drop",function(){var O,N,M;beforeEach(function(){K=new Ext.data.TreeStore({model:D,root:{expanded:true,id:0,name:"Root Node"},proxy:{type:"memory",data:[{name:"Foo",expanded:true,children:[]},{name:"Bar"},{name:"Bletch"}]}});O=K.getAt(0)});it("should remove all descendants, and add non-phantom descendants to removed list",function(){var P;expect(K.getCount()).toBe(3);N=O.appendChild({name:"Zarg",expanded:true});M=N.appendChild({name:"Blivit",leaf:true});expect(K.getCount()).toBe(5);O.drop();P=K.getRemovedRecords();expect(P.length).toBe(1);expect(P[0]===O).toBe(true);expect(K.getCount()).toBe(2)});it("should remove deleted records from removed list if they get added back",function(){var P=K.findNode("name","Bletch"),Q=P.parentNode;P.drop();expect(Ext.Array.contains(K.getRemovedRecords(),P)).toBe(true);Q.appendChild(P);expect(Ext.Array.contains(K.getRemovedRecords(),P)).toBe(false)})});describe("parentIdProperty",function(){var N;beforeEach(function(){K=new Ext.data.TreeStore({model:D,root:{},parentIdProperty:"foo"});N=K.getRoot()});afterEach(function(){N=null});function M(Q,O){var P={id:Q,expanded:true};if(arguments.length>1){P.foo=O}return P}it("should append items without a parentId to the loaded item",function(){N.expand();J([M(1),M(2),M(3)]);var O=N.childNodes;expect(L(1)).toBe(O[0]);expect(L(2)).toBe(O[1]);expect(L(3)).toBe(O[2])});it("should allow a parentId of 0",function(){N.expand();J([M(0),M(1,0)]);expect(L(1)).toBe(L(0).childNodes[0])});it("should throw an exception if a matching parent is not found",function(){N.expand();expect(function(){J([M(1),M(2,100)])}).toThrow()});it("should add children to their parent nodes, retaining any implied order",function(){N.expand();J([M("c21","c2"),M("a"),M("c2","c"),M("a1","a"),M("c"),M("b"),M("b1","b"),M("a2","a"),M("c1","c"),M("c22","c2"),M("a32","a3"),M("a31","a3"),M("a21","a2"),M("b12","b1"),M("b11","b1"),M("a3","a"),M("a211","a21")]);F(N,["a","c","b"]);F(L("a"),["a1","a2","a3"]);F(L("a2"),["a21"]);F(L("a21"),["a211"]);F(L("b"),["b1"]);F(L("b1"),["b12","b11"]);F(L("c"),["c2","c1"]);F(L("c2"),["c21","c22"])});describe("sorting",function(){it("should sort nodes via sorter",function(){K.getSorters().add("id");N.expand();J([M("c"),M("a"),M("b"),M("c3","c"),M("b3","b"),M("a3","a"),M("c2","c"),M("b2","b"),M("a2","a"),M("c1","c"),M("b1","b"),M("a1","a")]);F(N,["a","b","c"]);F(L("a"),["a1","a2","a3"]);F(L("b"),["b1","b2","b3"]);F(L("c"),["c1","c2","c3"])});it("should do an index sort if required",function(){N.expand();J([{id:"a",index:2},{id:"b",index:1},{id:"c",index:0},{id:"a1",foo:"a",index:2},{id:"a2",foo:"a",index:1},{id:"a3",foo:"a",index:0}]);F(N,["c","b","a"]);F(L("a"),["a3","a2","a1"])})});describe("filtering",function(){it("should apply filters",function(){var O=["a","c","a2","c1","c11","c13"];K.getFilters().add({filterFn:function(P){return Ext.Array.indexOf(O,P.id)>-1}});N.expand();J([M("a"),M("b"),M("c"),M("a1","a"),M("a2","a"),M("a3","a"),M("b1","b"),M("b2","b"),M("b3","b"),M("c1","c"),M("c11","c1"),M("c12","c1"),M("c13","c1"),M("c2","c"),M("c3","c")]);expect(K.isVisible(L("a"))).toBe(true);expect(K.isVisible(L("a1"))).toBe(false);expect(K.isVisible(L("a2"))).toBe(true);expect(K.isVisible(L("a3"))).toBe(false);expect(K.isVisible(L("b"))).toBe(false);expect(K.isVisible(L("b1"))).toBe(false);expect(K.isVisible(L("b2"))).toBe(false);expect(K.isVisible(L("b3"))).toBe(false);expect(K.isVisible(L("c"))).toBe(true);expect(K.isVisible(L("c1"))).toBe(true);expect(K.isVisible(L("c11"))).toBe(true);expect(K.isVisible(L("c12"))).toBe(false);expect(K.isVisible(L("c13"))).toBe(true);expect(K.isVisible(L("c2"))).toBe(false);expect(K.isVisible(L("c3"))).toBe(false)})})});describe("loading inline data with no configured root node",function(){it("should run without throwing an error",function(){expect(function(){new Ext.data.TreeStore({fields:["name","text","id","parentId"],parentIdProperty:"parentId",data:[{id:1,name:"A",value:10,parentId:null},{id:2,name:"B",value:12,parentId:1,leaf:true}]}).load()}).not.toThrow()})});describe("setting the root",function(){describe("via configuration",function(){describe("with a model config",function(){beforeEach(function(){K=new Ext.data.TreeStore({model:D,root:{}})});it("should set the root property",function(){expect(K.getRoot().get("root")).toBe(true)});it("should have the treeStore available",function(){var M=K.getRoot();expect(M.getTreeStore()).toBe(K)})});describe("with a model instance",function(){var M;beforeEach(function(){M=new D();K=new Ext.data.TreeStore({model:D,root:M})});afterEach(function(){M=null});it("should set the root property",function(){expect(M.get("root")).toBe(true)});it("should have the treeStore available",function(){expect(M.getTreeStore()).toBe(K)})})});describe("after creation",function(){describe("with a model config",function(){beforeEach(function(){K=new Ext.data.TreeStore({model:D,root:{}})});it("should set the root property",function(){var M=K.getRoot();K.setRoot({id:"foo"});expect(M.get("root")).toBe(false);expect(K.getRoot().get("root")).toBe(true);expect(K.getRoot().id).toBe("foo")});it("should have the treeStore available",function(){var M=K.getRoot();K.setRoot({id:"foo"});expect(M.getTreeStore()).toBeNull();expect(K.getRoot().getTreeStore()).toBe(K)})});describe("with a model instance",function(){var M,N;beforeEach(function(){M=new D();K=new Ext.data.TreeStore({model:D,root:{}});N=K.getRoot()});afterEach(function(){N=M=null});it("should set the root property",function(){K.setRoot(M);expect(N.get("root")).toBe(false);expect(K.getRoot().get("root")).toBe(true);expect(K.getRoot()).toBe(M)});it("should have the treeStore available",function(){K.setRoot(M);expect(N.getTreeStore()).toBeNull();expect(K.getRoot().getTreeStore()).toBe(K)})})})});describe("Changing root node",function(){it("should clear the root property",function(){K=new Ext.data.TreeStore({root:{text:"Root",expanded:true,children:[{text:"A",leaf:true},{text:"B",leaf:true}]}});var M=K.getRootNode();expect(M.get("root")).toBe(true);K.setRoot({text:"NewRoot",expanded:true,children:[{text:"New A",leaf:true},{text:"New B",leaf:true}]});expect(M.get("root")).toBe(false)})});describe("commitChanges",function(){beforeEach(function(){C([{text:"Foo",leaf:true}])});it("should clear the removed collection",function(){var M=K.getRoot();M.removeChild(M.getChildAt(0));K.commitChanges();expect(K.removedNodes.length).toBe(0)})});describe("proxy",function(){it("should use the model's memory proxy when no proxy is defined on the store",function(){K=new Ext.data.TreeStore({root:{text:"Foo"}});expect(K.getProxy().isMemoryProxy).toBe(true);expect(K.getProxy()).toBe(K.model.getProxy())});it("should set the store's proxy on the model",function(){K=new Ext.data.TreeStore({root:{text:"Foo"},proxy:{type:"ajax",url:"foo"}});expect(K.getProxy().isAjaxProxy).toBe(true);expect(K.getProxy().url).toBe("foo");expect(K.getProxy()).toBe(K.model.getProxy())})});describe("rejected changes",function(){function M(N){describe("rootVisible = "+N,function(){it("should not include the root node",function(){C([{children:[2,3]}],{rootVisible:N});expect(Ext.Array.contains(K.getRejectRecords(),K.getRoot())).toBe(false)})})}M(true);M(false)})})