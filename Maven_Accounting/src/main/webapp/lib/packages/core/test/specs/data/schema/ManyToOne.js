describe("Ext.data.schema.ManyToOne",function(){var E,D,I,H,B,G=false,C=false;function F(J){D=Ext.define("spec.Post",{extend:"Ext.data.Model",fields:["id","content",{name:"threadId",reference:Ext.apply({type:"Thread"},J)}],constructor:function(){C=true;this.callParent(arguments)}});H=D.associations.thread;B=I.associations.posts}function A(K,J){Ext.Ajax.mockComplete({status:J||200,responseText:Ext.JSON.encode(K)})}beforeEach(function(){G=C=false;MockAjaxManager.addMethods();E=Ext.data.Model.schema;E.setNamespace("spec");I=Ext.define("spec.Thread",{extend:"Ext.data.Model",fields:["id","title"],constructor:function(){G=true;this.callParent(arguments)}})});afterEach(function(){MockAjaxManager.removeMethods();Ext.undefine("spec.Post");Ext.undefine("spec.Thread");E.clear(true);D=B=I=H=E=null;G=C=false});describe("Model.associations",function(){it("should have an association role on each model",function(){F();expect(D.associations.thread).toBeDefined();expect(I.associations.posts).toBeDefined()});it("should have a reference back to the association for each role",function(){F();expect(D.associations.thread.association).toBe(I.associations.posts.association);expect(I.associations.posts.association.isManyToOne).toBe(true)})});describe("association default config",function(){var J;beforeEach(function(){F();J=H.association});it("should have a schema set",function(){expect(J.schema).toBe(E)});it("should have the reference field set",function(){expect(J.field).toBe(D.getField("threadId"))});it("should have the left part be set to the key holder",function(){expect(J.left).toBe(B)});it("should set definedBy to the key holder",function(){expect(J.definedBy).toBe(D)});it("should have the right part be set to the non key holder",function(){expect(J.right).toBe(H)});it("should have the owner as null",function(){expect(J.owner).toBeNull()});it("should set the assoc name to {PluralKeyHolder}By{SingluarOther}",function(){expect(J.name).toBe("ThreadPosts")})});describe("left",function(){beforeEach(function(){F()});it("should set the role to be plural lowercase & the type to be the entity name",function(){expect(B.role).toBe("posts");expect(B.type).toBe("Post")});it("should set the inverse role to the right",function(){expect(B.inverse).toBe(H)});it("should set the entity",function(){expect(B.cls).toBe(D)})});describe("right",function(){beforeEach(function(){F()});it("should set the role to be singular lowercase & the type to be the entity name",function(){expect(H.role).toBe("thread");expect(H.type).toBe("Thread")});it("should set the inverse role to the left",function(){expect(H.inverse).toBe(B)});it("should set the entity",function(){expect(H.cls).toBe(I)})});describe("configuring",function(){it("should set an association name",function(){F({association:"CustomName"});expect(B.association.name).toBe("CustomName")});it("should set the owner based on the child param",function(){F({child:true});expect(B.association.owner).toBe(B);expect(B.owner).toBe(true);expect(H.owner).toBe(false)});it("should set the owner based on the parent param",function(){F({parent:true});expect(B.association.owner).toBe(H);expect(H.owner).toBe(true);expect(B.owner).toBe(false)});it("should be able to set a custom role",function(){F({role:"foo"});H=D.associations.foo;expect(H.association.name).toBe("ThreadFooPosts");expect(H.role).toBe("foo")});describe("inverse",function(){it("should set with a string",function(){F({inverse:"foo"});B=I.associations.foo;expect(B.association.name).toBe("ThreadFoo");expect(B.role).toBe("foo")});it("should set with an object",function(){F({inverse:{role:"foo"}});B=I.associations.foo;expect(B.association.name).toBe("ThreadFoo");expect(B.role).toBe("foo")})})});describe("model decoration",function(){it("should generate a getter on the key holder",function(){F();expect(typeof D.prototype.getThread).toBe("function")});it("should generate a setter on the key holder",function(){F();expect(typeof D.prototype.setThread).toBe("function")});it("should define a getter on the inverse",function(){F();expect(typeof I.prototype.posts).toBe("function")});it("should allow a custom getter name on the key holder",function(){F({inverse:{getterName:"getFoo"}});expect(typeof I.prototype.getFoo).toBe("function")});it("should allow a custom setter name on the key holder",function(){F({setterName:"setFoo"});expect(typeof D.prototype.setFoo).toBe("function")});it("should allow a custom getter name on the inverse",function(){F({getterName:"ghosts"});expect(typeof D.prototype.ghosts).toBe("function")});it("should decorate the model based on the role",function(){var J=Ext.define("spec.OtherPost",{extend:"Ext.data.Model",fields:["id","name",{name:"threadAId",reference:{type:"Thread",role:"ThreadA"}},{name:"threadBId",reference:{type:"Thread",role:"ThreadB"}}]});expect(typeof J.prototype.getThreadA).toBe("function");expect(typeof J.prototype.getThreadB).toBe("function");Ext.undefine("spec.OtherPost")})});describe("subclassing",function(){describe("the left",function(){var J;beforeEach(function(){F();J=Ext.define("spec.SubPost",{extend:"spec.Post"})});afterEach(function(){Ext.undefine("spec.SubPost");J=null});it("should still have the original association",function(){var K=D.associations.thread.inverse;expect(K.role).toBe("posts");expect(K.cls).toBe(D)});it("should inherit the association from the parent and modify the relevant classes",function(){var K=J.associations.thread.inverse;expect(K.role).toBe("subPosts");expect(K.cls).toBe(J)})});describe("the right",function(){var J;beforeEach(function(){F();J=Ext.define("spec.SubThread",{extend:"spec.Thread"})});it("should not have any associations",function(){expect(J.associations).toEqual({})})})});describe("nested loading",function(){it("should infer the key when using remoteFilter: false",function(){F({inverse:{storeConfig:{remoteFilter:false}}});var J=I.load(1);A({id:1,posts:[{id:101},{id:102}]});var K=J.posts();expect(K.getAt(0).get("threadId")).toBe(1);expect(K.getAt(0).dirty).toBe(false);expect(K.getAt(1).get("threadId")).toBe(1);expect(K.getAt(1).dirty).toBe(false);expect(K.getRemoteFilter()).toBe(false)});it("should delete the many from the data collection",function(){F();var J=I.load(1);A({id:1,posts:[{id:101},{id:102}]});expect(J.get("posts")).toBeUndefined();expect(J.posts().getCount()).toBe(2)});it("should delete the one from the data collection",function(){F();var J=D.load(101);A({id:101,thread:{id:1}});expect(J.get("thread")).toBeUndefined();expect(J.getThread().getId()).toBe(1)});it("should not pollute the reader when reading nested data of the same type",function(){function J(){return{records:[{id:1,parentId:null,children:[{id:101,parentId:1},{id:102,parentId:1}]}]}}Ext.define("spec.Node",{extend:"Ext.data.Model",fields:[{name:"parentId",reference:{type:"Node",inverse:"children"}}],proxy:{type:"ajax",reader:{type:"json",rootProperty:"records"}}});var K=new Ext.data.Store({asynchronousLoad:false,model:"Node"});K.load();A(J());expect(K.first().children().getCount()).toBe(2);K.load();A(J());expect(K.first().children().getCount()).toBe(2);K.destroy();Ext.undefine("spec.Node")});describe("key inference",function(){describe("without session",function(){beforeEach(function(){F()});it("should infer the key from the parent",function(){var J=I.load(1);A({id:1,posts:[{id:101},{id:102}]});var K=J.posts();expect(K.getCount()).toBe(2);expect(K.getAt(0).getId()).toBe(101);expect(K.getAt(0).get("threadId")).toBe(1);expect(K.getAt(0).dirty).toBe(false);expect(K.getAt(1).getId()).toBe(102);expect(K.getAt(1).get("threadId")).toBe(1);expect(K.getAt(1).dirty).toBe(false)});it("should infer the key when loading the store, not nested",function(){var J=I.load(1);A({id:1});var K=J.posts();K.load();A([{id:101},{id:102}]);expect(K.getCount()).toBe(2);expect(K.getAt(0).getId()).toBe(101);expect(K.getAt(0).get("threadId")).toBe(1);expect(K.getAt(0).dirty).toBe(false);expect(K.getAt(1).getId()).toBe(102);expect(K.getAt(1).get("threadId")).toBe(1);expect(K.getAt(1).dirty).toBe(false)})});describe("with session",function(){var J;beforeEach(function(){F();J=new Ext.data.Session()});afterEach(function(){J.destroy();J=null});it("should favour an existing reference",function(){var L=J.createRecord("Post",{id:101,threadId:3});var K=I.load(1,null,J);A({id:1,posts:[{id:101},{id:102}]});var M=K.posts();expect(M.getCount()).toBe(1);expect(M.getAt(0).getId()).toBe(102);expect(M.getAt(0).get("threadId")).toBe(1);expect(M.getAt(0).dirty).toBe(false);expect(M.indexOf(L)).toBe(-1)});it("should infer the key from the parent if not specified",function(){var K=I.load(1,null,J);A({id:1,posts:[{id:101},{id:102}]});var L=K.posts();expect(L.getCount()).toBe(2);expect(L.getAt(0).getId()).toBe(101);expect(L.getAt(0).get("threadId")).toBe(1);expect(L.getAt(0).dirty).toBe(false);expect(L.getAt(1).getId()).toBe(102);expect(L.getAt(1).get("threadId")).toBe(1);expect(L.getAt(1).dirty).toBe(false)});it("should infer the key when loading the store, not nested",function(){var K=I.load(1,null,J);A({id:1});var L=K.posts();L.load();A([{id:101},{id:102}]);expect(L.getCount()).toBe(2);expect(L.getAt(0).getId()).toBe(101);expect(L.getAt(0).get("threadId")).toBe(1);expect(L.getAt(0).dirty).toBe(false);expect(L.getAt(1).getId()).toBe(102);expect(L.getAt(1).get("threadId")).toBe(1);expect(L.getAt(1).dirty).toBe(false)});it("should not infer the key from the parent if a key is specified",function(){var K=I.load(1,null,J);A({id:1,posts:[{id:101,threadId:100},{id:102}]});var L=K.posts();expect(L.getCount()).toBe(1);expect(L.getAt(0).getId()).toBe(102);expect(L.getAt(0).get("threadId")).toBe(1);expect(L.getAt(0).dirty).toBe(false);var M=J.peekRecord("Post",101);expect(L.indexOf(M)).toBe(-1)})})})});describe("getters/setters",function(){function J(K){describe(K?"with session":"without session",function(){var N,O,M,L;beforeEach(function(){N=jasmine.createSpy();if(K){O=new Ext.data.Session()}});afterEach(function(){if(K){O.destroy()}O=M=L=null});describe("the one",function(){beforeEach(function(){F()});describe("getter",function(){beforeEach(function(){M=new D({id:4},O)});describe("without an instance",function(){describe("with no foreign key value",function(){it("should return null",function(){expect(M.getThread()).toBeNull()});it("should not make any request",function(){N=spyOn(I.getProxy(),"read");M.getThread();expect(N).not.toHaveBeenCalled()});describe("callbacks",function(){it("should call the callbacks before the function returns",function(){M.getThread(N);expect(N).toHaveBeenCalled();N.reset();M.getThread({success:N});expect(N).toHaveBeenCalled();N.reset();M.getThread({callback:N});expect(N).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){M.getThread(N);var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1]).toBeNull();expect(P.args[2]).toBe(true);expect(P.object).toBe(M)});it("should accept a function with a scope",function(){var P={};M.getThread(N,P);expect(N.mostRecentCall.object).toBe(P)});it("should accept an options object with success and default the scope to the model",function(){M.getThread({success:N});var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1]).toBeNull();expect(P.object).toBe(M)});it("should accept an options object with success and a scope",function(){var Q={},P;M.getThread({scope:Q,success:N});P=N.mostRecentCall;expect(P.object).toBe(Q)});it("should accept an options object with callback and default the scope to the model",function(){M.getThread({callback:N});var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1]).toBeNull();expect(P.args[2]).toBe(true);expect(P.object).toBe(M)});it("should accept an options object with callback and a scope",function(){var Q={},P;M.getThread({scope:Q,callback:N});P=N.mostRecentCall;expect(P.object).toBe(Q)})})});describe("with a foreign key value",function(){beforeEach(function(){M.set("threadId",17)});if(K){it("should create an instance in the session",function(){expect(M.getThread()).toBe(O.getRecord("Thread",17,false))});it("should use an existing record instance",function(){L=O.getRecord("Thread",17,false);expect(M.getThread()).toBe(L)});it("should not load an existing instance",function(){L=O.getRecord("Thread",{id:17},false);M.getThread();expect(L.isLoading()).toBe(false)})}it("should return an instance with the matching id",function(){expect(M.getThread().getId()).toBe(17)});it("should be in a loading state",function(){expect(M.getThread().isLoading()).toBe(true)});it("should trigger a load for the record",function(){N=spyOn(I.getProxy(),"read");M.getThread();expect(N.mostRecentCall.args[0].getId()).toBe(17)});describe("calling while during a load",function(){it("should return the same record",function(){var P=M.getThread();expect(M.getThread()).toBe(P)});it("should not trigger a second load",function(){M.getThread();N=spyOn(I.getProxy(),"read");M.getThread();expect(N).not.toHaveBeenCalled()});it("should not trigger any callback until load completes",function(){M.getThread();M.getThread({success:N,callback:N});expect(N).not.toHaveBeenCalled()});it("should trigger the callbacks once loaded",function(){M.getThread();M.getThread({success:N,callback:N});A({});expect(N.callCount).toBe(2)})});describe("callbacks",function(){it("should not trigger any callbacks until the load completes",function(){M.getThread(N);M.getThread({success:N});M.getThread({failure:N});M.getThread({callback:N});expect(N).not.toHaveBeenCalled()});describe("when successful",function(){it("should accept a function as the callback and default the scope to the model",function(){L=M.getThread(N);A({});var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1].isOperation).toBe(true);expect(P.args[2]).toBe(true);expect(P.object).toBe(M)});it("should accept a function with a scope",function(){var P={};M.getThread(N,P);A({});expect(N.mostRecentCall.object).toBe(P)});it("should accept an options object with success and default the scope to the model",function(){L=M.getThread({success:N});A({});var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1].isOperation).toBe(true);expect(P.object).toBe(M)});it("should accept an options object with success and a scope",function(){var Q={},P;M.getThread({scope:Q,success:N});A({});P=N.mostRecentCall;expect(P.object).toBe(Q)});it("should accept an options object with callback and default the scope to the model",function(){L=M.getThread({callback:N});A({});var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1].isOperation).toBe(true);expect(P.args[2]).toBe(true);expect(P.object).toBe(M)});it("should accept an options object with callback and a scope",function(){var Q={},P;M.getThread({scope:Q,callback:N});A({});P=N.mostRecentCall;expect(P.object).toBe(Q)})});describe("when failed",function(){it("should accept a function as the callback and default the scope to the model",function(){L=M.getThread(N);A(null,500);var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1].isOperation).toBe(true);expect(P.args[2]).toBe(false);expect(P.object).toBe(M)});it("should accept a function with a scope",function(){var P={};M.getThread(N,P);A(null,500);expect(N.mostRecentCall.object).toBe(P)});it("should accept an options object with failure and default the scope to the model",function(){L=M.getThread({failure:N});A(null,500);var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1].isOperation).toBe(true);expect(P.object).toBe(M)});it("should accept an options object with failure and a scope",function(){var Q={},P;M.getThread({scope:Q,failure:N});A(null,500);P=N.mostRecentCall;expect(P.object).toBe(Q)});it("should accept an options object with callback and default the scope to the model",function(){L=M.getThread({callback:N});A(null,500);var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1].isOperation).toBe(true);expect(P.args[2]).toBe(false);expect(P.object).toBe(M)});it("should accept an options object with callback and a scope",function(){var Q={},P;M.getThread({scope:Q,callback:N});A(null,500);P=N.mostRecentCall;expect(P.object).toBe(Q)})})})})});describe("with an already loaded instance",function(){beforeEach(function(){L=new I({id:2},O);M.setThread(L)});it("should return the same instance",function(){expect(M.getThread()).toBe(L)});it("should not attempt to load",function(){N=spyOn(I.getProxy(),"read");M.getThread();expect(N).not.toHaveBeenCalled()});it("should attempt to reload if called with options.reload",function(){N=spyOn(I.getProxy(),"read").andReturn();M.getThread({reload:true});expect(N).toHaveBeenCalled()});it("should reload the same record when called with reload",function(){var P=M.getThread({reload:true});expect(P).toBe(L)});describe("callbacks",function(){it("should call the callbacks before the function returns",function(){M.getThread(N);expect(N).toHaveBeenCalled();N.reset();M.getThread({success:N});expect(N).toHaveBeenCalled();N.reset();M.getThread({callback:N});expect(N).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){M.getThread(N);var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1]).toBeNull();expect(P.args[2]).toBe(true);expect(P.object).toBe(M)});it("should accept a function with a scope",function(){var P={};M.getThread(N,P);expect(N.mostRecentCall.object).toBe(P)});it("should accept an options object with success and default the scope to the model",function(){M.getThread({success:N});var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1]).toBeNull();expect(P.object).toBe(M)});it("should accept an options object with success and a scope",function(){var Q={},P;M.getThread({scope:Q,success:N});P=N.mostRecentCall;expect(P.object).toBe(Q)});it("should accept an options object with callback and default the scope to the model",function(){M.getThread({callback:N});var P=N.mostRecentCall;expect(P.args[0]).toBe(L);expect(P.args[1]).toBeNull();expect(P.args[2]).toBe(true);expect(P.object).toBe(M)});it("should accept an options object with callback and a scope",function(){var Q={},P;M.getThread({scope:Q,callback:N});P=N.mostRecentCall;expect(P.object).toBe(Q)})})})});describe("setter",function(){beforeEach(function(){M=new D({id:7},O)});describe("instance",function(){var P;beforeEach(function(){P=new I({id:3},O)});describe("with nothing existing",function(){beforeEach(function(){M.setThread(P)});it("should have the same record reference",function(){expect(M.getThread()).toBe(P)});it("should set the underlying key value",function(){expect(M.get("threadId")).toBe(3)});it("should clear the instance and foreign key when setting to null",function(){M.setThread(null);expect(M.getThread()).toBeNull();expect(M.get("threadId")).toBeNull()})});describe("with an existing key, but no instance",function(){beforeEach(function(){M.setThread(1000);M.setThread(P)});it("should have the new record reference",function(){expect(M.getThread()).toBe(P)});it("should set the underlying key value",function(){expect(M.get("threadId")).toBe(3)});it("should clear the instance and foreign key when setting to null",function(){M.setThread(null);expect(M.getThread()).toBeNull();expect(M.get("threadId")).toBeNull()})});describe("with an existing instance",function(){beforeEach(function(){M.setThread(new I({id:1000},O));M.setThread(P)});it("should have the new record reference",function(){expect(M.getThread()).toBe(P)});it("should set the underlying key value",function(){expect(M.get("threadId")).toBe(3)});it("should clear the instance and foreign key when setting to null",function(){M.setThread(null);expect(M.getThread()).toBeNull();expect(M.get("threadId")).toBeNull()})})});describe("value",function(){describe("with nothing existing",function(){it("should set the underlying key",function(){M.setThread(16);expect(M.get("threadId")).toBe(16)});it("should return a new record object that loads",function(){M.setThread(16);N=spyOn(I.getProxy(),"read");expect(M.getThread().getId()).toBe(16);expect(N.mostRecentCall.args[0].getId()).toBe(16)});it("should do nothing if the key is null",function(){M.setThread(null);expect(M.getThread()).toBeNull()})});describe("with an existing key, but no instance",function(){beforeEach(function(){M.setThread(1000)});it("should set the underlying key",function(){M.setThread(16);expect(M.get("threadId")).toBe(16)});it("should return a new record object that loads",function(){M.setThread(16);N=spyOn(I.getProxy(),"read");expect(M.getThread().getId()).toBe(16);expect(N.mostRecentCall.args[0].getId()).toBe(16)});it("should clear the key",function(){M.setThread(null);expect(M.get("threadId")).toBeNull();expect(M.getThread()).toBeNull()})});describe("with an existing instance",function(){beforeEach(function(){M.setThread(new I({id:1000},O))});it("should set the underlying key",function(){M.setThread(16);expect(M.get("threadId")).toBe(16)});it("should return a new record object that loads",function(){M.setThread(16);N=spyOn(I.getProxy(),"read");expect(M.getThread().getId()).toBe(16);expect(N.mostRecentCall.args[0].getId()).toBe(16)});it("should clear the key",function(){M.setThread(null);expect(M.get("threadId")).toBeNull();expect(M.getThread()).toBeNull()})})});describe("timing",function(){var P,Q,R;beforeEach(function(){Q={afterEdit:function(){R()}};P=new I({id:101},O)});afterEach(function(){R=Q=null});it("should have the record instances set in afterEdit",function(){var S;R=function(){S=M.getThread()};M.join(Q);M.setThread(P);expect(S).toBe(P)});it("should have the value cleared in afterEdit",function(){var S;M.setThread(P);R=function(){S=M.getThread()};M.join(Q);M.setThread(null);expect(S).toBeNull()})});describe("callbacks",function(){it("should accept a function as the second arg, scope should default to the model",function(){M.setThread(16,N);A({});var P=N.mostRecentCall;expect(P.args[0]).toBe(M);expect(P.object).toBe(M)});it("should accept a function with a scope",function(){var P={};L=M.setThread(16,N,P);A({});expect(N.mostRecentCall.object).toBe(P)});describe("options object",function(){var R,P,Q;beforeEach(function(){R=jasmine.createSpy();P=jasmine.createSpy();Q=jasmine.createSpy()});afterEach(function(){R=P=Q=null});describe("on success",function(){it("should call success/callback and scope should default to the model",function(){M.setThread(16,{success:R,callback:Q,failure:P});A({});expect(P).not.toHaveBeenCalled();expect(R).toHaveBeenCalled();expect(Q).toHaveBeenCalled();expect(R.mostRecentCall.object).toBe(M);expect(Q.mostRecentCall.object).toBe(M)});it("should use a passed scope",function(){var S={};M.setThread(16,{scope:S,success:R,callback:Q});A({});expect(R.mostRecentCall.object).toBe(S);expect(Q.mostRecentCall.object).toBe(S)})});describe("on failure",function(){it("should call failure/callback and scope should default to the model",function(){M.setThread(16,{success:R,callback:Q,failure:P});A(null,500);expect(R).not.toHaveBeenCalled();expect(P).toHaveBeenCalled();expect(Q).toHaveBeenCalled();expect(P.mostRecentCall.object).toBe(M);expect(Q.mostRecentCall.object).toBe(M)});it("should use a passed scope",function(){var S={};M.setThread(16,{scope:S,failure:P,callback:Q});A(null,500);expect(P.mostRecentCall.object).toBe(S);expect(Q.mostRecentCall.object).toBe(S)})})})})});describe("modifying the foreign key",function(){var P,Q;beforeEach(function(){P=new I({id:1},O);Q=P.posts()});function R(T,S){M=new D({id:T,threadId:S||1},O)}afterEach(function(){Q=P=null});it("should remove from the store when changing the key to null",function(){R(101);Q.add(M);M.set("threadId",null);expect(Q.getCount()).toBe(0)});it("should remove from the store when changing the key to some other value",function(){R(101);Q.add(M);M.set("threadId",4);expect(Q.getCount()).toBe(0)});it("should null out the one when there is no key",function(){R(101);M.setThread(P);M.set("threadId",null);expect(M.thread).toBeFalsy();expect(M.getThread()).toBeNull()});it("should not remove the record from unrelated stores",function(){R(101);spyOn(Ext.log,"warn");var S=new Ext.data.Store();S.add(M);Q.add(M);M.set("threadId",null);expect(Q.getCount()).toBe(0);expect(S.first()).toBe(M);S.destroy()});if(K){it("should add to an existing store if a matching key is found",function(){var T=new I({id:2},O);var S=T.posts();R(101);Q.add(M);M.set("threadId",2);expect(Q.getCount()).toBe(0);expect(S.first()).toBe(M)});it("should set the many record if it exists in the session",function(){var T=new I({id:2},O);R(101);expect(M.getThread()).toBe(P);M.set("threadId",2);var S=D.associations.thread.getInstanceName();expect(M[S]).toBe(T);expect(M.getThread()).toBe(T)});it("should not create the record if the existing key does not exist",function(){R(101);Q.add(M);M.set("threadId",2);expect(O.peekRecord("Thread",2)).toBeNull()});it("should not create the store on an existing record",function(){var T=new I({id:2},O);var S=T.associations.posts.getStoreName();R(101);Q.add(M);M.set("threadId",2);expect(T[S]).toBeUndefined()});it("should not add if an existing store is loading",function(){var T=new I({id:2},O);var S=T.posts();S.load();R(101);Q.add(M);M.set("threadId",2);expect(Q.getCount()).toBe(0);expect(S.getCount()).toBe(0)})}})});describe("the many",function(){var R;function Q(){P=new I({id:3},O)}var P;afterEach(function(){R=P=null});it("should return a store",function(){F();Q();expect(P.posts().isStore).toBe(true)});it("should set the appropriate model type",function(){F();Q();expect(P.posts().model).toBe(D)});if(K){it("should set the session on the store",function(){F();Q();expect(P.posts().getSession()).toBe(O)})}it("should return the same store instance on multiple calls",function(){F();Q();var S=P.posts();expect(P.posts()).toBe(S)});it("should apply the storeConfig",function(){F({inverse:{storeConfig:{autoLoad:true}}});Q();R=P.posts();expect(R.getAutoLoad()).toBe(true);R.destroy()});it("should add a filter on the store",function(){F();Q();var T=P.posts(),S=T.getFilters().first();expect(S.getProperty()).toBe("threadId");expect(S.getValue()).toBe(3)});describe("autoLoad",function(){it("should not load the store by default",function(){F();Q();var S=spyOn(Ext.data.ProxyStore.prototype,"load").andReturn();P.posts();expect(S.callCount).toBe(0)});it("should load the store if configured with autoLoad: true",function(){F({inverse:{autoLoad:true}});Q();var S=spyOn(Ext.data.ProxyStore.prototype,"load").andReturn();P.posts();expect(S.callCount).toBe(1)})});describe("store modification",function(){beforeEach(function(){F()});describe("loading",function(){var S;beforeEach(function(){S=[{id:101,threadId:3},{id:102,threadId:3},{id:103,threadId:3}]});it("should set the owner instance when loading",function(){Q();var U=P.posts();U.load();A(S);var T=spyOn(D.getProxy(),"read");expect(U.getAt(0).getThread()).toBe(P);expect(U.getAt(1).getThread()).toBe(P);expect(U.getAt(2).getThread()).toBe(P);expect(T).not.toHaveBeenCalled()});it("should set the owner instance when loading via nested loading",function(){P=I.load(3);A({id:3,posts:S});var U=P.posts();var T=spyOn(D.getProxy(),"read");expect(U.getAt(0).getThread()).toBe(P);expect(U.getAt(1).getThread()).toBe(P);expect(U.getAt(2).getThread()).toBe(P);expect(T).not.toHaveBeenCalled()})});describe("adding",function(){beforeEach(function(){Q()});it("should default to the key to the primaryKey",function(){var T=P.posts(),S;T.load();A([]);S=T.add({})[0];expect(S.get("threadId")).toBe(3)});it("should set the primaryKey onto the foreignKey on add",function(){var T=P.posts(),S;T.load();A([]);S=T.add({threadId:1})[0];expect(S.get("threadId")).toBe(3)});it("should set the owner instance when adding",function(){var T=P.posts();T.load();A([]);M=T.add({})[0];var S=spyOn(D.getProxy(),"read");expect(M.getThread()).toBe(P);expect(S).not.toHaveBeenCalled()});it("should set the owner instance when adding when the record already has the FK",function(){var T=P.posts(),S=T.add({id:101,threadId:P.getId()})[0];expect(S.getThread()).toBe(P)});it("should have the key & instance set in the add event",function(){var S=P.posts(),U,T;M=new D({},O);S.on("add",function(){U=M.get("threadId");T=M.getThread()});S.add(M);expect(U).toBe(P.getId());expect(T).toBe(P)})});describe("removing",function(){beforeEach(function(){Q()});it("should set the key to null when removing an item",function(){var T=P.posts(),S;T.load();A([{id:12,threadId:3}]);S=T.first();T.remove(S);expect(S.get("threadId")).toBeNull()});it("should set the key to null when removing all items",function(){var V=P.posts(),U,T,S;V.load();A([{id:11,threadId:3},{id:12,threadId:3},{id:13,threadId:3}]);U=V.getAt(0);T=V.getAt(1);S=V.getAt(2);V.removeAll();expect(U.get("threadId")).toBeNull();expect(T.get("threadId")).toBeNull();expect(S.get("threadId")).toBeNull()});it("should not modify the store when removing the an item",function(){var T=P.posts(),S;T.load();A([{id:12,threadId:3}]);S=T.first();T.remove(S);expect(P.posts()).toBe(T);expect(S.getThread()).toBeNull()});it("should not modify the store when removing the all items",function(){var V=P.posts(),U,T,S;V.load();A([{id:11,threadId:3},{id:12,threadId:3},{id:13,threadId:3}]);U=V.getAt(0);T=V.getAt(1);S=V.getAt(2);V.removeAll();expect(U.getThread()).toBeNull();expect(T.getThread()).toBeNull();expect(S.getThread()).toBeNull();expect(P.posts()).toBe(V)});it("should have the key & instance cleared in the remove event",function(){var S=P.posts(),U,T;S.load();A([{id:11,threadId:3},{id:12,threadId:3},{id:13,threadId:3}]);M=S.first();S.on("remove",function(){U=M.get("threadId");T=M.getThread()});S.remove(M);expect(U).toBeNull();expect(T).toBeNull()})})});describe("reload",function(){beforeEach(function(){F();Q()});it("should reload an existing store",function(){P.posts();N=spyOn(D.getProxy(),"read");P.posts({reload:true});expect(N).toHaveBeenCalled()});it("should not trigger an existing load if already loading",function(){R=P.posts({});expect(R.isLoading()).toBe(true);N=spyOn(D.getProxy(),"read");P.posts({reload:true});expect(N).not.toHaveBeenCalled()})});describe("calling while during a load",function(){beforeEach(function(){F();Q()});it("should not trigger a second load",function(){P.posts({});N=spyOn(D.getProxy(),"read");P.posts({});expect(N).not.toHaveBeenCalled()});it("should not trigger any callback until load completes",function(){P.posts({});P.posts({success:N,callback:N});expect(N).not.toHaveBeenCalled()});it("should trigger the callbacks once loaded",function(){P.posts({});P.posts({success:N,callback:N});A([]);expect(N.callCount).toBe(2)})});describe("callbacks",function(){beforeEach(function(){F();Q()});describe("when not triggering a load",function(){beforeEach(function(){P.posts()});it("should call the callbacks before the function returns",function(){P.posts(N);expect(N).toHaveBeenCalled();N.reset();P.posts({success:N});expect(N).toHaveBeenCalled();N.reset();P.posts({callback:N});expect(N).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){R=P.posts(N);var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1]).toBeNull();expect(S.args[2]).toBe(true);expect(S.object).toBe(P)});it("should accept a function with a scope",function(){var S={};P.posts(N,S);expect(N.mostRecentCall.object).toBe(S)});it("should accept an options object with success and default the scope to the model",function(){R=P.posts({success:N});var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1]).toBeNull();expect(S.object).toBe(P)});it("should accept an options object with success and a scope",function(){var T={},S;P.posts({scope:T,success:N});S=N.mostRecentCall;expect(S.object).toBe(T)});it("should accept an options object with callback and default the scope to the model",function(){R=P.posts({callback:N});var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1]).toBeNull();expect(S.args[2]).toBe(true);expect(S.object).toBe(P)});it("should accept an options object with callback and a scope",function(){var T={},S;P.posts({scope:T,callback:N});S=N.mostRecentCall;expect(S.object).toBe(T)})});describe("when triggering a load",function(){it("should not trigger any callbacks until the load completes",function(){P.posts(N);P.posts({success:N});P.posts({failure:N});P.posts({callback:N});expect(N).not.toHaveBeenCalled()});describe("when successful",function(){it("should accept a function as the callback and default the scope to the model",function(){R=P.posts(N);A([]);var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1].isOperation).toBe(true);expect(S.args[2]).toBe(true);expect(S.object).toBe(P)});it("should accept a function with a scope",function(){var S={};P.posts(N,S);A([]);expect(N.mostRecentCall.object).toBe(S)});it("should accept an options object with success and default the scope to the model",function(){R=P.posts({success:N});A([]);var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1].isOperation).toBe(true);expect(S.object).toBe(P)});it("should accept an options object with success and a scope",function(){var T={},S;P.posts({scope:T,success:N});A([]);S=N.mostRecentCall;expect(S.object).toBe(T)});it("should accept an options object with callback and default the scope to the model",function(){R=P.posts({callback:N});A([]);var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1].isOperation).toBe(true);expect(S.args[2]).toBe(true);expect(S.object).toBe(P)});it("should accept an options object with callback and a scope",function(){var T={},S;P.posts({scope:T,callback:N});A([]);S=N.mostRecentCall;expect(S.object).toBe(T)})});describe("when failed",function(){it("should accept a function as the callback and default the scope to the model",function(){R=P.posts(N);A(null,500);var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1].isOperation).toBe(true);expect(S.args[2]).toBe(false);expect(S.object).toBe(P)});it("should accept a function with a scope",function(){var S={};P.posts(N,S);A(null,500);expect(N.mostRecentCall.object).toBe(S)});it("should accept an options object with failure and default the scope to the model",function(){R=P.posts({failure:N});A(null,500);var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1].isOperation).toBe(true);expect(S.object).toBe(P)});it("should accept an options object with failure and a scope",function(){var T={},S;P.posts({scope:T,failure:N});A(null,500);S=N.mostRecentCall;expect(S.object).toBe(T)});it("should accept an options object with callback and default the scope to the model",function(){R=P.posts({callback:N});A(null,500);var S=N.mostRecentCall;expect(S.args[0]).toBe(R);expect(S.args[1].isOperation).toBe(true);expect(S.args[2]).toBe(false);expect(S.object).toBe(P)});it("should accept an options object with callback and a scope",function(){var T={},S;P.posts({scope:T,callback:N});A(null,500);S=N.mostRecentCall;expect(S.object).toBe(T)})})})});if(K){describe("local store modifications with loading",function(){var S;beforeEach(function(){F();Q();R=P.posts();S=[{id:101,threadId:3},{id:102,threadId:3},{id:103,threadId:3}]});it("should exclude records with local foreign key changes",function(){R.load();A(S);var T=O.getRecord("Post",102);R.removeAt(1);expect(T.get("threadId")).toBeNull();R.load();A(S);expect(R.getCount()).toBe(2);expect(R.indexOf(T)).toBe(-1)});it("should append records with the key that were not attached",function(){R.load();A(S);var T=O.getRecord("Post",104);A({id:104});R.add(T);expect(T.get("threadId")).toBe(3);R.load();A(S);expect(R.getCount()).toBe(4);expect(R.indexOf(T)).toBe(3)});it("should include records added to the session with a matching key",function(){R.load();A(S);var U=new D({id:104,threadId:3},O);var T=new D({id:105,threadId:7},O);expect(R.indexOf(U)).toBe(3);expect(R.indexOf(T)).toBe(-1)})})}})})}J(false);J(true)});describe("dropping",function(){function J(P){var Q,N,K,O;beforeEach(function(){if(P){Q=new Ext.data.Session()}O=[{id:1,posts:[{id:101,threadId:1},{id:102,threadId:1},{id:103,threadId:1}]}]});afterEach(function(){if(P){Q.destroy();Q=null}O=N=K=null});function R(U,T){var S={id:U,threadId:T};N=new D(S,Q)}function M(S){K=new I({id:S},Q)}function L(T){var S=new Ext.data.Store({model:I,session:Q});S.loadRawData(T||O);return S}describe(P?"with session":"without session",function(){describe("the one",function(){beforeEach(function(){F()});describe("inverse not loaded",function(){it("should not create the the inverse record",function(){R(101,1);N.drop();expect(G).toBe(false)});it("should clear the foreign key",function(){R(101,1);N.drop();expect(N.get("threadId")).toBeNull()})});describe("inverse loaded",function(){var S,T;beforeEach(function(){S=L();K=S.first();T=K.posts();N=T.first()});afterEach(function(){S.destroy();S=T=null});it("should remove from the store",function(){expect(T.getCount()).toBe(3);N.drop();expect(T.getCount()).toBe(2);expect(T.indexOf(N)).toBe(-1)});it("should clear the foreign key",function(){N.drop();expect(N.get("threadId")).toBeNull()});it("should not return the inverse record",function(){expect(N.getThread()).toBe(K);N.drop();expect(N.getThread()).toBeNull()})})});describe("the many",function(){describe("inverse not loaded",function(){beforeEach(function(){F()});it("should not attempt to load the store",function(){M(1);var S=spyOn(D.getProxy(),"read");K.drop();expect(S).not.toHaveBeenCalled()})});describe("inverse loaded",function(){var S;afterEach(function(){if(S){S.destroy()}S=null});describe("no parent/child relationship",function(){beforeEach(function(){F()});it("should not raise an exception with an empty store",function(){S=L([{id:1}]);K=S.first();expect(function(){K.drop()}).not.toThrow()});it("should remove all children from the store",function(){S=L();K=S.first();var U=K.posts(),V=U.getRange(),T=jasmine.createSpy();U.on("clear",T);K.drop();expect(T.mostRecentCall.args[1]).toEqual(V)});it("should clear the foreign key for each child",function(){S=L();K=S.first();var T=K.posts(),U=T.getRange();K.drop();expect(U[0].get("threadId")).toBeNull();expect(U[1].get("threadId")).toBeNull();expect(U[2].get("threadId")).toBeNull()});it("should not drop the child records",function(){S=L();K=S.first();var T=K.posts(),U=T.getRange();K.drop();expect(U[0].dropped).toBe(false);expect(U[1].dropped).toBe(false);expect(U[2].dropped).toBe(false)});it("should clear the owner on the inverse",function(){S=L();K=S.first();var T=K.posts(),U=T.getRange();K.drop();expect(U[0].getThread()).toBeNull();expect(U[1].getThread()).toBeNull();expect(U[2].getThread()).toBeNull()})});describe("as a parent",function(){var T,V;function U(){S=L();K=S.first();T=K.posts();V=T.getRange();N=T.first()}beforeEach(function(){F({type:null,parent:"Thread"})});afterEach(function(){T=V=null});it("should not raise an exception with an empty store",function(){S=L([{id:1}]);K=S.first();expect(function(){K.drop()}).not.toThrow()});it("should drop each child in the store and remove it",function(){var W=jasmine.createSpy();U();T.on("clear",W);K.drop();expect(V[0].dropped).toBe(true);expect(V[1].dropped).toBe(true);expect(V[2].dropped).toBe(true);expect(W.mostRecentCall.args[1]).toEqual(V)});it("should clear the foreign key for each child",function(){U();K.drop();expect(V[0].get("threadId")).toBeNull();expect(V[1].get("threadId")).toBeNull();expect(V[2].get("threadId")).toBeNull()});it("should clear the owner on the inverse",function(){U();K.drop();expect(V[0].getThread()).toBeNull();expect(V[1].getThread()).toBeNull();expect(V[2].getThread()).toBeNull()});describe("dropping the child",function(){it("should drop a child when removing it from the store",function(){U();T.remove(N);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(true)});it("should drop a child when changing the foreign key",function(){U();N.set("threadId",null);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(true);expect(T.indexOf(N)).toBe(-1)});it("should drop a child when nulling out via the setter",function(){U();N.setThread(null);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(true);expect(T.indexOf(N)).toBe(-1)});if(P){it("should drop the child even if the store is not created",function(){K=new I({id:1},Q);var Z=new D({id:101,threadId:1},Q);var Y=new D({id:102,threadId:1},Q);var X=new D({id:103,threadId:1},Q);var W=new D({id:104,threadId:2});K.drop();expect(Z.dropped).toBe(true);expect(Y.dropped).toBe(true);expect(X.dropped).toBe(true);expect(W.dropped).toBe(false)})}});describe("not dropping the child",function(){it("should not drop the child when setting a new record",function(){U();var W=new I({id:2},Q);N.setThread(W);expect(N.dropped).toBe(false)});it("should not drop the child when setting a new key",function(){U();N.setThread(2);expect(N.dropped).toBe(false)});it("should not drop the child when adding to a new store",function(){U();var W=new I({id:2},Q);T.remove(N);W.posts().add(N);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(false)});it("should not drop the child when setting the foreign key",function(){U();T.remove(N);N.set("threadId",2);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(false)});it("should not drop the child when setting a new parent",function(){U();var W=new I({id:2},Q);T.remove(N);N.setThread(W);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(false)})})})})})})}J(false);J(true)})})