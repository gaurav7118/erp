describe("Ext.data.schema.OneToOne",function(){var D,J,H,C,E,I,F=false,G=false;function B(K){J=Ext.define("spec.User",{extend:"Ext.data.Model",fields:["id","name",{name:"addressId",unique:true,reference:Ext.apply({type:"Address"},K)}],constructor:function(){F=true;this.callParent(arguments)}});C=H.associations.user;E=J.associations.address;if(C){I=C.association}else{if(E){I=E.association}}}function A(L,K){Ext.Ajax.mockComplete({status:K||200,responseText:Ext.JSON.encode(L)})}beforeEach(function(){G=F=false;MockAjaxManager.addMethods();D=Ext.data.Model.schema;D.setNamespace("spec");H=Ext.define("spec.Address",{extend:"Ext.data.Model",fields:["id","street","city","zip"],constructor:function(){G=true;this.callParent(arguments)}})});afterEach(function(){MockAjaxManager.removeMethods();Ext.undefine("spec.User");Ext.undefine("spec.Address");D.clear(true);I=J=C=H=E=D=null;G=F=false});describe("Model.associations",function(){it("should have an association role on each model",function(){B();expect(J.associations.address).toBeDefined();expect(H.associations.user).toBeDefined()});it("should have a reference back to the association for each role",function(){B();expect(H.associations.user.association).toBe(J.associations.address.association);expect(H.associations.user.association.isOneToOne).toBe(true)})});describe("association default config",function(){beforeEach(function(){B()});it("should have a schema set",function(){expect(I.schema).toBe(D)});it("should have the reference field set",function(){expect(I.field).toBe(J.getField("addressId"))});it("should have the left part be set to the key holder",function(){expect(I.left).toBe(C)});it("should set definedBy to the key holder",function(){expect(I.definedBy).toBe(J)});it("should have the right part be set to the non key holder",function(){expect(I.right).toBe(E)});it("should have the owner as null",function(){expect(I.owner).toBeNull()});it("should set the assoc name to {SingularRight}{SingularLeft}",function(){expect(I.name).toBe("AddressUser")})});describe("left",function(){beforeEach(function(){B()});it("should set the role to be singular lowercase & the type to be the entity name",function(){expect(C.role).toBe("user");expect(C.type).toBe("User")});it("should set the inverse role to the right",function(){expect(C.inverse).toBe(E)});it("should set the entity",function(){expect(C.cls).toBe(J)})});describe("right",function(){beforeEach(function(){B()});it("should set the role to be singular lowercase & the type to be the entity name",function(){expect(E.role).toBe("address");expect(E.type).toBe("Address")});it("should set the inverse role to the left",function(){expect(E.inverse).toBe(C)});it("should set the entity",function(){expect(E.cls).toBe(H)})});describe("configuring",function(){it("should set an association name",function(){B({association:"CustomName"});expect(I.name).toBe("CustomName")});it("should set the owner based on the child param",function(){B({child:true});expect(I.owner).toBe(C);expect(C.owner).toBe(true);expect(E.owner).toBe(false)});it("should set the owner based on the parent param",function(){B({parent:true});expect(I.owner).toBe(E);expect(E.owner).toBe(true);expect(C.owner).toBe(false)});it("should be able to set a custom role",function(){B({role:"foo"});E=J.associations.foo;I=E.association;expect(I.name).toBe("AddressFooUser");expect(E.role).toBe("foo")});describe("inverse",function(){it("should set with a string",function(){B({inverse:"foo"});expect(I.name).toBe("AddressFoo");C=H.associations.foo;expect(C.role).toBe("foo")});it("should set with an object",function(){B({inverse:{role:"foo"}});expect(I.name).toBe("AddressFoo");C=H.associations.foo;expect(C.role).toBe("foo")})})});describe("model decoration",function(){function K(L,M){expect(typeof L.prototype[M]).toBe("function")}it("should generate a getter on the key holder",function(){B();K(J,"getAddress")});it("should generate a setter on the key holder",function(){B();K(J,"setAddress")});it("should define a getter on the inverse",function(){B();K(H,"getUser")});it("should allow a custom getter name on the key holder",function(){B({getterName:"getCoolUser"});K(J,"getCoolUser")});it("should allow a custom setter name on the key holder",function(){B({setterName:"setCoolUser"});K(J,"setCoolUser")});it("should allow a custom getter name on the inverse",function(){B({inverse:{getterName:"getCoolAddress"}});K(H,"getCoolAddress")});it("should decorate the model based on the role",function(){Ext.define("spec.OtherUser",{extend:"Ext.data.Model",fields:["id","name",{name:"useralAddressId",reference:{type:"Address",role:"useralAddress"}},{name:"homeAddressId",reference:{type:"Address",role:"homeAddress"}}]});K(spec.OtherUser,"getUseralAddress");K(spec.OtherUser,"getHomeAddress");Ext.undefine("spec.OtherUser")})});describe("subclasing",function(){describe("the left",function(){var K;beforeEach(function(){B();K=Ext.define("spec.SubUser",{extend:"spec.User"})});afterEach(function(){Ext.undefine("spec.SubUser")});it("should still have the original association",function(){var L=J.associations.address.inverse;expect(L.role).toBe("user");expect(L.cls).toBe(J)});it("should inherit the association from the parent and modify the relevant classes",function(){var L=K.associations.address.inverse;expect(L.role).toBe("subUser");expect(L.cls).toBe(K)})});describe("the right",function(){var K;beforeEach(function(){B();K=Ext.define("spec.SubAddress",{extend:"spec.Address"})});it("should not have any associations",function(){expect(K.associations).toEqual({})})})});describe("nested loading",function(){beforeEach(function(){B()});it("should delete the non-key holder from the data collection",function(){var K=J.load(1);A({id:1,address:{id:101}});expect(K.get("address")).toBeUndefined();expect(K.getAddress().getId()).toBe(101)});it("should delete the key holder from the data collection",function(){var K=H.load(101);A({id:101,user:{id:1}});expect(K.get("user")).toBeUndefined();expect(K.getUser().getId()).toBe(1)});describe("key inference",function(){describe("without session",function(){it("should infer the key from the parent",function(){var K=J.load(1);A({id:1,address:{id:101}});expect(K.getAddress().getId()).toBe(101);expect(K.get("addressId")).toBe(101);expect(K.dirty).toBe(false)})});describe("with session",function(){var K;beforeEach(function(){K=new Ext.data.Session()});afterEach(function(){K.destroy();K=null});it("should favour an existing reference",function(){var L=K.createRecord("User",{id:1,addressId:201});L.load();A({id:1,address:{id:101}});var M=K.peekRecord("Address",101);expect(L.getAddress().getId()).toBe(201);expect(L.get("addressId")).toBe(201);expect(L.dirty).toBe(false);expect(M).not.toBeNull();expect(L.getAddress()).not.toBe(M)});it("should infer the key from the parent if not specified",function(){var L=J.load(1,null,K);A({id:1,address:{id:101}});expect(L.getAddress().getId()).toBe(101);expect(L.get("addressId")).toBe(101);expect(L.dirty).toBe(false)});it("should not infer the key from the parent if a key is specified",function(){var L=J.load(1,null,K);A({id:1,addressId:201,address:{id:101}});expect(L.getAddress().getId()).toBe(201);expect(L.get("addressId")).toBe(201);expect(L.dirty).toBe(false)})})})});describe("getters/setters",function(){function K(L){describe(L?"with session":"without session",function(){var P,N,M,O;beforeEach(function(){B();O=jasmine.createSpy();if(L){P=new Ext.data.Session()}});afterEach(function(){if(L){P.destroy()}P=O=N=M=null});describe("the key holder",function(){describe("getter",function(){beforeEach(function(){N=new J({id:4},P)});describe("without an instance",function(){describe("with no foreign key value",function(){it("should return null",function(){expect(N.getAddress()).toBeNull()});it("should not make any request",function(){O=spyOn(H.getProxy(),"read");N.getAddress();expect(O).not.toHaveBeenCalled()});describe("callbacks",function(){it("should call the callbacks before the function returns",function(){N.getAddress(O);expect(O).toHaveBeenCalled();O.reset();N.getAddress({success:O});expect(O).toHaveBeenCalled();O.reset();N.getAddress({callback:O});expect(O).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){N.getAddress(O);var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1]).toBeNull();expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept a function with a scope",function(){var Q={};N.getAddress(O,Q);expect(O.mostRecentCall.object).toBe(Q)});it("should accept an options object with success and default the scope to the model",function(){N.getAddress({success:O});var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1]).toBeNull();expect(Q.object).toBe(N)});it("should accept an options object with success and a scope",function(){var R={},Q;N.getAddress({scope:R,success:O});Q=O.mostRecentCall;expect(Q.object).toBe(R)});it("should accept an options object with callback and default the scope to the model",function(){N.getAddress({callback:O});var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1]).toBeNull();expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var R={},Q;N.getAddress({scope:R,callback:O});Q=O.mostRecentCall;expect(Q.object).toBe(R)})})});describe("with a foreign key value",function(){beforeEach(function(){N.set("addressId",17)});if(L){it("should create an instance in the session",function(){expect(N.getAddress()).toBe(P.getRecord("Address",17,false))});it("should use an existing record instance",function(){M=P.getRecord("Address",17,false);expect(N.getAddress()).toBe(M)});it("should not load an existing instance",function(){M=P.getRecord("Address",{id:17},false);N.getAddress();expect(M.isLoading()).toBe(false)})}it("should return an instance with the matching id",function(){expect(N.getAddress().getId()).toBe(17)});it("should be in a loading state",function(){expect(N.getAddress().isLoading()).toBe(true)});it("should trigger a load for the record",function(){O=spyOn(H.getProxy(),"read");N.getAddress();expect(O.mostRecentCall.args[0].getId()).toBe(17)});describe("calling while during a load",function(){it("should return the same record",function(){var Q=N.getAddress();expect(N.getAddress()).toBe(Q)});it("should not trigger a second load",function(){N.getAddress();O=spyOn(H.getProxy(),"read");N.getAddress();expect(O).not.toHaveBeenCalled()});it("should not trigger any callback until load completes",function(){N.getAddress();N.getAddress({success:O,callback:O});expect(O).not.toHaveBeenCalled()});it("should trigger the callbacks once loaded",function(){N.getAddress();N.getAddress({success:O,callback:O});A({});expect(O.callCount).toBe(2)})});describe("callbacks",function(){it("should not trigger any callbacks until the load completes",function(){N.getAddress(O);N.getAddress({success:O});N.getAddress({failure:O});N.getAddress({callback:O});expect(O).not.toHaveBeenCalled()});describe("when successful",function(){it("should accept a function as the callback and default the scope to the model",function(){M=N.getAddress(O);A({});var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1].isOperation).toBe(true);expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept a function with a scope",function(){var Q={};N.getAddress(O,Q);A({});expect(O.mostRecentCall.object).toBe(Q)});it("should accept an options object with success and default the scope to the model",function(){M=N.getAddress({success:O});A({});var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1].isOperation).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with success and a scope",function(){var R={},Q;N.getAddress({scope:R,success:O});A({});Q=O.mostRecentCall;expect(Q.object).toBe(R)});it("should accept an options object with callback and default the scope to the model",function(){M=N.getAddress({callback:O});A({});var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1].isOperation).toBe(true);expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var R={},Q;N.getAddress({scope:R,callback:O});A({});Q=O.mostRecentCall;expect(Q.object).toBe(R)})});describe("when failed",function(){it("should accept a function as the callback and default the scope to the model",function(){M=N.getAddress(O);A(null,500);var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1].isOperation).toBe(true);expect(Q.args[2]).toBe(false);expect(Q.object).toBe(N)});it("should accept a function with a scope",function(){var Q={};N.getAddress(O,Q);A(null,500);expect(O.mostRecentCall.object).toBe(Q)});it("should accept an options object with failure and default the scope to the model",function(){M=N.getAddress({failure:O});A(null,500);var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1].isOperation).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with failure and a scope",function(){var R={},Q;N.getAddress({scope:R,failure:O});A(null,500);Q=O.mostRecentCall;expect(Q.object).toBe(R)});it("should accept an options object with callback and default the scope to the model",function(){M=N.getAddress({callback:O});A(null,500);var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1].isOperation).toBe(true);expect(Q.args[2]).toBe(false);expect(Q.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var R={},Q;N.getAddress({scope:R,callback:O});A(null,500);Q=O.mostRecentCall;expect(Q.object).toBe(R)})})})})});describe("with an already loaded instance",function(){beforeEach(function(){M=new H({id:2},P);N.setAddress(M)});it("should return the same instance",function(){expect(N.getAddress()).toBe(M)});it("should not attempt to load",function(){O=spyOn(H.getProxy(),"read");N.getAddress();expect(O).not.toHaveBeenCalled()});it("should attempt to reload if called with options.reload",function(){O=spyOn(H.getProxy(),"read").andReturn();N.getAddress({reload:true});expect(O).toHaveBeenCalled()});it("should reload the same record when called with reload",function(){var Q=N.getAddress({reload:true});expect(Q).toBe(M)});describe("callbacks",function(){it("should call the callbacks before the function returns",function(){N.getAddress(O);expect(O).toHaveBeenCalled();O.reset();N.getAddress({success:O});expect(O).toHaveBeenCalled();O.reset();N.getAddress({callback:O});expect(O).toHaveBeenCalled()});it("should accept a function as the callback and default the scope to the model",function(){N.getAddress(O);var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1]).toBeNull();expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept a function with a scope",function(){var Q={};N.getAddress(O,Q);expect(O.mostRecentCall.object).toBe(Q)});it("should accept an options object with success and default the scope to the model",function(){N.getAddress({success:O});var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1]).toBeNull();expect(Q.object).toBe(N)});it("should accept an options object with success and a scope",function(){var R={},Q;N.getAddress({scope:R,success:O});Q=O.mostRecentCall;expect(Q.object).toBe(R)});it("should accept an options object with callback and default the scope to the model",function(){N.getAddress({callback:O});var Q=O.mostRecentCall;expect(Q.args[0]).toBe(M);expect(Q.args[1]).toBeNull();expect(Q.args[2]).toBe(true);expect(Q.object).toBe(N)});it("should accept an options object with callback and a scope",function(){var R={},Q;N.getAddress({scope:R,callback:O});Q=O.mostRecentCall;expect(Q.object).toBe(R)})})})});describe("setter",function(){beforeEach(function(){N=new J({id:7},P)});describe("instance",function(){var Q;beforeEach(function(){Q=new H({id:3},P)});describe("with nothing existing",function(){beforeEach(function(){N.setAddress(Q)});it("should have the same record reference",function(){expect(N.getAddress()).toBe(Q)});it("should set the underlying key value",function(){expect(N.get("addressId")).toBe(3)});it("should clear the instance and foreign key when setting to null",function(){N.setAddress(null);expect(N.getAddress()).toBeNull();expect(N.get("addressId")).toBeNull()})});describe("with an existing key, but no instance",function(){beforeEach(function(){N.setAddress(1000);N.setAddress(Q)});it("should have the new record reference",function(){expect(N.getAddress()).toBe(Q)});it("should set the underlying key value",function(){expect(N.get("addressId")).toBe(3)});it("should clear the instance and foreign key when setting to null",function(){N.setAddress(null);expect(N.getAddress()).toBeNull();expect(N.get("addressId")).toBeNull()})});describe("with an existing instance",function(){beforeEach(function(){N.setAddress(new H({id:1000},P));N.setAddress(Q)});it("should have the new record reference",function(){expect(N.getAddress()).toBe(Q)});it("should set the underlying key value",function(){expect(N.get("addressId")).toBe(3)});it("should clear the instance and foreign key when setting to null",function(){N.setAddress(null);expect(N.getAddress()).toBeNull();expect(N.get("addressId")).toBeNull()})})});describe("value",function(){describe("with nothing existing",function(){it("should set the underlying key",function(){N.setAddress(16);expect(N.get("addressId")).toBe(16)});it("should return a new record object that loads",function(){N.setAddress(16);O=spyOn(H.getProxy(),"read");expect(N.getAddress().getId()).toBe(16);expect(O.mostRecentCall.args[0].getId()).toBe(16)});it("should do nothing if the key is null",function(){N.setAddress(null);expect(N.getAddress()).toBeNull()})});describe("with an existing key, but no instance",function(){beforeEach(function(){N.setAddress(1000)});it("should set the underlying key",function(){N.setAddress(16);expect(N.get("addressId")).toBe(16)});it("should return a new record object that loads",function(){N.setAddress(16);O=spyOn(H.getProxy(),"read");expect(N.getAddress().getId()).toBe(16);expect(O.mostRecentCall.args[0].getId()).toBe(16)});it("should clear the key",function(){N.setAddress(null);expect(N.get("addressId")).toBeNull();expect(N.getAddress()).toBeNull()})});describe("with an existing instance",function(){beforeEach(function(){N.setAddress(new H({id:1000},P))});it("should set the underlying key",function(){N.setAddress(16);expect(N.get("addressId")).toBe(16)});it("should return a new record object that loads",function(){N.setAddress(16);O=spyOn(H.getProxy(),"read");expect(N.getAddress().getId()).toBe(16);expect(O.mostRecentCall.args[0].getId()).toBe(16)});it("should clear the key",function(){N.setAddress(null);expect(N.get("addressId")).toBeNull();expect(N.getAddress()).toBeNull()})})});describe("timing",function(){var Q,R,S;beforeEach(function(){R={afterEdit:function(){S()}};Q=new H({id:101},P)});afterEach(function(){S=R=null});it("should have the record instances set in afterEdit",function(){var T;S=function(){T=N.getAddress()};N.join(R);N.setAddress(Q);expect(T).toBe(Q)});it("should have the value cleared in afterEdit",function(){var T;N.setAddress(Q);S=function(){T=N.getAddress()};N.join(R);N.setAddress(null);expect(T).toBeNull()})});describe("callbacks",function(){it("should accept a function as the second arg, scope should default to the model",function(){N.setAddress(16,O);A({});var Q=O.mostRecentCall;expect(Q.args[0]).toBe(N);expect(Q.object).toBe(N)});it("should accept a function with a scope",function(){var Q={};M=N.setAddress(16,O,Q);A({});expect(O.mostRecentCall.object).toBe(Q)});describe("options object",function(){var S,Q,R;beforeEach(function(){S=jasmine.createSpy();Q=jasmine.createSpy();R=jasmine.createSpy()});afterEach(function(){S=Q=R=null});describe("on success",function(){it("should call success/callback and scope should default to the model",function(){N.setAddress(16,{success:S,callback:R,failure:Q});A({});expect(Q).not.toHaveBeenCalled();expect(S).toHaveBeenCalled();expect(R).toHaveBeenCalled();expect(S.mostRecentCall.object).toBe(N);expect(R.mostRecentCall.object).toBe(N)});it("should use a passed scope",function(){var T={};N.setAddress(16,{scope:T,success:S,callback:R});A({});expect(S.mostRecentCall.object).toBe(T);expect(R.mostRecentCall.object).toBe(T)})});describe("on failure",function(){it("should call failure/callback and scope should default to the model",function(){N.setAddress(16,{success:S,callback:R,failure:Q});A(null,500);expect(S).not.toHaveBeenCalled();expect(Q).toHaveBeenCalled();expect(R).toHaveBeenCalled();expect(Q.mostRecentCall.object).toBe(N);expect(R.mostRecentCall.object).toBe(N)});it("should use a passed scope",function(){var T={};N.setAddress(16,{scope:T,failure:Q,callback:R});A(null,500);expect(Q.mostRecentCall.object).toBe(T);expect(R.mostRecentCall.object).toBe(T)})})})})});describe("modifying the foreign key",function(){var Q;beforeEach(function(){Q=new J({id:7},P)});it("should set the reference with no existing key",function(){Q.set("addressId",44);expect(Q.getAddress().getId()).toBe(44)});it("should clear the reference when setting to null",function(){M=new H({id:3},P);Q.setAddress(M);Q.set("addressId",null);expect(Q.address).toBeFalsy();expect(Q.getAddress()).toBeNull()});it("should change the reference for the key",function(){M=new H({id:3},P);Q.setAddress(M);Q.set("addressId",123);expect(Q.getAddress().getId()).toBe(123)});if(L){it("should set the new reference if it exists in the session",function(){M=new H({id:3},P);Q.setAddress(M);var R=new H({id:10},P);Q.set("addressId",10);var S=J.associations.address.getInstanceName();expect(Q[S]).toBe(R);expect(Q.getAddress()).toBe(R)})}})})})}K(false);K(true)});describe("dropping",function(){function K(Q){var S,O,N,P;beforeEach(function(){if(Q){S=new Ext.data.Session()}P=[{id:1,address:{id:101}}]});afterEach(function(){if(Q){S.destroy();S=null}P=O=N=null});function R(V,T){var U={id:V,addressId:T};O=new J(U,S)}function L(T){N=new H({id:T},S)}function M(U){var T=new Ext.data.Store({model:J,session:S});T.loadRawData(U||P);return T}describe(Q?"with session":"without session",function(){describe("the key holder",function(){describe("inverse not loaded",function(){beforeEach(function(){B()});it("should not create the the inverse record",function(){R(1,101);O.drop();expect(G).toBe(false)});it("should clear the foreign key",function(){R(1,101);O.drop();expect(O.get("addressId")).toBeNull()})});describe("inverse loaded",function(){var T;afterEach(function(){T.destroy();T=null});describe("no parent/child relationship",function(){beforeEach(function(){B();T=M();O=T.first();N=O.getAddress()});it("should clear the foreign key",function(){O.drop();expect(O.get("addressId")).toBeNull()});it("should not return the inverse record",function(){expect(O.getAddress()).toBe(N);O.drop();expect(O.getAddress()).toBeNull()});it("should not drop the child record",function(){O.drop();expect(N.dropped).toBe(false)});it("should clear the owner on the inverse",function(){O.drop();expect(N.getUser()).toBeNull()})});describe("as a parent",function(){beforeEach(function(){B({type:null,child:"Address"});T=M();O=T.first();N=O.getAddress()});it("should clear the foreign key",function(){O.drop();expect(O.get("addressId")).toBeNull()});it("should not return the inverse record",function(){expect(O.getAddress()).toBe(N);O.drop();expect(O.getAddress()).toBeNull()});describe("dropping the child",function(){it("should drop the child record",function(){O.drop();Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(true)});it("should clear the owner on the inverse",function(){O.drop();Ext.data.Model.schema.processKeyChecks(true);expect(N.getUser()).toBeNull()});it("should drop the child when changing the foreign key",function(){O.set("addressId",null);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(true)});it("should drop the child when nulling out via the setter",function(){O.setAddress(null);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(true)});it("should drop the child when setting a new record",function(){var U=new H({id:2},S);O.setAddress(U);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(true);expect(U.dropped).toBe(false)});it("should drop the child when setting a new key",function(){O.setAddress(2);Ext.data.Model.schema.processKeyChecks(true);expect(N.dropped).toBe(true)});if(Q){it("should drop when the the records are not connected",function(){O=new J({id:1001,addressId:5001},S);var V=new H({id:5001},S);var U=new H({id:5002},S);O.drop();Ext.data.Model.schema.processKeyChecks(true);expect(V.dropped).toBe(true);expect(U.dropped).toBe(false)})}});describe("not dropping the child",function(){it("should not drop the child immediately",function(){O.setAddress(null);expect(N.dropped).toBe(false)});it("should not drop the child if it has been reassigned",function(){var U=new J({id:5},S);O.setAddress(null);U.setAddress(N);Ext.data.Model.schema.processKeyChecks(true)})})})})});describe("the non-key holder",function(){beforeEach(function(){B()});describe("inverse not loaded",function(){it("should not raise an error",function(){L(101);expect(function(){N.drop()}).not.toThrow()})});describe("inverse loaded",function(){it("should clear the owner reference",function(){var T=M();O=T.first();N=O.getAddress();expect(N.getUser()).toBe(O);N.drop();expect(N.getUser()).toBeNull();T.destroy()})})})})}K(false);K(true)})})