describe("Ext.data.writer.Json",function(){var E,B,D,A,C,F={id:1,title:"Article 1",body:"content1"};beforeEach(function(){Ext.ClassManager.enableNamespaceParseCache=false;B=function(G){G=Ext.apply({writeAllFields:true},G);E=new Ext.data.writer.Json(G)};C=Ext.define("spec.Article",{extend:"Ext.data.Model",fields:[{name:"id",type:"int"},{name:"title",type:"string"},{name:"body",type:"string",writeName:"content"}]});D=function(H){var G=[];Ext.each(H,function(I){G.push(new C(I))});return G};A=function(G){return new Ext.data.operation.Create({records:G})}});afterEach(function(){Ext.ClassManager.enableNamespaceParseCache=true;E=B=A=C=null;Ext.data.Model.schema.clear();Ext.undefine("spec.Article")});describe("initialization",function(){it("should default root to undefined",function(){B();expect(E.getRootProperty()).toBeUndefined()});it("should default encode to false",function(){B();expect(E.getEncode()).toBe(false)});it("should default allowSingle to true",function(){B();expect(E.getAllowSingle()).toBe(true)});it("should default expandData to false",function(){B();expect(E.getExpandData()).toBe(false)})});describe("allowSingle",function(){it("should only send a single record if allowSingle is true and there's only 1 item",function(){B();var G=E.write(new Ext.data.Request({operation:A(D([F]))}));var H=G.getJsonData();expect(H).toEqual(F)});it("should wrap a single record in an array if allowSingle is false",function(){B({allowSingle:false});var G=E.write(new Ext.data.Request({operation:A(D([F]))}));expect(G.getJsonData()).toEqual([F])});it("should wrap records in an array if there is more than 1, regardless of allowSingle",function(){B();var G=E.write(new Ext.data.Request({operation:A(D([F,{id:2,title:"Article 2",body:"content2"}]))}));expect(G.getJsonData()).toEqual([F,{id:2,title:"Article 2",body:"content2"}])})});describe("with encode: true",function(){it("should throw an exception if no root is specified",function(){B({encode:true});expect(function(){E.write(new Ext.data.Request({operation:A(D([F]))}))}).toRaiseExtError()});it("should write the data to the request params",function(){B({encode:true,rootProperty:"root"});var G=E.write(new Ext.data.Request({params:{},operation:A(D([F]))}));expect(G.getParams().root).toBeDefined()});it("should encode the data",function(){B({encode:true,rootProperty:"root"});var G=E.write(new Ext.data.Request({params:{},operation:A(D([F]))}));expect(G.getParams().root).toBe(Ext.encode(F))});describe("with transform",function(){it("should not set the jsonData",function(){B({encode:true,rootProperty:"root",transform:Ext.identityFn});var G=E.write(new Ext.data.Request({params:{},operation:A(D([F]))}));expect(G.getJsonData()).toBeUndefined();expect(G.getParams().root).toBe(Ext.encode(F))})})});describe("with encode: false",function(){it("should create the jsonData if it doesn't exist",function(){B();var G=E.write(new Ext.data.Request({params:{},operation:A(D([F]))}));expect(G.getJsonData()).toBeDefined()});it("should write directly to the jsonData if no root is specified",function(){B();var G=E.write(new Ext.data.Request({params:{},operation:A(D([F]))}));expect(G.getJsonData()).toEqual(F)});it("should write to the root property jsonData if specified",function(){B({rootProperty:"root"});var G=E.write(new Ext.data.Request({params:{},operation:A(D([F]))}));expect(G.getJsonData()).toEqual({root:F})})});describe("nested data mappings",function(){var G;beforeEach(function(){Ext.data.Model.schema.clear();Ext.undefine("spec.Article");C=Ext.define("spec.Article",{extend:"Ext.data.Model",fields:[{name:"id",type:"int"},{name:"title",type:"string",mapping:"my_title"},{name:"someNestedProperty",type:"string",mapping:"some.nested.property"},{name:"someOtherProperty",type:"string",mapping:"some.other.property"},{name:"someOtherProperty2",type:"int",mapping:"some.other.property2"}]});G={id:1,title:"Article 1",someNestedProperty:"nested",someOtherProperty:"other",someOtherProperty2:5}});it("should write as flat output using the default field names by default",function(){B();var H=E.write(new Ext.data.Request({operation:A(D([G]))}));expect(H.getJsonData()).toEqual(G)});it("should write as flat output using the mapped field names by default when nameProperty is used",function(){B({nameProperty:"mapping"});var H=E.write(new Ext.data.Request({operation:A(D([G]))}));expect(H.getJsonData()).toEqual({id:1,my_title:"Article 1","some.nested.property":"nested","some.other.property":"other","some.other.property2":5})});it("should expand output to nested JSON when nameProperty is used and expandData = true",function(){B({nameProperty:"mapping",expandData:true});var H=E.write(new Ext.data.Request({operation:A(D([G]))}));expect(H.getJsonData()).toEqual({id:1,my_title:"Article 1",some:{nested:{property:"nested"},other:{property:"other",property2:5}}})})});describe("transform",function(){it("should invoke the transform function",function(){var H=function(I){return{id:2}};B({transform:H});var G=E.write(new Ext.data.Request({params:{},operation:A(D([F]))}));expect(G.getJsonData()).not.toEqual(F);expect(G.getJsonData()).toEqual({id:2})});it("should invoke the transform function with the specified scope",function(){var G={};var I=function(J){expect(this).toEqual(G);return{id:2}};B({transform:{fn:I,scope:G}});var H=E.write(new Ext.data.Request({params:{},operation:A(D([F]))}));expect(H.getJsonData()).not.toEqual(F);expect(H.getJsonData()).toEqual({id:2})})})})