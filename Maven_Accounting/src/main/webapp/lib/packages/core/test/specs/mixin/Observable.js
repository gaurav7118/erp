(function(){function B(C){describe(C.$className,function(){var Z,U,N,L,H,I,F,S,W,R,Q,O,K,P,G,M,E,Y,V,X,D,J;function T(a){a.resolveListenerScope=function(){if(!this.defaultScope){this.defaultScope={meth1:function(){},resolveListenerScope:function(){return null}}}return this.defaultScope}}beforeEach(function(){J={};D={"fired":true,"quit":true,"ask_salary_augmentation":true};Z=Ext.extend(C,{constructor:function(a){a=a||{};this.listeners=a.listeners;Z.superclass.constructor.call(this,a)},doSomething:function(){}});F=jasmine.createSpy("bossFiredFn");S=jasmine.createSpy("bossFired2Fn");W=jasmine.createSpy("bossQuitFn");I=jasmine.createSpy("bossAskFn");H={fn:I,scope:J};L={ask_salary_augmentation:H};N={listeners:L};U=new Z(N);R=Ext.extend(C,{constructor:function(a){a=a||{};this.listeners=a.listeners;R.superclass.constructor.call(this,a)},getBubbleTarget:function(){return this.boss}});Y=jasmine.createSpy("employeeFiredFn");X=jasmine.createSpy("employeeQuitFn");M=jasmine.createSpy("employeeAskFn");E={fn:Y,scope:J};V={fn:X,scope:J};G={fn:M,scope:J};K={ask_salary_augmentation:G,fired:E,quit:V};P=["ask_salary_augmentation"];O={listeners:K,bubbleEvents:P,boss:U};spyOn(R.prototype,"on").andCallThrough();spyOn(R.prototype,"addListener").andCallThrough();spyOn(R.prototype,"enableBubble").andCallThrough();Q=new R(O)});afterEach(function(){C.prototype.fireEventArgs.target=null});describe("constructor",function(){it("should allow the constructor to be called multiple times",function(){var b=Ext.define(null,{extend:C}),a=Ext.define(null,{extend:C}),c=Ext.define(null,{mixins:{mixinA:b,mixinB:a,observable:C},constructor:function(f){var e=spyOn(this,"initConfig").andCallThrough(),h=C.$className==="Ext.mixin.Observable",d,g;this.mixins.mixinA.constructor.call(this,f);if(h){expect(e).toHaveBeenCalledWith({foo:"bar"})}else{expect(this.foo).toBe("bar")}d=this.hasListeners;g=this.events;this.mixins.observable.constructor.call(this,f);expect(this.hasListeners).toBe(d);expect(this.events).toBe(g);this.mixins.mixinB.constructor.call(this,f);expect(this.hasListeners).toBe(d);expect(this.events).toBe(g);if(h){expect(e.callCount).toBe(1)}}});new c({foo:"bar"})})});describe("destroyable",function(){describe("listeners",function(){it("should remove the listeners when you destroy the returned Destroyable",function(){var a=new Z(),b=a.on({fired:function(){},quit:function(){},ask_salary_augmentation:function(){},destroyable:true});expect(a.hasListeners.fired).toEqual(1);expect(a.hasListeners.quit).toEqual(1);expect(a.hasListeners.ask_salary_augmentation).toEqual(1);b.destroy();expect(a.hasListeners.fired).toBeUndefined();expect(a.hasListeners.quit).toBeUndefined();expect(a.hasListeners.ask_salary_augmentation).toBeUndefined()})});describe("managed listeners",function(){it("should remove managed listeners when you destroy the returned Destroyable",function(){var a=new Z(),b=a.mon(a,{fired:function(){},quit:function(){},ask_salary_augmentation:function(){},destroyable:true});expect(a.hasListeners.fired).toEqual(1);expect(a.hasListeners.quit).toEqual(1);expect(a.hasListeners.ask_salary_augmentation).toEqual(1);b.destroy();expect(a.hasListeners.fired).toBeUndefined();expect(a.hasListeners.quit).toBeUndefined();expect(a.hasListeners.ask_salary_augmentation).toBeUndefined()})});describe("relayers",function(){it("should remove relayers when you destroy the returned Destroyable",function(){var c=new Z(),f=new R(),e=c.relayEvents(f,["fired","quit","ask_salary_augmentation"],"minion_"),b=0,d=0,a=0;c.on({minion_fired:function(){d++},minion_quit:function(){b++},minion_ask_salary_augmentation:function(){a++}});expect(f.hasListeners.fired).toEqual(1);expect(f.hasListeners.quit).toEqual(1);expect(f.hasListeners.ask_salary_augmentation).toEqual(1);f.fireEvent("fired");f.fireEvent("quit");f.fireEvent("ask_salary_augmentation");expect(d).toEqual(1);expect(b).toEqual(1);expect(a).toEqual(1);e.destroy();expect(f.hasListeners.fired).toBeUndefined();expect(f.hasListeners.quit).toBeUndefined();expect(f.hasListeners.ask_salary_augmentation).toBeUndefined();f.fireEvent("fired");f.fireEvent("quit");f.fireEvent("ask_salary_augmentation");expect(d).toEqual(1);expect(b).toEqual(1);expect(a).toEqual(1)})})});describe("instantiation",function(){describe("config initialization",function(){if(C===Ext.mixin.Observable){it("should invoke initConfig",function(){var a=Ext.define(null,{extend:C});spyOn(a.prototype,"initConfig");spyOn(Ext,"apply");var b=new a({x:1});expect(a.prototype.initConfig).toHaveBeenCalledWith({x:1});expect(Ext.apply).not.toHaveBeenCalled();b.destroy()});it("should apply configuration if $applyConfigs is true",function(){var a=Ext.define(null,{extend:C,$applyConfigs:true});spyOn(a.prototype,"initConfig");spyOn(Ext,"apply");var b=new a({x:1});expect(Ext.apply).toHaveBeenCalledWith(b,{x:1});expect(a.prototype.initConfig).not.toHaveBeenCalled();b.destroy()})}else{it("should apply configuration",function(){var a=Ext.define(null,{extend:C});spyOn(a.prototype,"initConfig");spyOn(Ext,"apply");var b=new a({x:1});expect(Ext.apply).toHaveBeenCalledWith(b,{x:1});expect(a.prototype.initConfig).not.toHaveBeenCalled();b.destroy()});it("should invoke initConfig if $applyConfigs is false",function(){var a=Ext.define(null,{extend:C,$applyConfigs:false});spyOn(a.prototype,"initConfig");spyOn(Ext,"apply");var b=new a({x:1});expect(a.prototype.initConfig).toHaveBeenCalledWith({x:1});expect(Ext.apply).not.toHaveBeenCalled();b.destroy()})}});it("should append event handlers passed in configuration params",function(){expect(R.prototype.addListener).toHaveBeenCalledWith(K)});it("should delete listeners configuration property",function(){expect(Q.listeners).toBeNull()});it("should enable bubble",function(){expect(R.prototype.enableBubble).toHaveBeenCalledWith(P)})});describe("event name normalization",function(){var a,b;beforeEach(function(){a=jasmine.createSpy();b=new C()});describe("firing",function(){it("should match when firing with lower case",function(){b.on("FOO",a);b.fireEvent("foo");expect(a).toHaveBeenCalled()});it("should match when firing with mixed case",function(){b.on("foo",a);b.fireEvent("FOO");expect(a).toHaveBeenCalled()});describe("using mon",function(){var c;beforeEach(function(){c=new C()});it("should match when firing with lower case",function(){c.mon(b,"FOO",a);b.fireEvent("foo");expect(a).toHaveBeenCalled()});it("should match when firing with mixed case",function(){c.mon(b,"foo",a);b.fireEvent("FOO");expect(a).toHaveBeenCalled()})})});describe("removing",function(){it("should match when removing with lower case",function(){b.on("FOO",a);b.un("foo",a);b.fireEvent("foo");expect(a).not.toHaveBeenCalled()});it("should match when removing with mixed case",function(){b.on("foo",a);b.un("FOO",a);b.fireEvent("FOO");expect(a).not.toHaveBeenCalled()});describe("using mon/mun",function(){var c;beforeEach(function(){c=new C()});it("should match when removing with lower case",function(){c.mon(b,"FOO",a);c.mun(b,"foo",a);b.fireEvent("foo");expect(a).not.toHaveBeenCalled()});it("should match when removing with mixed case",function(){c.mon(b,"foo",a);c.mun(b,"FOO",a);b.fireEvent("FOO");expect(a).not.toHaveBeenCalled()})})});describe("hasListener(s)",function(){it("should use lower case for hasListeners",function(){b.on("FOO",a);expect(b.hasListeners.foo).toBe(1)});it("should use lower case for hasListener",function(){b.on("FOO",a);expect(b.hasListener("foo")).toBe(true)});describe("using mon",function(){var c;beforeEach(function(){c=new C()});it("should use lower case for hasListeners",function(){c.mon(b,"FOO",a);expect(b.hasListeners.foo).toBe(1)});it("should use lower case for hasListener",function(){c.mon(b,"FOO",a);expect(b.hasListener("foo")).toBe(true)})})});describe("suspend/resume",function(){it("should ignore case when asking if an event is suspended",function(){b.suspendEvent("FOO");expect(b.isSuspended("foo")).toBe(true)});it("should ignore case when resuming events",function(){b.on("foo",a);b.suspendEvent("FOO");b.fireEvent("foo");expect(a).not.toHaveBeenCalled();b.resumeEvent("foo");b.fireEvent("foo");expect(a).toHaveBeenCalled()})});describe("bubbling",function(){it("should ignore case when bubbling events",function(){var c=new C();c.on("foo",a);b.enableBubble("FOO");b.getBubbleTarget=function(){return c};b.fireEvent("foo");expect(a).toHaveBeenCalled()})})});describe("firing events",function(){describe("without options",function(){beforeEach(function(){Q.fireEvent("fired","I'am fired :s")});describe("bubbling",function(){it("should not fire boss fired event",function(){expect(F).not.toHaveBeenCalled()})});it("should call the handler only one times",function(){expect(Y.callCount).toEqual(1)});it("should call the handler function with passed arguments",function(){expect(Y).toHaveBeenCalledWith("I'am fired :s",E)});it("should call the handler function with the correct scope",function(){expect(Y.calls[0].object).toBe(J)});describe("scope resolution",function(){describe("with a function reference",function(){it("should resolve to the instance with scope:'this'",function(){var a=jasmine.createSpy();U.on("fired",a,"this");U.fireEvent("fired");expect(a.mostRecentCall.object).toBe(U)});it("should throw an error with scope:'controller'",function(){var a=jasmine.createSpy();U.on("fired",a,"controller");expect(function(){U.fireEvent("fired")}).toThrow()})});describe("with scope: 'this'",function(){it("resolve to the observable",function(){U.on("fired","doSomething","this");var a=spyOn(U,"doSomething");U.fireEvent("fired");expect(a).toHaveBeenCalled()})});describe("with scope: 'controller'",function(){it("not be able to resolve",function(){U.on("fired","doSomething","controller");expect(function(){U.fireEvent("fired")}).toThrow('scope: "controller" can only be specified on classes that derive from Ext.Component or Ext.Widget')})});describe("without default listener scope",function(){it("should always fire on the passed scope",function(){var b={aMethod:function(){}};var a=spyOn(b,"aMethod");U.on("fired","aMethod",b);U.fireEvent("fired");expect(a).toHaveBeenCalled()});it("should default to the observable",function(){U.aMethod=function(){};var a=spyOn(U,"aMethod");U.on("fired","aMethod");U.fireEvent("fired");expect(a).toHaveBeenCalled()})});describe("with default listener scope",function(){beforeEach(function(){T(U)});it("should favour a passed scope",function(){var b={aMethod:function(){}};var a=spyOn(b,"aMethod");U.on("fired","aMethod",b);U.fireEvent("fired");expect(a).toHaveBeenCalled()});it("should favour a default listener scope over the observable",function(){var a=spyOn(U.resolveListenerScope(),"meth1");U.on("fired","meth1");U.fireEvent("fired");expect(a).toHaveBeenCalled()});it("should not cache the listener scope",function(){var a={meth1:function(){}},c=spyOn(U.resolveListenerScope(),"meth1"),b=spyOn(a,"meth1");U.on("fired","meth1");U.fireEvent("fired");expect(c).toHaveBeenCalled();expect(b).not.toHaveBeenCalled();c.reset();b.reset();U.resolveListenerScope=function(){return a};U.fireEvent("fired");expect(c).not.toHaveBeenCalled();expect(b).toHaveBeenCalled()})})})});describe("with options",function(){describe("single",function(){var a;beforeEach(function(){a=jasmine.createSpy("singleFn");U.addListener("singleevent",a,J,{single:true});U.fireEvent("singleevent","single 1");U.fireEvent("singleevent","single 2");U.fireEvent("singleevent","single 3")});it("should call the handler only one times",function(){expect(a.callCount).toEqual(1)});it("should call the handler function with passed arguments",function(){expect(a).toHaveBeenCalledWith("single 1",{single:true})});it("should call the handler function with the correct scope",function(){expect(a.calls[0].object).toBe(J)});it("should remove the listener",function(){expect(U.hasListener("singleevent")).toBe(false)});it("should fire with dynamic scope resoution",function(){U=new Z();T(U);var b=spyOn(U.resolveListenerScope(),"meth1");U.addListener("singleevent","meth1",undefined,{single:true});U.fireEvent("singleevent","single 1");U.fireEvent("singleevent","single 2");U.fireEvent("singleevent","single 3");expect(b.callCount).toBe(1)})});describe("target",function(){var b,a,c;beforeEach(function(){b=Ext.create("Ext.container.Container",{items:[{bubbleEvents:["add","remove"],xtype:"container",itemId:"foo",items:[{bubbleEvents:["add","remove"],xtype:"component",itemId:"bar"},{bubbleEvents:["add","remove"],xtype:"component",itemId:"baz"}]}]});a=jasmine.createSpy("callbackFn");c=jasmine.createSpy("callbackFn2")});afterEach(function(){b.destroy()});it("should bubble up to its owner containers when target is not defined",function(){b.on("remove",a);b.getComponent("foo").on("remove",c);b.getComponent("foo").remove("bar");expect(a).toHaveBeenCalled();expect(c).toHaveBeenCalled()});it("should not bubble up to its owner containers when target is defined on a different observable",function(){b.on("remove",a,b,{target:b});b.getComponent("foo").on("remove",c,b,{target:b});b.getComponent("foo").remove("baz");expect(a).not.toHaveBeenCalled();expect(c).not.toHaveBeenCalled()});it("should not bubble up to its owner container but will bubble up to its ancestor",function(){b.on("add",a);b.getComponent("foo").on("add",c,b,{target:b});b.getComponent("foo").add({xtype:"component",itemId:"test"});expect(a).toHaveBeenCalled();expect(c).not.toHaveBeenCalled()});it("should fire with dynamic scope resolution",function(){T(b);var d=spyOn(b.resolveListenerScope(),"meth1");b.on("add","meth1",undefined,{target:b});b.add({xtype:"component",itemId:"test"});expect(d).toHaveBeenCalled()})});(Ext.isSafari4?xdescribe:describe)("buffer",function(){var b,a;beforeEach(function(){b=jasmine.createSpy("bufferFn");U.addListener("bufferevent",b,J,{buffer:5});U.fireEvent("bufferevent","buffer 1");U.fireEvent("bufferevent","buffer 2");U.fireEvent("bufferevent","buffer 3")});it("should not call handler immediately",function(){expect(b).not.toHaveBeenCalled()});it("should call the handler only one times after a certain amount of time",function(){waitsFor(function(){return b.callCount===1},"bufferFn wasn't called")});it("should call the handler function with passed arguments coming from the last event firing",function(){waitsFor(function(){return b.callCount===1},"bufferFn wasn't called");runs(function(){expect(b).toHaveBeenCalledWith("buffer 3",{buffer:5})})});it("should call the handler function with the correct scope",function(){waitsFor(function(){return b.callCount===1},"bufferFn wasn't called");runs(function(){expect(b.calls[0].object).toBe(J)})});it("should not remove the listener",function(){waitsFor(function(){return b.callCount===1},"bufferFn wasn't called");runs(function(){expect(U.hasListener("bufferevent")).toBe(true)})});it("should fire with dynamic scope resolution",function(){U=new Z();T(U);var c=spyOn(U.resolveListenerScope(),"meth1");U.on("bufferevent","meth1",undefined,{buffer:5});U.fireEvent("bufferevent","buffer 1");U.fireEvent("bufferevent","buffer 2");U.fireEvent("bufferevent","buffer 3");waitsFor(function(){return c.callCount===1},"spy wasn't called");runs(function(){expect(c.callCount).toBe(1)})})});(Ext.isSafari4?xdescribe:describe)("delay",function(){var b,a;beforeEach(function(){b=jasmine.createSpy("delayFn");U.addListener("delayevent",b,J,{delay:5});U.fireEvent("delayevent","delay")});it("should not call handler immediately",function(){expect(b).not.toHaveBeenCalled()});it("should call the handler only one times after a certain amount of time",function(){waitsFor(function(){return b.callCount===1},"delayFn wasn't called")});it("should call the handler function with passed arguments",function(){waitsFor(function(){return b.callCount===1},"delayFn wasn't called");runs(function(){expect(b).toHaveBeenCalledWith("delay",{delay:5})})});it("should call the handler function with the correct scope",function(){waitsFor(function(){return b.callCount===1},"delayFn wasn't called");runs(function(){expect(b.calls[0].object).toBe(J)})});it("should fire with dynamic scope resolution",function(){U=new Z();T(U);var c=spyOn(U.resolveListenerScope(),"meth1");U.on("delayevent","meth1",undefined,{delay:5});U.fireEvent("delayevent","buffer 1");waitsFor(function(){return c.callCount===1},"spy wasn't called");runs(function(){expect(c).toHaveBeenCalled()})})});describe("priority",function(){var c,b;beforeEach(function(){Ext.define("A",{extend:C});c=new A();b=[]});afterEach(function(){Ext.undefine("A")});it("should call the handlers in priority order",function(){c.on("foo",function(){b.push(10)},null,{priority:10});c.on("foo",function(){b.push("u1")},null);c.on("foo",function(){b.push(-7)},null,{priority:-7});c.on("foo",function(){b.push(0)},null,{priority:0});c.on("foo",function(){b.push(5)},null,{priority:5});c.on("foo",function(){b.push(-3)},null,{priority:-3});c.on("foo",function(){b.push("u2")});c.fireEvent("foo");expect(b.join(" ")).toBe("10 5 u1 0 u2 -3 -7")});it("should add a 0 priority listener after removal of a positive priority listener, when the listeners array contains negative priority listeners",function(){function a(){b.push(10)}c.on("foo",function(){b.push("u1")});c.on("foo",a,null,{priority:10});c.on("foo",function(){b.push(-7)},null,{priority:-7});c.on("foo",function(){b.push(5)},null,{priority:5});c.un("foo",a);c.on("foo",function(){b.push("u2")});c.fireEvent("foo");expect(b.join(" ")).toBe("5 u1 u2 -7")})});describe("order",function(){var c,b;beforeEach(function(){Ext.define("A",{extend:C});c=new A();b=[]});afterEach(function(){Ext.undefine("A")});it("should fire events in the correct order using the order event option",function(){c.on("foo",function(){b.push(101)},null,{priority:101});c.on("foo",function(){b.push("after")},null,{order:"after"});c.on("foo",function(){b.push(-101)},null,{priority:-101});c.on("foo",function(){b.push("before")},null,{order:"before"});c.on("foo",function(){b.push("current")},null,{order:"current"});c.on("foo",function(){b.push(0)},null,{priority:0});c.fireEvent("foo");expect(b.join(" ")).toBe("101 before current 0 after -101")});it("should fire events in the correct order using the order method parameter",function(){c.on("foo",function(){b.push(101)},null,{priority:101});c.on("foo",function(){b.push("after")},null,null,"after");c.on("foo",function(){b.push(-101)},null,{priority:-101});c.on("foo",function(){b.push("before")},null,null,"before");c.on("foo",function(){b.push("current")},null,null,"current");c.on("foo",function(){b.push(0)},null,{priority:0});c.fireEvent("foo");expect(b.join(" ")).toBe("101 before current 0 after -101")})})});describe("return value",function(){var f,d,c,a,h,b,e,g=false;beforeEach(function(){h=b=e=g=false;f=function(){h=true;return true};d=function(){b=true;return true};c=function(){e=true;return true};a=function(){g=true;return false}});afterEach(function(){f=d=c=a=null});it("should return true if there are no listeners",function(){Q=new R();expect(Q.fireEvent("quit")).toBe(true)});it("should return true if none of the listeners return false",function(){Q=new R();Q.on("quit",f);Q.on("quit",d);Q.on("quit",c);expect(Q.fireEvent("quit")).toBe(true)});it("should return false if any handler returns false",function(){Q=new R();Q.on("quit",f);Q.on("quit",a);Q.on("quit",c);expect(Q.fireEvent("quit")).toBe(false)});it("should stop firing once a listener returns false",function(){Q=new R();Q.on("quit",f);Q.on("quit",a);Q.on("quit",d);Q.on("quit",c);Q.fireEvent("quit");expect(h).toBe(true);expect(g).toBe(true);expect(b).toBe(false);expect(e).toBe(false)})})});describe("adding/removing listeners",function(){describe("use a string as first param",function(){beforeEach(function(){U.addListener("fired",F,J);U.fireEvent("fired","I'am fired! (1)");U.removeListener("fired",F,J);U.fireEvent("fired","I'am fired! (2)")});it("should call the event handler only one time",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'am fired! (1)")});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(J)})});describe("use an object as first param without using fn to specify the function",function(){var a;beforeEach(function(){a={fired:F,scope:J};U.addListener(a);U.fireEvent("fired","I'am fired! (1)");U.removeListener(a);U.fireEvent("fired","I'am fired! (2)")});it("should call the event handler only one time",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'am fired! (1)",a)});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(J)})});describe("use an object as first param using fn to specify the function",function(){var b,a;beforeEach(function(){a={fn:F,scope:J};b={fired:a};U.addListener(b);U.fireEvent("fired","I'am fired! (1)");U.removeListener(b);U.fireEvent("fired","I'am fired! (2)")});it("should call the event handler only one time",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'am fired! (1)",a)});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(J)})});describe("add/remove using function name as string",function(){beforeEach(function(){J={bossFired:F}});afterEach(function(){J=null});describe("with object scope",function(){beforeEach(function(){U.addListener("fired","bossFired",J);U.fireEvent("fired","I'm fired! (1)");U.removeListener("fired","bossFired",J);U.fireEvent("fired","I'm fired! (2)")});it("should call the event handler only once",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'm fired! (1)")});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(J)});it("should only call the function once",function(){expect(F.callCount).toBe(1)})});describe("with scope: 'this'",function(){var a;beforeEach(function(){a=spyOn(U,"doSomething");U.addListener("fired","doSomething","this");U.fireEvent("fired","I'm fired! (1)");U.removeListener("fired","doSomething","this");U.fireEvent("fired","I'm fired! (2)")});it("should call the event handler only once",function(){expect(a.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(a).toHaveBeenCalledWith("I'm fired! (1)")});it("should call the event with correct scope",function(){expect(a.calls[0].object).toBe(U)});it("should only call the function once",function(){expect(a.callCount).toBe(1)})});describe("with scope: 'controller'",function(){var a;it("throw while firing",function(){a=spyOn(U,"doSomething");U.addListener("fired","doSomething","controller");expect(function(){U.fireEvent("fired","I'm fired! (1)")}).toThrow()});it("should be able to remove listeners",function(){a=spyOn(U,"doSomething");U.addListener("fired","doSomething","controller");U.removeListener("fired","doSomething","controller");U.fireEvent("fired","I'm fired! (2)");expect(a).not.toHaveBeenCalled()})});describe("with no scope specified",function(){describe("without a default listener scope holder",function(){beforeEach(function(){U.bossFired=F;U.addListener("fired","bossFired");U.fireEvent("fired","I'm fired! (1)");U.removeListener("fired","bossFired");U.fireEvent("fired","I'm fired! (2)")});it("should call the event handler only once",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'm fired! (1)")});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(U)});it("should only call the function once",function(){expect(F.callCount).toBe(1)});it("should raise an error if fn cannot be resolved when firing",function(){expect(function(){U.addListener("fired","bossFiredAgain");U.fireEvent("fired")}).toThrow()})});describe("with a default listener scope",function(){beforeEach(function(){T(U);U.resolveListenerScope().bossFired=F;U.addListener("fired","bossFired");U.fireEvent("fired","I'm fired! (1)");U.removeListener("fired","bossFired");U.fireEvent("fired","I'm fired! (2)")});it("should call the event handler only once",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'm fired! (1)")});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(U.resolveListenerScope())});it("should only call the function once",function(){expect(F.callCount).toBe(1)});it("should raise an error if fn cannot be resolved when firing",function(){expect(function(){U.addListener("fired","bossFiredAgain");U.fireEvent("fired")}).toThrow()})})})});describe("remove a listener when a buffered handler hasn't fired yet",function(){it("should never call the handler",function(){runs(function(){U.addListener("fired",F,J,{buffer:5});U.fireEvent("fired");U.removeListener("fired",F,J,{buffer:5})});waits(5);runs(function(){expect(F).not.toHaveBeenCalled()})})});describe("remove a listener when a delayed handler hasn't fired yet",function(){it("should never call the handler",function(){runs(function(){U.addListener("fired",F,J,{delay:5});U.fireEvent("fired");U.removeListener("fired",F,J,{buffer:5})});waits(5);runs(function(){expect(F).not.toHaveBeenCalled()})})});it("should continue to fire events after removing a non-existent event",function(){U.addListener("fired",F);U.fireEvent("fired");U.removeListener("fired",Ext.emptyFn);U.fireEvent("fired");expect(F.callCount).toBe(2)});it("should complain if the named method does not exist on the scope object",function(){var b=new C(),a={};expect(function(){b.addListener("bar","onBar",a)}).toThrow("No method named 'onBar' found on scope object")})});describe("clearListeners",function(){beforeEach(function(){Q.clearListeners();Q.fireEvent("fired","I'am fired :s");Q.fireEvent("quit","I'am quitting my job :)")});it("should not call fired event handler",function(){expect(Y).not.toHaveBeenCalled()});it("should not call quit event handler",function(){expect(X).not.toHaveBeenCalled()});it("should always return false on a hasListener call",function(){expect(Q.hasListener("ask_salary_augmentation")).toBe(false);expect(Q.hasListener("fired")).toBe(false);expect(Q.hasListener("quit")).toBe(false)})});describe("adding/removing managed listeners",function(){describe("use a string as first param",function(){describe("firing",function(){beforeEach(function(){U.addManagedListener(Q,"fired",F,J);Q.fireEvent("fired","I'am fired! (1)");U.removeManagedListener(Q,"fired",F,J);Q.fireEvent("fired","I'am fired! (2)")});it("should call the event handler only one time",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'am fired! (1)",E)});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(J)})});describe("destruction",function(){it("should remove the listener when the destroyer is invoked",function(){var a=U.addManagedListener(Q,"fired",F,J,{destroyable:true});Q.fireEvent("fired","I'am fired! (1)");expect(F.callCount).toBe(1);a.destroy();Q.fireEvent("fired","I'am fired! (2)");expect(F.callCount).toBe(1)});it("should remove the listener when the target observable is destroyed",function(){U.addManagedListener(Q,"fired",F,J);Q.fireEvent("fired","I'am fired! (1)");expect(F.callCount).toBe(1);U.destroy();Q.fireEvent("fired","I'am fired! (2)");expect(F.callCount).toBe(1)});it("should stop tracking the managed listener if the listener is removed from the target",function(){U.addManagedListener(Q,"fired",F,J);U.addManagedListener(Q,"fired",S,J);expect(U.managedListeners.length).toBe(2);Q.removeListener("fired",F,J);expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].fn).toBe(S)});it("should stop tracking the managed listener if the target is destroyed",function(){var a=new R();U.addManagedListener(Q,"fired",F,J);U.addManagedListener(a,"fired",S,J);expect(U.managedListeners.length).toBe(2);Q.destroy();expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].item).toBe(a);expect(U.managedListeners[0].fn).toBe(S)})})});describe("use an object as first param without using fn to specify the function",function(){var a;describe("firing",function(){beforeEach(function(){a={fired:F,scope:J};U.addManagedListener(Q,a);Q.fireEvent("fired","I'am fired! (1)");U.removeManagedListener(Q,a);Q.fireEvent("fired","I'am fired! (2)")});it("should call the event handler only one time",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'am fired! (1)",a)});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(J)})});describe("destruction",function(){it("should remove the listener when the destroyer is invoked",function(){var b=U.addManagedListener(Q,{fired:F,scope:J,destroyable:true});Q.fireEvent("fired","I'am fired! (1)");expect(F.callCount).toBe(1);b.destroy();Q.fireEvent("fired","I'am fired! (2)");expect(F.callCount).toBe(1)});it("should remove the listener when the target observable is destroyed",function(){U.addManagedListener(Q,{fired:F,scope:J});Q.fireEvent("fired","I'am fired! (1)");expect(F.callCount).toBe(1);U.destroy();Q.fireEvent("fired","I'am fired! (2)");expect(F.callCount).toBe(1)});it("should stop tracking the managed listener if the listener is removed from the target",function(){U.addManagedListener(Q,{fired:F,scope:J});U.addManagedListener(Q,{fired:S,scope:J});expect(U.managedListeners.length).toBe(2);Q.removeListener({fired:F,scope:J});expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].fn).toBe(S)});it("should stop tracking the managed listener if the target is destroyed",function(){var b=new R();U.addManagedListener(Q,{fired:F,scope:J});U.addManagedListener(b,{fired:S,scope:J});expect(U.managedListeners.length).toBe(2);Q.destroy();expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].item).toBe(b);expect(U.managedListeners[0].fn).toBe(S)})})});describe("use an object as first param  using fn to specify the function",function(){var b,a;describe("firing",function(){beforeEach(function(){a={fn:F,scope:J};b={fired:a};U.addManagedListener(Q,b);Q.fireEvent("fired","I'am fired! (1)");U.removeManagedListener(Q,b);Q.fireEvent("fired","I'am fired! (2)")});it("should call the event handler only one time",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'am fired! (1)",a)});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(J)})});describe("destruction",function(){it("should remove the listener when the destroyer is invoked",function(){var c=U.addManagedListener(Q,{fired:{fn:F,scope:J},destroyable:true});Q.fireEvent("fired","I'am fired! (1)");expect(F.callCount).toBe(1);c.destroy();Q.fireEvent("fired","I'am fired! (2)");expect(F.callCount).toBe(1)});it("should remove the listener when the target observable is destroyed",function(){U.addManagedListener(Q,{fired:{fn:F,scope:J}});Q.fireEvent("fired","I'am fired! (1)");expect(F.callCount).toBe(1);U.destroy();Q.fireEvent("fired","I'am fired! (2)");expect(F.callCount).toBe(1)});it("should stop tracking the managed listener if the listener is removed from the target",function(){U.addManagedListener(Q,{fired:{fn:F,scope:J}});U.addManagedListener(Q,{fired:{fn:S,scope:J}});expect(U.managedListeners.length).toBe(2);Q.removeListener({fired:{fn:F,scope:J}});expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].fn).toBe(S)});it("should stop tracking the managed listener if the target is destroyed",function(){var c=new R();U.addManagedListener(Q,{fired:{fn:F,scope:J}});U.addManagedListener(c,{fired:{fn:S,scope:J}});expect(U.managedListeners.length).toBe(2);Q.destroy();expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].item).toBe(c);expect(U.managedListeners[0].fn).toBe(S)})})});describe("add/remove using function name as string",function(){beforeEach(function(){J={employeeFired:F}});afterEach(function(){J=null});describe("with object scope",function(){beforeEach(function(){U.addManagedListener(Q,"fired","employeeFired",J);Q.fireEvent("fired","I'm fired! (1)");U.removeManagedListener(Q,"fired","employeeFired",J);Q.fireEvent("fired","I'm fired! (2)")});it("should call the event handler only once",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'm fired! (1)",E)});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(J)});it("should only call the function once",function(){expect(F.callCount).toBe(1)})});describe("with scope: 'this'",function(){var a;beforeEach(function(){a=spyOn(U,"doSomething");U.addManagedListener(Q,"fired","doSomething","this");Q.fireEvent("fired","I'm fired! (1)");U.removeManagedListener(Q,"fired","doSomething","this");Q.fireEvent("fired","I'm fired! (2)")});it("should call the event handler only once",function(){expect(a.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(a).toHaveBeenCalledWith("I'm fired! (1)",E)});it("should call the event with correct scope",function(){expect(a.calls[0].object).toBe(U)});it("should only call the function once",function(){expect(a.callCount).toBe(1)})});describe("with scope: 'controller'",function(){var a;it("should throw when firing the event",function(){a=spyOn(U,"doSomething");U.addManagedListener(Q,"fired","doSomething","controller");expect(function(){Q.fireEvent("fired","I'm fired! (1)")}).toThrow()});it("should be able to remove an event",function(){a=spyOn(U,"doSomething");U.addManagedListener(Q,"fired","doSomething","controller");U.removeManagedListener(Q,"fired","doSomething","controller");Q.fireEvent("fired","I'm fired! (2)");expect(a).not.toHaveBeenCalled()})});describe("with no scope specified",function(){beforeEach(function(){U.employeeFired=F;U.addManagedListener(Q,"fired","employeeFired");Q.fireEvent("fired","I'm fired! (1)");U.removeManagedListener(Q,"fired","employeeFired");Q.fireEvent("fired","I'm fired! (2)")});it("should call the event handler only once",function(){expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){expect(F).toHaveBeenCalledWith("I'm fired! (1)",E)});it("should call the event with correct scope",function(){expect(F.calls[0].object).toBe(U)});it("should only call the function once",function(){expect(F.callCount).toBe(1)})})})});describe("clearManagedListeners",function(){beforeEach(function(){U.addManagedListener(Q,"fired",F,J);U.clearManagedListeners();Q.fireEvent("fired","I'am fired!");Q.fireEvent("quit","I'am quitting!")});it("should not call fired event handler",function(){expect(F).not.toHaveBeenCalled()});it("should not call quit event handler",function(){expect(W).not.toHaveBeenCalled()})});describe("auto managed listeners",function(){describe("use a string as first param",function(){beforeEach(function(){Q.addListener("fired",F,U)});it("should call the event handler only one time",function(){Q.fireEvent("fired","I am fired!");expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){Q.fireEvent("fired","I am fired!");expect(F).toHaveBeenCalledWith("I am fired!",E)});it("should call the event with correct scope",function(){Q.fireEvent("fired","I am fired!");expect(F.calls[0].object).toBe(U)});it("should remove the listener when the scope is destroyed",function(){U.destroy();Q.fireEvent("fired","I am fired!");expect(F).not.toHaveBeenCalled()});it("should stop tracking the managed listener if the listener is removed",function(){Q.addListener("fired",S,U);expect(U.managedListeners.length).toBe(2);Q.removeListener("fired",F,U);expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].fn).toBe(S)});it("should stop tracking the managed listener if the target is destroyed",function(){var a=new R();a.addListener("fired",S,U);expect(U.managedListeners.length).toBe(2);Q.destroy();expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].item).toBe(a);expect(U.managedListeners[0].fn).toBe(S)})});describe("use an object as first param without using fn to specify the function",function(){var a;beforeEach(function(){a={fired:F,scope:U};Q.addListener(a)});it("should call the event handler only one time",function(){Q.fireEvent("fired","I am fired!");expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){Q.fireEvent("fired","I am fired!");expect(F).toHaveBeenCalledWith("I am fired!",a)});it("should call the event with correct scope",function(){Q.fireEvent("fired","I am fired!");expect(F.calls[0].object).toBe(U)});it("should remove the listener when the scope is destroyed",function(){U.destroy();Q.fireEvent("fired","I am fired!");expect(F).not.toHaveBeenCalled()});it("should stop tracking the managed listener if the listener is removed",function(){Q.addListener({fired:S,scope:U});expect(U.managedListeners.length).toBe(2);Q.removeListener({fired:F,scope:U});expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].fn).toBe(S)});it("should stop tracking the managed listener if the target is destroyed",function(){var b=new R();b.addListener({fired:S,scope:U});expect(U.managedListeners.length).toBe(2);Q.destroy();expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].item).toBe(b);expect(U.managedListeners[0].fn).toBe(S)})});describe("use an object as first param  using fn to specify the function",function(){var b,a;beforeEach(function(){a={fn:F,scope:U};b={fired:a};Q.addListener(b)});it("should call the event handler only one time",function(){Q.fireEvent("fired","I am fired!");expect(F.callCount).toEqual(1)});it("should call the event with correct arguments",function(){Q.fireEvent("fired","I am fired!");expect(F).toHaveBeenCalledWith("I am fired!",a)});it("should call the event with correct scope",function(){Q.fireEvent("fired","I am fired!");expect(F.calls[0].object).toBe(U)});it("should remove the listener when the scope is destroyed",function(){U.destroy();Q.fireEvent("fired","I am fired!");expect(F).not.toHaveBeenCalled()});it("should stop tracking the managed listener if the listener is removed",function(){Q.addListener({fired:{fn:S,scope:U}});expect(U.managedListeners.length).toBe(2);Q.removeListener({fired:{fn:F,scope:U}});expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].fn).toBe(S)});it("should stop tracking the managed listener if the target is destroyed",function(){var c=new R();c.addListener({fired:{fn:S,scope:U}});expect(U.managedListeners.length).toBe(2);Q.destroy();expect(U.managedListeners.length).toBe(1);expect(U.managedListeners[0].item).toBe(c);expect(U.managedListeners[0].fn).toBe(S)})})});describe("hasListener",function(){it("should return true if the observable has a listener on a particular event",function(){expect(U.hasListener("ask_salary_augmentation")).toBe(true)});it("should normalize the case",function(){expect(U.hasListener("ASK_salary_augmentation")).toBe(true)});it("should return false if the observable has no listener on a particular event",function(){expect(U.hasListener("fired")).toBe(false)})});describe("fireAction",function(){var a,f,e,b,c;beforeEach(function(){a=[];f=new C();f.on("foo",function(){c=arguments;a.push(1)});f.on("foo",function(){a.push(2)})});function d(){e=this;b=arguments;a.push("action")}it("should call the action fn before the handlers",function(){f.fireAction("foo",null,d);expect(a).toEqual(["action",1,2])});it("should call the action fn before the handlers if order is 'before'",function(){f.fireAction("foo",null,d,null,null,"before");expect(a).toEqual(["action",1,2])});it("should call the action fn after the handlers if order is 'after'",function(){f.fireAction("foo",null,d,null,null,"after");expect(a).toEqual([1,2,"action"])});describe("with a 'before' and 'after' handler",function(){beforeEach(function(){f.on({foo:function(){a.push(0)},order:"before"});f.on({foo:function(){a.push(3)},order:"after"})});it("should call the action fn after the 'before' handler",function(){f.fireAction("foo",null,d);expect(a).toEqual([0,"action",1,2,3])});it("should call the action fn after the 'before' handler if order is 'before'",function(){f.fireAction("foo",null,d,null,null,"before");expect(a).toEqual([0,"action",1,2,3])});it("should call the action fn before the 'after' handler if order is 'after'",function(){f.fireAction("foo",null,d,null,null,"after");expect(a).toEqual([0,1,2,"action",3])})});describe("if a handler returns false",function(){beforeEach(function(){f.on("foo",function(){a.push(3);return false})});it("should call the action fn",function(){f.fireAction("foo",null,d);expect(a).toEqual(["action",1,2,3])});it("should call the action fn if order is 'before'",function(){f.fireAction("foo",null,d,null,null,"before");expect(a).toEqual(["action",1,2,3])});it("should not call the action fn if order is 'after'",function(){f.fireAction("foo",null,d,null,null,"after");expect(a).toEqual([1,2,3])})});it("should use the observable instance as the default scope for the action fn",function(){f.fireAction("foo",null,d);expect(e).toBe(f)});it("should call the action fn with the passed scope",function(){f.fireAction("foo",null,d,J);expect(e).toBe(J)});it("should call the action fn with the passed arguments",function(){f.fireAction("foo",["a","b","c"],d);expect(b.length).toBe(4);expect(b[0]).toBe("a");expect(b[1]).toBe("b");expect(b[2]).toBe("c")});it("should call the handlers with the passed arguments",function(){f.fireAction("foo",["a","b","c"],d);expect(c.length).toBe(4);expect(c[0]).toBe("a");expect(c[1]).toBe("b");expect(c[2]).toBe("c")});it("should not call the action fn on next fire (it should remove the single listener)",function(){d=jasmine.createSpy();f.fireAction("foo",null,d);expect(d.callCount).toBe(1);f.fireEvent("foo");expect(d.callCount).toBe(1)})});describe("setListeners",function(){it("should be an alias for addListener",function(){var b=new C(),a={foo:"onFoo"};spyOn(b,"addListener");b.setListeners(a);expect(b.addListener).toHaveBeenCalledWith(a)})});describe("suspend/resume events",function(){var a=function(){Q.fireEvent("fired","I'am fired :s (1)");Q.fireEvent("fired","I'am fired :s (2)");Q.fireEvent("quit","I'am quitting my job :) (1)");Q.fireEvent("quit","I'am quitting my job :) (2)")};describe("queue suspended events to be fired after the resumeEvents",function(){beforeEach(function(){Q.suspendEvents(true);a()});describe("when suspended",function(){it("should not call fired event handler",function(){expect(Y).not.toHaveBeenCalled()});it("should not call quit event handler",function(){expect(X).not.toHaveBeenCalled()})});describe("on resume",function(){describe("without discarding",function(){beforeEach(function(){Q.resumeEvents()});it("should call fired event handler two times",function(){expect(Y.callCount).toEqual(2)});it("should call quit event handler two times",function(){expect(X.callCount).toEqual(2)})});describe("with discarding",function(){beforeEach(function(){Q.resumeEvents(true)});it("should not call fired event handler",function(){expect(Y).not.toHaveBeenCalled()});it("should call quit event handler two times",function(){expect(X).not.toHaveBeenCalled()})})})});describe("discard events",function(){beforeEach(function(){Q.suspendEvents();a()});describe("when suspended",function(){it("should not call fired event handler",function(){expect(Y).not.toHaveBeenCalled()});it("should not call quit event handler",function(){expect(X).not.toHaveBeenCalled()})});describe("on resume",function(){beforeEach(function(){Q.resumeEvents()});it("should not call fired event handler",function(){expect(Y).not.toHaveBeenCalled()});it("should call quit event handler two times",function(){expect(X).not.toHaveBeenCalled()})})});describe("multiple suspend/resume",function(){it("should not fire events if there are more suspend than resume calls",function(){Q.suspendEvents();Q.suspendEvents();Q.resumeEvents();a();expect(Y).not.toHaveBeenCalled();expect(X).not.toHaveBeenCalled()});it("should fire events if the suspend/resume calls match",function(){Q.suspendEvents();Q.suspendEvents();Q.suspendEvents();Q.resumeEvents();Q.resumeEvents();Q.resumeEvents();a();expect(Y).toHaveBeenCalled();expect(X).toHaveBeenCalled()});it("should ignore extra resumeEvents calls",function(){Q.suspendEvents();Q.resumeEvents();Q.resumeEvents();Q.resumeEvents();a();expect(Y).toHaveBeenCalled();expect(X).toHaveBeenCalled()})});describe("specific events",function(){it("should be able to suspend a specific event",function(){Q.suspendEvent("fired");a();expect(Y).not.toHaveBeenCalled()});it("should be able to suspend a specific event before anything is bound",function(){var c=new C(),b=false;c.suspendEvent("foo");c.on("foo",function(){b=true});c.fireEvent("foo",c);expect(b).toBe(false)});it("should begin firing events after resuming a specific event",function(){Q.suspendEvent("fired");a();Q.resumeEvent("fired");a();expect(Y.callCount).toBe(2)});it("should not resume firing if suspend is called more than resume",function(){Q.suspendEvent("fired");Q.suspendEvent("fired");Q.resumeEvent("fired");a();expect(Y).not.toHaveBeenCalled()})});describe("isSuspended",function(){describe("all events",function(){it("should return false if all events aren't suspended",function(){expect(Q.isSuspended()).toBe(false)});it("should return false after suspending and then resuming all events",function(){Q.suspendEvents();Q.resumeEvents();expect(Q.isSuspended()).toBe(false)});it("should return true when events are globally suspended",function(){Q.suspendEvents();expect(Q.isSuspended()).toBe(true)})});describe("specific event",function(){it("should return false if the specific event is not suspended",function(){expect(Q.isSuspended("fired")).toBe(false)});it("should return false if the specific event is suspended then resumed",function(){Q.suspendEvent("fired");Q.resumeEvent("fired");expect(Q.isSuspended("fired")).toBe(false)});it("should return true if a specific event is suspended",function(){Q.suspendEvent("fired");expect(Q.isSuspended("fired")).toBe(true)});it("should return true if all events are suspended and the specific event is not",function(){Q.suspendEvents();expect(Q.isSuspended("fired")).toBe(true)})})})});describe("event bubbling",function(){describe("if handler doesn't return false",function(){beforeEach(function(){Q.fireEvent("ask_salary_augmentation","I want 5%!")});describe("in the bubbling target",function(){it("should call the handler only one times",function(){expect(I.callCount).toEqual(1)});it("should call the handler function with passed arguments",function(){expect(I).toHaveBeenCalledWith("I want 5%!",H)});it("should call the handler function with the correct scope",function(){expect(I.calls[0].object).toBe(J)})});describe("in the main observable",function(){it("should call the handler only one times",function(){expect(M.callCount).toEqual(1)});it("should call the handler function with passed arguments",function(){expect(M).toHaveBeenCalledWith("I want 5%!",G)});it("should call the handler function with the correct scope",function(){expect(M.calls[0].object).toBe(J)})})});describe("if handler return false",function(){beforeEach(function(){M.andReturn(false);Q.fireEvent("ask_salary_augmentation","I want 5%!")});describe("in the bubbling target",function(){it("should not call the handler",function(){expect(I).not.toHaveBeenCalled()})});describe("in the main observable",function(){it("should call the handler only one times",function(){expect(M.callCount).toEqual(1)});it("should call the handler function with passed arguments",function(){expect(M).toHaveBeenCalledWith("I want 5%!",G)});it("should call the handler function with the correct scope",function(){expect(M.calls[0].object).toBe(J)})})})});describe("relaying events",function(){it("should call the event handler only one time",function(){Q.relayEvents(U,["fired"]);U.fireEvent("fired","You're fired!");expect(Y.callCount).toEqual(1)});it("should call the event with correct arguments",function(){Q.relayEvents(U,["fired"]);U.fireEvent("fired","You're fired!");expect(Y).toHaveBeenCalledWith("You're fired!",E)});it("should call the event with correct scope",function(){Q.relayEvents(U,["fired"]);U.fireEvent("fired","You're fired!");expect(Y.calls[0].object).toBe(J)});it("should respect the prefix parameter",function(){Q.relayEvents(U,["fired"],"got");Q.on("gotfired",Y);U.fireEvent("fired","You're fired!");expect(Y).toHaveBeenCalled()});it("should remove relaying functions when the relayer clears its listeners",function(){Q.relayEvents(U,["fired"],"got");expect(U.hasListeners.fired).toEqual(1);Q.clearListeners();expect(U.hasListeners.fired).toBeUndefined()});it("should should return false & stop firing events if a listener returns false",function(){var a=jasmine.createSpy(),b=jasmine.createSpy();Q.relayEvents(U,["fired"]);Q.on("fired",a.andReturn(false));U.on("fired",b);expect(U.fireEvent("fired")).toBe(false);expect(b).not.toHaveBeenCalled()});describe("with options",function(){it("should should return false & stop firing events if a listener returns false with single: true",function(){var a=jasmine.createSpy(),b=jasmine.createSpy();Q.relayEvents(U,["fired"]);Q.on("fired",a.andReturn(false),null,{single:true});U.on("fired",b);expect(U.fireEvent("fired")).toBe(false);expect(b).not.toHaveBeenCalled()})})});describe("creating relayers",function(){it("should call the event handler only one time",function(){U.on({quit:Q.createRelayer("fired")});U.fireEvent("quit","You're fired!");expect(Y.callCount).toEqual(1)});it("should call the event with correct arguments",function(){U.on({quit:Q.createRelayer("fired",[0,-1])});U.fireEvent("quit","You can't fire me, I quit!");expect(Y).toHaveBeenCalledWith("You can't fire me, I quit!",E)});it("should call the event with correct scope",function(){U.on({quit:Q.createRelayer("fired")});U.fireEvent("quit","You're fired!");expect(Y.calls[0].object).toBe(J)});it("should reference same object at same position regardless of number of function parameters",function(){U.on({quit:Q.createRelayer("fired",[0,-1])});U.on({quit:Q.createRelayer("fired",[0,2])});U.fireEvent("quit",U,true);U.fireEvent("quit",U,true,["bob","chuck"],{});expect(Y.calls[0].args[2]).toBe(Y.calls[1].args[2])})});describe("args",function(){it("should append the firing args to the event option args",function(){var d=new C(),b=function(){a=arguments},c={bar:b,args:[1,2,3]},a;d.on(c);d.fireEvent("bar",4,5);expect(a).toEqual([1,2,3,4,5,c])})});describe("alias",function(){it("should alias addListener with on",function(){spyOn(C.prototype,"addListener");C.prototype.on();expect(C.prototype.addListener).toHaveBeenCalled()});it("should alias removeListener with un",function(){spyOn(C.prototype,"removeListener");C.prototype.un();expect(C.prototype.removeListener).toHaveBeenCalled()});it("should alias addManagedListener with mon",function(){spyOn(C.prototype,"addManagedListener");C.prototype.mon();expect(C.prototype.addManagedListener).toHaveBeenCalled()});it("should alias removeManagedListener with mun",function(){spyOn(C.prototype,"removeManagedListener");C.prototype.mun();expect(C.prototype.removeManagedListener).toHaveBeenCalled()});it("should alias observe with observeClass for retro compatibility",function(){expect(C.observeClass).toEqual(C.observe)})});describe("capture/release",function(){var a;beforeEach(function(){spyOn(Ext.Function,"createInterceptor").andCallThrough();a=jasmine.createSpy("capturer");C.capture(U,a,J)});afterEach(function(){C.releaseCapture(U)});describe("capture",function(){it("should create an interceptor of observable fireEventArgs method",function(){expect(Ext.Function.createInterceptor).toHaveBeenCalled()})});describe("capturer",function(){it("should have the same signature as fireEvent",function(){U.fireEvent("foo","bar","baz");expect(a).toHaveBeenCalledWith("foo","bar","baz")})});describe("release",function(){beforeEach(function(){C.releaseCapture(U)});it("should restore the original fireEvent function",function(){expect(U.fireEventArgs).toEqual(C.prototype.fireEventArgs)})})});describe("observe",function(){var a,d,c,b;beforeEach(function(){a={fn:F,scope:J};d={fn:S,scope:J};C.observe(Z,{fired:a});c=new Z();b=new Z();if(c.hasListeners.fired){c.fireEvent("fired","You're Fired! (boss 1)")}if(b.hasListeners.fired){b.fireEvent("fired","You're Fired! (boss 2)")}c.on({fired:d});if(c.hasListeners.fired){c.fireEvent("fired","You're Fired! (boss 3)")}c.un("fired",S,J);if(c.hasListeners.fired){c.fireEvent("fired","You're Fired! (boss 4)")}Z.un("fired",F,J)});afterEach(function(){Z.un("fired",a);C.releaseCapture(Z)});it("should call bossFiredFn several times",function(){expect(F.callCount).toEqual(4)});it("should call bossFired2Fn",function(){expect(S.callCount).toEqual(1)});it("should have no listeners on instances",function(){expect(c.hasListeners.fired).toBeFalsy();expect(b.hasListeners.fired).toBeFalsy()});describe("first event firing",function(){var e;beforeEach(function(){e=F.calls[0]});it("should execute handler with the correct scope",function(){expect(e.object).toBe(J)});it("should execute handler with desired params",function(){expect(e.args).toEqual(["You're Fired! (boss 1)",a])})});describe("second event firing",function(){var e;beforeEach(function(){e=F.calls[1]});it("should execute handler with the correct scope",function(){expect(e.object).toBe(J)});it("should execute handler with desired params",function(){expect(e.args).toEqual(["You're Fired! (boss 2)",a])})});describe("third event firing",function(){var e;beforeEach(function(){e=F.calls[2]});it("should execute handler with the correct scope",function(){expect(e.object).toBe(J)});it("should execute handler with desired params",function(){expect(e.args).toEqual(["You're Fired! (boss 3)",a])})});describe("third event firing to instance",function(){var e;beforeEach(function(){e=S.calls[0]});it("should execute handler with the correct scope",function(){expect(e.object).toBe(J)});it("should execute handler with desired params",function(){expect(e.args).toEqual(["You're Fired! (boss 3)",d])})});describe("fourth event firing",function(){var e;beforeEach(function(){e=F.calls[3]});it("should execute handler with the correct scope",function(){expect(e.object).toBe(J)});it("should execute handler with desired params",function(){expect(e.args).toEqual(["You're Fired! (boss 4)",a])})})});describe("using mixin and extend in combination",function(){var c;function a(h,g){var f,e;if(g.charAt(0)===h){f=parseInt(g.charAt(1),10);if(f){e=h+(f+1)+g.substring(2)}else{e=h+"2"+g.substring(1)}}else{e=h+g}return e}function d(f,i){var g=a(i,f.name),e=g.toLowerCase(),h={base:f,fullName:"spec.observable."+g,name:g,lowerName:e,events:f.events.concat([e])};return h}function b(f,i){var g=d(f,"E");Ext.define(g.fullName,{extend:f.T,constructor:function(){this.callParent(arguments)}});var e={},h=d(f,"M");e[f.lowerName]=f.T;Ext.define(h.fullName,{mixins:e,constructor:function(){this.mixins[f.lowerName].constructor.apply(this,arguments)}});C.observe(g.T=spec.observable[g.name]);C.observe(h.T=spec.observable[h.name]);c.push(g,h);if(i){b(g,i-1);b(h,i-1)}}beforeEach(function(){c=[];b({T:C,name:"O",events:[]},5)});afterEach(function(){Ext.Array.forEach(c,function(e){Ext.undefine(e.fullName)});c=null});it("should prepare all classes",function(){Ext.Array.forEach(c,function(e){if(typeof e.T.HasListeners!=="function"){expect(e.fullName).toBe("prepared")}})});it("should fire events on instances",function(){Ext.Array.forEach(c,function(e){Ext.Array.forEach(e.events,function(j){var f=e.T,g=0,i={},h=function(){++g};i[j]=h;var k=new f({listeners:i});if(k.hasListeners[j]){k.fireEvent(j)}if(!g){expect(f.$className+" "+j+" event").toBe("fired")}k.un(j,h);if(k.hasListeners[j]){expect(f.$className+".hasListeners."+j).toBe("0 after")}})})});it("should fire events to all bases",function(){Ext.Array.forEach(c,function(f){var e=f.T,h=new e(),g;for(g=f.base;g;g=g.base){Ext.Array.forEach(g.events,function(k){var l=g.T,i=0,j=function(){++i};if(h.hasListeners[k]){expect(e.$className+".hasListeners."+k).toBe("0 before")}l.on(k,j);if(h.hasListeners[k]){h.fireEvent(k)}if(!i){expect(e.$className+" "+k+" event").toBe("fired")}l.un(k,j);if(h.hasListeners[k]){expect(e.$className+".hasListeners."+k).toBe("0 after")}})}})})});describe("listener merging",function(){var a,f,g,e,c,b;beforeEach(function(){e=jasmine.createSpy();c=jasmine.createSpy();b=jasmine.createSpy()});function d(){this.mixins.observable.constructor.apply(this,arguments)}afterEach(function(){e=c=b=g=a=f=null});describe("via mixin",function(){function h(i){f=Ext.define(null,Ext.apply({mixins:[C],constructor:d},i))}describe("direct mixin",function(){it("should fire events with listeners only on the instance",function(){h();g=new f({listeners:{foo:e}});g.fireEvent("foo");expect(e).toHaveBeenCalled()});it("should fire events with listeners only on the class",function(){h({listeners:{foo:e}});g=new f();g.fireEvent("foo");expect(e).toHaveBeenCalled()});it("should fire events with listeners on the class & instance",function(){h({listeners:{foo:e}});g=new f({listeners:{foo:c}});g.fireEvent("foo");expect(e).toHaveBeenCalled();expect(c).toHaveBeenCalled()})});describe("subclass of mixin",function(){beforeEach(function(){h({listeners:{foo:e}})});it("should fire events with listeners only on the instance",function(){a=Ext.define(null,{extend:f});g=new a({listeners:{foo:c}});g.fireEvent("foo");expect(e).toHaveBeenCalled();expect(c).toHaveBeenCalled()});it("should fire events with listeners only on the class",function(){a=Ext.define(null,{extend:f,listeners:{foo:c}});g=new a();g.fireEvent("foo");expect(e).toHaveBeenCalled();expect(c).toHaveBeenCalled()});it("should fire events with listeners on the class & instance",function(){a=Ext.define(null,{extend:f,listeners:{foo:c}});g=new a({listeners:{foo:b}});g.fireEvent("foo");expect(e).toHaveBeenCalled();expect(c).toHaveBeenCalled();expect(b).toHaveBeenCalled()})})});describe("via extend",function(){function h(i){f=Ext.define(null,Ext.apply({extend:C},i))}describe("direct subclass",function(){it("should fire events with listeners only on the instance",function(){h();g=new f({listeners:{foo:e}});g.fireEvent("foo");expect(e).toHaveBeenCalled()});it("should fire events with listeners only on the class",function(){h({listeners:{foo:e}});g=new f();g.fireEvent("foo");expect(e).toHaveBeenCalled()});it("should fire events with listeners on the class & instance",function(){h({listeners:{foo:e}});g=new f({listeners:{foo:c}});g.fireEvent("foo");expect(e).toHaveBeenCalled();expect(c).toHaveBeenCalled()})});describe("subclass of subclass",function(){beforeEach(function(){h({listeners:{foo:e}})});it("should fire events with listeners only on the instance",function(){a=Ext.define(null,{extend:f});g=new a({listeners:{foo:c}});g.fireEvent("foo");expect(e).toHaveBeenCalled();expect(c).toHaveBeenCalled()});it("should fire events with listeners only on the class",function(){a=Ext.define(null,{extend:f,listeners:{foo:c}});g=new a();g.fireEvent("foo");expect(e).toHaveBeenCalled();expect(c).toHaveBeenCalled()});it("should fire events with listeners on the class & instance",function(){a=Ext.define(null,{extend:f,listeners:{foo:c}});g=new a({listeners:{foo:b}});g.fireEvent("foo");expect(e).toHaveBeenCalled();expect(c).toHaveBeenCalled();expect(b).toHaveBeenCalled()})})})});describe("declarative listeners",function(){var d,c,b,e,a=[];beforeEach(function(){d=Ext.define(null,{mixins:[C],type:"ParentMixin",listeners:{foo:"parentMixinHandler",scope:"this"},constructor:function(f){this.mixins.observable.constructor.call(this,f)},parentMixinHandler:function(){a.push("parentMixin:"+this.id)}});c=Ext.define(null,{extend:d,mixinId:"childMixin",type:"ChildMixin",listeners:{foo:"childMixinHandler",scope:"this"},childMixinHandler:function(){a.push("childMixin:"+this.id)}});b=Ext.define(null,{mixins:[c],type:"ParentClass",listeners:{foo:"parentClassHandler",scope:"this"},constructor:function(f){this.mixins.childMixin.constructor.call(this,f)},parentClassHandler:function(){a.push("parentClass:"+this.id)}});e=Ext.define(null,{extend:b,type:"ChildClass",listeners:{foo:"childClassHandler",scope:"this"},childClassHandler:function(){a.push("childClass:"+this.id)}})});it("should call all the listeners",function(){var f=new e({listeners:{foo:function(){a.push("childInstance:"+this.id)}}});f.id="theId";f.fireEvent("foo");expect(a).toEqual(["parentMixin:theId","childMixin:theId","parentClass:theId","childClass:theId","childInstance:theId"])});it("should not call addListener if extending and no listeners are declared",function(){var f=jasmine.createSpy();var g=Ext.define(null,{extend:C,constructor:function(h){this.callParent(arguments)},addListener:f});new g();expect(f).not.toHaveBeenCalled()});it("should not call addListener if mixing in and no listeners are declared",function(){var f=jasmine.createSpy();var g=Ext.define(null,{mixins:[C],constructor:function(h){this.mixins.observable.constructor.apply(this,arguments)},addListener:f});new g();expect(f).not.toHaveBeenCalled()});describe("with options",function(){var h,g;function f(i){h=Ext.define(null,{mixins:[C],constructor:function(j){this.mixins.observable.constructor.apply(this,arguments)},listeners:i,trigger:function(){this.fireEvent("foo")}})}beforeEach(function(){g=jasmine.createSpy()});afterEach(function(){g=h=null});it("should default the scope to the class when specifying no scope & a function when using single: true",function(){f({foo:{single:true,fn:g}});var i=new h();i.trigger();expect(g.mostRecentCall.object).toBe(i)});it("should default the scope to the class when specifying no scope & a function when using delay",function(){f({foo:{delay:1,fn:g}});var i=new h();i.trigger();waitsFor(function(){return g.callCount>0},"Function never called");runs(function(){expect(g.mostRecentCall.object).toBe(i)})});it("should default the scope to the class when specifying no scope & a function when using buffer",function(){f({foo:{buffer:1,fn:g}});var i=new h();i.trigger();waitsFor(function(){return g.callCount>0},"Function never called");runs(function(){expect(g.mostRecentCall.object).toBe(i)})})})});describe("fireEventedAction",function(){var f;var e,c,d,a;var b;beforeEach(function(){c=e=d=a=null;b=false;f=Ext.define(null,{mixins:[C],constructor:function(){this.mixins.observable.constructor.call(this)},doFoo:function(i,g,h){d=Ext.Array.slice(arguments);if(b){h.pause()}return a},foo:function(h,g){this.fireEventedAction("foo",[this,h,g],"doFoo",this,false)}})});it("should fire events before and after the action",function(){var g=new f();g.on({blurp:42,beforefoo:function(j,i,h){expect(d).toBe(null);c=Ext.Array.slice(arguments)},foo:function(j,i,h){expect(d).not.toBe(null);e=Ext.Array.slice(arguments)}});g.foo(2,4);expect(c.length).toBe(5);expect(c[0]===g).toBe(true);expect(c[1]).toBe(2);expect(c[2]).toBe(4);expect(typeof c[3].pause).toBe("function");expect(c[4].blurp).toBe(42);expect(d.length).toBe(3);expect(d[0]).toBe(2);expect(d[1]).toBe(4);expect(typeof d[2].pause).toBe("function");expect(e.length).toBe(4);expect(e[0]===g).toBe(true);expect(e[1]).toBe(2);expect(e[2]).toBe(4);expect(e[3].blurp).toBe(42)});it("should allow before events to prevent action",function(){var g=new f();g.on({blurp:42,beforefoo:function(j,i,h){expect(d).toBe(null);c=Ext.Array.slice(arguments);return false},foo:function(j,i,h){expect(d!==null).toBe(true);e=Ext.Array.slice(arguments)}});g.foo(2,4);expect(d).toBe(null);expect(e).toBe(null);expect(c.length).toBe(5);expect(c[0]===g).toBe(true);expect(c[1]).toBe(2);expect(c[2]).toBe(4);expect(typeof c[3].pause).toBe("function");expect(c[4].blurp).toBe(42)});it("should allow action to prevent events",function(){var g=new f();g.on({blurp:42,beforefoo:function(j,i,h){expect(d).toBe(null);c=Ext.Array.slice(arguments)},foo:function(j,i,h){expect(d!==null).toBe(true);e=Ext.Array.slice(arguments)}});a=false;g.foo(2,4);expect(d!==null).toBe(true);expect(e).toBe(null);expect(c.length).toBe(5);expect(c[0]===g).toBe(true);expect(c[1]).toBe(2);expect(c[2]).toBe(4);expect(typeof c[3].pause).toBe("function");expect(c[4].blurp).toBe(42)});it("should allow pausing of action and events",function(){var g=new f();g.on({blurp:42,beforefoo:function(k,j,h,i){expect(d).toBe(null);c=Ext.Array.slice(arguments);i.pause()},foo:function(j,i,h){expect(d!==null).toBe(true);e=Ext.Array.slice(arguments)}});g.foo(2,4);expect(d).toBe(null);expect(e).toBe(null);expect(c.length).toBe(5);expect(c[0]===g).toBe(true);expect(c[1]).toBe(2);expect(c[2]).toBe(4);expect(typeof c[3].pause).toBe("function");expect(c[4].blurp).toBe(42);b=true;c[3].resume();expect(d.length).toBe(3);expect(d[0]).toBe(2);expect(d[1]).toBe(4);expect(typeof d[2].pause).toBe("function");expect(e).toBe(null);c[3].resume();expect(e.length).toBe(4);expect(e[0]===g).toBe(true);expect(e[1]).toBe(2);expect(e[2]).toBe(4);expect(e[3].blurp).toBe(42)})});describe("destroy",function(){it("should hook the clearListeners method on destroy when used as a mixin",function(){var a=Ext.define(null,{mixins:[C],constructor:function(){this.mixins.observable.constructor.call(this)}}),b=new a();spyOn(C.prototype,"clearListeners").andCallThrough();b.destroy();expect(C.prototype.clearListeners).toHaveBeenCalled()})})})}B(Ext.mixin.Observable);B(Ext.util.Observable)})()