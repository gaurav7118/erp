describe("Ext.promise.Promise",function(){var F=Ext.Deferred,A=Ext.promise.Promise,E={},H,I,G;if(Object.freeze){Object.freeze(E)}beforeEach(function(){G=Ext.log;Ext.log=Ext.emptyFn;H=I=null});afterEach(function(){Ext.log=G;H=I=G=null});function C(N,M,L){var K=false,J;N.then(function(O){J=O;K=true});waitsFor(function(){return K});runs(function(){if(L){expect(J).toEqual(M)}else{expect(J).toBe(M)}})}function B(O,L,M){var K=false,J,N;O.then(function(P){J=P;K=true},function(P){N=P;K=true});waitsFor(function(){return K});runs(function(){expect(J).toBe(undefined);if(typeof L==="string"){expect(N).toBe(L)}else{expect(N instanceof L).toBe(true);if(M){expect(N.message).toBe(M)}}})}function D(K){var J;if(K instanceof A){return"Promise"}if(K instanceof F){return"Deferred"}if(K instanceof Ext.ClassManager.get("Ext.Base")){return Ext.ClassManager.getName(K)}if(Ext.isArray(K)){J=Ext.Array.map(K,D);return"["+(J.join(", "))+"]"}if(Ext.isObject(K)){return"Object"}if(Ext.isString(K)){return'"'+K+'"'}return""+K}describe("resolved()",function(){var J=[void 0,null,false,0,1,"expected value",[1,2,3],{},new Error("error message")];describe("returns a Promise that will resolve with the specified value",function(){Ext.each(J,function(K){it(D(K),function(){I=F.resolved(K);expect(I instanceof A).toBe(true);C(I,K)})})});describe("returns a Promise that will resolve with the resolved value for the specified Promise when it resolves",function(){Ext.each(J,function(K){it(D(K),function(){var L=new F();L.resolve(K);I=F.resolved(L.promise);expect(I).not.toBe(L.promise);expect(I instanceof A).toBe(true);C(I,K)})})});describe("returns a Promise that will reject with the error associated with the specified Promise when it rejects",function(){it("Error: error message",function(){H=new F();H.reject(new Error("error message"));I=F.resolved(H.promise);expect(I).not.toBe(H.promise);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will adapt the specified untrusted (aka third-party) then-able",function(){var K=function(){};K.prototype.then=function(L,M){this.successCallback=L;this.failureCallback=M;switch(this.state){case"resolved":this.successCallback(this.value);break;case"rejected":this.failureCallback(this.value)}};K.prototype.resolve=function(L){this.value=L;this.state="resolved";if(this.successCallback!=null){this.successCallback(this.value)}};K.prototype.reject=function(L){this.value=L;this.state="rejected";if(this.failureCallback!=null){this.failureCallback(this.value)}};it("resolves when resolved",function(){var L=new K();L.resolve("expected value");I=F.resolved(L);expect(I).not.toBe(L);expect(I instanceof A).toBe(true);C(I,"expected value")});it("rejects when rejected",function(){var L=new K();L.reject("error message");I=F.resolved(L);expect(I).not.toBe(L);expect(I instanceof A).toBe(true);B(I,"error message")})})});describe("Promise.is()",function(){describe("returns true for a Promise or then()-able",function(){it("Promise",function(){I=new F().promise;expect(A.is(I)).toBe(true)});it("returns true for any then()-able",function(){I={then:function(){}};expect(A.is(I)).toBe(true)})});describe("returns false for non-promises",function(){var J=[void 0,null,false,0,1,"value",[1,2,3],{},new Error("error message")];Ext.each(J,function(K){it(D(K),function(){expect(A.is(K)).toBe(false)})})})});describe("all()",function(){describe("returns a new Promise that will resolve with the resolved values for the specified Array of Promises(s) or values.",function(){it("Empty Array",function(){var J=[];I=A.all(J);expect(I instanceof A).toBe(true);C(I,J,true)});it("Array with one value",function(){var J=["expected value"];I=A.all(J);expect(I instanceof A).toBe(true);C(I,J,true)});it("Array of values",function(){var J=[1,2,3];I=A.all(J);expect(I instanceof A).toBe(true);C(I,J,true)});it("Sparse Array",function(){var J=[,2,,4,5];I=A.all(J);expect(I instanceof A).toBe(true);C(I,J,true)});it("Array with one resolved Promise",function(){I=A.all([F.resolved("expected value")]);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Array of resolved Promises",function(){I=A.all([F.resolved(1),F.resolved(2),F.resolved(3)]);expect(I instanceof A).toBe(true);C(I,[1,2,3],true)})});describe("returns a new Promise that will resolve with the resolved values for the specified resolved Promise of an Array of Promises(s) or values.",function(){it("Promise of an empty Array",function(){I=A.all(F.resolved([]));expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an Array with one value",function(){I=A.all(F.resolved(["expected value"]));expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Promise of an Array of values",function(){I=A.all(F.resolved([1,2,3]));expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Promise of a sparse Array",function(){I=A.all(F.resolved([,2,,4,5]));expect(I instanceof A).toBe(true);C(I,[,2,,4,5],true)});it("Promise of an Array with one resolved Promise",function(){I=A.all(F.resolved([F.resolved("expected value")]));expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Promise of an Array of resolved Promises",function(){I=A.all(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]));expect(I instanceof A).toBe(true);C(I,[1,2,3],true)})});describe("returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects",function(){it("Array with one rejected Promise",function(){I=A.all([F.rejected(new Error("error message"))]);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of resolved Promises and a rejected Promise",function(){I=A.all([F.resolved(1),F.rejected(new Error("error message")),F.resolved(3)]);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values, pending and resolved Promises and a rejected Promise",function(){I=A.all([1,2,F.rejected(new Error("error message")),F.resolved(4),new F().promise]);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects",function(){it("Promise of an Array with one rejected Promise",function(){I=A.all(F.resolved([F.rejected(new Error("error message"))]));expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of resolved Promises and a rejected Promise",function(){I=A.all(F.resolved([F.resolved(1),F.rejected(new Error("error message")),F.resolved(3)]));expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values, pending and resolved Promises and a rejected Promise",function(){I=A.all(F.resolved([1,2,F.rejected(new Error("error message")),F.resolved(4),new F().promise]));expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)",function(){it("Error: error message",function(){I=A.all(F.rejected(new Error("error message")));expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("throws an Error if anything other than Array or Promise of an Array is specified",function(){it("no parameters",function(){expect(function(){return A.all()}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("a single non-Array parameter",function(){expect(function(){return A.all(1)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("multiple non-Array parameters",function(){expect(function(){return A.all(1,2,3)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")})})});describe("any()",function(){function J(N,M){var L=false,K;N.then(function(O){K=O;L=true});waitsFor(function(){return L});runs(function(){expect(Ext.Array.indexOf(M,K)).not.toBe(-1)})}describe("returns a new Promise that will resolve once any one of the specified Array of Promises(s) or values have resolved.",function(){it("Array with one value",function(){I=F.any(["expected value"]);expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Array of values",function(){I=F.any([1,2,3]);expect(I instanceof A).toBe(true);J(I,[1,2,3])});it("Sparse Array",function(){I=F.any([,2,,4,5]);expect(I instanceof A).toBe(true);J(I,[2,4,5])});it("Array with one resolved Promise",function(){I=F.any([F.resolved("expected value")]);expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Array of resolved Promises",function(){I=F.any([F.resolved(1),F.resolved(2),F.resolved(3)]);expect(I instanceof A).toBe(true);J(I,[1,2,3])});it("Array of rejected Promises and one resolved Promise",function(){I=F.any([F.rejected("error message"),F.resolved("expected value"),F.rejected("error message")]);expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Array of pending and rejected Promises and one resolved Promise",function(){I=F.any([new F().promise,F.resolved("expected value"),F.rejected("error message")]);expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Array of pending and rejected Promises and multiple resolved Promises",function(){I=F.any([new F().promise,F.resolved(1),F.rejected("error message"),F.resolved(2)]);expect(I instanceof A).toBe(true);J(I,[1,2])})});describe("returns a new Promise that will resolve once any one of the specified resolved Promise of an Array of Promises(s) or values have resolved.",function(){it("Promise of an Array with one value",function(){I=F.any(F.resolved(["expected value"]));expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Promise of an Array of values",function(){I=F.any(F.resolved([1,2,3]));expect(I instanceof A).toBe(true);J(I,[1,2,3])});it("Promise of a sparse Array",function(){I=F.any(F.resolved([,2,,4,5]));expect(I instanceof A).toBe(true);J(I,[2,4,5])});it("Promise of an Array with one resolved Promise",function(){I=F.any(F.resolved([F.resolved("expected value")]));expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Promise of an Array of resolved Promise",function(){I=F.any(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]));expect(I instanceof A).toBe(true);J(I,[1,2,3])});it("Promise of an Array of rejected Promises and one resolved Promise",function(){I=F.any(F.resolved([F.rejected("error message"),F.resolved("expected value"),F.rejected("error message")]));expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Promise of an Array of pending and rejected Promises and one resolved Promise",function(){I=F.any(F.resolved([new F().promise,F.resolved("expected value"),F.rejected("error message")]));expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Promise of an Array of pending and rejected Promises and multiple resolved Promises",function(){I=F.any(F.resolved([new F().promise,F.resolved(1),F.rejected("error message"),F.resolved(2)]));expect(I instanceof A).toBe(true);J(I,[1,2])})});describe("returns a new Promise that will reject if none of the specified Array of Promises(s) or values resolves.",function(){it("Empty Array",function(){I=F.any([]);expect(I instanceof A).toBe(true);B(I,Error,"No Promises were resolved.")});it("Array with one rejected Promise",function(){I=F.any([F.rejected("error message")]);expect(I instanceof A).toBe(true);B(I,Error,"No Promises were resolved.")});it("Array of rejected Promises",function(){I=F.any([F.rejected("error message"),F.rejected("error message"),F.rejected("error message")]);expect(I instanceof A).toBe(true);B(I,Error,"No Promises were resolved.")})});describe("returns a new Promise that will reject if none of the specified resolved Promise of an Array of Promises(s) or values resolves.",function(){it("Promise of an empty Array",function(){I=F.any(F.resolved([]));expect(I instanceof A).toBe(true);B(I,Error,"No Promises were resolved.")});it("Promise of an Array with one rejected Promise",function(){I=F.any(F.resolved([F.rejected("error message")]));expect(I instanceof A).toBe(true);B(I,Error,"No Promises were resolved.")});it("Promise of an Array of rejected Promises",function(){I=F.any(F.resolved([F.rejected("error message"),F.rejected("error message"),F.rejected("error message")]));expect(I instanceof A).toBe(true);B(I,Error,"No Promises were resolved.")})});describe("returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)",function(){it("Error: error message",function(){I=F.any(F.rejected(new Error("error message")));expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("throws an Error if anything other than Array or Promise of an Array is specified",function(){it("no parameters",function(){expect(function(){return F.any()}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("a single non-Array parameter",function(){expect(function(){return F.any(1)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("multiple non-Array parameters",function(){expect(function(){return F.any(1,2,3)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")})})});describe("some()",function(){function J(O,N,M){var L=false,K;O.then(function(P){K=P;L=true});waitsFor(function(){return L});runs(function(){expect(K.length).toBe(N);var R={};for(var Q=0;Q<K.length;++Q){var P=Ext.Array.indexOf(M,K[Q]);expect(P).not.toBe(-1);expect(R[P]).not.toBe(true);R[P]=true}})}describe("returns a new Promise that will resolve once the specified number of the specified Array of Promises(s) or values have resolved.",function(){it("Array with one value",function(){I=F.some(["expected value"],1);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Array of values",function(){I=F.some([1,2,3],2);expect(I instanceof A).toBe(true);J(I,2,[1,2,3])});it("Sparse Array",function(){I=F.some([,2,,4,5],2);expect(I instanceof A).toBe(true);J(I,2,[2,4,5])});it("Array with one resolved Promise",function(){I=F.some([F.resolved("expected value")],1);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Array of resolved Promises",function(){I=F.some([F.resolved(1),F.resolved(2),F.resolved(3)],2);expect(I instanceof A).toBe(true);J(I,2,[1,2,3])});it("Array of rejected Promises and one resolved Promise",function(){I=F.some([F.rejected("error message"),F.resolved("expected value"),F.rejected("error message")],1);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Array of pending and rejected Promises and one resolved Promise",function(){I=F.some([new F().promise,F.resolved("expected value"),F.rejected("error message")],1);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Array of rejected Promises and multiple resolved Promises",function(){I=F.some([F.rejected("error message"),F.resolved(1),F.rejected("error message"),F.resolved(2)],2);expect(I instanceof A).toBe(true);J(I,2,[1,2])});it("Array of pending and rejected Promises and multiple resolved Promises",function(){I=F.some([new F().promise,F.resolved(1),F.rejected("error message"),F.resolved(2)],2);expect(I instanceof A).toBe(true);J(I,2,[1,2])})});describe("returns a new Promise that will resolve once the specified number of the specified resolved Promise of an Array of Promises(s) or values have resolved.",function(){it("Promise of an Array with one value",function(){I=F.some(F.resolved(["expected value"]),1);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Promise of an Array of values",function(){I=F.some(F.resolved([1,2,3]),2);expect(I instanceof A).toBe(true);J(I,2,[1,2,3])});it("Promise of a sparse Array",function(){I=F.some(F.resolved([,2,,4,5]),2);expect(I instanceof A).toBe(true);J(I,2,[2,4,5])});it("Promise of an Array with one resolved Promise",function(){I=F.some(F.resolved([F.resolved("expected value")]),1);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Promise of an Array of resolved Promises",function(){I=F.some(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),2);expect(I instanceof A).toBe(true);J(I,2,[1,2,3])});it("Promise of an Array of rejected Promises and one resolved Promise",function(){I=F.some(F.resolved([F.rejected("error message"),F.resolved("expected value"),F.rejected("error message")]),1);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Promise of an Array of pending and rejected Promises and one resolved Promise",function(){I=F.some(F.resolved([new F().promise,F.resolved("expected value"),F.rejected("error message")]),1);expect(I instanceof A).toBe(true);C(I,["expected value"],true)});it("Promise of an Array of rejected Promises and multiple resolved Promises",function(){I=F.some(F.resolved([F.rejected("error message"),F.resolved(1),F.rejected("error message"),F.resolved(2)]),2);expect(I instanceof A).toBe(true);J(I,2,[1,2])});it("Promise of an Array of pending and rejected Promises and multiple resolved Promises",function(){I=F.some(F.resolved([new F().promise,F.resolved(1),F.rejected("error message"),F.resolved(2)]),2);expect(I instanceof A).toBe(true);J(I,2,[1,2])})});describe("returns a new Promise that will reject if too few of the specified Array of Promises(s) or values resolves.",function(){it("Empty Array with one resolved value requested",function(){I=F.some([],1);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Empty Array with multiple resolved values requested",function(){I=F.some([],2);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Array with one rejected Promise with one resolved value requested",function(){I=F.some([F.rejected("error message")],1);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Array with one rejected Promise with multiple resolved values requested",function(){I=F.some([F.rejected("error message")],2);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Array of rejected Promises with one resolved value requested",function(){I=F.some([F.rejected("error message"),F.rejected("error message"),F.rejected("error message")],1);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Array of rejected Promises with multiple resolved values requested",function(){I=F.some([F.rejected("error message"),F.rejected("error message"),F.rejected("error message")],2);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")})});describe("returns a new Promise that will reject if too few of the specified resolved Promise of an Array of Promises(s) or values resolves.",function(){it("Promise of an empty Array with one resolved value requested",function(){I=F.some(F.resolved([]),1);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Promise of an empty Array with multiple resolved values requested",function(){I=F.some(F.resolved([]),2);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Promise of an Array with one rejected Promise with one resolved value requested",function(){I=F.some(F.resolved([F.rejected("error message")]),1);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Promise of an Array with one rejected Promise with multiple resolved values requested",function(){I=F.some(F.resolved([F.rejected("error message")]),2);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Promise of an Array of rejected Promises with one resolved value requested",function(){I=F.some(F.resolved([F.rejected("error message"),F.rejected("error message"),F.rejected("error message")]),1);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")});it("Promise of an Array of rejected Promises with multiple resolved values requested",function(){I=F.some(F.resolved([F.rejected("error message"),F.rejected("error message"),F.rejected("error message")]),2);expect(I instanceof A).toBe(true);B(I,Error,"Too few Promises were resolved.")})});describe("returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)",function(){it("Error: error message",function(){I=F.some(F.rejected(new Error("error message")),2);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("throws an Error if anything other than Array or Promise of an Array is specified",function(){it("no parameters",function(){expect(function(){return F.some()}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("a single non-Array parameter",function(){expect(function(){return F.some(1)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("multiple non-Array parameters",function(){expect(function(){return F.some(1,2,3)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("a single Array parameter",function(){expect(function(){return F.some([1,2,3])}).toThrow("Invalid parameter: expected a positive integer.")});it("a single Array parameter and a non-numeric value",function(){expect(function(){return F.some([1,2,3],"value")}).toThrow("Invalid parameter: expected a positive integer.")})})});describe("delay()",function(){describe("returns a new Promise that will resolve after the specified delay",function(){it("0 ms delay",function(){I=F.delay(0);expect(I instanceof A).toBe(true);C(I,void 0,true)});it("value with 100 ms delay",function(){I=F.delay(100);var J=Ext.now();expect(I instanceof A).toBe(true);I=I.then(function(K){expect(Ext.now()-J).toBeGE(84);return K});C(I,void 0,true)})});describe("returns a new Promise that will resolve with the specified Promise or value after the specified delay",function(){it("value with 0 ms delay",function(){I=F.delay("expected value",0);expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("resolved Promise with 0 delay",function(){I=F.delay(F.resolved("expected value"),0);expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("value with 100 ms delay",function(){I=F.delay("expected value",100);var J=Ext.now();expect(I instanceof A).toBe(true);I=I.then(function(K){expect(Ext.now()-J).toBeGE(84);return K});C(I,"expected value",true)});it("resolved Promise with 100 ms delay",function(){I=F.delay(F.resolved("expected value"),100);var J=Ext.now();expect(I instanceof A).toBe(true);I=I.then(function(K){expect(Ext.now()-J).toBeGE(84);return K});C(I,"expected value",true)})});describe("returns a new Promise that will reject with the error associated with the specified rejected Promise after the specified delay",function(){it("rejected Promise with 100 ms delay",function(){I=F.delay(F.rejected(new Error("error message")),100);var J=Ext.now();expect(I instanceof A).toBe(true);I=I.then(function(K){return K},function(K){expect(Ext.now()-J).toBeGE(84);throw K});B(I,Error,"error message")})})});(Ext.isGecko?xdescribe:describe)("timeout()",function(){describe("returns a new Promise that will resolve with the specified Promise or value if it resolves before the specified timeout",function(){it("value with 100 ms timeout",function(){I=F.timeout("expected value",100);expect(I instanceof A).toBe(true);C(I,"expected value",true)});it("Promise that resolves in 50 ms with a 100 ms timeout",function(){I=F.timeout(F.delay("expected value",50),100);expect(I instanceof A).toBe(true);C(I,"expected value",true)})});describe("returns a new Promise that will reject with the error associated with the specified rejected Promise if it rejects before the specified timeout",function(){it("Promise that rejects in 50 ms with a 100 ms timeout",function(){I=F.timeout(F.delay(F.rejected(new Error("error message")),50),100);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject after the specified timeout if the specified Promise or value has not yet resolved or rejected",function(){it("Promise that resolves in 100 ms with a 50 ms timeout",function(){I=F.timeout(F.delay("expected value",100),50);expect(I instanceof A).toBe(true);B(I,Error,"Promise timed out.")});it("Promise that rejects in 50 ms with a 100 ms timeout",function(){I=F.timeout(F.delay(F.rejected(new Error("error message")),100),50);expect(I instanceof A).toBe(true);B(I,Error,"Promise timed out.")})})});describe("memoize()",function(){function J(L){return(L<2)?L:J(L-1)+J(L-2)}function K(L){++K.calls;K.scope=this;return J(L)}beforeEach(function(){K.calls=0;delete K.scope});describe("returns a new function that wraps the specified function, caching results for previously processed inputs, and returns a Promise that will resolve with the result value",function(){it("value",function(){var L=F.memoize(K);I=A.all([L(12),L(12)]).then(function(M){expect(K.calls).toBe(1);return M},function(M){throw M});C(I,[J(12),J(12)],true)});it("resolved Promise",function(){var L=F.memoize(K);I=A.all([L(F.resolved(12)),L(F.resolved(12))]).then(function(M){expect(K.calls).toBe(1);return M},function(M){throw M});C(I,[J(12),J(12)],true)})});describe("executes the wrapped function in the optionally specified scope",function(){it("optional scope omitted",function(){var L=F.memoize(K);I=L(12).then(function(M){expect(K.calls).toBe(1);expect(K.scope==window).toBe(true);return M},function(M){throw M});C(I,J(12),true)});it("scope specified",function(){var L=F.memoize(K,E);I=L(12).then(function(M){expect(K.calls).toBe(1);expect(K.scope).toBe(E);return M},function(M){throw M});C(I,J(12),true)})});describe("returns a new function that wraps the specified function and returns a Promise that will reject with the associated error when the wrapper function is called with a rejected Promise",function(){it("rejected Promise",function(){var L=F.memoize(K);I=L(F.rejected(new Error("error message")));B(I,Error,"error message")})})});describe("map()",function(){function J(N,M,O){expect(arguments.length).toBe(3);expect(O instanceof Array).toBe(true);expect(M).toBeGE(0);expect(M).toBeLT(O.length);return N*2}function K(N,M,O){expect(arguments.length).toBe(3);expect(O instanceof Array).toBe(true);expect(M).toBeGE(0);expect(M).toBeLT(O.length);return F.resolved(N*2)}function L(N,M,O){expect(arguments.length).toBe(3);expect(O instanceof Array).toBe(true);expect(M).toBeGE(0);expect(M).toBeLT(O.length);return F.rejected(new Error("error message"))}describe("returns a new Promise that will resolve with an Array of the mapped values for the specified Array of Promise(s) or value(s)",function(){it("Empty Array",function(){I=F.map([],J);expect(I instanceof A).toBe(true);C(I,[],true)});it("Array with one value",function(){I=F.map([1],J);expect(I instanceof A).toBe(true);C(I,[2],true)});it("Array of values",function(){I=F.map([1,2,3],J);expect(I instanceof A).toBe(true);C(I,[2,4,6],true)});it("Sparse Array",function(){I=F.map([,2,,4,5],J);expect(I instanceof A).toBe(true);C(I,[,4,,8,10],true)});it("Array with one resolved Promise",function(){I=F.map([F.resolved(1)],J);expect(I instanceof A).toBe(true);C(I,[2],true)});it("Array of resolved Promises",function(){I=F.map([F.resolved(1),F.resolved(2),F.resolved(3)],J);expect(I instanceof A).toBe(true);C(I,[2,4,6],true)});it("Array of values and resolved Promises",function(){I=F.map([1,F.resolved(2),F.resolved(3),4],J);expect(I instanceof A).toBe(true);C(I,[2,4,6,8],true)})});describe("returns a new Promise that will resolve with an Array of the mapped values for the specified resolved Promise of an Array of Promise(s) or value(s)",function(){it("Promise of an empty Array",function(){I=F.map(F.resolved([]),J);expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an Array with one value",function(){I=F.map(F.resolved([1]),J);expect(I instanceof A).toBe(true);C(I,[2],true)});it("Promise of an Array of values",function(){I=F.map(F.resolved([1,2,3]),J);expect(I instanceof A).toBe(true);C(I,[2,4,6],true)});it("Promise of a sparse Array",function(){I=F.map(F.resolved([,2,,4,5]),J);expect(I instanceof A).toBe(true);C(I,[,4,,8,10],true)});it("Promise of an Array with one resolved Promise",function(){I=F.map(F.resolved([F.resolved(1)]),J);expect(I instanceof A).toBe(true);C(I,[2],true)});it("Promise of an Array of resolved Promises",function(){I=F.map(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),J);expect(I instanceof A).toBe(true);C(I,[2,4,6],true)});it("Promise of an Array of values and resolved Promises",function(){I=F.map(F.resolved([1,F.resolved(2),F.resolved(3),4]),J);expect(I instanceof A).toBe(true);C(I,[2,4,6,8],true)})});describe("returns a new Promise that will resolve with an Array of the resolved mapped Promises values for the specified Array of Promise(s) or value(s)",function(){it("Empty Array",function(){I=F.map([],K);expect(I instanceof A).toBe(true);C(I,[],true)});it("Array with one value",function(){I=F.map([1],K);expect(I instanceof A).toBe(true);C(I,[2],true)});it("Array of values",function(){I=F.map([1,2,3],K);expect(I instanceof A).toBe(true);C(I,[2,4,6],true)});it("Sparse Array",function(){I=F.map([,2,,4,5],K);expect(I instanceof A).toBe(true);C(I,[,4,,8,10],true)});it("Array with one resolved Promise",function(){I=F.map([F.resolved(1)],K);expect(I instanceof A).toBe(true);C(I,[2],true)});it("Array of resolved Promises",function(){I=F.map([F.resolved(1),F.resolved(2),F.resolved(3)],K);expect(I instanceof A).toBe(true);C(I,[2,4,6],true)});it("Array of values and resolved Promises",function(){I=F.map([1,F.resolved(2),F.resolved(3),4],K);expect(I instanceof A).toBe(true);C(I,[2,4,6,8],true)})});describe("returns a new Promise that will resolve with an Array of the resolved mapped Promises values for the specified resolved Promise of an Array of Promise(s) or value(s)",function(){it("Promise of an empty Array",function(){I=F.map(F.resolved([]),K);expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an Array with one value",function(){I=F.map(F.resolved([1]),K);expect(I instanceof A).toBe(true);C(I,[2],true)});it("Promise of an Array of values",function(){I=F.map(F.resolved([1,2,3]),K);expect(I instanceof A).toBe(true);C(I,[2,4,6],true)});it("Promise of a sparse Array",function(){I=F.map(F.resolved([,2,,4,5]),K);expect(I instanceof A).toBe(true);C(I,[,4,,8,10],true)});it("Promise of an Array with one resolved Promise",function(){I=F.map(F.resolved([F.resolved(1)]),K);expect(I instanceof A).toBe(true);C(I,[2],true)});it("Promise of an Array of resolved Promises",function(){I=F.map(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),K);expect(I instanceof A).toBe(true);C(I,[2,4,6],true)});it("Promise of an Array of values and resolved Promises",function(){I=F.map(F.resolved([1,F.resolved(2),F.resolved(3),4]),K);expect(I instanceof A).toBe(true);C(I,[2,4,6,8],true)})});describe("returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects",function(){it("Array with one rejected Promise",function(){I=F.map([F.rejected(new Error("error message"))],J);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values and a rejected Promise",function(){I=F.map([1,F.rejected(new Error("error message")),3],J);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of resolved Promises and a rejected Promise",function(){I=F.map([F.resolved(1),F.rejected(new Error("error message")),F.resolved(3)],J);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values, pending and resolved Promises and a rejected Promise",function(){I=F.map([1,2,F.rejected(new Error("error message")),F.resolved(4),new F().promise],J);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects",function(){it("Promise of an Array with one rejected Promise",function(){I=F.map(F.resolved([F.rejected(new Error("error message"))]),J);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values and a rejected Promise",function(){I=F.map(F.resolved([1,F.rejected(new Error("error message")),3]),J);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of resolved Promises and a rejected Promise",function(){I=F.map(F.resolved([F.resolved(1),F.rejected(new Error("error message")),F.resolved(3)]),J);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values, pending and resolved Promises and a rejected Promise",function(){I=F.map(F.resolved([1,2,F.rejected(new Error("error message")),F.resolved(4),new F().promise]),J);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the first mapped Promise value in the specified Array of Promise(s) or value(s) that rejects",function(){it("Array with one value",function(){I=F.map([1],L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values",function(){I=F.map([1,2,3],L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Sparse Array",function(){I=F.map([,2,,4,5],L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array with one resolved Promise",function(){I=F.map([F.resolved(1)],L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of resolved Promises",function(){I=F.map([F.resolved(1),F.resolved(2),F.resolved(3)],L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values and resolved Promises",function(){I=F.map([1,F.resolved(2),F.resolved(3),4],L);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the first mapped Promise value in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects",function(){it("Promise of an Array with one value",function(){I=F.map(F.resolved([1]),L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values",function(){I=F.map(F.resolved([1,2,3]),L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of a sparse Array",function(){I=F.map(F.resolved([,2,,4,5]),L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array with one resolved Promise",function(){I=F.map(F.resolved([F.resolved(1)]),L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of resolved Promises",function(){I=F.map(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),L);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values and resolved Promises",function(){I=F.map(F.resolved([1,F.resolved(2),F.resolved(3),4]),L);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)",function(){it("Error: error message",function(){I=F.map(F.rejected(new Error("error message")),J);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("throws an Error if anything other than an Array or Promise of an Array and a function are specified",function(){it("no parameters",function(){expect(function(){return F.map()}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("a single non-Array parameter",function(){expect(function(){return F.map(1)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("multiple non-Array parameters",function(){expect(function(){return F.map(1,2,3)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("an Array and no function",function(){expect(function(){return F.map([1,2,3])}).toThrow("Invalid parameter: expected a function.")});it("a Promise of an Array and no function",function(){expect(function(){return F.map(F.resolved([1,2,3]))}).toThrow("Invalid parameter: expected a function.")});it("an Array and a non-function parameter",function(){expect(function(){return F.map([1,2,3],"not a function")}).toThrow("Invalid parameter: expected a function.")});it("a Promise of a non-function parameter",function(){expect(function(){return F.map(F.resolved([1,2,3],"not a function"))}).toThrow("Invalid parameter: expected a function.")})})});describe("reduce()",function(){function K(M,O,N,P){expect(arguments.length).toBe(4);expect(P instanceof Array).toBe(true);expect(N).toBeGE(0);expect(N).toBeLT(P.length);return M+O}function L(M,O,N,P){expect(arguments.length).toBe(4);expect(P instanceof Array).toBe(true);expect(N).toBeGE(0);expect(N).toBeLT(P.length);return F.resolved(M+O)}function J(M,O,N,P){expect(arguments.length).toBe(4);expect(P instanceof Array).toBe(true);expect(N).toBeGE(0);expect(N).toBeLT(P.length);return F.rejected(new Error("error message"))}describe("returns a Promise that will resolve with the value obtained by reducing the specified Array of Promise(s) or value(s) using the specified function and initial value",function(){it("Empty Array and an initial value",function(){I=F.reduce([],K,0);expect(I instanceof A).toBe(true);C(I,0,true)});it("Empty Array and a resolved Promise of an initial value",function(){I=F.reduce([],K,F.resolved(0));expect(I instanceof A).toBe(true);C(I,0,true)});it("Array with one value",function(){I=F.reduce([1],K);expect(I instanceof A).toBe(true);C(I,1,true)});it("Array with one value and an initial value",function(){I=F.reduce([1],K,10);expect(I instanceof A).toBe(true);C(I,11,true)});it("Array with one value and a resolved Promise of an initial value",function(){I=F.reduce([1],K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,11,true)});it("Array of values",function(){I=F.reduce([1,2,3,4],K);expect(I instanceof A).toBe(true);C(I,10,true)});it("Array of values and an initial value",function(){I=F.reduce([1,2,3,4],K,10);expect(I instanceof A).toBe(true);C(I,20,true)});it("Array of values and a resolved Promise of an initial value",function(){I=F.reduce([1,2,3,4],K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,20,true)});it("Sparse Array",function(){I=F.reduce([,2,,4,5],K);expect(I instanceof A).toBe(true);C(I,11,true)});it("Sparse Array and an initial value",function(){I=F.reduce([,2,,4,5],K,10);expect(I instanceof A).toBe(true);C(I,21,true)});it("Sparse Array and a resolved Promise of an initial value",function(){I=F.reduce([,2,,4,5],K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,21,true)});it("Array with one resolved Promise",function(){I=F.reduce([F.resolved(1)],K);expect(I instanceof A).toBe(true);C(I,1,true)});it("Array with one resolved Promise and an initial value",function(){I=F.reduce([F.resolved(1)],K,10);expect(I instanceof A).toBe(true);C(I,11,true)});it("Array with one resolved Promise and a resolved Promise of an initial value",function(){I=F.reduce([F.resolved(1)],K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,11,true)});it("Array of resolved Promises",function(){I=F.reduce([F.resolved(1),F.resolved(2),F.resolved(3)],K);expect(I instanceof A).toBe(true);C(I,6,true)});it("Array of resolved Promises and an initial value",function(){I=F.reduce([F.resolved(1),F.resolved(2),F.resolved(3)],K,10);expect(I instanceof A).toBe(true);C(I,16,true)});it("Array of resolved Promises and a resolved Promise of an initial value",function(){I=F.reduce([F.resolved(1),F.resolved(2),F.resolved(3)],K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,16,true)});it("Array of values and resolved Promises",function(){I=F.reduce([1,F.resolved(2),3,F.resolved(4)],K);expect(I instanceof A).toBe(true);C(I,10,true)});it("Array of values and resolved Promises and an initial value",function(){I=F.reduce([1,F.resolved(2),3,F.resolved(4)],K,10);expect(I instanceof A).toBe(true);C(I,20,true)});it("Array of values and resolved Promises and a resolved Promise of an initial value",function(){I=F.reduce([1,F.resolved(2),3,F.resolved(4)],K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,20,true)})});describe("returns a Promise that will resolve with the value obtained by reducing the specified resolved Promise of an Array of Promise(s) or value(s) using the specified function and initial value",function(){it("Promise of an empty Array and an initial value",function(){I=F.reduce(F.resolved([]),K,0);expect(I instanceof A).toBe(true);C(I,0,true)});it("Promise of an empty Array and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([]),K,F.resolved(0));expect(I instanceof A).toBe(true);C(I,0,true)});it("Promise of an Array with one value",function(){I=F.reduce(F.resolved([1]),K);expect(I instanceof A).toBe(true);C(I,1,true)});it("Promise of an Array with one value and an initial value",function(){I=F.reduce(F.resolved([1]),K,10);expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of an Array with one value and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([1]),K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of an Array of values",function(){I=F.reduce(F.resolved([1,2,3,4]),K);expect(I instanceof A).toBe(true);C(I,10,true)});it("Promise of an Array of values and an initial value",function(){I=F.reduce(F.resolved([1,2,3,4]),K,10);expect(I instanceof A).toBe(true);C(I,20,true)});it("Promise of an Array of values and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([1,2,3,4]),K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,20,true)});it("Promise of a sparse Array",function(){I=F.reduce(F.resolved([,2,,4,5]),K);expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of a sparse Array and an initial value",function(){I=F.reduce(F.resolved([,2,,4,5]),K,10);expect(I instanceof A).toBe(true);C(I,21,true)});it("Promise of a sparse Array and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([,2,,4,5]),K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,21,true)});it("Promise of an Array with one resolved Promise",function(){I=F.reduce(F.resolved([F.resolved(1)]),K);expect(I instanceof A).toBe(true);C(I,1,true)});it("Promise of an Array with one resolved Promise and an initial value",function(){I=F.reduce(F.resolved([F.resolved(1)]),K,10);expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of an Array with one resolved Promise and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([F.resolved(1)]),K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of an Array of resolved Promises",function(){I=F.reduce(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),K);expect(I instanceof A).toBe(true);C(I,6,true)});it("Promise of an Array of resolved Promises and an initial value",function(){I=F.reduce(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),K,10);expect(I instanceof A).toBe(true);C(I,16,true)});it("Promise of an Array of resolved Promises and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,16,true)});it("Promise of an Array of values and resolved Promises",function(){I=F.reduce(F.resolved([1,F.resolved(2),3,F.resolved(4)]),K);expect(I instanceof A).toBe(true);C(I,10,true)});it("Promise of an Array of values and resolved Promises and an initial value",function(){I=F.reduce(F.resolved([1,F.resolved(2),3,F.resolved(4)]),K,10);expect(I instanceof A).toBe(true);C(I,20,true)});it("Promise of an Array of values and resolved Promises and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([1,F.resolved(2),3,F.resolved(4)]),K,F.resolved(10));expect(I instanceof A).toBe(true);C(I,20,true)})});describe("returns a Promise that will resolve with the resolved Promise value obtained by reducing the specified Array of Promise(s) or value(s) using the specified function and initial value",function(){it("Empty Array and an initial value",function(){I=F.reduce([],L,0);expect(I instanceof A).toBe(true);C(I,0,true)});it("Empty Array and a resolved Promise of an initial value",function(){I=F.reduce([],L,F.resolved(0));expect(I instanceof A).toBe(true);C(I,0,true)});it("Array with one value",function(){I=F.reduce([1],L);expect(I instanceof A).toBe(true);C(I,1,true)});it("Array with one value and an initial value",function(){I=F.reduce([1],L,10);expect(I instanceof A).toBe(true);C(I,11,true)});it("Array with one value and a resolved Promise of an initial value",function(){I=F.reduce([1],L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,11,true)});it("Array of values",function(){I=F.reduce([1,2,3,4],L);expect(I instanceof A).toBe(true);C(I,10,true)});it("Array of values and an initial value",function(){I=F.reduce([1,2,3,4],L,10);expect(I instanceof A).toBe(true);C(I,20,true)});it("Array of values and a resolved Promise of an initial value",function(){I=F.reduce([1,2,3,4],L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,20,true)});it("Sparse Array",function(){I=F.reduce([,2,,4,5],L);expect(I instanceof A).toBe(true);C(I,11,true)});it("Sparse Array and an initial value",function(){I=F.reduce([,2,,4,5],L,10);expect(I instanceof A).toBe(true);C(I,21,true)});it("Sparse Array and a resolved Promise of an initial value",function(){I=F.reduce([,2,,4,5],L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,21,true)});it("Array with one resolved Promise",function(){I=F.reduce([F.resolved(1)],L);expect(I instanceof A).toBe(true);C(I,1,true)});it("Array with one resolved Promise and an initial value",function(){I=F.reduce([F.resolved(1)],L,10);expect(I instanceof A).toBe(true);C(I,11,true)});it("Array with one resolved Promise and a resolved Promise of an initial value",function(){I=F.reduce([F.resolved(1)],L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,11,true)});it("Array of resolved Promises",function(){I=F.reduce([F.resolved(1),F.resolved(2),F.resolved(3)],L);expect(I instanceof A).toBe(true);C(I,6,true)});it("Array of resolved Promises and an initial value",function(){I=F.reduce([F.resolved(1),F.resolved(2),F.resolved(3)],L,10);expect(I instanceof A).toBe(true);C(I,16,true)});it("Array of resolved Promises and a resolved Promise of an initial value",function(){I=F.reduce([F.resolved(1),F.resolved(2),F.resolved(3)],L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,16,true)});it("Array of values and resolved Promises",function(){I=F.reduce([1,F.resolved(2),3,F.resolved(4)],L);expect(I instanceof A).toBe(true);C(I,10,true)});it("Array of values and resolved Promises and an initial value",function(){I=F.reduce([1,F.resolved(2),3,F.resolved(4)],L,10);expect(I instanceof A).toBe(true);C(I,20,true)});it("Array of values and resolved Promises and a resolved Promise of an initial value",function(){I=F.reduce([1,F.resolved(2),3,F.resolved(4)],L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,20,true)})});describe("returns a Promise that will resolve with the resolved Promise value obtained by reducing the specified resolved Promise of an Array of Promise(s) or value(s) using the specified function and initial value",function(){it("Promise of an empty Array and an initial value",function(){I=F.reduce(F.resolved([]),L,0);expect(I instanceof A).toBe(true);C(I,0,true)});it("Promise of an empty Array and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([]),L,F.resolved(0));expect(I instanceof A).toBe(true);C(I,0,true)});it("Promise of an Array with one value",function(){I=F.reduce(F.resolved([1]),L);expect(I instanceof A).toBe(true);C(I,1,true)});it("Promise of an Array with one value and an initial value",function(){I=F.reduce(F.resolved([1]),L,10);expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of an Array with one value and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([1]),L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of an Array of values",function(){I=F.reduce(F.resolved([1,2,3,4]),L);expect(I instanceof A).toBe(true);C(I,10,true)});it("Promise of an Array of values and an initial value",function(){I=F.reduce(F.resolved([1,2,3,4]),L,10);expect(I instanceof A).toBe(true);C(I,20,true)});it("Promise of an Array of values and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([1,2,3,4]),L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,20,true)});it("Promise of a sparse Array",function(){I=F.reduce(F.resolved([,2,,4,5]),L);expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of a sparse Array and an initial value",function(){I=F.reduce(F.resolved([,2,,4,5]),L,10);expect(I instanceof A).toBe(true);C(I,21,true)});it("Promise of a sparse Array and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([,2,,4,5]),L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,21,true)});it("Promise of an Array with one resolved Promise",function(){I=F.reduce(F.resolved([F.resolved(1)]),L);expect(I instanceof A).toBe(true);C(I,1,true)});it("Promise of an Array with one resolved Promise and an initial value",function(){I=F.reduce(F.resolved([F.resolved(1)]),L,10);expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of an Array with one resolved Promise and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([F.resolved(1)]),L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,11,true)});it("Promise of an Array of resolved Promises",function(){I=F.reduce(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),L);expect(I instanceof A).toBe(true);C(I,6,true)});it("Promise of an Array of resolved Promises and an initial value",function(){I=F.reduce(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),L,10);expect(I instanceof A).toBe(true);C(I,16,true)});it("Promise of an Array of resolved Promises and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,16,true)});it("Promise of an Array of values and resolved Promises",function(){I=F.reduce(F.resolved([1,F.resolved(2),3,F.resolved(4)]),L);expect(I instanceof A).toBe(true);C(I,10,true)});it("Promise of an Array of values and resolved Promises and an initial value",function(){I=F.reduce(F.resolved([1,F.resolved(2),3,F.resolved(4)]),L,10);expect(I instanceof A).toBe(true);C(I,20,true)});it("Promise of an Array of values and resolved Promises and a resolved Promise of an initial value",function(){I=F.reduce(F.resolved([1,F.resolved(2),3,F.resolved(4)]),L,F.resolved(10));expect(I instanceof A).toBe(true);C(I,20,true)})});describe("returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects",function(){it("Array with one rejected Promise",function(){I=F.reduce([F.rejected(new Error("error message"))],K);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values and a rejected Promise",function(){I=F.reduce([1,F.rejected(new Error("error message")),3],K);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of resolved Promises and a rejected Promise",function(){I=F.reduce([F.resolved(1),F.rejected(new Error("error message")),F.resolved(3)],K);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values, pending and resolved Promises and a rejected Promise",function(){I=F.reduce([1,2,F.rejected(new Error("error message")),F.resolved(4),new F().promise],K);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects",function(){it("Promise of an Array with one rejected Promise",function(){I=F.reduce(F.resolved([F.rejected(new Error("error message"))]),K);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values and a rejected Promise",function(){I=F.reduce(F.resolved([1,F.rejected(new Error("error message")),3]),K);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of resolved Promises and a rejected Promise",function(){I=F.reduce(F.resolved([F.resolved(1),F.rejected(new Error("error message")),F.resolved(3)]),K);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values, pending and resolved Promises and a rejected Promise",function(){I=F.reduce(F.resolved([1,2,F.rejected(new Error("error message")),F.resolved(4),new F().promise]),K);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)",function(){it("Error: error message",function(){I=F.reduce(F.rejected(new Error("error message")),K);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the first rejected Promise returned by the specified function for the the specified Array of Promise(s) or value(s)",function(){it("Array with one value",function(){I=F.reduce([1],J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values",function(){I=F.reduce([1,2,3],J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Sparse Array",function(){I=F.reduce([,2,,4,5],J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array with one resolved Promise",function(){I=F.reduce([F.resolved(1)],J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of resolved Promises",function(){I=F.reduce([F.resolved(1),F.resolved(2),F.resolved(3)],J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Array of values and resolved Promises",function(){I=F.reduce([1,F.resolved(2),F.resolved(3),4],J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the first rejected Promise returned by the specified function for the the specified resolved Promise of an Array of Promise(s) or value(s)",function(){it("Promise of an Array with one value",function(){I=F.reduce(F.resolved([1]),J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values",function(){I=F.reduce(F.resolved([1,2,3]),J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of a sparse Array",function(){I=F.reduce(F.resolved([,2,,4,5]),J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array with one resolved Promise",function(){I=F.reduce(F.resolved([F.resolved(1)]),J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of resolved Promises",function(){I=F.reduce(F.resolved([F.resolved(1),F.resolved(2),F.resolved(3)]),J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")});it("Promise of an Array of values and resolved Promises",function(){I=F.reduce(F.resolved([1,F.resolved(2),F.resolved(3),4]),J,10);expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the error associated with the rejected Promise of an initial value",function(){it("Error: error message",function(){I=F.reduce([1,2,3],K,F.rejected(new Error("error message")));expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject if reduce is attempted on an empty Array with no initial value specified",function(){it("Empty Array",function(){I=F.reduce([],K);expect(I instanceof A).toBe(true);B(I,TypeError)});it("Promise of an empty Array",function(){I=F.reduce(F.resolved([]),K);expect(I instanceof A).toBe(true);B(I,TypeError)})});describe("throws an Error if anything other than an Array or Promise of an Array and a function are specified as the first two parameters",function(){it("no parameters",function(){expect(function(){return F.reduce()}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("a single non-Array parameter",function(){expect(function(){return F.reduce(1)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("multiple non-Array parameters",function(){expect(function(){return F.reduce(1,2,3)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("an Array and no function",function(){expect(function(){return F.reduce([1,2,3])}).toThrow("Invalid parameter: expected a function.")});it("a Promise of an Array and no function",function(){expect(function(){return F.reduce(F.resolved([1,2,3]))}).toThrow("Invalid parameter: expected a function.")});it("an Array and a non-function parameter",function(){expect(function(){return F.reduce([1,2,3],"not a function")}).toThrow("Invalid parameter: expected a function.")});it("a Promise of a non-function parameter",function(){expect(function(){return F.reduce(F.resolved([1,2,3],"not a function"))}).toThrow("Invalid parameter: expected a function.")})})});describe("then()",function(){describe("with a progress handler",function(){var J;describe("attaches a progress handler that will be called on progress updates",function(){it("called with progress update when updated",function(K){J=jasmine.createSpy();H=new F();I=H.promise;I.then(null,null,J);Ext.asap(function(){H.update("progress");expect(J.callCount).toBe(1);expect(J.calls[0].args).toEqual(["progress"]);K()})});it("called with progress update in specified scope when updated",function(K){J=jasmine.createSpy();H=new F();I=H.promise;I.then(null,null,J,E);Ext.asap(function(){H.update("progress");expect(J.callCount).toBe(1);expect(J.calls[0].args).toEqual(["progress"]);expect(J.calls[0].scope).toBe(E);K()})})});describe("propagates transformed progress updates that originate from this Promise",function(){it("propagates progress updates to subsequent Promises in the chain if a progress handler is omitted",function(K){J=jasmine.createSpy();H=new F();I=H.promise;I.then().then(null,null,J);Ext.asap(function(){H.update("progress");expect(J.callCount).toBe(1);expect(J.calls[0].args).toEqual(["progress"]);K()})});it("propagates transformed progress updates to subsequent Promises in the chain if a progress handler transforms the progress update",function(L){J=jasmine.createSpy();J.andReturn("transformed progress");var M=jasmine.createSpy();M.andReturn("transformed transformed progress");var K=jasmine.createSpy();H=new F();I=H.promise;I.then(null,null,J).then(null,null,M).then(null,null,K);Ext.asap(function(){H.update("progress");expect(J.callCount).toBe(1);expect(J.calls[0].args).toEqual(["progress"]);expect(M.callCount).toBe(1);expect(M.calls[0].args).toEqual(["transformed progress"]);expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["transformed transformed progress"]);L()})})})});describe("with parameters specified via a configuration object",function(){describe("attaches an onResolved callback to this Promise that will be called when it resolves",function(){describe("when only a success handler is specified",function(){it("called with resolved value when resolved",function(J){var K=jasmine.createSpy();I=F.resolved("resolved value");I.then({success:K});Ext.asap(function(){expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["resolved value"]);J()})});it("called with resolved value in the specified scope when resolved",function(J){var K=jasmine.createSpy();I=F.resolved("resolved value");I.then({success:K,scope:E});Ext.asap(function(){expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["resolved value"]);expect(K.calls[0].scope).toBe(E);J()})})});describe("when success, failure and progress handlers are specified",function(){it("called with resolved value when resolved",function(J){var M=jasmine.createSpy();var K=jasmine.createSpy();var L=jasmine.createSpy();I=F.resolved("resolved value");I.then({success:M,failure:K,progress:L});Ext.asap(function(){expect(M.callCount).toBe(1);expect(M.calls[0].args).toEqual(["resolved value"]);expect(K.callCount).toBe(0);expect(L.callCount).toBe(0);J()})});it("called with resolved value in the specified scope when resolved",function(J){var M=jasmine.createSpy();var K=jasmine.createSpy();var L=jasmine.createSpy();I=F.resolved("resolved value");I.then({success:M,failure:K,progress:L,scope:E});Ext.asap(function(){expect(M.callCount).toBe(1);expect(M.calls[0].args).toEqual(["resolved value"]);expect(M.calls[0].scope).toBe(E);expect(K.callCount).toBe(0);expect(L.callCount).toBe(0);J()})})})});describe("attaches an onRejected callback to this Promise that will be called when it rejects",function(){describe("when only a failure handler is specified",function(){it("called with rejection reason when rejected",function(J){var K=jasmine.createSpy();I=F.rejected("rejection reason");I.then({failure:K});Ext.asap(function(){expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["rejection reason"]);J()})});it("called with rejection reason in specified scope when rejected",function(J){var K=jasmine.createSpy();I=F.rejected("rejection reason");I.then({failure:K,scope:E});Ext.asap(function(){expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["rejection reason"]);expect(K.calls[0].scope).toBe(E);J()})})});describe("when success, failure and progress handlers are specified",function(){it("called with rejection reason when rejected",function(J){var M=jasmine.createSpy();var K=jasmine.createSpy();var L=jasmine.createSpy();I=F.rejected("rejection reason");I.then({success:M,failure:K,progress:L});Ext.asap(function(){expect(M.callCount).toBe(0);expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["rejection reason"]);expect(L.callCount).toBe(0);J()})});it("called with rejection reason in specified scope when rejected",function(J){var M,K,L;L=jasmine.createSpy();K=jasmine.createSpy();M=jasmine.createSpy();I=F.rejected("rejection reason");I.then({success:L,failure:K,progress:M,scope:E});Ext.asap(function(){expect(L.callCount).toBe(0);expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["rejection reason"]);expect(K.calls[0].scope).toBe(E);expect(M.callCount).toBe(0);J()})})})});describe("attaches an onProgress callback to this Promise that will be called when it resolves",function(){describe("when only a progress handler is specified",function(){it("called with progress update when updated",function(J){var K=jasmine.createSpy();H=new F();I=H.promise;I.then({progress:K});Ext.asap(function(){H.update("progress");expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["progress"]);J()})});it("called with progress update in specified scope when updated",function(J){var K=jasmine.createSpy();H=new F();I=H.promise;I.then({progress:K,scope:E});Ext.asap(function(){H.update("progress");expect(K.callCount).toBe(1);expect(K.calls[0].args).toEqual(["progress"]);expect(K.calls[0].scope).toBe(E);J()})})});describe("when success, failure and progress handlers are specified",function(){it("called with progress update when updated",function(J){var M=jasmine.createSpy();var K=jasmine.createSpy();var L=jasmine.createSpy();H=new F();I=H.promise;I.then({success:M,failure:K,progress:L});Ext.asap(function(){H.update("progress");expect(L.callCount).toBe(1);expect(L.calls[0].args).toEqual(["progress"]);expect(M.callCount).toBe(0);expect(K.callCount).toBe(0);J()})});it("called with progress update in specified scope when updated",function(J){var M=jasmine.createSpy();var K=jasmine.createSpy();var L=jasmine.createSpy();H=new F();I=H.promise;I.then({success:M,failure:K,progress:L,scope:E});Ext.asap(function(){H.update("progress");expect(M.callCount).toBe(0);expect(K.callCount).toBe(0);expect(L.callCount).toBe(1);expect(L.calls[0].args).toEqual(["progress"]);expect(L.calls[0].scope).toBe(E);J()})})})})})});describe("otherwise()",function(){describe("attaches a callback that will be called if this Promise is rejected",function(){describe("with parameters specified via function arguments",function(){it("called if rejected",function(J){var M=this;var L=jasmine.createSpy();var K=new Error("error message");I=F.rejected(K);I.otherwise(L);I.then(null,function(){try{expect(L.callCount).toBe(1);expect(L.calls[0].args.length).toBe(1);expect(L.calls[0].args[0]).toBe(K);J()}catch(N){M.fail(N);J()}})});it("called in specified scope if rejected",function(J){var M=this;var L=jasmine.createSpy();var K=new Error("error message");I=F.rejected(K);I.otherwise(L,E);I.then(null,function(){try{expect(L.callCount).toBe(1);expect(L.calls[0].args.length).toBe(1);expect(L.calls[0].args[0]).toBe(K);expect(L.calls[0].scope).toBe(E);J()}catch(N){M.fail(N);J()}})});it("not called if resolved",function(J){var L=this;var K=jasmine.createSpy();I=F.resolved("value");I.otherwise(K);I.then(function(){try{expect(K.callCount).toBe(0);J()}catch(M){L.fail(M);J()}})})});describe("with parameters specified via a configuration object",function(){it("called if rejected",function(J){var M=this;var L=jasmine.createSpy();var K=new Error("error message");I=F.rejected(K);I.otherwise({fn:L});I.then(null,function(){try{expect(L.callCount).toBe(1);expect(L.calls[0].args.length).toBe(1);expect(L.calls[0].args[0]).toBe(K);J()}catch(N){M.fail(N);J()}})});it("called in specified scope if rejected",function(J){var M=this;var L=jasmine.createSpy();var K=new Error("error message");I=F.rejected(K);I.otherwise({fn:L,scope:E});I.then(null,function(){try{expect(L.callCount).toBe(1);expect(L.calls[0].args.length).toBe(1);expect(L.calls[0].args[0]).toBe(K);expect(L.calls[0].scope).toBe(E);J()}catch(N){M.fail(N);J()}})});it("not called if resolved",function(J){var L=this;var K=jasmine.createSpy();I=F.resolved("value");I.otherwise({fn:K});I.then(function(){try{expect(K.callCount).toBe(0);J()}catch(M){L.fail(M);J()}})})})});describe("returns a Promise of the transformed future value",function(){it("resolves with the returned value if callback returns a value",function(){var J=function(){return"returned value"};I=F.rejected(new Error("error message")).otherwise(J);expect(I instanceof A).toBe(true);C(I,"returned value",true)});it("resolves with the resolved value if callback returns a Promise that resolves with value",function(){var J=function(){return F.resolved("resolved value")};I=F.rejected(new Error("error message")).otherwise(J);expect(I instanceof A).toBe(true);C(I,"resolved value",true)});it("rejects with the thrown Error if callback throws an Error",function(){var J=function(){throw new Error("thrown error message")};I=F.rejected(new Error("error message")).otherwise(J);expect(I instanceof A).toBe(true);B(I,Error,"thrown error message")});it("rejects with the rejection reason if callback returns a Promise that rejects with a reason",function(){var J=function(){return F.rejected(new Error("rejection reason"))};I=F.rejected(new Error("original error message")).otherwise(J);expect(I instanceof A).toBe(true);B(I,Error,"rejection reason")})})});describe("always()",function(){describe("attaches a callback to this Promise that will be called when it resolves or rejects",function(){describe("with parameters specified via function arguments",function(){it("called with no parameters when resolved",function(J){var K=this;var L=jasmine.createSpy();I=F.resolved("value");I.always(L);I.then(function(){try{expect(L.callCount).toBeGT(0);J()}catch(M){K.fail(M);J()}})});it("called with no parameters in the specified scope when resolved",function(J){var K=this;var L=jasmine.createSpy();I=F.resolved("value");I.always(L,E);I.then(function(){try{expect(L.callCount).toBeGT(0);J()}catch(M){K.fail(M);J()}})});it("called with no parameters when rejected",function(J){var K=this;var L=jasmine.createSpy();I=F.rejected(new Error("error message"));I.always(L);I.then(null,function(){try{expect(L.callCount).toBeGT(0);J()}catch(M){K.fail(M);J()}})});it("called with no parameters in the specified scope when rejected",function(J){var K=this;var L=jasmine.createSpy();I=F.rejected(new Error("error message"));I.always(L,E);I.then(null,function(){try{expect(L.callCount).toBeGT(0);J()}catch(M){K.fail(M);J()}})})});describe("with parameters specified via a configuration object",function(){it("called with no parameters when resolved",function(J){var K=this;var L=jasmine.createSpy();I=F.resolved("value");I.always({fn:L});I.then(function(){var M;try{expect(L.callCount).toBeGT(0);J()}catch(N){K.fail(N);J()}})});it("called with no parameters in the specified scope when resolved",function(J){var K=this;var L=jasmine.createSpy();I=F.resolved("value");I.always({fn:L,scope:E});I.then(function(){var M;try{expect(L.callCount).toBeGT(0);J()}catch(N){K.fail(N);J()}})});it("called with no parameters when rejected",function(J){var K=this;var L=jasmine.createSpy();I=F.rejected(new Error("error message"));I.always({fn:L});I.then(null,function(){var M;try{expect(L.callCount).toBeGT(0);J()}catch(N){K.fail(N);J()}})});it("called with no parameters in the specified scope when rejected",function(J){var K=this;var L=jasmine.createSpy();I=F.rejected(new Error("error message"));I.always({fn:L,scope:E});I.then(null,function(){var M;try{expect(L.callCount).toBeGT(0);J()}catch(N){K.fail(N);J()}})})})});describe('return a new "pass-through" Promise that resolves with the original value or rejects with the original reason',function(){it("if the originating Promise resolves, ignores value returned by callback",function(){function J(){return"callback return value"}I=F.resolved("resolved value").always(J);expect(I instanceof A).toBe(true);C(I,"resolved value",true)});xit("if the originating Promise resolves, ignores and later rethrows Error thrown by callback",function(J){var K=this;function L(){throw new Error("callback error message")}I=F.resolved("resolved value").always(L);expect(I instanceof A).toBe(true);I.then(function(M){expect(M).toBe("resolved value")},function(M){expect(M.message).toBe("callback error message");J()})});it("if the originating Promise rejects, ignores value returned by callback",function(){function J(){return"callback return value"}I=F.rejected(new Error("rejection reason")).always(J);expect(I instanceof A).toBe(true);B(I,Error,"rejection reason")});xit("if the originating Promise rejects, ignores and later rethrows Error thrown by callback",function(J){var K=this;function L(){throw new Error("callback error message")}I=F.rejected(new Error("rejection reason")).always(L);expect(I instanceof A).toBe(true);I.then(function(M){K.fail("should reject");J()},function(M){expect(M.message).toBe("rejection value");J()})})})});xdescribe("done()",function(){describe("terminates a Promise chain, ensuring that unhandled rejections will be thrown as Errors",function(){it("rethrows the rejection as an error if the originating Promise rejects",function(J){I=F.rejected(new Error("rejection reason")).done();assert.eventuallyThrows(new Error("rejection reason"),J,100)});it("rethrows the rejection as an error if an ancestor Promise rejects and that rejection is unhandled",function(J){this.slow(250);I=F.rejected(new Error("rejection reason")).then(function(K){return K}).done();assert.eventuallyThrows(new Error("rejection reason"),J,100)})})});describe("cancel()",function(){describe("cancels a Promise if it is still pending, triggering a rejection with a CancellationError that will propagate to any Promises originating from that Promise",function(){it("rejects a pending Promise with a CancellationError",function(){I=new F().promise;I.cancel();B(I,Ext.promise.Promise.CancellationError)});it("rejects a pending Promise with a CancellationError with a reason",function(){I=new F().promise;I.cancel("cancellation reason");B(I,Ext.promise.Promise.CancellationError,"cancellation reason")});it("ignores attempts to cancel a fulfilled Promise",function(){I=F.resolved("resolved value");I.cancel();C(I,"resolved value",true)});it("ignores attempts to cancel a rejected Promise",function(){I=F.rejected(new Error("rejection reason"));I.cancel();B(I,Error,"rejection reason")});it("propagates rejection with that CancellationError to Promises that originate from the cancelled Promise",function(){I=new F().promise;I.cancel("cancellation reason");B(I.then(),Ext.promise.Promise.CancellationError,"cancellation reason")})})});xdescribe("log()",function(){describe("logs the resolution or rejection of this Promise using Logger.log()",function(){beforeEach(function(){return jasmine.createSpy(Logger,"log")});afterEach(function(){return Logger.log.restore()});it("logs a fulfilled promise",function(J){var L,K;K="resolved value";L=F.resolved(K).log();expect(L instanceof A).toBe(true);L.always(function(){var M;try{expect(Logger.log).to.be.calledOnce.and.calledWith("Promise resolved with value: "+K);J()}catch(N){me.fail(N);J(N)}})});it("logs a fulfilled promise, with the optional name specified",function(J){var L,K;K="resolved value";L=F.resolved(K).log("Test Promise");expect(L instanceof A).toBe(true);L.always(function(){var M;try{expect(Logger.log).to.be.calledOnce.and.calledWith("Test Promise resolved with value: "+K);J()}catch(N){me.fail(N);J()}})});it("logs a rejected promise",function(J){var L,K;K=new Error("rejection reason");L=F.rejected(K).log();expect(L instanceof A).toBe(true);L.always(function(){var M;try{expect(Logger.log).to.be.calledOnce.and.calledWith("Promise rejected with reason: "+K);J()}catch(N){me.fail(N);J()}})});it("logs a rejected promise, with the optional name specified",function(J){var L,K;K=new Error("rejection reason");L=F.rejected(K).log("Test Promise");expect(L instanceof A).toBe(true);L.always(function(){var M;try{expect(Logger.log).to.be.calledOnce.and.calledWith("Test Promise rejected with reason: "+K);J()}catch(N){me.fail(N);J()}})})});describe('return a new "pass-through" Promise that resolves with the original value or rejects with the original reason',function(){it("resolves if the originating Promise resolves",function(){I=F.resolved("resolved value").log();expect(I instanceof A).toBe(true);C(I,"resolved value",true)});it("rejects if the originating Promise rejects",function(){I=F.rejected(new Error("rejection reason")).log();expect(I instanceof A).toBe(true);B(I,Error,"rejection reason")})})});describe("Extras",function(){function J(M,L){return function(){expect(this).toBe(L);return M.apply(this,arguments)}}function K(M,L){return function(){var N=Ext.Array.slice(arguments,0);expect(N).toEqual(L);return M.apply(this,arguments)}}describe("sequence()",function(){var N=function(){++N.callCount;expect(M.callCount).toBe(0);expect(L.callCount).toBe(0);return 1};var M=function(){++M.callCount;expect(N.callCount).toBe(1);expect(L.callCount).toBe(0);return 2};var L=function(){++L.callCount;expect(N.callCount).toBe(1);expect(M.callCount).toBe(1);return 3};beforeEach(function(){N.callCount=M.callCount=L.callCount=0});describe("returns a new Promise that will resolve with an Array of the results returned by calling the specified functions in sequence order",function(){it("Empty Array",function(){var O=[];I=F.sequence(O);expect(I instanceof A).toBe(true);C(I,[],true)});it("Empty Array with the optional scope specified",function(){var O=[];I=F.sequence(O,E);expect(I instanceof A).toBe(true);C(I,[],true)});it("Empty Array with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[];I=F.sequence(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[],true)});it("Array with one function",function(){var O=[N];I=F.sequence(O);expect(I instanceof A).toBe(true);C(I,[1],true)});it("Array with one function with the optional scope specified",function(){var O=[J(N,E)];I=F.sequence(O,E);expect(I instanceof A).toBe(true);C(I,[1],true)});it("Array with one function with the optional scope and arguments specified",function(){var O,P;O=["a","b","c"];P=[K(J(N,E),O)];I=F.sequence(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1],true)});it("Array of two functions",function(){var O;O=[N,M];I=F.sequence(O);expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Array of two functions with the optional scope specified",function(){var O;O=[J(N,E),J(M,E)];I=F.sequence(O,E);expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Array of two functions with the optional scope and arguments specified",function(){var O,P;O=["a","b","c"];P=[K(J(N,E),O),K(J(M,E),O)];I=F.sequence(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Array of three functions",function(){var O;O=[N,M,L];I=F.sequence(O);expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Array of three functions with the optional scope specified",function(){var O;O=[J(N,E),J(M,E),J(L,E)];I=F.sequence(O,E);expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Array of three functions with the optional scope and arguments specified",function(){var O,P;O=["a","b","c"];P=[K(J(N,E),O),K(J(M,E),O),K(J(L,E),O)];I=F.sequence(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1,2,3],true)})});describe("returns a new Promise that will resolve with an Array of the results returned by calling the specified resolved Promise of an Array of functions in sequence order",function(){it("Promise of an empty Array",function(){var O;O=[];I=F.sequence(F.resolved(O));expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an empty Array with the optional scope specified",function(){var O;O=[];I=F.sequence(F.resolved(O),E);expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an empty Array with the optional scope and arguments specified",function(){var O,P;O=["a","b","c"];P=[];I=F.sequence(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an Array with one function",function(){var O=[N];I=F.sequence(F.resolved(O));expect(I instanceof A).toBe(true);C(I,[1],true)});it("Promise of an Array with one function with the optional scope specified",function(){var O;O=[J(N,E)];I=F.sequence(F.resolved(O),E);expect(I instanceof A).toBe(true);C(I,[1],true)});it("Promise of an Array with one function with the optional scope and arguments specified",function(){var O,P;O=["a","b","c"];P=[K(J(N,E),O)];I=F.sequence(F.resolved(P),E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1],true)});it("Promise of an Array of two functions",function(){var O;O=[N,M];I=F.sequence(F.resolved(O));expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Promise of an Array of two functions with the optional scope specified",function(){var O;O=[J(N,E),J(M,E)];I=F.sequence(F.resolved(O),E);expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Promise of an Array of two functions with the optional scope and arguments specified",function(){var O,P;O=["a","b","c"];P=[K(J(N,E),O),K(J(M,E),O)];I=F.sequence(F.resolved(P),E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Promise of an Array of three functions",function(){var O;O=[N,M,L];I=F.sequence(F.resolved(O));expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Promise of an Array of three functions with the optional scope specified",function(){var O;O=[J(N,E),J(M,E),J(L,E)];I=F.sequence(F.resolved(O),E);expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Promise of an Array of three functions with the optional scope and arguments specified",function(){var O,P;O=["a","b","c"];P=[K(J(N,E),O),K(J(M,E),O),K(J(L,E),O)];I=F.sequence(F.resolved(P),E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1,2,3],true)})});describe("returns a new Promise that will reject with the Error associated with the specified rejected Promise of an Array of functions",function(){it("Error: error message",function(){I=F.sequence(F.rejected(new Error("error message")));expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Array of functions throws an Error",function(){function O(){throw new Error("Error message")}it("Array with one function that throws an Error",function(){var P;P=[O];I=F.sequence(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with one function and one function that throws an Error",function(){var P;P=[N,O];I=F.sequence(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with two functions and one function that throws an Error",function(){var P;P=[N,M,O];I=F.sequence(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions throws an Error",function(){function O(){throw new Error("Error message")}it("Promise of an Array with one function that throws an Error",function(){var P;P=[O];I=F.sequence(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with one function and one function that throws an Error",function(){var P;P=[N,O];I=F.sequence(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with two functions and one function that throws an Error",function(){var P;P=[N,M,O];I=F.sequence(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Array of functions returns a rejected Promise",function(){function O(){return F.rejected(new Error("Error message"))}it("Array with one function that returns a rejected Promise",function(){var P;P=[O];I=F.sequence(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with one function and one function that returns a rejected Promise",function(){var P;P=[N,O];I=F.sequence(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with two functions and one function that returns a rejected Promise",function(){var P;P=[N,M,O];I=F.sequence(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions returns a rejected Promise",function(){function O(){return F.rejected(new Error("Error message"))}it("Promise of an Array with one function that returns a rejected Promise",function(){var P;P=[O];I=F.sequence(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with one function and one function that returns a rejected Promise",function(){var P;P=[N,O];I=F.sequence(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with two functions and one function that returns a rejected Promise",function(){var P;P=[N,M,O];I=F.sequence(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the items in the specified Array is not a function",function(){it("Array with one non-function value",function(){var O;O=[1];I=F.sequence(O);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Array with one function and one non-function value",function(){var O;O=[N,1];I=F.sequence(O);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Array with two functions and one non-function value",function(){var O;O=[N,M,1];I=F.sequence(O);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")})});describe("returns a new Promise that will reject with the associated Error if any of the items in the specified resolved Promise of an Array is not a function ",function(){it("Promise of an Array with one non-function value",function(){var O;O=[1];I=F.sequence(F.resolved(O));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Promise of an Array with one function and one non-function value",function(){var O;O=[N,1];I=F.sequence(F.resolved(O));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Promise of an Array with two functions and one non-function value",function(){var O;O=[N,M,1];I=F.sequence(F.resolved(O));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")})});describe("throws an Error if anything other than Array or Promise of an Array is specified as the first parameter",function(){it("No parameters",function(){expect(function(){return F.sequence()}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("A non-Array parameter",function(){expect(function(){return F.sequence(1)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")})})});describe("parallel()",function(){var N=function(){++N.callCount;return 1};var M=function(){++M.callCount;return 2};var L=function(){++L.callCount;return 3};beforeEach(function(){N.callCount=M.callCount=L.callCount=0});describe("returns a new Promise that will resolve with an Array of the results returned by calling the specified functions in parallel",function(){it("Empty Array",function(){var O=[];I=F.parallel(O);expect(I instanceof A).toBe(true);C(I,[],true)});it("Empty Array with the optional scope specified",function(){var O=[];I=F.parallel(O,E);expect(I instanceof A).toBe(true);C(I,[],true)});it("Empty Array with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[];I=F.parallel(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[],true)});it("Array with one function",function(){var O=[N];I=F.parallel(O);expect(I instanceof A).toBe(true);C(I,[1],true)});it("Array with one function with the optional scope specified",function(){var O=[J(N,E)];I=F.parallel(O,E);expect(I instanceof A).toBe(true);C(I,[1],true)});it("Array with one function with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[K(J(N,E),O)];I=F.parallel(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1],true)});it("Array of two functions",function(){var O=[N,M];I=F.parallel(O);expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Array of two functions with the optional scope specified",function(){var O=[J(N,E),J(M,E)];I=F.parallel(O,E);expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Array of two functions with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[K(J(N,E),O),K(J(M,E),O)];I=F.parallel(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Array of three functions",function(){var O=[N,M,L];I=F.parallel(O);expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Array of three functions with the optional scope specified",function(){var O=[J(N,E),J(M,E),J(L,E)];I=F.parallel(O,E);expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Array of three functions with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[K(J(N,E),O),K(J(M,E),O),K(J(L,E),O)];I=F.parallel(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1,2,3],true)})});describe("returns a new Promise that will resolve with an Array of the results returned by calling the specified resolved Promise of an Array of functions in parallel",function(){it("Promise of an empty Array",function(){var O=[];I=F.parallel(F.resolved(O));expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an empty Array with the optional scope specified",function(){var O=[];I=F.parallel(F.resolved(O),E);expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an empty Array with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[];I=F.parallel(P,E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[],true)});it("Promise of an Array with one function",function(){var O=[N];I=F.parallel(F.resolved(O));expect(I instanceof A).toBe(true);C(I,[1],true)});it("Promise of an Array with one function with the optional scope specified",function(){var O=[J(N,E)];I=F.parallel(F.resolved(O),E);expect(I instanceof A).toBe(true);C(I,[1],true)});it("Promise of an Array with one function with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[K(J(N,E),O)];I=F.parallel(F.resolved(P),E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1],true)});it("Promise of an Array of two functions",function(){var O=[N,M];I=F.parallel(F.resolved(O));expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Promise of an Array of two functions with the optional scope specified",function(){var O=[J(N,E),J(M,E)];I=F.parallel(F.resolved(O),E);expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Promise of an Array of two functions with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[K(J(N,E),O),K(J(M,E),O)];I=F.parallel(F.resolved(P),E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1,2],true)});it("Promise of an Array of three functions",function(){var O=[N,M,L];I=F.parallel(F.resolved(O));expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Promise of an Array of three functions with the optional scope specified",function(){var O=[J(N,E),J(M,E),J(L,E)];I=F.parallel(F.resolved(O),E);expect(I instanceof A).toBe(true);C(I,[1,2,3],true)});it("Promise of an Array of three functions with the optional scope and arguments specified",function(){var O=["a","b","c"];var P=[K(J(N,E),O),K(J(M,E),O),K(J(L,E),O)];I=F.parallel(F.resolved(P),E,"a","b","c");expect(I instanceof A).toBe(true);C(I,[1,2,3],true)})});describe("returns a new Promise that will reject with the Error associated with the specified rejected Promise of an Array of functions",function(){it("Error: error message",function(){I=F.parallel(F.rejected(new Error("error message")));expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Array of functions throws an Error",function(){function O(){throw new Error("Error message")}it("Array with one function that throws an Error",function(){var P=[O];I=F.parallel(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with one function and one function that throws an Error",function(){var P=[N,O];I=F.parallel(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with two functions and one function that throws an Error",function(){var P=[N,M,O];I=F.parallel(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions throws an Error",function(){function O(){throw new Error("Error message")}it("Promise of an Array with one function that throws an Error",function(){var P=[O];I=F.parallel(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with one function and one function that throws an Error",function(){var P=[N,O];I=F.parallel(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with two functions and one function that throws an Error",function(){var P=[N,M,O];I=F.parallel(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Array of functions returns a rejected Promise",function(){function O(){return F.rejected(new Error("Error message"))}it("Array with one function that returns a rejected Promise",function(){var P=[O];I=F.parallel(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with one function and one function that returns a rejected Promise",function(){var P=[N,O];I=F.parallel(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with two functions and one function that returns a rejected Promise",function(){var P=[N,M,O];I=F.parallel(P);expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions returns a rejected Promise",function(){function O(){return F.rejected(new Error("Error message"))}it("Promise of an Array with one function that returns a rejected Promise",function(){var P=[O];I=F.parallel(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with one function and one function that returns a rejected Promise",function(){var P=[N,O];I=F.parallel(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with two functions and one function that returns a rejected Promise",function(){var P=[N,M,O];I=F.parallel(F.resolved(P));expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the items in the specified Array is not a function",function(){it("Array with one non-function value",function(){var O=[1];I=F.parallel(O);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Array with one function and one non-function value",function(){var O=[N,1];I=F.parallel(O);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Array with two functions and one non-function value",function(){var O=[N,M,1];I=F.parallel(O);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")})});describe("returns a new Promise that will reject with the associated Error if any of the items in the specified resolved Promise of an Array is not a function ",function(){it("Promise of an Array with one non-function value",function(){var O=[1];I=F.parallel(F.resolved(O));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Promise of an Array with one function and one non-function value",function(){var O=[N,1];I=F.parallel(F.resolved(O));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Promise of an Array with two functions and one non-function value",function(){var O=[N,M,1];I=F.parallel(F.resolved(O));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")})});describe("throws an Error if anything other than Array or Promise of an Array is specified as the first parameter",function(){it("No parameters",function(){expect(function(){return F.parallel()}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("A non-Array parameter",function(){expect(function(){return F.parallel(1)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")})})});describe("pipeline()",function(){function L(M){return function(N){return N?N+M:M}}describe("returns a new Promise that will resolve with the result returned by calling the specified Array of functions as a pipeline",function(){it("Empty Array",function(){var M=[];I=F.pipeline(M);expect(I instanceof A).toBe(true);C(I,void 0,true)});it("Empty Array with an initial value",function(){var M=[];I=F.pipeline(M,"initial value");expect(I instanceof A).toBe(true);C(I,"initial value",true)});it("Empty Array with an initial value and scope",function(){var M=[];I=F.pipeline(M,"initial value");expect(I instanceof A).toBe(true);C(I,"initial value",true)});it("Array with one function",function(){var M=[L("a")];I=F.pipeline(M);expect(I instanceof A).toBe(true);C(I,"a",true)});it("Array with one function with an initial value",function(){var M=[L("b")];I=F.pipeline(M,"a");expect(I instanceof A).toBe(true);C(I,"ab",true)});it("Array with one function with an initial value and scope",function(){var M=[J(L("b"),E)];I=F.pipeline(M,"a",E);expect(I instanceof A).toBe(true);C(I,"ab",true)});it("Array of two functions",function(){var M=[L("a"),L("b")];I=F.pipeline(M);expect(I instanceof A).toBe(true);C(I,"ab",true)});it("Array of two functions with an initial value",function(){var M=[L("b"),L("c")];I=F.pipeline(M,"a");expect(I instanceof A).toBe(true);C(I,"abc",true)});it("Array of two functions with an initial value and scope",function(){var M=[J(L("b"),E),J(L("c"),E)];I=F.pipeline(M,"a",E);expect(I instanceof A).toBe(true);C(I,"abc",true)});it("Array of three functions",function(){var M=[L("a"),L("b"),L("c")];I=F.pipeline(M);expect(I instanceof A).toBe(true);C(I,"abc",true)});it("Array of three functions with an initial value",function(){var M=[L("b"),L("c"),L("d")];I=F.pipeline(M,"a");expect(I instanceof A).toBe(true);C(I,"abcd",true)});it("Array of three functions with an initial value",function(){var M=[J(L("b"),E),J(L("c"),E),J(L("d"),E)];I=F.pipeline(M,"a",E);expect(I instanceof A).toBe(true);C(I,"abcd",true)})});describe("returns a new Promise that will resolve with the result returned by calling the specified Promise of an Array of functions as a pipeline",function(){it("Promise of an empty Array",function(){var M=[];I=F.pipeline(F.resolved(M));expect(I instanceof A).toBe(true);C(I,void 0,true)});it("Promise of an empty Array with an initial value",function(){var M=[];I=F.pipeline(F.resolved(M),"initial value");expect(I instanceof A).toBe(true);C(I,"initial value",true)});it("Promise of an empty Array with an initial value and scope",function(){var M=[];I=F.pipeline(F.resolved(M),"initial value");expect(I instanceof A).toBe(true);C(I,"initial value",true)});it("Promise of an Array with one function",function(){var M=[L("a")];I=F.pipeline(F.resolved(M));expect(I instanceof A).toBe(true);C(I,"a",true)});it("Promise of an Array with one function with an initial value",function(){var M=[L("b")];I=F.pipeline(F.resolved(M),"a");expect(I instanceof A).toBe(true);C(I,"ab",true)});it("Promise of an Array with one function with an initial value and scope",function(){var M=[J(L("b"),E)];I=F.pipeline(F.resolved(M),"a",E);expect(I instanceof A).toBe(true);C(I,"ab",true)});it("Promise of an Array of two functions",function(){var M=[L("a"),L("b")];I=F.pipeline(F.resolved(M));expect(I instanceof A).toBe(true);C(I,"ab",true)});it("Promise of an Array of two functions with an initial value",function(){var M=[L("b"),L("c")];I=F.pipeline(F.resolved(M),"a");expect(I instanceof A).toBe(true);C(I,"abc",true)});it("Promise of an Array of two functions with an initial value and scope",function(){var M=[J(L("b"),E),J(L("c"),E)];I=F.pipeline(F.resolved(M),"a",E);expect(I instanceof A).toBe(true);C(I,"abc",true)});it("Promise of an Array of three functions",function(){var M=[L("a"),L("b"),L("c")];I=F.pipeline(F.resolved(M));expect(I instanceof A).toBe(true);C(I,"abc",true)});it("Promise of an Array of three functions with an initial value",function(){var M=[L("b"),L("c"),L("d")];I=F.pipeline(F.resolved(M),"a");expect(I instanceof A).toBe(true);C(I,"abcd",true)});it("Promise of an Array of three functions with an initial value",function(){var M=[J(L("b"),E),J(L("c"),E),J(L("d"),E)];I=F.pipeline(F.resolved(M),"a",E);expect(I instanceof A).toBe(true);C(I,"abcd",true)})});describe("returns a new Promise that will reject with the Error associated with the specified rejected Promise of an Array of functions",function(){it("Error: error message",function(){I=F.pipeline(F.rejected(new Error("error message")));expect(I instanceof A).toBe(true);B(I,Error,"error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Array of functions throws an Error",function(){function M(){throw new Error("Error message")}it("Array with one function that throws an Error",function(){var N=[M];I=F.pipeline(N);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with one function and one function that throws an Error",function(){var N=[L("a"),M];I=F.pipeline(N);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with two functions and one function that throws an Error",function(){var N=[L("a"),L("b"),M];I=F.pipeline(N);expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions throws an Error",function(){function M(){throw new Error("Error message")}it("Promise of an Array with one function that throws an Error",function(){var N=[M];I=F.pipeline(F.resolved(N));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with one function and one function that throws an Error",function(){var N=[L("a"),M];I=F.pipeline(F.resolved(N));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Promise of an Array with two functions and one function that throws an Error",function(){var N=[L("a"),L("b"),M];I=F.pipeline(F.resolved(N));expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Array of functions returns a rejected Promise",function(){function M(){return F.rejected(new Error("Error message"))}it("Array with one function that returns a rejected Promise",function(){var N=[M];I=F.pipeline(N);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with one function and one function that returns a rejected Promise",function(){var N=[L("a"),M];I=F.pipeline(N);expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with two functions and one function that returns a rejected Promise",function(){var N=[L("a"),L("b"),M];I=F.pipeline(N);expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the specified Promise of an Array of functions returns a rejected Promise",function(){function M(){return F.rejected(new Error("Error message"))}it("Array with one function that returns a rejected Promise",function(){var N=[M];I=F.pipeline(F.resolved(N));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with one function and one function that returns a rejected Promise",function(){var N=[L("a"),M];I=F.pipeline(F.resolved(N));expect(I instanceof A).toBe(true);B(I,Error,"Error message")});it("Array with two functions and one function that returns a rejected Promise",function(){var N=[L("a"),L("b"),M];I=F.pipeline(F.resolved(N));expect(I instanceof A).toBe(true);B(I,Error,"Error message")})});describe("returns a new Promise that will reject with the associated Error if any of the items in the specified Array is not a function",function(){it("Array with one non-function value",function(){var M=[1];I=F.pipeline(M);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Array with one function and one non-function value",function(){var M=[L("a"),1];I=F.pipeline(M);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Array with two functions and one non-function value",function(){var M=[L("a"),L("b"),1];I=F.pipeline(M);expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")})});describe("returns a new Promise that will reject with the associated Error if any of the items in the specified resolved Promise of an Array is not a function ",function(){it("Promise of an Array with one non-function value",function(){var M=[1];I=F.pipeline(F.resolved(M));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Promise of an Array with one function and one non-function value",function(){var M=[L("a"),1];I=F.pipeline(F.resolved(M));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")});it("Promise of an Array with two functions and one non-function value",function(){var M=[L("a"),L("b"),1];I=F.pipeline(F.resolved(M));expect(I instanceof A).toBe(true);B(I,Error,"Invalid parameter: expected a function.")})});describe("throws an Error if anything other than Array or Promise of an Array is specified as the first parameter",function(){it("No parameters",function(){expect(function(){return F.pipeline()}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")});it("A non-Array parameter",function(){expect(function(){return F.pipeline(1)}).toThrow("Invalid parameter: expected an Array or Promise of an Array.")})})})})})