/*
 * Copyright (C) 2012  Krawler Information Systems Pvt Ltd
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package com.krawler.spring.accounting.debitnote;

import com.krawler.common.admin.*;
import com.krawler.common.dao.BaseDAO;
import com.krawler.common.service.ServiceException;
import com.krawler.common.util.Constants;
import com.krawler.common.util.IndiaComplianceConstants;
import com.krawler.common.util.StringUtil;
import com.krawler.hql.accounting.*;
import com.krawler.spring.accounting.account.accAccountDAOImpl;
import com.krawler.spring.accounting.bankreconciliation.accBankReconciliationDAO;
import com.krawler.spring.accounting.costCenter.CCConstants;
import com.krawler.spring.accounting.handler.AccountingManager;
import com.krawler.spring.authHandler.authHandler;
import com.krawler.spring.common.KwlReturnObject;
import com.krawler.utils.json.base.JSONArray;
import com.krawler.utils.json.base.JSONException;
import com.krawler.utils.json.base.JSONObject;
import java.net.URLDecoder;
import java.sql.SQLException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.hibernate.Session;

/**
 *
 * @author krawler
 */
public class accDebitNoteImpl extends BaseDAO implements accDebitNoteDAO {

    private accBankReconciliationDAO accBankReconciliationDAOObj;
    
    public void setaccBankReconciliationDAO(accBankReconciliationDAO accBankReconciliationDAOObj) {
        this.accBankReconciliationDAOObj = accBankReconciliationDAOObj;
    }
    
    @Override
    public KwlReturnObject addDebitNote(HashMap<String, Object> hm) throws ServiceException {
        List list = new ArrayList();
        try {
            DebitNote dn = new DebitNote();
            dn.setDeleted(false);
            if (hm.containsKey("createdby")) {
                User createdby = hm.get("createdby") == null ? null : (User) get(User.class, (String) hm.get("createdby"));
                dn.setCreatedby(createdby);
            }
            if (hm.containsKey("modifiedby")) {
                User modifiedby = hm.get("modifiedby") == null ? null : (User) get(User.class, (String) hm.get("modifiedby"));
                dn.setModifiedby(modifiedby);
            }
            if (hm.containsKey("createdon")) {
                dn.setCreatedon((Long) hm.get("createdon"));
            }
            if (hm.containsKey("updatedon")) {
                dn.setUpdatedon((Long) hm.get("updatedon"));
            }
            if (hm.containsKey("taxid")) {
                dn.setTax((Tax) get(Tax.class, (String)hm.get("taxid")));
            }
            if (hm.containsKey(Constants.SEQFORMAT)) {
                dn.setSeqformat((SequenceFormat) get(SequenceFormat.class, (String) hm.get(Constants.SEQFORMAT)));
            }
            if (hm.containsKey(Constants.SEQNUMBER)) {
                dn.setSeqnumber(Integer.parseInt(hm.get(Constants.SEQNUMBER).toString()));
            }
            if (hm.containsKey(Constants.DATEPREFIX) && hm.get(Constants.DATEPREFIX) != null) {
                dn.setDatePreffixValue((String) hm.get(Constants.DATEPREFIX));
            }
            if (hm.containsKey(Constants.DATEAFTERPREFIX) && hm.get(Constants.DATEAFTERPREFIX) != null) {
                dn.setDateAfterPreffixValue((String) hm.get(Constants.DATEAFTERPREFIX));
            }
            if (hm.containsKey(Constants.DATESUFFIX) && hm.get(Constants.DATESUFFIX) != null) {
                dn.setDateSuffixValue((String) hm.get(Constants.DATESUFFIX));
            }
            if (hm.containsKey("entrynumber")) {
                dn.setDebitNoteNumber((String) hm.get("entrynumber"));
            }
            if (hm.containsKey("currencyid")) {
                KWLCurrency currency = hm.get("currencyid") == null ? null : (KWLCurrency) get(KWLCurrency.class, (String) hm.get("currencyid"));
                dn.setCurrency(currency);
            }
            if (hm.containsKey("autogenerated")) {
                dn.setAutoGenerated((Boolean) hm.get("autogenerated"));
            }
            if (hm.containsKey("memo")) {
                dn.setMemo((String) hm.get("memo"));
            }
            if (hm.containsKey("sequence")) {
                dn.setSequence((Integer) hm.get("sequence"));
            }
            if (hm.containsKey("includingGST")) {
                dn.setIncludingGST((Boolean) hm.get("includingGST"));
            }
            if (hm.containsKey("companyid")) {
                Company company = hm.get("companyid") == null ? null : (Company) get(Company.class, (String) hm.get("companyid"));
                dn.setCompany(company);
            }
            if (hm.containsKey("journalentryid")) {
                JournalEntry je = hm.get("journalentryid") == null ? null : (JournalEntry) get(JournalEntry.class, (String) hm.get("journalentryid"));
                dn.setJournalEntry(je);
            }
            if (hm.containsKey("vendorentry")) {
                JournalEntryDetail je = hm.get("vendorentry") == null ? null : (JournalEntryDetail) get(JournalEntryDetail.class, (String) hm.get("vendorentry"));
                dn.setVendorEntry(je);
            }
            if (hm.containsKey("dndetails")) {
                dn.setRows((Set<DebitNoteDetail>) hm.get("dndetails"));
            }
            if (hm.containsKey("customerid")) {
                Customer customer = hm.get("customerid") == null ? null : (Customer) get(Customer.class, (String) hm.get("customerid"));
                dn.setCustomer(customer);
            }
            if (hm.containsKey("vendorid")) {
                Vendor vendor = hm.get("vendorid") == null ? null : (Vendor) get(Vendor.class, (String) hm.get("vendorid"));
                dn.setVendor(vendor);
            }
            if (hm.containsKey("otherwise")) {
                dn.setOtherwise((Boolean) hm.get("otherwise"));
            }
            if (hm.containsKey("oldRecord")) {
                dn.setOldRecord((Boolean) hm.get("oldRecord"));
            }
            if (hm.containsKey("openflag")) {
                dn.setOpenflag((Boolean) hm.get("openflag"));
            }
            if (hm.containsKey("dnamount") && hm.get("dnamount") != null) {
                dn.setDnamount(Double.parseDouble(hm.get("dnamount").toString()));
            }
            if (hm.containsKey("dnamountdue") && hm.get("dnamountdue") != null) {
                dn.setDnamountdue(Double.parseDouble(hm.get("dnamountdue").toString()));
            }
            if (hm.containsKey("narrationValue") && hm.get("narrationValue") != null) {//
                dn.setNarration(hm.get("narrationValue").toString());
            }
            if (hm.containsKey("creationDate") && hm.get("creationDate") != null) {//
                dn.setCreationDate((Date) hm.get("creationDate"));
            }
            if (hm.containsKey("isOpeningBalenceDN")) {//
                boolean isOpeningBalenceDN = hm.get("isOpeningBalenceDN") != null ? Boolean.parseBoolean(hm.get("isOpeningBalenceDN").toString()) : false;
                dn.setIsOpeningBalenceDN(isOpeningBalenceDN);
                if(isOpeningBalenceDN){
                    dn.setApprovestatuslevel(11);
                }                
            } else {
                dn.setIsOpeningBalenceDN(false);
            }
            if (hm.containsKey("isDNForVendor")) {//
                dn.setdNForVendor((Boolean) hm.get("isDNForVendor"));
            }
            if (hm.containsKey("normalDN")) {//
                dn.setNormalDN((Boolean) hm.get("normalDN"));
            } else {
                dn.setNormalDN(true);
            }
            if (hm.containsKey("openingBalanceAmountDue") && hm.get("openingBalanceAmountDue") != null) {//
                dn.setOpeningBalanceAmountDue(Double.parseDouble(hm.get("openingBalanceAmountDue").toString()));
            }
            if (hm.containsKey(Constants.openingBalanceBaseAmountDue) && hm.get(Constants.openingBalanceBaseAmountDue) != null) {//
                dn.setOpeningBalanceAmountDue(Double.parseDouble(hm.get(Constants.openingBalanceBaseAmountDue).toString()));
            }
            if (hm.containsKey(Constants.originalOpeningBalanceBaseAmount) && !StringUtil.isNullOrEmpty(hm.get(Constants.originalOpeningBalanceBaseAmount).toString())) {
                dn.setOriginalOpeningBalanceBaseAmount(Double.parseDouble(hm.get(Constants.originalOpeningBalanceBaseAmount).toString()));
            }
            if (hm.containsKey("exchangeRateForOpeningTransaction")) {//
                double exchangeRateForOpeningTransaction = (Double) hm.get("exchangeRateForOpeningTransaction");
                dn.setExchangeRateForOpeningTransaction(exchangeRateForOpeningTransaction);
            }
            if (hm.containsKey("externalCurrencyRate")) {//
                double externalCurrencyRate = (Double) hm.get("externalCurrencyRate");
                dn.setExternalCurrencyRate(externalCurrencyRate);
            }
            if (hm.containsKey("conversionRateFromCurrencyToBase")) {//
                dn.setConversionRateFromCurrencyToBase((Boolean) hm.get("conversionRateFromCurrencyToBase"));
            }
            if (hm.containsKey("accountId") && hm.get("accountId") != null) {
                Account account = (Account) get(Account.class, (String) hm.get("accountId"));
                dn.setAccount(account);
            }
            if (hm.containsKey("purchaseReturnId") && hm.get("purchaseReturnId") != null) {
                PurchaseReturn purchaseReturn = hm.get("purchaseReturnId") == null ? null : (PurchaseReturn) get(PurchaseReturn.class, (String) hm.get("purchaseReturnId"));
                dn.setPurchaseReturn(purchaseReturn);
            }

            if (hm.containsKey("cntype") && hm.get("cntype") != null) {
                dn.setDntype(Integer.parseInt(hm.get("cntype").toString()));
            }
            if (hm.containsKey("costcenter")) {
                CostCenter costcenter =StringUtil.isNullOrEmpty(hm.get("costcenter").toString())?null:(CostCenter) get(CostCenter.class, (String) hm.get("costcenter"));
                dn.setCostcenter(costcenter);
            }
            if (hm.containsKey("dnamountinbase") && hm.get("dnamountinbase") != null) {
                dn.setDnamountinbase(Double.parseDouble(hm.get("dnamountinbase").toString()));
            }
            if (hm.containsKey("billshipAddressid") && hm.get("billshipAddressid") != null) {
                BillingShippingAddresses bsa = StringUtil.isNullOrEmpty(hm.get("billshipAddressid").toString()) ? null : (BillingShippingAddresses) get(BillingShippingAddresses.class, (String) hm.get("billshipAddressid"));
                dn.setBillingShippingAddresses(bsa);
            }
            if (hm.containsKey("approvestatuslevel") && hm.get("approvestatuslevel") != null) {
                 dn.setApprovestatuslevel(Integer.parseInt(hm.get("approvestatuslevel").toString()));
            }
            if (hm.containsKey(Constants.SUPPLIERINVOICENO) && hm.get(Constants.SUPPLIERINVOICENO) != null) {
                dn.setSupplierInvoiceNo((String) hm.get(Constants.SUPPLIERINVOICENO));
            }
            if (hm.containsKey(Constants.MVATTRANSACTIONNO) && hm.get(Constants.MVATTRANSACTIONNO) != null) {
                dn.setMvatTransactionNo((String) hm.get(Constants.MVATTRANSACTIONNO));
            }
            if (hm.containsKey("salesPerson") && hm.get("salesPerson") != null) {       //ERP-28249 Debit note against customer for malaysian country.
                MasterItem masterItem = (MasterItem) get(MasterItem.class, (String) hm.get("salesPerson"));
                dn.setSalesPerson(masterItem);
            }
            if (hm.containsKey("agent") && hm.get("agent") != null) {
                MasterItem masterItem = (MasterItem) get(MasterItem.class, (String) hm.get("agent"));
                dn.setAgent(masterItem);
            }
            if (hm.containsKey("gstCurrencyRate") && hm.get("gstCurrencyRate") != null) {
                dn.setGstCurrencyRate(Double.parseDouble(hm.get("gstCurrencyRate").toString()));
            }            
            saveOrUpdate(dn);
            list.add(dn);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.addDebitNote : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Debit Note has been added successfully", null, list, list.size());
    }

    /**
     * Description : Method is used to Save saveDebitNoteGstDetails
     * Requisition
     *
     * @param <dataMap> :-Contains parameters company ID
     *
     * @return :return list
     */
     @Override
    public KwlReturnObject saveDebitNoteGstDetails(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            String srdid = (String) dataMap.get("id");

            DebitNoteAgainstCustomerGst debitNoteAgainstVendorGst = new DebitNoteAgainstCustomerGst();
            if (dataMap.containsKey("cnId")) {
                DebitNote debitNote = dataMap.get("cnId") == null ? null : (DebitNote) get(DebitNote.class, (String) dataMap.get("cnId"));
                debitNoteAgainstVendorGst.setDebitNote(debitNote);
            }
            if (dataMap.containsKey("srno")) {
                debitNoteAgainstVendorGst.setSrno((Integer) dataMap.get("srno"));
            }
            if (dataMap.containsKey("quantity")) {
                debitNoteAgainstVendorGst.setActualQuantity((Double) dataMap.get("quantity"));
            }
            if (dataMap.containsKey("returnquantity")) {
                debitNoteAgainstVendorGst.setReturnQuantity((Double) dataMap.get("returnquantity"));
            }
            if (dataMap.containsKey("uomid")) {
                debitNoteAgainstVendorGst.setUom((UnitOfMeasure) get(UnitOfMeasure.class, dataMap.get("uomid").toString()));
            }

            if (dataMap.containsKey("InvoiceDetail")) {
                debitNoteAgainstVendorGst.setCidetails((InvoiceDetail) dataMap.get("InvoiceDetail"));
            }

            if (dataMap.containsKey("baseuomrate") && dataMap.get("baseuomrate") != null && dataMap.get("baseuomrate") != "") {
                debitNoteAgainstVendorGst.setBaseuomrate((Double) dataMap.get("baseuomrate"));
            }
            if (dataMap.containsKey("baseuomquantity") && dataMap.get("baseuomquantity") != null && dataMap.get("baseuomquantity") != "") {
                debitNoteAgainstVendorGst.setBaseuomquantity((Double) dataMap.get("baseuomquantity"));
            }
            if (dataMap.containsKey("baseuomreturnquantity") && dataMap.get("baseuomreturnquantity") != null && dataMap.get("baseuomreturnquantity") != "") {
                debitNoteAgainstVendorGst.setBaseuomquantity((Double) dataMap.get("baseuomreturnquantity"));
            }
            if (dataMap.containsKey("remark")) {
                debitNoteAgainstVendorGst.setRemark(StringUtil.DecodeText(StringUtil.isNullOrEmpty((String) dataMap.get("remark")) ? "" : (String) dataMap.get("remark")));
            }
            if (dataMap.containsKey("description")) {
                debitNoteAgainstVendorGst.setDescription(StringUtil.DecodeText((String) dataMap.get("description")));
            }
            if (dataMap.containsKey("productid")) {
                Product product = dataMap.get("productid") == null ? null : (Product) get(Product.class, (String) dataMap.get("productid"));
                debitNoteAgainstVendorGst.setProduct(product);
            }
            if (dataMap.containsKey("companyid")) {
                Company company = dataMap.get("companyid") == null ? null : (Company) get(Company.class, (String) dataMap.get("companyid"));
                debitNoteAgainstVendorGst.setCompany(company);
            }

            if (dataMap.containsKey("reason") && dataMap.get("reason") != null) {
                MasterItem masterItem = dataMap.get("reason") == null ? null : (MasterItem) get(MasterItem.class, (String) dataMap.get("reason"));
                debitNoteAgainstVendorGst.setReason(masterItem);
            }

            if (dataMap.containsKey("prtaxid") && dataMap.get("prtaxid") != null) {
                Tax tax = dataMap.get("prtaxid") == null ? null : (Tax) get(Tax.class, (String) dataMap.get("prtaxid"));
                debitNoteAgainstVendorGst.setTax(tax);
            }

            if (dataMap.containsKey("taxamount") && dataMap.get("taxamount") != null) {
                debitNoteAgainstVendorGst.setRowTaxAmount((Double) dataMap.get("taxamount"));
            }

            if (dataMap.containsKey("discount")) {
                debitNoteAgainstVendorGst.setDiscount((Double) dataMap.get("discount"));
            }

            if (dataMap.containsKey("discountispercent")) {
                debitNoteAgainstVendorGst.setDiscountispercent((Integer) dataMap.get("discountispercent"));
            }
            if (dataMap.containsKey("rate") && dataMap.get("rate") != null) {
                debitNoteAgainstVendorGst.setRate((double) dataMap.get("rate"));
            }
            if (dataMap.containsKey("grdetail") && dataMap.get("grdetail") != null) {
                debitNoteAgainstVendorGst.setGrdetail((GoodsReceiptDetail) dataMap.get("grdetail"));
            }
            saveOrUpdate(debitNoteAgainstVendorGst);
            list.add(debitNoteAgainstVendorGst);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("SaveCreditNoteAgainstVendorGst : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    
    
    @Override
    public KwlReturnObject updateDebitNote(HashMap<String, Object> hm) throws ServiceException {
        List list = new ArrayList();
        String companyid = "";
        try {
            String dnid = (String) hm.get("dnid");
            DebitNote dn = (DebitNote) get(DebitNote.class, dnid);
            if (hm.containsKey("companyid")) {
                companyid = (String) hm.get("companyid");
            }
            if (dn != null) {
                if (hm.containsKey("modifiedby")) {
                    User modifiedby = hm.get("modifiedby") == null ? null : (User) get(User.class, (String) hm.get("modifiedby"));
                    dn.setModifiedby(modifiedby);
                }
                if (hm.containsKey("updatedon")) {
                    dn.setUpdatedon((Long) hm.get("updatedon"));
                }
                if (hm.containsKey(Constants.SEQFORMAT)) {
                    dn.setSeqformat((SequenceFormat) get(SequenceFormat.class, (String) hm.get(Constants.SEQFORMAT)));
                }
                if (hm.containsKey(Constants.SEQNUMBER)) {
                    dn.setSeqnumber(Integer.parseInt(hm.get(Constants.SEQNUMBER).toString()));
                }
                if (hm.containsKey(Constants.DATEPREFIX) && hm.get(Constants.DATEPREFIX) != null) {
                    dn.setDatePreffixValue((String) hm.get(Constants.DATEPREFIX));
                }
                if (hm.containsKey(Constants.DATEAFTERPREFIX) && hm.get(Constants.DATEAFTERPREFIX) != null) {
                    dn.setDatePreffixValue((String) hm.get(Constants.DATEAFTERPREFIX));
                }
                if (hm.containsKey(Constants.DATESUFFIX) && hm.get(Constants.DATESUFFIX) != null) {
                    dn.setDateSuffixValue((String) hm.get(Constants.DATESUFFIX));
                }
                if (hm.containsKey("entrynumber")) {
                    dn.setDebitNoteNumber((String) hm.get("entrynumber"));
                }
                if (hm.containsKey("currencyid")) {
                    KWLCurrency currency = hm.get("currencyid") == null ? null : (KWLCurrency) get(KWLCurrency.class, (String) hm.get("currencyid"));
                    dn.setCurrency(currency);
                }
                if (hm.containsKey("includingGST")) {
                    dn.setIncludingGST((Boolean) hm.get("includingGST"));
                }
                if (hm.containsKey("autogenerated")) {
                    dn.setAutoGenerated((Boolean) hm.get("autogenerated"));
                }
                if (hm.containsKey("memo")) {
                    dn.setMemo((String) hm.get("memo"));
                }
                if (hm.containsKey("sequence")) {
                    dn.setSequence((Integer) hm.get("sequence"));
                }
                if (hm.containsKey("companyid")) {
                    Company company = hm.get("companyid") == null ? null : (Company) get(Company.class, (String) hm.get("companyid"));
                    dn.setCompany(company);
                }
                if (hm.containsKey("journalentryid")) {
                    JournalEntry je = hm.get("journalentryid") == null ? null : (JournalEntry) get(JournalEntry.class, (String) hm.get("journalentryid"));
                    dn.setJournalEntry(je);
                }
                if (hm.containsKey("vendorentry")) {
                    JournalEntryDetail je = hm.get("vendorentry") == null ? null : (JournalEntryDetail) get(JournalEntryDetail.class, (String) hm.get("vendorentry"));
                    dn.setVendorEntry(je);
                }
                if (hm.containsKey("dndetails")) {
                    dn.setRows((Set<DebitNoteDetail>) hm.get("dndetails"));
                }
                if (hm.containsKey("debitNoteTaxEntryDetails")) {
                    dn.setDnTaxEntryDetails((Set<DebitNoteTaxEntry>) hm.get("debitNoteTaxEntryDetails"));
                }
                if (hm.containsKey("customerid")) {
                    Customer customer = hm.get("customerid") == null ? null : (Customer) get(Customer.class, (String) hm.get("customerid"));
                    dn.setCustomer(customer);
                }
                if (hm.containsKey("vendorid")) {
                    Vendor vendor = hm.get("vendorid") == null ? null : (Vendor) get(Vendor.class, (String) hm.get("vendorid"));
                    dn.setVendor(vendor);
                }
                if (hm.containsKey("otherwise")) {
                    dn.setOtherwise((Boolean) hm.get("otherwise"));
                }
                if (hm.containsKey("openflag")) {
                    dn.setOpenflag((Boolean) hm.get("openflag"));
                }
                if (hm.containsKey("dnamount") && hm.get("dnamount") != null) {
                    dn.setDnamount(Double.parseDouble(hm.get("dnamount").toString()));
                }
                if (hm.containsKey("dnamountdue") && hm.get("dnamountdue") != null) {
                    dn.setDnamountdue(Double.parseDouble(hm.get("dnamountdue").toString()));
                }
                if (hm.containsKey("narrationValue") && hm.get("narrationValue") != null) {//
                    dn.setNarration(hm.get("narrationValue").toString());
                }
                if (hm.containsKey("creationDate") && hm.get("creationDate") != null) {//
                    dn.setCreationDate((Date) hm.get("creationDate"));
                }
                if (hm.containsKey("isOpeningBalenceDN") && hm.get("isOpeningBalenceDN") != null) {//
                    boolean isOpeningBalenceDN = hm.get("isOpeningBalenceDN") != null ? Boolean.parseBoolean(hm.get("isOpeningBalenceDN").toString()) : false;
                    dn.setIsOpeningBalenceDN(isOpeningBalenceDN);
                    if(isOpeningBalenceDN){
                        dn.setApprovestatuslevel(11);
                    }
                }
                if (hm.containsKey("isDNForVendor")) {//
                    dn.setdNForVendor((Boolean) hm.get("isDNForVendor"));
                }
                if (hm.containsKey("normalDN")) {//
                    dn.setNormalDN((Boolean) hm.get("normalDN"));
                }
                 if (hm.containsKey("openingBalanceDebitNoteCustomData")) {
                    OpeningBalanceDebitNoteCustomData openingBalanceDebitNoteCustomData = hm.get("openingBalanceDebitNoteCustomData") == null ? null : (OpeningBalanceDebitNoteCustomData) get(OpeningBalanceDebitNoteCustomData.class, (String) hm.get("openingBalanceDebitNoteCustomData"));
                    dn.setOpeningBalanceDebitNoteCustomData(openingBalanceDebitNoteCustomData);
                }
                if (hm.containsKey("openingBalanceAmountDue") && hm.get("openingBalanceAmountDue") != null) {//
                    dn.setOpeningBalanceAmountDue(Double.parseDouble(hm.get("openingBalanceAmountDue").toString()));
                }
                if (hm.containsKey(Constants.openingBalanceBaseAmountDue) && hm.get(Constants.openingBalanceBaseAmountDue) != null) {//
                    dn.setOpeningBalanceBaseAmountDue(authHandler.round(Double.parseDouble(hm.get(Constants.openingBalanceBaseAmountDue).toString()), companyid));
                }
                if (hm.containsKey(Constants.originalOpeningBalanceBaseAmount) && !StringUtil.isNullOrEmpty(hm.get(Constants.originalOpeningBalanceBaseAmount).toString())) {
                    dn.setOriginalOpeningBalanceBaseAmount(authHandler.round(Double.parseDouble(hm.get(Constants.originalOpeningBalanceBaseAmount).toString()), companyid));
                }
                if (hm.containsKey("exchangeRateForOpeningTransaction")) {//
                    double exchangeRateForOpeningTransaction = (Double) hm.get("exchangeRateForOpeningTransaction");
                    dn.setExchangeRateForOpeningTransaction(exchangeRateForOpeningTransaction);
                }
                if (hm.containsKey("conversionRateFromCurrencyToBase")) {//
                    dn.setConversionRateFromCurrencyToBase((Boolean) hm.get("conversionRateFromCurrencyToBase"));
                }
                if (hm.containsKey("accountId") && hm.get("accountId") != null) {
                    Account account = (Account) get(Account.class, (String) hm.get("accountId"));
                    dn.setAccount(account);
                }
                
                if (hm.containsKey("purchaseReturnId") && hm.get("purchaseReturnId") != null) {
                    PurchaseReturn purchaseReturn = hm.get("purchaseReturnId") == null ? null : (PurchaseReturn) get(PurchaseReturn.class, (String) hm.get("purchaseReturnId"));
                    dn.setPurchaseReturn(purchaseReturn);
                }

                if (hm.containsKey("cntype") && hm.get("cntype") != null) {
                    dn.setDntype(Integer.parseInt(hm.get("cntype").toString()));
                }
                if (hm.containsKey(Constants.MARKED_PRINTED)) {
                    dn.setPrinted(Boolean.parseBoolean((String) hm.get(Constants.MARKED_PRINTED)));
                }
                if (hm.containsKey("costcenter")) {
                    CostCenter costcenter =StringUtil.isNullOrEmpty(hm.get("costcenter").toString())?null:(CostCenter) get(CostCenter.class, (String) hm.get("costcenter"));
                    dn.setCostcenter(costcenter);
                }
                if (hm.containsKey("externalCurrencyRate")) {//
                    double externalCurrencyRate = (Double) hm.get("externalCurrencyRate");
                    dn.setExternalCurrencyRate(externalCurrencyRate);
                }
                if (hm.containsKey("dnamountinbase") && hm.get("dnamountinbase") != null) {
                    dn.setDnamountinbase(Double.parseDouble(hm.get("dnamountinbase").toString()));
                }
                if (hm.containsKey("billshipAddressid") && hm.get("billshipAddressid") != null) {
                    BillingShippingAddresses bsa = StringUtil.isNullOrEmpty(hm.get("billshipAddressid").toString()) ? null : (BillingShippingAddresses) get(BillingShippingAddresses.class, (String) hm.get("billshipAddressid"));
                    dn.setBillingShippingAddresses(bsa);
                }
                if (hm.containsKey("approvestatuslevel") && hm.get("approvestatuslevel") != null) {
                  dn.setApprovestatuslevel(Integer.parseInt(hm.get("approvestatuslevel").toString()));
                } 
                if (hm.containsKey(Constants.SUPPLIERINVOICENO) && hm.get(Constants.SUPPLIERINVOICENO) != null) {
                    dn.setSupplierInvoiceNo((String) hm.get(Constants.SUPPLIERINVOICENO));
                }
                if (hm.containsKey(Constants.MVATTRANSACTIONNO) && hm.get(Constants.MVATTRANSACTIONNO) != null) {
                    dn.setMvatTransactionNo((String) hm.get(Constants.MVATTRANSACTIONNO));
                }
                if (hm.containsKey("salesPerson") && hm.get("salesPerson") != null) {       //ERP-28249 Debit note against customer for malaysian country.
                    MasterItem masterItem=(MasterItem) get(MasterItem.class, (String) hm.get("salesPerson"));
                    dn.setSalesPerson(masterItem);
                }
                if (hm.containsKey("agent") && hm.get("agent") != null) {
                    MasterItem masterItem = (MasterItem) get(MasterItem.class, (String) hm.get("agent"));
                    dn.setAgent(masterItem);
                }
                if (hm.containsKey("gstCurrencyRate") && hm.get("gstCurrencyRate") != null) {
                    dn.setGstCurrencyRate(Double.parseDouble(hm.get("gstCurrencyRate").toString()));
                }
                saveOrUpdate(dn);
            }
            list.add(dn);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.updateDebitNote : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Debit Note has been updated successfully", null, list, list.size());
    }

    public KwlReturnObject saveBillingDebitNote(HashMap<String, Object> hm) throws ServiceException {
        List list = new ArrayList();
        try {
            BillingDebitNote dn = null;
            String dnid = (String) hm.get("bdnid");
            if (StringUtil.isNullOrEmpty(dnid)) {
                dn = new BillingDebitNote();
            } else {
                dn = (BillingDebitNote) get(BillingDebitNote.class, dnid);
            }
            dn.setDeleted(false);
            if (hm.containsKey(Constants.SEQFORMAT)) {
                dn.setSeqformat((SequenceFormat) get(SequenceFormat.class, (String) hm.get(Constants.SEQFORMAT)));
            }
            if (hm.containsKey(Constants.SEQNUMBER)) {
                dn.setSeqnumber(Integer.parseInt(hm.get(Constants.SEQNUMBER).toString()));
            }
            if (hm.containsKey("entrynumber")) {
                dn.setDebitNoteNumber((String) hm.get("entrynumber"));
            }
            if (hm.containsKey("currencyid")) {
                KWLCurrency currency = hm.get("currencyid") == null ? null : (KWLCurrency) get(KWLCurrency.class, (String) hm.get("currencyid"));
                dn.setCurrency(currency);
            }
            if (hm.containsKey("autogenerated")) {
                dn.setAutoGenerated((Boolean) hm.get("autogenerated"));
            }
            if (hm.containsKey("memo")) {
                dn.setMemo((String) hm.get("memo"));
            }
            if (hm.containsKey("sequence")) {
                dn.setSequence((Integer) hm.get("sequence"));
            }
            if (hm.containsKey("companyid")) {
                Company company = hm.get("companyid") == null ? null : (Company) get(Company.class, (String) hm.get("companyid"));
                dn.setCompany(company);
            }
            if (hm.containsKey("journalentryid")) {
                JournalEntry je = hm.get("journalentryid") == null ? null : (JournalEntry) get(JournalEntry.class, (String) hm.get("journalentryid"));
                dn.setJournalEntry(je);
            }
            if (hm.containsKey("bdndetails")) {
                dn.setRows((Set<BillingDebitNoteDetail>) hm.get("bdndetails"));
            }
            saveOrUpdate(dn);
            list.add(dn);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.addDebitNote : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Debit Note has been added successfully", null, list, list.size());
    }

    public KwlReturnObject getDebitNotes(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        try {
            DateFormat df = (DateFormat) request.get(Constants.df);
            String companyid = (String) request.get(Constants.companyKey);
            String start = (String) request.get(Constants.start);
            String limit = (String) request.get(Constants.limit);
            String ss = (String) request.get(Constants.ss);
            boolean deleted = Boolean.parseBoolean((String) request.get("deleted"));
            boolean nondeleted = Boolean.parseBoolean((String) request.get("nondeleted"));
            boolean isIAF = request.get("isIAF") != null ? (Boolean) request.get("isIAF") : false;
            ArrayList params = new ArrayList();
            params.add(companyid);
            String condition="";
            if(isIAF){
                 condition = " where dn.company.companyID=?";
            }else{
                 condition = " where  dn.company.companyID=?";  //ERP-12796
            }            
           
            if (StringUtil.isNullOrEmpty(ss) == false) {
                for (int i = 0; i <= 3; i++) {
                    params.add(ss + "%");
                }
                condition += " and ( dn.debitNoteNumber like ? or v.name like ?  or dn.memo like ? or dn.journalEntry.entryNumber like ?) ";
            }
            String costCenterId = (String) request.get(CCConstants.REQ_costCenterId);
            if (!StringUtil.isNullOrEmpty(costCenterId)) {
                params.add(costCenterId);
                condition += " and dn.journalEntry.costcenter.ID=?";
            }

            String jeIds = (String) request.get("jeIds");
            if (!StringUtil.isNullOrEmpty(jeIds)) {
                condition += " and dn.journalEntry.ID IN(" + jeIds + ")";
            }

            String noteId = (String) request.get("noteid");
            if (!StringUtil.isNullOrEmpty(noteId)) {
                params.add(noteId);
                condition += " and dn.ID = ? ";
            }

            String startDate = (String) request.get(Constants.REQ_startdate);
            String endDate = (String) request.get(Constants.REQ_enddate);
            if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
//                condition += " and (dn.journalEntry.entryDate >=? and dn.journalEntry.entryDate <=?)";
                condition += " and (dn.creationDate >=? and dn.creationDate <=?)";
                params.add(df.parse(startDate));
                params.add(df.parse(endDate));
            }
            if (nondeleted) {
                condition += " and dn.deleted=false ";
            } else if (deleted) {
                condition += " and dn.deleted=true ";
            }
            boolean isPartyEntry=false;
            if(request.containsKey("isPartyEntry")){// party journal entry
                isPartyEntry = (Boolean) request.get("isPartyEntry");
                if(isPartyEntry){
                    condition+=" and je.typeValue=?";
                    params.add(2);
                }
            }
            
            boolean isPendingApproval = false;
            if (request.containsKey("pendingapproval") && request.get("pendingapproval") != null && !StringUtil.isNullOrEmpty(request.get("pendingapproval").toString())) {
                isPendingApproval = Boolean.parseBoolean(request.get("pendingapproval").toString());
            }
            if(isPendingApproval){
                condition += " and dn.approvestatuslevel != ? ";
                params.add(11);
            } else {
                condition += " and dn.approvestatuslevel = ? ";
                params.add(11);
            }
            String appendCase = "and";
            String mySearchFilterString = "";
            String joinString = "";
            HashMap<String, Object> reqParams1 = new HashMap<String, Object>();
            reqParams1.putAll(request);
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
                Searchjson = request.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    reqParams1.put(Constants.Searchjson, Searchjson);
                    reqParams1.put(Constants.appendCase, appendCase);
                    reqParams1.put("filterConjuctionCriteria", filterConjuctionCriteria);
                    mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(reqParams1, true).get(Constants.myResult));
                    mySearchFilterString = mySearchFilterString.replaceAll("accjecustomdata", "dn.journalEntry.accBillInvCustomData");
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "jed.accJEDetailCustomData");//  
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "jed.accJEDetailsProductCustomData");
                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                }
            }    
            
            String query = "select dn, dn.vendor, jed from DebitNote dn inner join dn.journalEntry je inner join je.details jed "+ condition + mySearchFilterString;//inner join jed.account ac, Vendor v
            list = executeQuery( query, params.toArray()); 
            count = list.size();
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.getDebitNotes : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    public KwlReturnObject getDebitNotesCustomers(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        try {
            DateFormat df = (DateFormat) request.get(Constants.df);
            String companyid = (String) request.get(Constants.companyKey);
            String start = (String) request.get(Constants.start);
            String limit = (String) request.get(Constants.limit);
            String ss = (String) request.get(Constants.ss);
            boolean deleted = Boolean.parseBoolean((String) request.get("deleted"));
            boolean nondeleted = Boolean.parseBoolean((String) request.get("nondeleted"));
            boolean isIAF = request.get("isIAF") != null ? (Boolean) request.get("isIAF") : false;
            ArrayList params = new ArrayList();
            params.add(companyid);
            String condition = "";
            if(isIAF){
                condition = " where dn.company.companyID=?";
            }else{
                condition = " where dn.company.companyID=?";  //ERP-12796
            }
            if (StringUtil.isNullOrEmpty(ss) == false) {
                for (int i = 0; i <= 3; i++) {
                    params.add(ss + "%");
                }
                condition += " and ( dn.debitNoteNumber like ? or v.name like ?  or dn.memo like ? or dn.journalEntry.entryNumber like ?) ";
            }
            String costCenterId = (String) request.get(CCConstants.REQ_costCenterId);
            if (!StringUtil.isNullOrEmpty(costCenterId)) {
                params.add(costCenterId);
                condition += " and dn.journalEntry.costcenter.ID=?";
            }

            String jeIds = (String) request.get("jeIds");
            if (!StringUtil.isNullOrEmpty(jeIds)) {
                condition += " and dn.journalEntry.ID IN(" + jeIds + ")";
            }

            String noteId = (String) request.get("noteid");
            if (!StringUtil.isNullOrEmpty(noteId)) {
                params.add(noteId);
                condition += " and dn.ID = ? ";
            }

            String startDate = (String) request.get(Constants.REQ_startdate);
            String endDate = (String) request.get(Constants.REQ_enddate);
            if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
//                condition += " and (dn.journalEntry.entryDate >=? and dn.journalEntry.entryDate <=?)";
                condition += " and (dn.creationDate >=? and dn.creationDate <=?)";
                params.add(df.parse(startDate));
                params.add(df.parse(endDate));
            }
            if (nondeleted) {
                condition += " and dn.deleted=false ";
            } else if (deleted) {
                condition += " and dn.deleted=true ";
            }
            boolean isPartyEntry = false;
            if (request.containsKey("isPartyEntry")) { // party journal entry
                isPartyEntry = (Boolean) request.get("isPartyEntry");
                if (isPartyEntry) {
                    condition += " and je.typeValue=?";
                    params.add(2);
                }
            }
            boolean isPendingApproval = false;
            if (request.containsKey("pendingapproval") && request.get("pendingapproval") != null && !StringUtil.isNullOrEmpty(request.get("pendingapproval").toString())) {
                isPendingApproval = Boolean.parseBoolean(request.get("pendingapproval").toString());
            }
            if (isPendingApproval) {
                condition += " and dn.approvestatuslevel != ? ";
                params.add(11);
            } else {
                condition += " and dn.approvestatuslevel = ? ";
                params.add(11);
            }
            String appendCase = "and";
            String mySearchFilterString = "";
            String joinString = "";
            HashMap<String, Object> reqParams1 = new HashMap<String, Object>();
            reqParams1.putAll(request);
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
                Searchjson = request.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    reqParams1.put(Constants.Searchjson, Searchjson);
                    reqParams1.put(Constants.appendCase, appendCase);
                    reqParams1.put("filterConjuctionCriteria", filterConjuctionCriteria);
                    mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(reqParams1, true).get(Constants.myResult));
                    mySearchFilterString = mySearchFilterString.replaceAll("accjecustomdata", "dn.journalEntry.accBillInvCustomData");
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "jed.accJEDetailCustomData");//   
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "jed.accJEDetailsProductCustomData");
                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                }
            }
            
            String query = "select dn, dn.customer, jed from DebitNote dn inner join dn.journalEntry je inner join je.details jed " + condition + mySearchFilterString;//inner join jed.account ac, Customer v
            list = executeQuery( query, params.toArray());
            count = list.size();
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.getDebitNotes : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    public KwlReturnObject getBillingDebitNotes(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        try {
            DateFormat df = (DateFormat) request.get(Constants.df);
            String companyid = (String) request.get(Constants.companyKey);
            String start = (String) request.get(Constants.start);
            String limit = (String) request.get(Constants.limit);
            String ss = (String) request.get(Constants.ss);
            boolean deleted = Boolean.parseBoolean((String) request.get("deleted"));
            boolean nondeleted = Boolean.parseBoolean((String) request.get("nondeleted"));
            ArrayList params = new ArrayList();
            params.add(companyid);
            String condition = " where ac.ID=v.account.ID and dn.company.companyID=?";
            if (StringUtil.isNullOrEmpty(ss) == false) {
                for (int i = 0; i <= 3; i++) {
                    params.add(ss + "%");
                }
                condition += " and ( dn.debitNoteNumber like ? or v.name like ?  or dn.memo like ? or dn.journalEntry.entryNumber like ?) ";
            }
            String costCenterId = (String) request.get(CCConstants.REQ_costCenterId);
            if (!StringUtil.isNullOrEmpty(costCenterId)) {
                params.add(costCenterId);
                condition += " and dn.journalEntry.costcenter.ID=?";
            }

            String jeIds = (String) request.get("jeIds");
            if (!StringUtil.isNullOrEmpty(jeIds)) {
                condition += " and dn.journalEntry.ID IN(" + jeIds + ")";
            }

            String noteId = (String) request.get("noteid");
            if (!StringUtil.isNullOrEmpty(noteId)) {
                params.add(noteId);
                condition += " and dn.ID = ? ";
            }

            String startDate = (String) request.get(Constants.REQ_startdate);
            String endDate = (String) request.get(Constants.REQ_enddate);
            if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
//                condition += " and (dn.journalEntry.entryDate >=? and dn.journalEntry.entryDate <=?)";
                condition += " and (dn.creationDate >=? and dn.creationDate <=?)";
                params.add(df.parse(startDate));
                params.add(df.parse(endDate));
            }
            if (nondeleted) {
                condition += " and dn.deleted=false ";
            } else if (deleted) {
                condition += " and dn.deleted=true ";
            }
            String query = "select dn, v, jed from BillingDebitNote dn inner join dn.journalEntry je inner join je.details jed inner join jed.account ac, Vendor v" + condition;
            list = executeQuery( query, params.toArray());
            count = list.size();
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.getBillingDebitNotes : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    public KwlReturnObject getDNFromNoteNo(String noteno, String companyid) throws ServiceException {
        List list = new ArrayList();
        String query = "from DebitNote where debitNoteNumber=? and company.companyID=?";
        list = executeQuery( query, new Object[]{noteno, companyid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject getBDNFromNoteNo(String noteno, String companyid) throws ServiceException {
        List list = new ArrayList();
        String query = "from BillingDebitNote where debitNoteNumber=? and company.companyID=?";
        list = executeQuery( query, new Object[]{noteno, companyid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject getDNSequenceNo(String companyid, Date applydate) throws ServiceException {
        List list = new ArrayList();
        String query = "select count(dn.ID) from DebitNote dn inner join dn.journalEntry je  where dn.company.companyID=? and je.entryDate<=?";
        list = executeQuery( query, new Object[]{companyid, applydate});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject getBDNSequenceNo(String companyid, Date applydate) throws ServiceException {
        List list = new ArrayList();
        String query = "select count(dn.ID) from BillingDebitNote dn inner join dn.journalEntry je  where dn.company.companyID=? and je.entryDate<=?";
        list = executeQuery( query, new Object[]{companyid, applydate});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject getDNFromGReceipt(String receiptid) throws ServiceException {
        List list = new ArrayList();
        String query = "select dn, dnr, dnd from DebitNote dn left join dn.rows dnr left join dn.discounts dnd"
                + " where dn.deleted=false and (dnr.goodsReceiptRow.goodsReceipt.ID=? or dnd.goodsReceipt.ID=?) order by dn.sequence";
        list = executeQuery( query, new Object[]{receiptid, receiptid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    @Override
    public KwlReturnObject getDNFromGoodsReceiptOtherwise(String goodsReceiptId, String companyid) throws ServiceException {
        String selQuery = "from DebitNoteDetail dn  where dn.goodsReceipt.ID=? and dn.debitNote.deleted=false and dn.company.companyID=?";
        List list = executeQuery( selQuery, new Object[]{goodsReceiptId, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject getDNLinkedWithGoodsReceipts(String debitNoteId, String companyid) throws ServiceException {
        String selQuery = "from DebitNoteDetail dn where dn.goodsReceipt is not null and dn.debitNote.ID =? and dn.debitNote.deleted=false and dn.company.companyID=?";
        List list = executeQuery( selQuery, new Object[]{debitNoteId, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    /*
     Checked whether Debit Note linked in Payment
     */

    public KwlReturnObject getDNLinkedWithPayment(String debitNoteId, String companyid) throws ServiceException {
        String selQuery = "from DebitNotePaymentDetails dn where dn.receipt is not null and dn.debitnote.ID =? and dn.debitnote.deleted=false and dn.debitnote.company.companyID=?";
        List list = executeQuery(selQuery, new Object[]{debitNoteId, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    public KwlReturnObject getDistintDNFromGReceipt(String receiptid) throws ServiceException {
        List list = new ArrayList();
        String query = "select distinct dn from DebitNote dn left join dn.rows dnr left join dn.discounts dnd"
                + " where dn.deleted=false and (dnr.goodsReceiptRow.goodsReceipt.ID=? or dnd.goodsReceipt.ID=?) order by dn.sequence";
        list = executeQuery( query, new Object[]{receiptid, receiptid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject getDNDetailsFromGReceipt(String receiptid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String query = "from DebitNoteDetail dn  where dn.goodsReceiptRow.goodsReceipt.ID=? and dn.debitNote.deleted=false and dn.company.companyID=?";
        list = executeQuery( query, new Object[]{receiptid, companyid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject getDNDetailsFromGReceiptOtherwise(String receiptid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String query = "from DebitNoteDetail dn  where dn.goodsReceipt.ID=? and dn.debitNote.deleted=false and dn.company.companyID=?";
        list = executeQuery( query, new Object[]{receiptid, companyid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject getDNDetailsFromOpeningBalanceGR(String receiptid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String query = "from DebitNoteDetail dn where dn.goodsReceipt.ID=? and dn.debitNote.deleted=false and dn.company.companyID=?";
        list = executeQuery( query, new Object[]{receiptid, companyid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject getDebitNoteDetails(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from DebitNoteDetail";
        return buildNExecuteQuery( query, requestParams);
    }
    
    public KwlReturnObject getDebitNoteDetailsGst(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from DebitNoteAgainstCustomerGst";
        return buildNExecuteQuery(query, requestParams);
    }

    public KwlReturnObject geDebitNoteCustomData(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from AccJEDetailCustomData";
        return buildNExecuteQuery( query, requestParams);
    }

    public KwlReturnObject getBillingDebitNoteDetails(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from BillingDebitNoteDetail";
        return buildNExecuteQuery( query, requestParams);
    }

    public KwlReturnObject getDNFromJE(String jeid, String companyid) throws ServiceException {
        String selQuery = "from DebitNote where journalEntry.ID=? and deleted=false and company.companyID=?";
        List list = executeQuery( selQuery, new Object[]{jeid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getBDNFromJE(String jeid, String companyid) throws ServiceException {
        String selQuery = "from BillingDebitNote where journalEntry.ID=? and deleted=false and company.companyID=?";
        List list = executeQuery( selQuery, new Object[]{jeid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getJEFromDN(String dnid) throws ServiceException {
        String selQuery = "select dn.journalEntry.ID from DebitNote dn where dn.ID=? and dn.company.companyID=dn.journalEntry.company.companyID";
        List list = executeQuery( selQuery, new Object[]{dnid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getJEFromBDN(String dnid, String companyid) throws ServiceException {
        String selQuery = "from BillingDebitNote dn where dn.ID = ? and dn.company.companyID = ?";
//        String selQuery = "select dn.journalEntry.ID from DebitNote dn where dn.ID=? and dn.company.companyID=dn.journalEntry.company.companyID";
        List list = executeQuery( selQuery, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getDNDFromDN(String dnid) throws ServiceException {
        String selQuery = "select dnd.discount.ID from DebitNoteDiscount dnd where dnd.debitNote.ID=? and dnd.company.companyID=dnd.discount.company.companyID";
        List list = executeQuery( selQuery, new Object[]{dnid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getDNDFromBDN(String dnid, String companyid) throws ServiceException {
        String selQuery = "from BillingDebitNoteDiscount dnd where dnd.debitNote.ID = ? and dnd.company.companyID = ?";
//        String selQuery = "select dnd.discount.ID from DebitNoteDiscount dnd where dnd.debitNote.ID=? and dnd.company.companyID=dnd.discount.company.companyID";
        List list = executeQuery( selQuery, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getDNDIFromDN(String dnid) throws ServiceException {
        String selQuery = "select dnd.discount.ID from DebitNoteDetail dnd where dnd.debitNote.ID=? and dnd.company.companyID=dnd.discount.company.companyID";
        List list = executeQuery( selQuery, new Object[]{dnid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getDNDFromBDND(String bdnid, String companyid) throws ServiceException {
        String selQuery = "from BillingDebitNoteDetail dnd where dnd.debitNote.ID = ? and dnd.company.companyID = ?";
//        String selQuery = "select dnd.discount.ID from DebitNoteDetail dnd where dnd.debitNote.ID=? and dnd.company.companyID=dnd.discount.company.companyID";
        List list = executeQuery( selQuery, new Object[]{bdnid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getDNDInvFromDN(String dnid) throws ServiceException {
        String selQuery = "select dnd.inventory.ID from DebitNoteDetail dnd where dnd.debitNote.ID=? and dnd.company.companyID=dnd.discount.company.companyID";
        List list = executeQuery( selQuery, new Object[]{dnid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject deleteDebitNote(String dnid, String companyid) throws ServiceException,AccountingException {
        String query = "update DebitNote set deleted=true where ID=? and company.companyID=?";
        int numRows = executeUpdate( query, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, "Debit Note has been deleted successfully.", null, null, numRows);
    }

    public KwlReturnObject deleteOpeningDebitNote(String dnid, String companyid) throws ServiceException {
        String query = "delete from DebitNote where ID=? and company.companyID=?  AND openflag = true";
        int numRows = executeUpdate( query, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, "Debit Note has been deleted successfully.", null, null, numRows);
    }

    @Override
    public KwlReturnObject deleteDebitNoteDetails(String dnid, String companyid) throws ServiceException {
        ArrayList params5 = new ArrayList();
        params5.add(companyid);
        params5.add(companyid);
        params5.add(dnid);
        String delQuery5 = "delete from accjedetailcustomdata where jedetailId in (select id from jedetail where company =? and journalEntry in (select journalentry from debitnote where company =? and id =?))";
        int numRows5 = executeSQLUpdate( delQuery5, params5.toArray());
        String query = "delete from DebitNoteDetail dnd where dnd.debitNote.ID=? AND dnd.company.companyID=?";
        int numRows = executeUpdate( query, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, "Debit Note Detail has been deleted successfully.", null, null, numRows);
    }

    @Override
    public KwlReturnObject deleteDebitTaxDetails(String dnid, String companyid) throws ServiceException {
        String query = "delete from DebitNoteTaxEntry dnd where dnd.debitNote.ID=? and dnd.company.companyID=?";
        int numRows = executeUpdate( query, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, "Debit Note Tax Entry has been deleted successfully.", null, null, numRows);
    }
    
    @Override
    public KwlReturnObject deleteDebitNotesPermanent(HashMap<String, Object> requestParams) throws ServiceException,AccountingException {

        String delQuery = "", delQuery1 = "", delQuery2 = "", delQuery3 = "", delQuery4 = "", delQuery5 = "", delQuery6 = "", delQuery7 = "", delQuery8 = "";
        ;
        int numtotal = 0;
        try {
            if (requestParams.containsKey("dnid") && requestParams.containsKey("companyid")) {

                ArrayList params8 = new ArrayList();
                params8.add(requestParams.get("companyid"));
                params8.add(requestParams.get("dnid"));
//                String myquery = "select id from dndetails where debitNote in (select id from debitnote where company =? and id = ?)";
                String myquery = "select dnd.id from dndetails dnd inner join debitnote dn on dnd.debitNote=dn.id  where dn.company =? and dn.id = ?";
                List list = executeSQLQuery( myquery, params8.toArray());
                Iterator itr = list.iterator();
                String idStrings = "";
                while (itr.hasNext()) {

                    String invdid = itr.next().toString();
                    idStrings += "'" + invdid + "',";
                }
                if (!StringUtil.isNullOrEmpty(idStrings)) {
                    idStrings = idStrings.substring(0, idStrings.length() - 1);
                }

                ArrayList params5 = new ArrayList();
                params5.add(requestParams.get("companyid"));
                params5.add(requestParams.get("dnid"));
//                delQuery5 = "delete from dndetails where debitNote in (select id from debitnote where company =? and id = ?)";
                delQuery5 = "delete dnd from dndetails dnd inner join debitnote dn on dnd.debitNote=dn.id where dn.company =? and dn.id = ?";
                int numRows5 = executeSQLUpdate( delQuery5, params5.toArray());


//                ArrayList params = new ArrayList();
//                params.add(requestParams.get("companyid"));
//                //   params.add(requestParams.get("invoiceid"));
//                delQuery = "delete  from inventory where company =?  and id in(" + idStrings + ") ";
//                int numRows = executeSQLUpdate( delQuery, params.toArray());
                int numRows=0;
                 if (!StringUtil.isNullOrEmpty(idStrings)) {
                 String companyid=(String) requestParams.get("companyid");
                 String selQuery = "from Inventory where company.companyID = ? and  ID in (" + idStrings + ") ";
                 List resultList = executeQuery( selQuery, new Object[]{companyid});
                 Iterator itrInv = resultList.iterator();
                 while (itrInv.hasNext()) {
                    Inventory inventory = (Inventory) itrInv.next();
                    if (inventory != null && inventory.isDeleted() == false) {
                        if (inventory.isCarryIn()) {
                            inventory.getProduct().setAvailableQuantity(inventory.getProduct().getAvailableQuantity() - inventory.getBaseuomquantity());// minus Purchase and Plus Sales (for Reverse effect for quantity)
                        } else {
                            inventory.getProduct().setAvailableQuantity(inventory.getProduct().getAvailableQuantity() + inventory.getBaseuomquantity());
                        }
                    }
                 }
                   deleteAll(resultList);
                   numRows =resultList.size();
                 }


                ArrayList params9 = new ArrayList();
                params9.add(requestParams.get("companyid"));
                params9.add(requestParams.get("dnid"));
                String myquery1 = " select journalentry from debitnote where company = ? and id=?";
                List list1 = executeSQLQuery( myquery1, params9.toArray());
                Iterator itr1 = list1.iterator();
                String journalent = "";
                String jeid = "";
                while (itr1.hasNext()) {
                    Object jeidobj = itr1.next();
                    String jeidi = (jeidobj != null) ? jeidobj.toString() : "";
                    journalent += "'" + jeidi + "',";
                    jeid += jeidi + ",";
                }
                if (!StringUtil.isNullOrEmpty(journalent)) {
                    journalent = journalent.substring(0, journalent.length() - 1);
                    jeid = jeid.substring(0, jeid.length() - 1);
                }

                deleteGstDocHistoryDetails((String)requestParams.get("dnid"));
                deleteGstTaxClassDetails((String)requestParams.get("dnid"));
                ArrayList params1 = new ArrayList();
                params1.add(requestParams.get("companyid"));
                params1.add(requestParams.get("companyid"));
                params1.add(requestParams.get("dnid"));
                delQuery1 = "delete  from accjedetailcustomdata where jedetailId in (select id from jedetail where company = ? and journalEntry in (select journalentry from debitnote where company =? and id = ?))";
                int numRows1 = executeSQLUpdate( delQuery1, params1.toArray());

                ArrayList params11 = new ArrayList();
                params11.add(requestParams.get("companyid"));
                params11.add(requestParams.get("dnid"));
                delQuery8 = "delete dndtm from debitnotedetailtermmap dndtm inner join dntaxentry dnt on dnt.id = dndtm.debitnotetaxentry where dnt.company =? and dnt.debitnote= ?";
                executeSQLUpdate(delQuery8, params11.toArray());
                
                params11 = new ArrayList();
                params11.add(requestParams.get("companyid"));
                params11.add(requestParams.get("dnid"));
                delQuery8 = "delete  from dntaxentry  where company =? and debitnote= ?";
                int numRows8 = executeSQLUpdate( delQuery8, params11.toArray());
                
                ArrayList params12 = new ArrayList();
                String delQuery12 = "delete from openingbalancedebitnotecustomdata where openingbalancedebitnoteid=? ";
                params12.add(requestParams.get("dnid"));
                int numRows12 = executeSQLUpdate(delQuery12, params12.toArray());

                /**
                 * Need to delete mapping from debitnoteinvociemappinginfo. It
                 * is used to store debit note & goodsreceipt mapping for India
                 * country.
                 */
                ArrayList params6 = new ArrayList();
                params6.add(requestParams.get("dnid"));
                delQuery6 = "delete from debitnoteinvoicemappinginfo where debitnote = ?";
                executeSQLUpdate( delQuery6, params6.toArray());
                
                params6 = new ArrayList();
                params6.add(requestParams.get("companyid"));
                params6.add(requestParams.get("dnid"));
                delQuery6 = "delete  from debitnote  where company =? and id = ?";
                int numRows6 = executeSQLUpdate( delQuery6, params6.toArray());

                ArrayList params10 = new ArrayList();
                params10.add(requestParams.get("companyid"));
                params10.add(requestParams.get("dnid"));
                delQuery7 = "delete from dndiscount where company =? and debitnote =?";
                int numRows7 = executeSQLUpdate( delQuery7, params10.toArray());

                int numRows3 = 0;
                int numRows4 = 0;
                int numRows2 = 0;
                if (!requestParams.containsKey("debitNote")) {
                    List list13 = new ArrayList();
                    ArrayList params13 = new ArrayList();
                    params13.add(requestParams.get("companyid"));
                    String myquery13 = "select bankReconciliation from bankreconciliationdetail where journalEntry in (" + journalent + ") and company=?";
                    if(!StringUtil.isNullOrEmpty(idStrings)){
                        list13 = executeSQLQuery(myquery13, params13.toArray());
                    }
                    Iterator itr13 = list13.iterator();
                    String bankrec = "";
                    while (itr13.hasNext()) {
                        Object bankrecobj = itr13.next();
                        String bankrecid = (bankrecobj != null) ? bankrecobj.toString() : "";
                        bankrec += "'" + bankrecid + "',";
                    }
                    if (!StringUtil.isNullOrEmpty(bankrec)) {
                        bankrec = bankrec.substring(0, bankrec.length() - 1);
                    }
                    /**
                     * delete unreconciled records in case of permanent delete.
                     */
                    requestParams.put("jeid", jeid);
                    accBankReconciliationDAOObj.deleteUnReconciliationRecords(requestParams);
                    
                    ArrayList params14 = new ArrayList();
                    params14.add(requestParams.get("companyid"));
                    String delquery14 = "delete from bankunreconciliationdetail where journalEntry in (" + journalent + ") and company = ?";
                    if (!StringUtil.isNullOrEmpty(idStrings)) {
                        int numRows14 = executeSQLUpdate(delquery14, params14.toArray());
                    }
                    
                    if (!StringUtil.isNullOrEmpty(bankrec)) {
                        ArrayList params15 = new ArrayList();
                        params15.add(requestParams.get("companyid"));
                        String delQuery15 = "delete from bankreconciliation where id in (" + bankrec + ") and company =?";
                        int numRows15 = executeSQLUpdate(delQuery15, params15.toArray());
                    }
                    
                    ArrayList params3 = new ArrayList();
                    params3.add(requestParams.get("companyid"));
                    delQuery3 = "delete from jedetail where company = ? and journalEntry in (" + journalent + ") ";
                    numRows3 = executeSQLUpdate( delQuery3, params3.toArray());

                    ArrayList params4 = new ArrayList();
                    delQuery4 = "delete from journalentry where id  in (" + journalent + ")";
                    numRows4 = executeSQLUpdate( delQuery4, params4.toArray());

                    ArrayList params2 = new ArrayList();
                    delQuery2 = "delete  from accjecustomdata where journalentryId in (" + journalent + ")";
                    numRows2 = executeSQLUpdate( delQuery2, params2.toArray());
                }
                numtotal = numRows + numRows1 + numRows2 + numRows3 + numRows4 + numRows5 + numRows6 + numRows7 + numRows8;
            }

            return new KwlReturnObject(true, "Debit Note has been deleted successfully.", null, null, numtotal);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("Cannot delete Debit Note as its referance child field is not deleted.", ex);//+ex.getMessage(), ex);
        }

    }

    public KwlReturnObject deleteBillingDebitNote(String bdnid, String companyid) throws ServiceException {
        String query = "update BillingDebitNote set deleted=true where ID = ? and company.companyID=?";
//        String query = "update DebitNote set deleted=true where ID=? and company.companyID=?";
        int numRows = executeUpdate( query, new Object[]{bdnid, companyid});
        return new KwlReturnObject(true, "Debit Note has been deleted successfully.", null, null, numRows);
    }

    public KwlReturnObject getDNRFromBDN(String receiptid) throws ServiceException {
        String selQuery = "select dn, dnr, dnd from BillingDebitNote dn left join dn.rows dnr left join dn.discounts dnd where dn.deleted=false and (dnr.goodsReceiptRow.billingGoodsReceipt.ID=? or dnd.goodsReceipt.ID=?) order by dn.sequence";
        List list = executeQuery( selQuery, new Object[]{receiptid, receiptid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getBDNDetailsFromGReceipt(String receiptid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String query = "from BillingDebitNoteDetail dn  where dn.goodsReceiptRow.billingGoodsReceipt.ID = ?  and dn.debitNote.deleted=false and dn.company.companyID=?";
        //String query = "from DebitNoteDetail dn  where dn.goodsReceiptRow.goodsReceipt.ID=? and dn.debitNote.deleted=false and dn.company.companyID=?";
        list = executeQuery( query, new Object[]{receiptid, companyid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject getTotalDiscountAndQty(String receiptid) throws ServiceException {
        String selQuery = "select sum(dnd.discount.discount) as totaldiscount, sum(dnd.quantity) as totalqty  from DebitNoteDetail dnd where dnd.goodsReceiptRow.ID =? and dnd.discount.deleted=false";
//        String selQuery = "select sum(discount) from Discount where ID in (select discount from DebitNoteDetail where goodsReceiptRow.ID =?) and deleted=false";
        List list = executeQuery( selQuery, new Object[]{receiptid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

//    public KwlReturnObject getTotalQty(String invId) throws ServiceException {
//        String selQuery = "select sum(quantity) from DebitNoteDetail where goodsReceiptRow.ID=? and discount.deleted=false";
//        List list = executeQuery( selQuery, new Object[]{invId});
//        return new KwlReturnObject(true, "", null, list, list.size());
//    }
    public KwlReturnObject getTotalTax_TotalDiscount(String dnid) throws ServiceException {
        String selQuery = "select sum(taxAmount), sum(totalDiscount) from DebitNoteDetail where debitNote.ID = ?";
        List list = executeQuery( selQuery, new Object[]{dnid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getTotalTax_TotalDiscount_Billing(String dnid) throws ServiceException {
        String selQuery = "select sum(taxAmount), sum(totalDiscount) from BillingDebitNoteDetail where debitNote.ID = ?";
        List list = executeQuery( selQuery, new Object[]{dnid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject getOpeningBalanceCustomerDNs(HashMap<String, Object> request) throws ServiceException {
        List<DebitNote> list = null;
        boolean excludeNormal = false;
        boolean onlyOpeningNormalDNs = false;
        int count = 0;
        String companyid = (String) request.get("companyid");
        DateFormat df = (DateFormat) request.get(Constants.df);
        String start = (String) request.get("start");
        String limit = (String) request.get("limit");
        String customerid = (String) request.get("customerid");
        String vendorIdGroup = (String) request.get("custVendorID");
        if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
            vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
        }
        boolean isAgedReport = (request.containsKey("agedReport") && request.get("agedReport") != null) ? Boolean.parseBoolean(request.get("agedReport").toString()) : false;
        boolean isAgedSummary = (request.containsKey("isAgedSummary") && request.get("isAgedSummary") != null) ? Boolean.parseBoolean(request.get("isAgedSummary").toString()) : false;
        boolean isSOA = (request.containsKey("isSOA") && request.get("isSOA") != null) ? Boolean.parseBoolean(request.get("isSOA").toString()) : false;
        
        boolean onlyAmountDue = (request.containsKey("onlyAmountDue") && request.get("onlyAmountDue") != null) ? Boolean.parseBoolean(request.get("onlyAmountDue").toString()) : false;
        boolean isAccountDNs = false;
        boolean isPendingApproval = false;
        if (request.containsKey("pendingapproval") && request.get("pendingapproval") != null && !StringUtil.isNullOrEmpty(request.get("pendingapproval").toString())) {
            isPendingApproval = Boolean.parseBoolean(request.get("pendingapproval").toString());
        }
        if (request.containsKey("isAccountDNs") && request.get("isAccountDNs") != null) {
            isAccountDNs = (Boolean) request.get("isAccountDNs");
        }
        String newcustomerid = "";
        if (request.containsKey(Constants.newcustomerid) && request.get(Constants.newcustomerid) != null) {
            newcustomerid = (String) request.get(Constants.newcustomerid);
        }
        String newvendorid = "";
        if (request.containsKey(Constants.newvendorid) && request.get(Constants.newvendorid) != null) {
            newvendorid = (String) request.get(Constants.newvendorid);
        }
        try {
            String condition = "";
            ArrayList params = new ArrayList();

            params.add(companyid);
            
            if (!StringUtil.isNullOrEmpty(newcustomerid)) {
                if (newcustomerid.contains(",")) {
                    newcustomerid = AccountingManager.getFilterInString(newcustomerid);
                    condition += " and dn.customer.ID IN" + newcustomerid;
                } else {
                    params.add(newcustomerid);
                    condition += " and dn.customer.ID = ? ";
                }
            }
            if (!StringUtil.isNullOrEmpty(newvendorid)) {
                condition += " and dn.vendor.ID = ? ";
                params.add(newvendorid);
            }
            if (isAccountDNs && request.containsKey("accountId") && request.get("accountId") != null) {
                String accountId = request.get("accountId").toString();
                condition += " AND dn.account.ID=? ";
                params.add(accountId);
            } else if (!StringUtil.isNullOrEmpty(customerid)) {
                condition += " AND dn.customer.ID=? ";
                params.add(customerid);
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " AND dn.customer.ID IN " + vendorIdGroup;
            }

            if (request.get("excludeNormal") != null) {
                excludeNormal = Boolean.parseBoolean(request.get("excludeNormal").toString());
            }

            if (excludeNormal) {
                condition += " AND dn.normalDN=false ";
            }

            if (request.get("onlyOpeningNormalDNs") != null) {
                onlyOpeningNormalDNs = Boolean.parseBoolean(request.get("onlyOpeningNormalDNs").toString());
            }

            if (onlyOpeningNormalDNs) {
                condition += " AND dn.normalDN=true ";
            }

            if (onlyAmountDue) {
                condition += " AND dn.openingBalanceAmountDue > 0 ";
            }
            String currencyfilterfortrans = "";
            if (request.containsKey("currencyfilterfortrans")) {
                currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            }

            boolean isNoteForPayment = false;
            if (request.get("isNoteForPayment") != null) {
                isNoteForPayment = (Boolean) request.get("isNoteForPayment");
            }
            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)&&!isNoteForPayment) {
                params.add(currencyfilterfortrans);
                condition += " and dn.currency.currencyID = ? ";
            }

            if (request.containsKey("groupcombo") && request.get("groupcombo") != null && request.containsKey(Constants.globalCurrencyKey) && request.get(Constants.globalCurrencyKey) != null) {
                int groupcombo = (Integer) request.get("groupcombo");

                if (groupcombo == Constants.AgedPayableBaseCurrency) {
                    condition += " and dn.currency.currencyID=" + Integer.parseInt((String) request.get(Constants.globalCurrencyKey));
                } else if (groupcombo == Constants.AgedPayableOtherthanBaseCurrency) {
                    condition += " and dn.currency.currencyID!=" + Integer.parseInt((String) request.get(Constants.globalCurrencyKey));
                }
            }
            
                String startDate = (String) request.get(Constants.REQ_startdate);
                String endDate = (String) request.get(Constants.REQ_enddate);
            if (!(isAgedReport || isAgedSummary || isSOA)) { //in aged report all opening transactions are required so no need to give start and end date
                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                    condition += " and (dn.creationDate >=? and dn.creationDate <=?) ";
                    params.add(df.parse(startDate));
                    params.add(df.parse(endDate));
                }
            } else if (!isSOA) {
                 if (request.containsKey("MonthlyAgeingEndDate") && request.get("MonthlyAgeingEndDate") != null) {
                    condition += " and dn.creationDate <=? ";
                    params.add(request.get("MonthlyAgeingEndDate"));
                 } else if (!StringUtil.isNullOrEmpty(endDate)) {
                    condition += " and dn.creationDate <=? ";
                    params.add(df.parse(endDate));
                }
            }

            String ss = (request.containsKey("ss") && request.get("ss") != null) ? (String) request.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.customer.name","dn.customer.aliasname","dn.customer.acccode", "dn.debitNoteNumber", "dn.account.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 5);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery + " AND dn.customer IS NOT NULL ";
            }
            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().trim().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
             if (isPendingApproval) { // Get only pending approved records
                condition += " and dn.approvestatuslevel != ? ";
                params.add(11);
            }
            String Searchjson = "";
            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
                Searchjson = StringUtil.DecodeText(request.get("searchJson").toString());

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                        request.put(Constants.Searchjson, Searchjson);
                        request.put(Constants.appendCase, appendCase);
                        request.put("isOpeningBalance",true);
                        request.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(request, true).get(Constants.myResult));
                        mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "OpeningBalanceDebitNoteCustomData");
                        mySearchFilterString = mySearchFilterString.replaceAll("CustomerCustomData", "dn.customer.accCustomerCustomData");
                        mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "dn.openingBalanceDebitNoteCustomData");
                        mySearchFilterString = mySearchFilterString.replaceAll("accjecustomdata", "dn.openingBalanceDebitNoteCustomData");
                        StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                        request.put("isOpeningBalance",false);
                    }
                }
            if (!mySearchFilterString.contains("VendorCustomData")) {
                String query = "Select dn from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=false AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
                list = executeQuery( query, params.toArray());
                count = list.size();
                if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                    list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
                }
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getOpeningBalanceCustomerDNs : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }
    
    @Override
    public int getOpeningBalanceCustomerDNCount(HashMap<String, Object> request) throws ServiceException {
        List list = null;
        boolean excludeNormal = false;
        boolean onlyOpeningNormalDNs = false;
        int count = 0;
        String companyid = (String) request.get("companyid");
        DateFormat df = (DateFormat) request.get(Constants.df);
        String customerid = (String) request.get("customerid");
        String vendorIdGroup = (String) request.get("custVendorID");
        if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
            vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
        }
        boolean isAgedReport = (request.containsKey("agedReport") && request.get("agedReport") != null) ? Boolean.parseBoolean(request.get("agedReport").toString()) : false;
        boolean isAgedSummary = (request.containsKey("isAgedSummary") && request.get("isAgedSummary") != null) ? Boolean.parseBoolean(request.get("isAgedSummary").toString()) : false;

        boolean isAccountDNs = false;
        if (request.containsKey("isAccountDNs") && request.get("isAccountDNs") != null) {
            isAccountDNs = (Boolean) request.get("isAccountDNs");
        }

        try {
            String condition = "";
            ArrayList params = new ArrayList();

            params.add(companyid);

            if (isAccountDNs && request.containsKey("accountId") && request.get("accountId") != null) {
                String accountId = request.get("accountId").toString();
                condition += " AND dn.account.ID=? ";
                params.add(accountId);
            } else if (!StringUtil.isNullOrEmpty(customerid)) {
                condition += " AND dn.customer.ID=? ";
                params.add(customerid);
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " AND dn.customer.ID IN " + vendorIdGroup;
            }

            if (request.get("excludeNormal") != null) {
                excludeNormal = Boolean.parseBoolean(request.get("excludeNormal").toString());
            }

            if (excludeNormal) {
                condition += " AND dn.normalDN=false ";
            }

            if (request.get("onlyOpeningNormalDNs") != null) {
                onlyOpeningNormalDNs = Boolean.parseBoolean(request.get("onlyOpeningNormalDNs").toString());
            }

            if (onlyOpeningNormalDNs) {
                condition += " AND dn.normalDN=true ";
            }

            String currencyfilterfortrans = "";
            if (request.containsKey("currencyfilterfortrans")) {
                currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            }

            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)) {
                params.add(currencyfilterfortrans);
                condition += " and dn.currency.currencyID = ? ";
            }

            if (!isAgedReport && !isAgedSummary) { //in aged report all opening transactions are required so no need to give start and end date
                String startDate = (String) request.get(Constants.REQ_startdate);
                String endDate = (String) request.get(Constants.REQ_enddate);
                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                    condition += " and (dn.creationDate >=? and dn.creationDate <=?) ";
                    params.add(df.parse(startDate));
                    params.add(df.parse(endDate));
                }
            }

            String ss = (request.containsKey("ss") && request.get("ss") != null) ? (String) request.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.customer.name","dn.customer.acccode", "dn.debitNoteNumber", "dn.account.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 4);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery + " AND dn.customer IS NOT NULL ";
            }
            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
//            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
//                Searchjson = request.get("searchJson").toString();
//
//                if (!StringUtil.isNullOrEmpty(Searchjson)) {
//                    request.put(Constants.Searchjson, Searchjson);
//                    request.put(Constants.appendCase, appendCase);
//                    request.put("isOpeningBalance",true);
//                    request.put("filterConjuctionCriteria", filterConjuctionCriteria);
//                    mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
//                    mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "dn.openingBalanceDebitNoteCustomData");
//                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
//                }
//            }
            String query = "Select count(dn.ID) from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=false AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
            list = executeQuery( query, params.toArray());
            Long totalCnt = 0l;
            if (list != null && !list.isEmpty()){
                totalCnt = (Long) list.get(0);
            }
            count = totalCnt.intValue();
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getOpeningBalanceCustomerDNCount : " + ex.getMessage(), ex);
        }
        return count;
    }
    
    
    @Override
    public KwlReturnObject getOpeningBalanceTotalBaseAmountDueForCustomerDNs(HashMap<String, Object> request) throws ServiceException {
        List<DebitNote> list = null;
        boolean excludeNormal = false;
        boolean onlyOpeningNormalDNs = false;
        int count = 0;
        String companyid = (String) request.get("companyid");
        DateFormat df = (DateFormat) request.get(Constants.df);
        String start = (String) request.get("start");
        String limit = (String) request.get("limit");
        String customerid = (String) request.get("customerid");
        String vendorIdGroup = (String) request.get("custVendorID");
        if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
            vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
        }
        boolean isAgedReport = (request.containsKey("agedReport") && request.get("agedReport") != null) ? Boolean.parseBoolean(request.get("agedReport").toString()) : false;
        boolean isAgedSummary = (request.containsKey("isAgedSummary") && request.get("isAgedSummary") != null) ? Boolean.parseBoolean(request.get("isAgedSummary").toString()) : false;

        boolean isAccountDNs = false;
        if (request.containsKey("isAccountDNs") && request.get("isAccountDNs") != null) {
            isAccountDNs = (Boolean) request.get("isAccountDNs");
        }

        try {
            String condition = "";
            ArrayList params = new ArrayList();

            params.add(companyid);

            if (isAccountDNs && request.containsKey("accountId") && request.get("accountId") != null) {
                String accountId = request.get("accountId").toString();
                condition += " AND dn.account.ID=? ";
                params.add(accountId);
            } else if (!StringUtil.isNullOrEmpty(customerid)) {
                condition += " AND dn.customer.ID=? ";
                params.add(customerid);
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " AND dn.customer.ID IN " + vendorIdGroup;
            }

            if (request.get("excludeNormal") != null) {
                excludeNormal = Boolean.parseBoolean(request.get("excludeNormal").toString());
            }

            if (excludeNormal) {
                condition += " AND dn.normalDN=false ";
            }

            if (request.get("onlyOpeningNormalDNs") != null) {
                onlyOpeningNormalDNs = Boolean.parseBoolean(request.get("onlyOpeningNormalDNs").toString());
            }

            if (onlyOpeningNormalDNs) {
                condition += " AND dn.normalDN=true ";
            }

            String currencyfilterfortrans = "";
            if (request.containsKey("currencyfilterfortrans")) {
                currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            }

            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)) {
                params.add(currencyfilterfortrans);
                condition += " and dn.currency.currencyID = ? ";
            }

            if (!isAgedReport && !isAgedSummary) { //in aged report all opening transactions are required so no need to give start and end date
                String startDate = (String) request.get(Constants.REQ_startdate);
                String endDate = (String) request.get(Constants.REQ_enddate);
                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                    condition += " and (dn.creationDate >=? and dn.creationDate <=?) ";
                    params.add(df.parse(startDate));
                    params.add(df.parse(endDate));
                }
            }

            String ss = (request.containsKey("ss") && request.get("ss") != null) ? (String) request.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.customer.name","dn.customer.acccode", "dn.debitNoteNumber", "dn.account.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 4);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery + " AND dn.customer IS NOT NULL ";
            }
            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
                Searchjson = request.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    request.put(Constants.Searchjson, Searchjson);
                    request.put(Constants.appendCase, appendCase);
                    request.put("isOpeningBalance",true);
                    request.put("filterConjuctionCriteria", filterConjuctionCriteria);
                    mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
                    mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "dn.openingBalanceDebitNoteCustomData");
                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                }
            }
            String query = "Select COALESCE(SUM(dn.openingBalanceBaseAmountDue),0) from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=false AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
            list = executeQuery( query, params.toArray());
            count = list.size();
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getOpeningBalanceTotalBaseAmountDueForCustomerDNs : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }
    
     @Override
    public KwlReturnObject getOpeningBalanceTotalBaseAmountForCustomerDNs(HashMap<String, Object> request) throws ServiceException {
        List<DebitNote> list = null;
        boolean excludeNormal = false;
        boolean onlyOpeningNormalDNs = false;
        int count = 0;
        String companyid = (String) request.get("companyid");
        DateFormat df = (DateFormat) request.get(Constants.df);
        String start = (String) request.get("start");
        String limit = (String) request.get("limit");
        String customerid = (String) request.get("customerid");
        String vendorIdGroup = (String) request.get("custVendorID");
        if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
            vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
        }
        boolean isAgedReport = (request.containsKey("agedReport") && request.get("agedReport") != null) ? Boolean.parseBoolean(request.get("agedReport").toString()) : false;
        boolean isAgedSummary = (request.containsKey("isAgedSummary") && request.get("isAgedSummary") != null) ? Boolean.parseBoolean(request.get("isAgedSummary").toString()) : false;

        boolean isAccountDNs = false;
        if (request.containsKey("isAccountDNs") && request.get("isAccountDNs") != null) {
            isAccountDNs = (Boolean) request.get("isAccountDNs");
        }

        try {
            String condition = "";
            ArrayList params = new ArrayList();

            params.add(companyid);

            if (isAccountDNs && request.containsKey("accountId") && request.get("accountId") != null) {
                String accountId = request.get("accountId").toString();
                condition += " AND dn.account.ID=? ";
                params.add(accountId);
            } else if (!StringUtil.isNullOrEmpty(customerid)) {
                condition += " AND dn.customer.ID=? ";
                params.add(customerid);
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " AND dn.customer.ID IN " + vendorIdGroup;
            }

            if (request.get("excludeNormal") != null) {
                excludeNormal = Boolean.parseBoolean(request.get("excludeNormal").toString());
            }

            if (excludeNormal) {
                condition += " AND dn.normalDN=false ";
            }

            if (request.get("onlyOpeningNormalDNs") != null) {
                onlyOpeningNormalDNs = Boolean.parseBoolean(request.get("onlyOpeningNormalDNs").toString());
            }

            if (onlyOpeningNormalDNs) {
                condition += " AND dn.normalDN=true ";
            }

            String currencyfilterfortrans = "";
            if (request.containsKey("currencyfilterfortrans")) {
                currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            }

            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)) {
                params.add(currencyfilterfortrans);
                condition += " and dn.currency.currencyID = ? ";
            }
////For now this method get called from 2 places and from both places we does need to apply start date and end date. It is casusing issue like SDP-5696 So commenting below code
//            if (!isAgedReport && !isAgedSummary) { //in aged report all opening transactions are required so no need to give start and end date
//                String startDate = (String) request.get(Constants.REQ_startdate);
//                String endDate = (String) request.get(Constants.REQ_enddate);
//                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
//                    condition += " and (dn.creationDate >=? and dn.creationDate <=?) ";
//                    params.add(df.parse(startDate));
//                    params.add(df.parse(endDate));
//                }
//            }
            String ss = (request.containsKey("ss") && request.get("ss") != null) ? (String) request.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.customer.name", "dn.customer.acccode", "dn.debitNoteNumber", "dn.account.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 4);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery + " AND dn.customer IS NOT NULL ";
            }

            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (request.containsKey("Searchjson") && request.get("Searchjson") != null && !StringUtil.isNullOrEmpty((String) request.get("Searchjson"))) {
                Searchjson = request.get("Searchjson").toString();
                Searchjson = getJsornStringForSearch(Searchjson, companyid);
                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    request.put(Constants.Searchjson, Searchjson);
                    request.put(Constants.appendCase, appendCase);
                    request.put(Constants.moduleid, 10);
                    request.put("isOpeningBalance", true);
                    request.put("filterConjuctionCriteria", filterConjuctionCriteria);
                    mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "dn.openingBalanceDebitNoteCustomData");
                    mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "dn.openingBalanceDebitNoteCustomData");
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "dn.openingBalanceDebitNoteCustomData");
                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                }
            }
            String query = "";
            if (request.containsKey("Searchjson") && request.get("Searchjson") != null && !StringUtil.isNullOrEmpty((String) request.get("Searchjson"))) {
                if (!StringUtil.isNullOrEmpty(mySearchFilterString) && !mySearchFilterString.equals(" ")) {
                    query = "Select COALESCE(SUM(dn.originalOpeningBalanceBaseAmount),0) from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=false AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
                    list = executeQuery( query, params.toArray());
                    count = list.size();
                }
            } else {
                query = "Select COALESCE(SUM(dn.originalOpeningBalanceBaseAmount),0) from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=false AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
                list = executeQuery( query, params.toArray());
                count = list.size();
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getOpeningBalanceTotalBaseAmountForCustomerDNs : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    public KwlReturnObject getFieldParams(HashMap<String, Object> requestParams) {
        KwlReturnObject result = null;
        List list = null;
        try {
            ArrayList name = null;
            String hql = "";
            ArrayList value = null;
            ArrayList orderby = null;
            ArrayList ordertype = null;
            String[] searchCol = null;
            hql = "from FieldParams ";
            if (requestParams.get("filter_names") != null && requestParams.get("filter_values") != null) {
                name = new ArrayList((List<String>) requestParams.get("filter_names"));
                value = new ArrayList((List<Object>) requestParams.get("filter_values"));
                hql += com.krawler.common.util.StringUtil.filterQuery(name, "where");
                int ind = hql.indexOf("(");
                if (ind > -1) {
                    int index = Integer.valueOf(hql.substring(ind + 1, ind + 2));
                    hql = hql.replace("(" + index + ")", "(" + value.get(index).toString() + ")");
                    value.remove(index);
                }
            }
            int moduleId = 0;
            if (requestParams.containsKey("moduleid")) {
                moduleId = requestParams.get("moduleid") != null ? Integer.parseInt(requestParams.get("moduleid").toString()) : 0;
            }

            if (requestParams.get("searchcol") != null && requestParams.get("ss") != null) {
                searchCol = (String[]) requestParams.get("searchcol");
                hql += StringUtil.getSearchquery(requestParams.get("ss").toString(), searchCol, value);
            }

            if (requestParams.containsKey("customfield") && (Integer) requestParams.get("customfield") != null) {
                hql += " and customfield = 1";
            }
            if (requestParams.containsKey("isActivated") && (Integer) requestParams.get("isActivated") != null) {
                int activatedFlag = (Integer) requestParams.get("isActivated");
                hql += " and isactivated = " + activatedFlag;
            }
            if (requestParams.containsKey("relatedmoduleid")) {
                hql += " and relatedmoduleid like '%" + requestParams.get("relatedmoduleid") + "%'";
            }
            if (requestParams.containsKey("parentid")) {
                hql += " and parentid = '" + requestParams.get("parentid") + "'";
            }
            if (requestParams.containsKey("checkForParent")) {
                hql += " and parentid is not null ";
            }
            if (moduleId != 0) {
                value.add(moduleId);
                hql += " and moduleid = ? ";
            }
            if (requestParams.get("order_by") != null && requestParams.get("order_type") != null) {
                orderby = new ArrayList((List<String>) requestParams.get("order_by"));
                ordertype = new ArrayList((List<Object>) requestParams.get("order_type"));
                hql += com.krawler.common.util.StringUtil.orderQuery(orderby, ordertype);
            }

            list = executeQuery( hql, value.toArray());


        } catch (Exception ex) {
            ex.printStackTrace();

        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public String getJsornStringForSearch(String Searchjson, String companyId) throws ServiceException {
        String returnStr = "";
        try {
            JSONArray jArray = new JSONArray();
            JSONObject jSONObject = new JSONObject();
            JSONObject jobjSearch = new JSONObject(Searchjson);
            int count = jobjSearch.getJSONArray(Constants.root).length();
            for (int i = 0; i < count; i++) {
                KwlReturnObject result = null;
                KwlReturnObject resultdata = null;
                JSONObject jobj1 = jobjSearch.getJSONArray(Constants.root).getJSONObject(i);
                String[] arr = null;
                HashMap<String, Object> requestParams = new HashMap<String, Object>();
                requestParams.put("moduleid", 10);
                requestParams.put(Constants.filter_names, Arrays.asList(Constants.companyid, Constants.fieldlabel));
                requestParams.put(Constants.filter_values, Arrays.asList(companyId,StringUtil.DecodeText(jobj1.optString("columnheader"))));
                result = getFieldParams(requestParams);
                List lst = result.getEntityList();
                Iterator ite = lst.iterator();
                while (ite.hasNext()) {
                    JSONObject jobj = new JSONObject();
                    FieldParams tmpcontyp = null;
                    tmpcontyp = (FieldParams) ite.next();
                    jobj.put("column", tmpcontyp.getId());
                    jobj.put("refdbname", Constants.Custom_Column_Prefix + tmpcontyp.getColnum());
                    jobj.put("xfield", Constants.Custom_Column_Prefix + tmpcontyp.getColnum());
                    jobj.put("iscustomcolumn", jobj1.getString("iscustomcolumn"));
                    jobj.put("iscustomcolumndata", tmpcontyp.isIsForKnockOff() ? (tmpcontyp.getCustomcolumn() == 1 ? "true" : "false") : jobj1.getString("iscustomcolumndata"));
                    jobj.put("isfrmpmproduct", jobj1.getString("isfrmpmproduct"));
                    jobj.put("fieldtype", tmpcontyp.getFieldtype());
                    if (tmpcontyp.getFieldtype() == 4 || tmpcontyp.getFieldtype() == 7 || tmpcontyp.getFieldtype() == 12) {
                        arr = jobj1.getString("searchText").split(",");
                        String Searchstr = "";
                        HashMap<String, Object> requestParamsdata = null;
                        for (String key : arr) {
                            FieldComboData fieldComboData1 = (FieldComboData) get(FieldComboData.class, key);
                            requestParamsdata = new HashMap<String, Object>();
                            requestParamsdata.put(Constants.filter_names, Arrays.asList(Constants.Acc_custom_fieldId, "value"));
                            try {
                                requestParamsdata.put(Constants.filter_values, Arrays.asList(tmpcontyp.getId(), StringUtil.DecodeText(fieldComboData1.getValue())));
                            } catch (Exception e) {
                                requestParamsdata.put(Constants.filter_values, Arrays.asList(tmpcontyp.getId(), fieldComboData1.getValue()));
                            }

                            resultdata = getFieldParamsComboData(requestParamsdata);
                            List lstdata = resultdata.getEntityList();
                            Iterator itedata = lstdata.iterator();
                            if (itedata.hasNext()) {
                                FieldComboData fieldComboData = null;
                                fieldComboData = (FieldComboData) itedata.next();
                                Searchstr += fieldComboData.getId().toString() + ",";
                            }
                        }
                        jobj.put("searchText", Searchstr);
                        jobj.put("search", Searchstr);
                    } else {
                        jobj.put("searchText", jobj1.getString("searchText"));
                        jobj.put("search", jobj1.getString("searchText"));
                    }
                    jobj.put("columnheader", StringUtil.DecodeText(jobj1.optString("columnheader")));
                    try{
                        jobj.put("combosearch", StringUtil.DecodeText(jobj1.optString("combosearch")));
                    } catch(Exception e){
                        jobj.put("combosearch", jobj1.getString("combosearch"));
                    }
                    jobj.put("isinterval", jobj1.getString("isinterval"));
                    jobj.put("interval", jobj1.getString("interval"));
                    jobj.put("isbefore", jobj1.getString("isbefore"));
                    jobj.put("xtype", StringUtil.getXtypeVal(tmpcontyp.getFieldtype()));
                    jArray.put(jobj);
                    if (tmpcontyp.getCustomcolumn() == 1 && tmpcontyp.getCustomfield() == 0) {
                        JSONObject jobjOnlyForDimention = new JSONObject(jobj.toString());
                        jobjOnlyForDimention.remove("iscustomcolumndata");
                        jobjOnlyForDimention.put("iscustomcolumndata", "true");
                        jArray.put(jobjOnlyForDimention);
                    }
                }
            }
            jSONObject.put("root", jArray);
            returnStr = jSONObject.toString();
        } catch (JSONException ex) {
            Logger.getLogger(accAccountDAOImpl.class.getName()).log(Level.SEVERE, null, ex);
        }catch (Exception e) {
            Logger.getLogger(accAccountDAOImpl.class.getName()).log(Level.SEVERE, null, e);
        }
        return returnStr;
    }

    public KwlReturnObject getFieldParamsComboData(HashMap<String, Object> requestParams) {
        KwlReturnObject result = null;
        List list = null;
        try {
            ArrayList name = null;
            String hql = "";
            ArrayList value = null;
            ArrayList orderby = null;
            ArrayList ordertype = null;
            String[] searchCol = null;
            hql = "from FieldComboData ";
            if (requestParams.get("filter_names") != null && requestParams.get("filter_values") != null) {
                name = new ArrayList((List<String>) requestParams.get("filter_names"));
                value = new ArrayList((List<Object>) requestParams.get("filter_values"));
                hql += com.krawler.common.util.StringUtil.filterQuery(name, "where");
                int ind = hql.indexOf("(");

                if (ind > -1) {
                    int index = Integer.valueOf(hql.substring(ind + 1, ind + 2));
                    hql = hql.replace("(" + index + ")", "(" + value.get(index).toString() + ")");
                    value.remove(index);
                }
            }

            if (requestParams.get("searchcol") != null && requestParams.get("ss") != null) {
                searchCol = (String[]) requestParams.get("searchcol");
                hql += StringUtil.getSearchquery(requestParams.get("ss").toString(), searchCol, value);
            }

            if (requestParams.get("order_by") != null && requestParams.get("order_type") != null) {
                orderby = new ArrayList((List<String>) requestParams.get("order_by"));
                ordertype = new ArrayList((List<Object>) requestParams.get("order_type"));
                hql += com.krawler.common.util.StringUtil.orderQuery(orderby, ordertype);
            }
            if (requestParams.containsKey("customfield") && (Integer) requestParams.get("customfield") != null) {
                hql += " and customfield = 1";
            }
            if (requestParams.containsKey("relatedmoduleid")) {
                hql += " and relatedmoduleid like '%" + requestParams.get("relatedmoduleid") + "%'";
            }
            list = executeQuery( hql, value.toArray());
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject getOpeningBalanceDNs(HashMap<String, Object> request) throws ServiceException {
        List<DebitNote> list = null;
        boolean excludeNormal = false;
        boolean onlyOpeningNormalDNs = false;
        boolean isAgedReport = (request.containsKey("agedReport") && request.get("agedReport") != null) ? Boolean.parseBoolean(request.get("agedReport").toString()) : false;
        boolean isAgedSummary = (request.containsKey("isAgedSummary") && request.get("isAgedSummary") != null) ? Boolean.parseBoolean(request.get("isAgedSummary").toString()) : false;
        
        boolean onlyAmountDue = (request.containsKey("onlyAmountDue") && request.get("onlyAmountDue") != null) ? Boolean.parseBoolean(request.get("onlyAmountDue").toString()) : false;

        boolean isPendingApproval = false;
        if (request.containsKey("pendingapproval") && request.get("pendingapproval") != null && !StringUtil.isNullOrEmpty(request.get("pendingapproval").toString())) {
            isPendingApproval = Boolean.parseBoolean(request.get("pendingapproval").toString());
        }
        int count = 0;
        String companyid = (String) request.get("companyid");
        DateFormat df = (DateFormat) request.get(Constants.df);
        String start = (String) request.get("start");
        String limit = (String) request.get("limit");
        String vendorid = (String) request.get("vendorid");

        String vendorIdGroup = (String) request.get("custVendorID");
        if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
            vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
        }
        boolean isAccountDNs = false;
        if (request.containsKey("isAccountDNs") && request.get("isAccountDNs") != null) {
            isAccountDNs = (Boolean) request.get("isAccountDNs");
        }

        String newcustomerid = "";
        if (request.containsKey(Constants.newcustomerid) && request.get(Constants.newcustomerid) != null) {
            newcustomerid = (String) request.get(Constants.newcustomerid);
        }
        String newvendorid = "";
        if (request.containsKey(Constants.newvendorid) && request.get(Constants.newvendorid) != null) {
            newvendorid = (String) request.get(Constants.newvendorid);
        }
        try {
            String condition = "";
            ArrayList params = new ArrayList();

            params.add(companyid);
            
            if (!StringUtil.isNullOrEmpty(newcustomerid)) {
                condition += " and dn.customer = ? ";
                params.add(newcustomerid);
            }
            
            if (!StringUtil.isNullOrEmpty(newvendorid)) {
                if (newvendorid.contains(",")) {
                    newvendorid = AccountingManager.getFilterInString(newvendorid);
                    condition += " and dn.vendor.ID IN" + newvendorid;
                } else {
                    params.add(newvendorid);
                    condition += " and dn.vendor.ID = ? ";

                }
            }
            
            if (isAccountDNs && request.containsKey("accountId") && request.get("accountId") != null) {
                String accountId = request.get("accountId").toString();
                condition += " AND dn.account.ID=? ";
                params.add(accountId);
            } else if (vendorid != null) {
                condition += " AND dn.vendor.ID=? ";
                params.add(vendorid);
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " AND dn.vendor.ID IN " + vendorIdGroup;
            }

            if (request.get("excludeNormal") != null) {
                excludeNormal = Boolean.parseBoolean(request.get("excludeNormal").toString());
            }
            if (onlyAmountDue) {
                condition += " AND dn.openingBalanceAmountDue > 0 ";
            }
            if (excludeNormal) {
                condition += " AND dn.normalDN=false ";
            }

            if (request.get("onlyOpeningNormalDNs") != null) {
                onlyOpeningNormalDNs = Boolean.parseBoolean(request.get("onlyOpeningNormalDNs").toString());
            }

            if (onlyOpeningNormalDNs) {
                condition += " AND dn.normalDN=true ";
            }

            String currencyfilterfortrans = "";
            if (request.containsKey("currencyfilterfortrans")) {
                currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            }
            boolean isNoteForPayment = false;
            if (request.get("isNoteForPayment") != null) {
                isNoteForPayment = (Boolean) request.get("isNoteForPayment");
            }
            
            if (request.containsKey("groupcombo") && request.get("groupcombo") != null && request.containsKey(Constants.globalCurrencyKey) && request.get(Constants.globalCurrencyKey) != null) {
                int groupcombo = (Integer) request.get("groupcombo");

                if (groupcombo == Constants.AgedPayableBaseCurrency) {
                    condition += " and dn.currency.currencyID=" + Integer.parseInt((String) request.get(Constants.globalCurrencyKey));
                } else if(groupcombo == Constants.AgedPayableOtherthanBaseCurrency) {
                    condition += " and dn.currency.currencyID!=" + Integer.parseInt((String) request.get(Constants.globalCurrencyKey));
                }
            }
            
            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)&&!isNoteForPayment) {
                params.add(currencyfilterfortrans);
                condition += " and dn.currency.currencyID = ? ";
            }
            
                String startDate = (String) request.get(Constants.REQ_startdate);
                String endDate = (String) request.get(Constants.REQ_enddate);
                
            if (!isAgedReport && !isAgedSummary) { //in aged report We are appling EndDate Filter For opening transactions
                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                    condition += " and (dn.creationDate >=? and dn.creationDate <=?) ";
                    params.add(df.parse(startDate));
                    params.add(df.parse(endDate));
                }
            } else {
                if (request.containsKey("MonthlyAgeingEndDate") && request.get("MonthlyAgeingEndDate") != null) {
                    condition += " and dn.creationDate <=? ";
                    params.add(request.get("MonthlyAgeingEndDate"));
                } else if (!StringUtil.isNullOrEmpty(endDate)) {
                    condition += " and dn.creationDate <=? ";
                    params.add(df.parse(endDate));
                }
            }

            String ss = (request.containsKey("ss") && request.get("ss") != null) ? (String) request.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.vendor.name","dn.vendor.aliasname","dn.vendor.acccode", "dn.debitNoteNumber", "dn.account.name"};
                Map SearchStringMap = StringUtil.insertParamSearchStringMap(params, ss, 5);
                StringUtil.insertParamSearchString(SearchStringMap);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery + " AND dn.vendor IS NOT NULL ";
            }
            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().trim().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            if (isPendingApproval) { // Get only pending approved records
                condition += " and dn.approvestatuslevel != ? ";
                params.add(11);
            }
            String Searchjson = "";
            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
                Searchjson = StringUtil.DecodeText(request.get("searchJson").toString());

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    request.put(Constants.Searchjson, Searchjson);
                    request.put(Constants.appendCase, appendCase);
                    request.put("isOpeningBalance",true);
                    request.put("filterConjuctionCriteria", filterConjuctionCriteria);
                    mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(request, true).get(Constants.myResult));
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "OpeningBalanceDebitNoteCustomData");
                    mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "dn.openingBalanceDebitNoteCustomData");
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "dn.openingBalanceDebitNoteCustomData");
                    if (mySearchFilterString.contains("VendorCustomData")) {
                        mySearchFilterString=mySearchFilterString.replaceAll("VendorCustomData", "dn.vendor.accVendorCustomData");
                    }
                    if (mySearchFilterString.contains("CustomerCustomData")) {
                        mySearchFilterString=mySearchFilterString.replaceAll("CustomerCustomData", "dn.customer.CustomerCustomData");
                    }
                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                    request.put("isOpeningBalance",false);
                }
            }
            if (!mySearchFilterString.contains("CustomerCustomData")) {
                String query = "Select dn from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=true AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
                list = executeQuery( query, params.toArray());
                count = list.size();
                if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                    list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
                }
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getOpeningBalanceDNs : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }
    
    @Override
    public int getOpeningBalanceDNCount(HashMap<String, Object> request) throws ServiceException {
        List list = null;
        boolean excludeNormal = false;
        boolean onlyOpeningNormalDNs = false;
        boolean isAgedReport = (request.containsKey("agedReport") && request.get("agedReport") != null) ? Boolean.parseBoolean(request.get("agedReport").toString()) : false;
        boolean isAgedSummary = (request.containsKey("isAgedSummary") && request.get("isAgedSummary") != null) ? Boolean.parseBoolean(request.get("isAgedSummary").toString()) : false;

        int count = 0;
        String companyid = (String) request.get("companyid");
        DateFormat df = (DateFormat) request.get(Constants.df);
        String vendorid = (String) request.get("vendorid");

        String vendorIdGroup = (String) request.get("custVendorID");
        if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
            vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
        }
        boolean isAccountDNs = false;
        if (request.containsKey("isAccountDNs") && request.get("isAccountDNs") != null) {
            isAccountDNs = (Boolean) request.get("isAccountDNs");
        }

        try {
            String condition = "";
            ArrayList params = new ArrayList();

            params.add(companyid);

            if (isAccountDNs && request.containsKey("accountId") && request.get("accountId") != null) {
                String accountId = request.get("accountId").toString();
                condition += " AND dn.account.ID=? ";
                params.add(accountId);
            } else if (vendorid != null) {
                condition += " AND dn.vendor.ID=? ";
                params.add(vendorid);
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " AND dn.vendor.ID IN " + vendorIdGroup;
            }

            if (request.get("excludeNormal") != null) {
                excludeNormal = Boolean.parseBoolean(request.get("excludeNormal").toString());
            }

            if (excludeNormal) {
                condition += " AND dn.normalDN=false ";
            }

            if (request.get("onlyOpeningNormalDNs") != null) {
                onlyOpeningNormalDNs = Boolean.parseBoolean(request.get("onlyOpeningNormalDNs").toString());
            }

            if (onlyOpeningNormalDNs) {
                condition += " AND dn.normalDN=true ";
            }

            String currencyfilterfortrans = "";
            if (request.containsKey("currencyfilterfortrans")) {
                currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            }

            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)) {
                params.add(currencyfilterfortrans);
                condition += " and dn.currency.currencyID = ? ";
            }
            if (!isAgedReport && !isAgedSummary) { //in aged report all opening transactions are required so no need to give start and end date
                String startDate = (String) request.get(Constants.REQ_startdate);
                String endDate = (String) request.get(Constants.REQ_enddate);
                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                    condition += " and (dn.creationDate >=? and dn.creationDate <=?) ";
                    params.add(df.parse(startDate));
                    params.add(df.parse(endDate));
                }
            }

            String ss = (request.containsKey("ss") && request.get("ss") != null) ? (String) request.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.vendor.name","dn.vendor.acccode", "dn.debitNoteNumber", "dn.account.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 4);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery + " AND dn.vendor IS NOT NULL ";
            }
            String appendCase = "and";
            String mySearchFilterString = "";
//            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
//            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
//                if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
//                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
//                }
//            }
//            String Searchjson = "";
//            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
//                Searchjson = request.get("searchJson").toString();
//
//                if (!StringUtil.isNullOrEmpty(Searchjson)) {
//                    request.put(Constants.Searchjson, Searchjson);
//                    request.put(Constants.appendCase, appendCase);
//                    request.put("isOpeningBalance",true);
//                    request.put("filterConjuctionCriteria", filterConjuctionCriteria);
//                    mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
//                    mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "dn.openingBalanceDebitNoteCustomData");
//                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
//                }
//            }
            String query = "Select count(dn.ID) from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=true AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
            list = executeQuery( query, params.toArray());
            Long totalCnt = 0l;
            if (list != null && !list.isEmpty()){
                totalCnt = (Long) list.get(0);
            }
            count = totalCnt.intValue();
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getOpeningBalanceDNCount : " + ex.getMessage(), ex);
        }
        return count;
    }
    
    @Override
    public KwlReturnObject getOpeningBalanceTotalBaseAmountDueForDNs(HashMap<String, Object> request) throws ServiceException {
        List<DebitNote> list = null;
        boolean excludeNormal = false;
        boolean onlyOpeningNormalDNs = false;
        boolean isAgedReport = (request.containsKey("agedReport") && request.get("agedReport") != null) ? Boolean.parseBoolean(request.get("agedReport").toString()) : false;
        boolean isAgedSummary = (request.containsKey("isAgedSummary") && request.get("isAgedSummary") != null) ? Boolean.parseBoolean(request.get("isAgedSummary").toString()) : false;

        int count = 0;
        String companyid = (String) request.get("companyid");
        DateFormat df = (DateFormat) request.get(Constants.df);
        String start = (String) request.get("start");
        String limit = (String) request.get("limit");
        String vendorid = (String) request.get("vendorid");

        String vendorIdGroup = (String) request.get("custVendorID");
        if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
            vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
        }
        boolean isAccountDNs = false;
        if (request.containsKey("isAccountDNs") && request.get("isAccountDNs") != null) {
            isAccountDNs = (Boolean) request.get("isAccountDNs");
        }

        try {
            String condition = "";
            ArrayList params = new ArrayList();

            params.add(companyid);

            if (isAccountDNs && request.containsKey("accountId") && request.get("accountId") != null) {
                String accountId = request.get("accountId").toString();
                condition += " AND dn.account.ID=? ";
                params.add(accountId);
            } else if (vendorid != null) {
                condition += " AND dn.vendor.ID=? ";
                params.add(vendorid);
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " AND dn.vendor.ID IN " + vendorIdGroup;
            }

            if (request.get("excludeNormal") != null) {
                excludeNormal = Boolean.parseBoolean(request.get("excludeNormal").toString());
            }

            if (excludeNormal) {
                condition += " AND dn.normalDN=false ";
            }

            if (request.get("onlyOpeningNormalDNs") != null) {
                onlyOpeningNormalDNs = Boolean.parseBoolean(request.get("onlyOpeningNormalDNs").toString());
            }

            if (onlyOpeningNormalDNs) {
                condition += " AND dn.normalDN=true ";
            }

            String currencyfilterfortrans = "";
            if (request.containsKey("currencyfilterfortrans")) {
                currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            }

            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)) {
                params.add(currencyfilterfortrans);
                condition += " and dn.currency.currencyID = ? ";
            }
            if (!isAgedReport && !isAgedSummary) { //in aged report all opening transactions are required so no need to give start and end date
                String startDate = (String) request.get(Constants.REQ_startdate);
                String endDate = (String) request.get(Constants.REQ_enddate);
                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                    condition += " and (dn.creationDate >=? and dn.creationDate <=?) ";
                    params.add(df.parse(startDate));
                    params.add(df.parse(endDate));
                }
            }

            String ss = (request.containsKey("ss") && request.get("ss") != null) ? (String) request.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.vendor.name", "dn.vendor.acccode", "dn.debitNoteNumber", "dn.account.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 4);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery + " AND dn.vendor IS NOT NULL ";
            }
            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
                Searchjson = request.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    request.put(Constants.Searchjson, Searchjson);
                    request.put(Constants.appendCase, appendCase);
                    request.put("isOpeningBalance",true);
                    request.put("filterConjuctionCriteria", filterConjuctionCriteria);
                    mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
                    mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "dn.openingBalanceDebitNoteCustomData");
                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                }
            }
            String query = "Select COALESCE(SUM(dn.openingBalanceBaseAmountDue),0) from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=true AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
            list = executeQuery( query, params.toArray());
            count = list.size();
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getOpeningBalanceTotalBaseAmountDueForDNs : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    
    @Override
    public KwlReturnObject getOpeningBalanceTotalBaseAmountForDNs(HashMap<String, Object> request) throws ServiceException {
        List<DebitNote> list = null;
        boolean excludeNormal = false;
        boolean onlyOpeningNormalDNs = false;
        boolean isAgedReport = (request.containsKey("agedReport") && request.get("agedReport") != null) ? Boolean.parseBoolean(request.get("agedReport").toString()) : false;
        boolean isAgedSummary = (request.containsKey("isAgedSummary") && request.get("isAgedSummary") != null) ? Boolean.parseBoolean(request.get("isAgedSummary").toString()) : false;

        int count = 0;
        String companyid = (String) request.get("companyid");
        DateFormat df = (DateFormat) request.get(Constants.df);
        String start = (String) request.get("start");
        String limit = (String) request.get("limit");
        String vendorid = (String) request.get("vendorid");

        String vendorIdGroup = (String) request.get("custVendorID");
        if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
            vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
        }
        boolean isAccountDNs = false;
        if (request.containsKey("isAccountDNs") && request.get("isAccountDNs") != null) {
            isAccountDNs = (Boolean) request.get("isAccountDNs");
        }

        try {
            String condition = "";
            ArrayList params = new ArrayList();

            params.add(companyid);

            if (isAccountDNs && request.containsKey("accountId") && request.get("accountId") != null) {
                String accountId = request.get("accountId").toString();
                condition += " AND dn.account.ID=? ";
                params.add(accountId);
            } else if (vendorid != null) {
                condition += " AND dn.vendor.ID=? ";
                params.add(vendorid);
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " AND dn.vendor.ID IN " + vendorIdGroup;
            }

            if (request.get("excludeNormal") != null) {
                excludeNormal = Boolean.parseBoolean(request.get("excludeNormal").toString());
            }

            if (excludeNormal) {
                condition += " AND dn.normalDN=false ";
            }

            if (request.get("onlyOpeningNormalDNs") != null) {
                onlyOpeningNormalDNs = Boolean.parseBoolean(request.get("onlyOpeningNormalDNs").toString());
            }

            if (onlyOpeningNormalDNs) {
                condition += " AND dn.normalDN=true ";
            }

            String currencyfilterfortrans = "";
            if (request.containsKey("currencyfilterfortrans")) {
                currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            }

            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)) {
                params.add(currencyfilterfortrans);
                condition += " and dn.currency.currencyID = ? ";
            }
//   For now this method get called from 2 places and from both places we does need to apply start date and end date. It is casusing issue like SDP-5696 So commenting below code
//            if (!isAgedReport && !isAgedSummary) { //in aged report all opening transactions are required so no need to give start and end date
//                String startDate = (String) request.get(Constants.REQ_startdate);
//                String endDate = (String) request.get(Constants.REQ_enddate);
//                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
//                    condition += " and (dn.creationDate >=? and dn.creationDate <=?) ";
//                    params.add(df.parse(startDate));
//                    params.add(df.parse(endDate));
//                }
//            }

            String ss = (request.containsKey("ss") && request.get("ss") != null) ? (String) request.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.vendor.name","dn.vendor.acccode", "dn.debitNoteNumber", "dn.account.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 4);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery + " AND dn.vendor IS NOT NULL ";
            }

            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (request.containsKey("Searchjson") && request.get("Searchjson") != null && !StringUtil.isNullOrEmpty((String) request.get("Searchjson"))) {
                Searchjson = request.get("Searchjson").toString();
                Searchjson = getJsornStringForSearch(Searchjson, companyid);
                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    request.put(Constants.Searchjson, Searchjson);
                    request.put(Constants.appendCase, appendCase);
                    request.put(Constants.moduleid, 10);
                    request.put("isOpeningBalance", true);
                    request.put("filterConjuctionCriteria", filterConjuctionCriteria);
                    mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "dn.openingBalanceDebitNoteCustomData");
                    mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "dn.openingBalanceDebitNoteCustomData");
                    mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "dn.openingBalanceDebitNoteCustomData");
                    StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                }
            }

            String query = "Select COALESCE(SUM(dn.originalOpeningBalanceBaseAmount),0) from DebitNote dn where dn.isOpeningBalenceDN=true AND dn.dNForVendor=true AND dn.deleted=false AND dn.company.companyID=?" + condition + mySearchFilterString;
            list = executeQuery( query, params.toArray());
            count = list.size();
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getOpeningBalanceTotalBaseAmountForDNs : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    
    @Override
    public KwlReturnObject getDebitNoteMerged(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        try {
            DateFormat df = (DateFormat) request.get(Constants.df);
            String companyid = (String) request.get(Constants.companyKey);
            String start = (String) request.get(Constants.start);
            String limit = (String) request.get(Constants.limit);
            String ss = (String) request.get(Constants.ss);
            String moduleid = "";
            Map<String, Object> paramMap = new HashMap<>();
            paramMap.put("id", companyid);
            Object exPrefObject = executeQueryWithProjection(ExtraCompanyPreferences.class, new String[]{"columnPref"}, paramMap);
            JSONObject jObj = StringUtil.isNullObject(exPrefObject) ? new JSONObject() : new JSONObject(exPrefObject.toString());
            boolean isPostingDateCheck = false;
            boolean getRecordBasedOnJEDate = false;
            boolean isToFetchRecordLessEndDate = (request.containsKey("isToFetchRecordLessEndDate") && request.get("isToFetchRecordLessEndDate") != null) ? Boolean.parseBoolean(request.get("isToFetchRecordLessEndDate").toString()) : false;
            if (!StringUtil.isNullObject(jObj) && jObj.has(Constants.IS_POSTING_DATE_CHECK) && jObj.get(Constants.IS_POSTING_DATE_CHECK) != null && jObj.optBoolean(Constants.IS_POSTING_DATE_CHECK, false)) {
                isPostingDateCheck = true;
            }
            if (request.containsKey("getRecordBasedOnJEDate") && request.get("getRecordBasedOnJEDate") != null && Boolean.parseBoolean(request.get("getRecordBasedOnJEDate").toString())) {
                getRecordBasedOnJEDate = true;
            }
            if (request.containsKey(Constants.moduleid) && request.get(Constants.moduleid) != null) {
                moduleid = request.get(Constants.moduleid).toString();
            }
            boolean deleted = Boolean.parseBoolean((String) request.get("deleted"));
            boolean nondeleted = Boolean.parseBoolean((String) request.get("nondeleted"));
            boolean isAged = (request.containsKey("isAged") && request.get("isAged") != null) ? Boolean.parseBoolean(request.get("isAged").toString()) : false;
            String upperLimitDate=(String) request.get("upperLimitDate");
            String vendorIdGroup = (String) request.get("custVendorID");
            
            String userID = "";
            boolean isenableSalesPersonAgentFlow = false;
            if (request.containsKey("enablesalespersonagentflow") && request.get("enablesalespersonagentflow") != null && !StringUtil.isNullOrEmpty(request.get("enablesalespersonagentflow").toString())) {
                isenableSalesPersonAgentFlow = Boolean.parseBoolean(request.get("enablesalespersonagentflow").toString());
                if (isenableSalesPersonAgentFlow) {
                    if (request.containsKey("userid") && request.get("userid") != null && !StringUtil.isNullOrEmpty(request.get("userid").toString())) {
                        userID = (String) request.get("userid");
                    }
                }
            }
            
            if (!StringUtil.isNullOrEmpty(vendorIdGroup)) {
                vendorIdGroup = AccountingManager.getFilterInString(vendorIdGroup);
            }
            int cntype = 1;
            int transactiontype = 1;
            boolean isprinted = false;
            if (request.get(Constants.MARKED_PRINTED) != null) {
                isprinted = Boolean.parseBoolean((String) request.get(Constants.MARKED_PRINTED));
            }
            if (request.containsKey("cntype") && request.get("cntype") != null) {
                cntype = Integer.parseInt(request.get("cntype").toString());
            }
            if (request.containsKey("transactiontype") && request.get("transactiontype") != null) {
                transactiontype = Integer.parseInt(request.get("transactiontype").toString());
            }
            boolean isMonthlyAgeingReport = false;
            if (request.get("isMonthlyAgeingReport") != null) {
                isMonthlyAgeingReport = Boolean.parseBoolean(request.get("isMonthlyAgeingReport").toString());
            }
            boolean isCustomDetailLineReport=false;
            if (request.containsKey("isCustomDetailLineReport") && request.get("isCustomDetailLineReport") != null && !StringUtil.isNullOrEmpty(request.get("isCustomDetailLineReport").toString())) {
                isCustomDetailLineReport = Boolean.parseBoolean(request.get("isCustomDetailLineReport").toString());
            }
            String newcustomerid = "";
            if (request.containsKey(Constants.newcustomerid) && request.get(Constants.newcustomerid) != null) {
                newcustomerid = (String) request.get(Constants.newcustomerid);
            }
            String newvendorid = "";
            if (request.containsKey(Constants.newvendorid) && request.get(Constants.newvendorid) != null) {
                newvendorid = (String) request.get(Constants.newvendorid);
            }
            boolean isPendingApproval = false;
            if (request.containsKey("pendingapproval") && request.get("pendingapproval") != null && !StringUtil.isNullOrEmpty(request.get("pendingapproval").toString())) {
                isPendingApproval = Boolean.parseBoolean(request.get("pendingapproval").toString());
            }
            String userDepartment = "";
            if (request.containsKey("userDepartment") && request.get("userDepartment") != null) {
                userDepartment = (String) request.get("userDepartment");
            }
            ArrayList params = new ArrayList();
            ArrayList param = new ArrayList();
            params.add(companyid);
            param.add(companyid);
            String condition = " where dn.company=?";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"dn.dnnumber", "dn.supplierinvoiceno", "v.name","v.aliasname", "dn.memo", "je.entryno"};
                Map SearchStringMap = StringUtil.insertParamSearchStringMap(params, ss, 6);
                StringUtil.insertParamSearchString(SearchStringMap);
                SearchStringMap = StringUtil.insertParamSearchStringMap(param, ss, 6);
                StringUtil.insertParamSearchString(SearchStringMap);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
            }
            //SDP-5325
            if (request.containsKey("groupcombo") && request.get("groupcombo") != null && request.containsKey(Constants.globalCurrencyKey) && request.get(Constants.globalCurrencyKey) != null) {
                int groupcombo = (Integer) request.get("groupcombo");
                if (groupcombo == Constants.AgedPayableBaseCurrency) {
                    condition += " and dn.currency=" + Integer.parseInt((String) request.get(Constants.globalCurrencyKey));
                } else if (groupcombo == Constants.AgedPayableOtherthanBaseCurrency) {
                    condition += " and dn.currency!=" + Integer.parseInt((String) request.get(Constants.globalCurrencyKey));
                }
            }
            
            if (!StringUtil.isNullOrEmpty(newcustomerid)) {
                condition += " and dn.customer = ? ";
                params.add(newcustomerid);
            }
            
            if (!StringUtil.isNullOrEmpty(newvendorid)) {
                if (newvendorid.contains(",")) {
                    newvendorid = AccountingManager.getFilterInString(newvendorid);
                    condition += " and dn.vendor IN" + newvendorid;
                } else {
                    params.add(newvendorid);
                    condition += " and dn.vendor = ? ";

                }
            }
            if (request.containsKey("upperLimitDate") && request.get("upperLimitDate") != null && request.get("upperLimitDate") != "") {
                condition += " and je.entrydate <= ?";
                params.add(df.parse(upperLimitDate));
                param.add(df.parse(upperLimitDate));
            }
            String costCenterId = (String) request.get(CCConstants.REQ_costCenterId);
            if (!StringUtil.isNullOrEmpty(costCenterId)) {
                params.add(costCenterId);
                param.add(costCenterId);
                condition += " and je.costcenter=?";
            }

            String jeIds = (String) request.get("jeIds");
            if (!StringUtil.isNullOrEmpty(jeIds)) {
                condition += " and je.id IN(" + jeIds + ")";
            }

            String noteId = (String) request.get("noteid");
            if (!StringUtil.isNullOrEmpty(noteId)) {
                params.add(noteId);
                param.add(noteId);
                condition += " and dn.id = ? ";
            }
            if (isPendingApproval) { // Get only pending approved records
                condition += " and dn.approvestatuslevel != ? ";
                params.add(11);
                param.add(11);
            } else {// Get only approved records
                condition += " and dn.approvestatuslevel = ?";
                params.add(11);
                param.add(11);
            }
            String currencyfilterfortrans = (String) request.get("currencyfilterfortrans");
            boolean isNoteForPayment = false;
            boolean isNewUI = false;
            if (request.get("isNoteForPayment") != null) {
                isNoteForPayment = (Boolean) request.get("isNoteForPayment");
            }
            if (request.get("isNewUI") != null) {
                isNewUI = (Boolean) request.get("isNewUI");
            }
            if (!StringUtil.isNullOrEmpty(currencyfilterfortrans)&&!(isNoteForPayment&&isNewUI)) {
                params.add(currencyfilterfortrans);
                param.add(currencyfilterfortrans);
                condition += " and dn.currency = ? ";
            }
                        
            String withInvCondition = "";
            String accID = (String) request.get("accid");
            if (!StringUtil.isNullOrEmpty(accID)) {
                params.add(accID);
                param.add(accID);
                condition += " and v.id = ? ";
//                withInvCondition += " and dn.dnamountdue > 0";
            }
            
            
            String customerVendorID = (String) request.get("customerVendorID");
            if (!StringUtil.isNullOrEmpty(customerVendorID)) {
                params.add(customerVendorID);
                condition += " and v.id = ? ";
            }

            if (!StringUtil.isNullOrEmpty(vendorIdGroup) && !vendorIdGroup.contains("All")) {
                condition += " and v.id in " + vendorIdGroup;
//                withInvCondition += " and dn.dnamountdue > 0";
            }

            String startDate = request.get(Constants.REQ_startdate)!=null? StringUtil.DecodeText((String) request.get(Constants.REQ_startdate)):(String) request.get(Constants.REQ_startdate);
            String endDate = request.get(Constants.REQ_enddate)!=null? StringUtil.DecodeText((String) request.get(Constants.REQ_enddate)):(String) request.get(Constants.REQ_enddate);
            if((isAged || isToFetchRecordLessEndDate) && !StringUtil.isNullOrEmpty(endDate) && !isMonthlyAgeingReport){ //Fetching all transactions whose creation date is upto end date
                condition += " and je.entrydate <=? ";
                params.add(df.parse(endDate));
                param.add(df.parse(endDate));
            } else if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                 if (isPostingDateCheck && !getRecordBasedOnJEDate) {
                    condition += " and (dn.creationDate >=? and dn.creationDate <=?)";
                }else{
                    condition += " and (je.entrydate >=? and je.entrydate <=?)";
                 }
                if (isMonthlyAgeingReport) {
                    params.add(new Date(Long.parseLong(startDate)));
                    params.add(new Date(Long.parseLong(endDate)));
                    param.add(new Date(Long.parseLong(startDate)));
                    param.add(new Date(Long.parseLong(endDate)));
                } else {
                    params.add(df.parse(startDate));
                    params.add(df.parse(endDate));
                    param.add(df.parse(startDate));
                    param.add(df.parse(endDate));
                }
            }
            String appendCase = "and";
            String mySearchFilterString = "";
            String joinString = "";
            String joinString1 = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
                if (request.get("filterConjuctionCriteria").toString().trim().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String groupBy = "";
            String Searchjson = "";
            String searchDefaultFieldSQL = "";
            String jeDetailsDebitCondition = " and jed.id=dn.centry ";
            if (request.containsKey("searchJson") && request.get("searchJson") != null) {
                Searchjson = StringUtil.DecodeText(request.get("searchJson").toString());

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    JSONObject serachJobj = new JSONObject(Searchjson);
                    JSONArray customSearchFieldArray = new JSONArray();
                    JSONArray defaultSearchFieldArray = new JSONArray();
                    StringUtil.seperateCostomAndDefaultSerachJson(serachJobj, customSearchFieldArray, defaultSearchFieldArray);
                    if (defaultSearchFieldArray.length() > 0) {
                        /*
                         Advance Search For Default Form fields
                         */
                        ArrayList tableArray = new ArrayList();
                        tableArray.add("vendor"); //this table array used to identified wheather join exists on table or not                         
                        Map<String, Object> map = buildSqlDefaultFieldAdvSearch(defaultSearchFieldArray, params, moduleid, tableArray, filterConjuctionCriteria);
                        joinString += map.containsKey("searchjoin") ? map.get("searchjoin") : "";
                        searchDefaultFieldSQL = (String) (map.containsKey("condition") ? map.get("condition") : "");
                        searchDefaultFieldSQL = searchDefaultFieldSQL.replaceAll("debitnote", "dn");
                        searchDefaultFieldSQL = searchDefaultFieldSQL.replaceAll("journalentry", "je");
                        joinString += " left join debitnotelinking dnlinking on dnlinking.docid=dn.id and dnlinking.sourceflag = 1 ";
                        groupBy = " GROUP BY dn.id ";
                    }
                    if (customSearchFieldArray.length() > 0) {   //Advance search case for Custome field
                        request.put(Constants.Searchjson, Searchjson);
                        request.put(Constants.appendCase, appendCase);
                        request.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(request, true).get(Constants.myResult));
                        if(mySearchFilterString.contains("accjecustomdata")){
                            joinString += " inner join accjecustomdata on accjecustomdata.journalentryId=dn.journalentry ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "accjedetailcustomdata");//    
                            joinString += " inner join accjedetailcustomdata  on accjedetailcustomdata.jedetailId=jed.id ";
                            jeDetailsDebitCondition = " ";
                            if (StringUtil.isNullOrEmpty(groupBy)) {
                                groupBy = " GROUP BY jed.journalentry ";
                            } else {
                                groupBy+= " ,jed.journalentry ";
                            }
                        }
                        if (mySearchFilterString.contains("VendorCustomData")) {
                            joinString += " left join vendorcustomdata  on vendorcustomdata.vendorId=dn.vendor ";
                            mySearchFilterString = mySearchFilterString.replaceAll("VendorCustomData", "vendorcustomdata");
                        }
                        if (mySearchFilterString.contains("CustomerCustomData")) {
                            joinString += " inner join customercustomdata on customercustomdata.customerId=dn.customer ";
                            mySearchFilterString = mySearchFilterString.replaceAll("CustomerCustomData", "customercustomdata");
                        }
                        groupBy = " GROUP BY dn.id ";
                        StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                        StringUtil.insertParamAdvanceSearchString1(param, Searchjson);
                    }
                    mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(searchDefaultFieldSQL, mySearchFilterString, filterConjuctionCriteria);
                }
            }
            String orderBy = "";
            String[] stringSort = null;
            String sort_Col = "";
            if (request.containsKey("dir") && request.containsKey("sort")) {
                String Col_Name = request.get("sort").toString();
                String Col_Dir = request.get("dir").toString();
                stringSort = columSort(Col_Name, Col_Dir);
                orderBy += stringSort[0];
                sort_Col += stringSort[1];
            } else {
                orderBy += " ORDER BY date DESC ";
                sort_Col += ", je.entrydate AS date ";
            }
            
            if (cntype == 12 ) { // With purchase return
                condition += " and dn.purchaseReturn is not NULL ";
            } 
            if (cntype == 13 ) { // Without Purchase Return
                condition += " and dn.purchaseReturn is NULL ";
            }
            if (nondeleted) {
                condition += " and dn.deleteflag='F' ";
            } else if (deleted) {
                condition += " and dn.deleteflag='T' ";
            }
            if (isprinted) {
                condition += " and dn.printedflag=true";
            }
            
            if (request.containsKey("linknumber") && request.containsKey("linknumber") && request.get("linknumber") != null && !request.get("linknumber").toString().equals("")) {
                condition += " and dn.dnnumber = '"+request.get("linknumber")+"' ";
            }
            if (!StringUtil.isNullOrEmpty(userDepartment)) {
                joinString += " inner join users on users.userid = dn.createdby ";
                condition += " and users.department = ? ";
                params.add(userDepartment);
            }
//            String withInvVendorCondition = " vendor v ";
            String isCustomer = " dn.vendor ";
            String iscustomerJoin = " INNER JOIN vendor v on v.id = dn.vendor ";
            String query = "";
            
             String agentMappingQueryWithVendor = "";
            String filterQueryForagentvendorMapping="";
           if (isenableSalesPersonAgentFlow && !StringUtil.isNullOrEmpty(userID)) {
                agentMappingQueryWithVendor = " left join vendoragentmapping spm on spm.vendorid=dn.vendor  left join masteritem  mst on mst.id=spm.agent ";
                filterQueryForagentvendorMapping += " and ((mst.user= '" + userID + "' or mst.user is null  and v.vendavailtoagent='T' ) or  (v.vendavailtoagent='F')) ";
            }
            
//            String jeDetailsDebitCondition = " and jed.DEBIT='T' ";
//            String jeDetailsDebitCondition = " and jed.id=dn.centry ";
            if (transactiontype != 8) {
                if (cntype == 4 ||cntype == 5) {//DN against customer
                    withInvCondition += " and (dn.dntype=4 or dn.dntype=5) ";
//               withInvVendorCondition = " customer v ";
                    isCustomer = " dn.customer ";
                    iscustomerJoin = " INNER JOIN customer v on v.id = dn.customer ";
                    query = "SELECT  'False' as withoutinventory,dn.id as debitnote," + isCustomer + ",jed.id as jedetail "+sort_Col
                            + "FROM debitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry " + joinString
                            + "INNER JOIN account ac ON jed.account=ac.id " + iscustomerJoin + condition + withInvCondition + jeDetailsDebitCondition + mySearchFilterString
                            + //                               " UNION ALL "+
                            //                               "SELECT  'True' as withoutinventory,dn.id as debitnote,v.id as vendor,jed.id as jedetail,je.entrydate as date "+
                            //                               "FROM  billingdebitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry "+joinString1+
                            //                               "INNER JOIN account ac ON jed.account=ac.id,vendor v "+condition+mySearchFilterString+
                            groupBy + orderBy;           //" ORDER BY date DESC";
                } else if (cntype == 8) {
                    String Customer = " dn.customer ";
                    String customerJoin = " INNER JOIN customer v on v.id = dn.customer ";
//                    withInvCondition += " and dn.dntype!=1 "; //ERP-11761
                    query = "SELECT  'False' as withoutinventory,dn.id as debitnote," + Customer + ",jed.id as jedetail "+sort_Col
                            + "FROM debitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry " + joinString
                            + "INNER JOIN account ac ON jed.account=ac.id " + customerJoin + condition + withInvCondition + jeDetailsDebitCondition + mySearchFilterString
                            + " UNION ALL "
                            + "SELECT  'True' as withoutinventory,dn.id as debitnote," + isCustomer + ",jed.id as jedetail "+sort_Col
                            + "FROM debitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry " + joinString
                            + "INNER JOIN account ac ON jed.account=ac.id " + iscustomerJoin + condition + withInvCondition + jeDetailsDebitCondition + mySearchFilterString
                            + groupBy + orderBy;           //" ORDER BY date DESC";
                    for (Object object : param) {
                        params.add(object);
                    }
                } else if(cntype == 6){
                    withInvCondition += " and dn.dntype = 6 ";
                    query = "SELECT  'False' as withoutinventory,dn.id as debitnote," + isCustomer + ",jed.id as jedetail " + sort_Col
                            + "FROM debitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry " + joinString
                            + "INNER JOIN account ac ON jed.account=ac.id " + iscustomerJoin + agentMappingQueryWithVendor + condition + filterQueryForagentvendorMapping + withInvCondition + jeDetailsDebitCondition + mySearchFilterString
                            + groupBy + orderBy;
                } else {
                    withInvCondition += " and dn.dntype!=4 ";
                    if (isCustomDetailLineReport) { // Fetch all DN irrespective of cntype.
                        withInvCondition = "";
                        isCustomer = " -99 ";
                        iscustomerJoin = "";
                    }
//                String jeDetailsDebitCondition = " and jed.DEBIT='T' ";
                    query = "SELECT  'False' as withoutinventory,dn.id as debitnote," + isCustomer + ",jed.id as jedetail "+sort_Col
                            + "FROM debitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry " + joinString
                            + "INNER JOIN account ac ON jed.account=ac.id " + iscustomerJoin + agentMappingQueryWithVendor + condition+filterQueryForagentvendorMapping + withInvCondition + jeDetailsDebitCondition + mySearchFilterString
//                            + " UNION ALL "
//                            + "SELECT  'True' as withoutinventory,dn.id as debitnote,v.id as vendor,jed.id as jedetail,je.entrydate as date "
//                            + "FROM  billingdebitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry " + joinString1
//                            + "INNER JOIN account ac ON jed.account=ac.id, vendor v " + condition + " and ac.id=v.account " + mySearchFilterString
                            + groupBy + orderBy;           //" ORDER BY date DESC";
                    //String query = "select dn, v, jed from DebitNote dn inner join dn.journalEntry je inner join je.details jed inner join jed.account ac, Vendor v" + condition;
//                    for (Object object : param) {
//                        params.add(object);
//                    }
                }
            } else {
                withInvCondition += " and (dn.dntype=2 or dn.dntype=3) ";
//                withInvVendorCondition = "inner join  vendor v ";
                query = "SELECT  'False' as withoutinventory,dn.id as debitnote," + isCustomer + ",jed.id as jedetail "+sort_Col
                        + "FROM debitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry " + joinString
                        + "INNER JOIN account ac ON jed.account=ac.id " + iscustomerJoin + condition + withInvCondition + jeDetailsDebitCondition + mySearchFilterString
                        + //                               " UNION ALL "+
                        //                               "SELECT  'True' as withoutinventory,dn.id as debitnote,v.id as vendor,jed.id as jedetail,je.entrydate as date "+
                        //                               "FROM  billingdebitnote dn INNER JOIN journalentry je ON dn.journalentry=je.id INNER JOIN jedetail jed ON je.id=jed.journalentry "+joinString1+
                        //                               "INNER JOIN account ac ON jed.account=ac.id,vendor v "+condition+mySearchFilterString+
                        groupBy + orderBy;           //" ORDER BY date DESC";
            }

            list = executeSQLQuery( query, params.toArray());
            count = list.size();
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                list = executeSQLQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.getDebitNotes : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    public KwlReturnObject getGDOIDFromVendorInvoiceDetails(String soid) throws ServiceException {
        String selQuery = "from GoodsReceiptOrderDetails ge where ge.videtails.ID = ? and ge.grOrder.deleted = false";
        List list = executeQuery( selQuery, new Object[]{soid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    //Get amount knock off using otherwise open debit notes.
    public KwlReturnObject getDNRowsOpen_vendor(String vendorid) throws ServiceException {//Used to get otherwise credit notes unused amount due.
        List list = new ArrayList();
        String query = "select dn from DebitNote dn where dn.deleted=false and dn.vendor.ID=? and dn.openflag = true order by dn.sequence";
        list = executeQuery( query, new Object[]{vendorid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    //Get amount of otherwise open credit notes.

    public KwlReturnObject getCNRowsOpen_vendor(String vendorid) throws ServiceException {//Used to get otherwise credit notes unused amount due.
        List list = new ArrayList();
        String query = "select dn from CreditNote dn where dn.deleted=false and dn.vendor.ID=? and dn.openflag = true order by dn.sequence";
        list = executeQuery( query, new Object[]{vendorid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getDNRowsFromVendorInvoice(String VenInvoiceid) throws ServiceException {//Used to get otherwise credit notes applied to this invoice.
        List list = new ArrayList();
        String query = "select dn, dnr from DebitNote dn left join dn.rows dnr where dn.deleted=false and dnr.goodsReceipt.ID=? order by dn.sequence";
        list = executeQuery( query, new Object[]{VenInvoiceid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
     
    @Override
    public KwlReturnObject getDNRowsFromVendorInvoice(HashMap<String, Object> reqParams) throws ServiceException {
        List dnList = Collections.EMPTY_LIST;
        try {
            String condition = " where dnd.debitNote.deleted=false and dnd.goodsReceipt is not null ";
            ArrayList params = new ArrayList();
            DateFormat df = (DateFormat) reqParams.get(Constants.df);
            if (reqParams.containsKey("grid") && reqParams.get("grid") != null) {
                String grid = (String) reqParams.get("grid");
                condition += " and dnd.goodsReceipt.ID=?";
                params.add(grid);
            }
            if (reqParams.containsKey("companyid") && reqParams.get("companyid") != null) {
                String companyId = (String) reqParams.get("companyid");
                condition += " and dnd.debitNote.company.companyID=?";
                params.add(companyId);
            }
            if (reqParams.containsKey("debitnoteid") && reqParams.get("debitnoteid") != null) {
                String dnid = (String) reqParams.get("debitnoteid");
                condition += " and dnd.debitNote.ID=? ";
                params.add(dnid);
            }
            if (reqParams.containsKey("asofdate") && reqParams.get("asofdate") != null) {
                String asOfDate = (String) reqParams.get("asofdate");
                condition += " and dnd.grLinkDate <=? ";
                params.add(df.parse(asOfDate));
            }
            boolean isMonthlyAgedPayable=false;
            if(reqParams.containsKey("isMonthlyAgedPayable") && reqParams.get("isMonthlyAgedPayable")!=null){
                isMonthlyAgedPayable=Boolean.parseBoolean(reqParams.get("isMonthlyAgedPayable").toString());
            }
            if (isMonthlyAgedPayable) { // call from Monthly Aged Payable report
                String selQuery = "select dnd.ID from DebitNoteDetail dnd  " + condition;
                dnList = executeQuery(selQuery, params.toArray());
            } else {
                String selQuery = "from DebitNoteDetail dnd  " + condition;
                dnList = executeQuery(selQuery, params.toArray());
            }
        } catch (ParseException ex) {
            Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, dnList, dnList.size());
    }
    @Override
    public KwlReturnObject getDNRowsFromCreditNote(HashMap<String, Object> reqParams) throws ServiceException {
        List dnList = Collections.EMPTY_LIST;
        try {
            String condition = " where dnd.debitNote.deleted=false and dnd.creditNoteId is not null ";
            ArrayList params = new ArrayList();
            DateFormat df = (DateFormat) reqParams.get(Constants.df);
            String creditnoteid=null;
            if (reqParams.containsKey("creditnoteid") && reqParams.get("creditnoteid") != null) {
                creditnoteid = (String) reqParams.get("creditnoteid");
                condition += " and dnd.creditNoteId=?";
                params.add(creditnoteid);
            }
            if (reqParams.containsKey("companyid") && reqParams.get("companyid") != null) {
                String companyId = (String) reqParams.get("companyid");
                condition += " and dnd.debitNote.company.companyID=?";
                params.add(companyId);
            }
            if (reqParams.containsKey("debitnoteid") && reqParams.get("debitnoteid") != null && creditnoteid==null) {
                String dnid = (String) reqParams.get("debitnoteid");
                condition += " and dnd.debitNote.ID=? ";
                params.add(dnid);
            }
            if (reqParams.containsKey("asofdate") && reqParams.get("asofdate") != null) {
                String asOfDate = (String) reqParams.get("asofdate");
                condition += " and dnd.grLinkDate <=? ";
                params.add(df.parse(asOfDate));
            }
            boolean isMonthlyAgedPayable=false;
            if(reqParams.containsKey("isMonthlyAgedPayable") && reqParams.get("isMonthlyAgedPayable")!=null){
                isMonthlyAgedPayable=Boolean.parseBoolean(reqParams.get("isMonthlyAgedPayable").toString());
            }
            if (isMonthlyAgedPayable) { // call from Monthly Aged Payable report
                String selQuery = "select dnd.ID from DebitNoteDetail dnd  " + condition;
                dnList = executeQuery(selQuery, params.toArray());
            } else {
                String selQuery = "from DebitNoteDetail dnd  " + condition;
                dnList = executeQuery(selQuery, params.toArray());
            }
        } catch (ParseException | ServiceException ex) {
            Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, dnList, dnList.size());
    }
    
    public Map<String, List<DebitNoteDetail>>  getDNRowsFromVendorInvoiceList(List<String> invoiceIDLIST) throws ServiceException {
        Map<String, List<DebitNoteDetail>> map = new HashMap<String, List<DebitNoteDetail>>();
        if (invoiceIDLIST != null && !invoiceIDLIST.isEmpty())
        {
            List li = null;
            String query = "select dnr.goodsReceipt.ID, dnr from DebitNote dn left join dn.rows dnr where"
                    + " dn.deleted=false and dnr.goodsReceipt.ID in (:invoiceIDList) order by dn.sequence";
            List<List> values = new ArrayList<List>();
            values.add(invoiceIDLIST);
            List<Object[]> results = executeCollectionQuery( query, Collections.singletonList("invoiceIDList"), values);
            
            if (results != null)
            {
                for (Object[] result: results)
                {
                    String invID = (String) result[0];
                    if(map.containsKey(invID)) {
                        li = map.get(invID);
                    } else {
                        li = new ArrayList<DebitNoteDetail>();
                    }
                    li.add((DebitNoteDetail)result[1]);
                    map.put(invID, li);
                }
            }
        }
        return map;
    }
    @Override
    public KwlReturnObject saveDebitNoteTermMap(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            DebitNoteTermsMap termmap = new DebitNoteTermsMap();

            if (dataMap.containsKey("termamount")) {
                termmap.setTermamount((Double) dataMap.get("termamount"));
            }
            if (dataMap.containsKey("termpercentage")) {
                termmap.setPercentage((Integer) dataMap.get("termpercentage"));
            }
            if (dataMap.containsKey("debitNoteId")) {
                DebitNote debitNote = (DebitNote) get(DebitNote.class, (String) dataMap.get("debitNoteId"));
                termmap.setDebitNote(debitNote);
            }
            if (dataMap.containsKey("term")) {
                InvoiceTermsSales term = (InvoiceTermsSales) get(InvoiceTermsSales.class, (String) dataMap.get("term"));
                termmap.setTerm(term);
            }
            if (dataMap.containsKey("userid")) {
                User userid = (User) get(User.class, (String) dataMap.get("userid"));
                termmap.setCreator(userid);
            }
            if (dataMap.containsKey("createdon")) {
                termmap.setCreatedOn(((Date) dataMap.get("creationdate")).getTime());
            }
            saveOrUpdate(termmap);
            list.add(termmap);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.saveDebitNoteTermMap : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject getDebitNoteTermMap(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            String debitNoteId = dataMap.get("debitNoteId").toString();
            String query = "from DebitNoteTermsMap where debitNote.ID = ?";
            list = executeQuery( query, new Object[]{debitNoteId});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.getDebitNoteTermMap:" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject getReceivePaymentIdLinkedWithDebitNote(String noteId) throws ServiceException {
        List params = new ArrayList();
        params.add(noteId);
        String query = "select receiptid from debitnotepayment where dnid=?";
        List list = executeSQLQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject getDebitNotelinkedInCreditNote(String creditNoteId, String companyId) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(creditNoteId);
        params.add(companyId);
        String query = "select count(cnd.id) from cndetails cnd where cnd.debitnoteid=? and cnd.company = ? ";

        List list = executeSQLQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    public KwlReturnObject getDebitNoteIdFromReceiptId(String receiptid) throws ServiceException {
        List params = new ArrayList();
        params.add(receiptid);
        String query = "select id, dnid, description, totaljedid from debitnotepayment where receiptid=?";
        List list = executeSQLQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject getVendorInvoicesLinkedWithDebitNote(String noteId, String companyId) throws ServiceException {
        List params = new ArrayList();
        params.add(noteId);
        params.add(companyId);
        String query = "select goodsreceipt from dndetails where goodsreceipt IS NOT NULL and debitNote=? and company=?";
        List list = executeSQLQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public void deletePartyJournalDN(String dnid, String companyid) throws ServiceException,AccountingException {
//        String selQuery = "from DebitNote where journalEntry.ID=? and deleted=false and company.companyID=?";
//        List list = executeQuery( selQuery, new Object[]{jeId, companyid});
        HashMap<String, Object> requestParams = new HashMap<String, Object>();
        requestParams.put("dnid", dnid);
        requestParams.put("companyid", companyid);
        requestParams.put("debitNote", true);
        deleteDebitNotesPermanent(requestParams);
    }

    @Override
    public KwlReturnObject getDNFromNoteNoAndId(String entryNumber, String companyid, String debitNoteId) throws ServiceException {
        List list = new ArrayList();
        String query = "from DebitNote where debitNoteNumber=? and company.companyID=? and ID!=?";
        list = executeQuery( query, new Object[]{entryNumber, companyid, debitNoteId});
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
     public KwlReturnObject getDebitNoteIdFromPRId(String prid, String companyid) throws ServiceException {
        String selQuery = "from DebitNote dn where dn.purchaseReturn.ID = ? and dn.company.companyID=? ";
        List list = executeQuery( selQuery, new Object[]{prid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
     
   @Override
    public KwlReturnObject getCustomerDnPayment(String receiptId) throws ServiceException {
        List list = new ArrayList();
        try {
            String query = "select * from debitnotepayment where receiptid=? ";
            list =executeSQLQuery( query, new Object[]{receiptId});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accVendorPaymentImpl.getVendorCnPayment:" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getJEFromDNDetail(String jeid, String companyid) throws ServiceException {
        String selQuery = "select * from dndetails where linkedgainlossje=? and company=?";
        List list = executeSQLQuery( selQuery, new Object[]{jeid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
}
     @Override
    public KwlReturnObject getDebitTaxDetails(HashMap<String, Object> paramsTaxDetails) throws ServiceException {
        List list = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            String Condition = " where dnt.company.companyID=?";
            params.add(paramsTaxDetails.get("companyid"));

            if (paramsTaxDetails.containsKey("dnid") && paramsTaxDetails.get("dnid") != null) {
                Condition += " and dnt.debitNote.ID=?";
                params.add((String) paramsTaxDetails.get("dnid"));
            }
            if (paramsTaxDetails.containsKey("accid") && paramsTaxDetails.get("accid") != null) {
                Condition += " and dnt.account.ID=? ";
                params.add((String) paramsTaxDetails.get("accid"));
            }

            String query = " from DebitNoteTaxEntry dnt" + Condition;
            list = executeQuery(query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
     
    @Override
    public KwlReturnObject getDebitNoteAgainstCustomerGst(String dnid, String companyid) throws ServiceException {
        String query = " from DebitNoteAgainstCustomerGst dn where dn.debitNote.ID = ? and dn.company.companyID = ? ";
        List list = executeQuery(query, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, null, null, list, list.size());
    }
     
    public KwlReturnObject getDebitNoteIdFromReceiptIdLedger(String receiptid) throws ServiceException {
        Session session = null;
        List params = new ArrayList();
        List list = new ArrayList();
        try {
            params.add(receiptid);
            String query = "select id, dnid, description from debitnotepayment where receiptid=?";
            list = executeSQLQuery(query, params.toArray());
        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
            return new KwlReturnObject(true, "", null, list, list.size());
        }
    } 

    public List getForeignGainLossJE(String dnid, String companyid) throws ServiceException {
        String selQuery = "select linkedgainlossje from dndetails where debitNote=? and company=? and linkedgainlossje is not null ";
        List list = executeSQLQuery( selQuery, new Object[]{dnid, companyid});
        return list;
    }
    
    
    public List getCreditNoteDetailsForDebitNote(String cnId, String companyId) throws ServiceException {
//        String selQuery = "select creditnote.id,cnnumber,if(isopeningbalencecn='1',creationdate,journalentry.entrydate)as creationdate,"
        String selQuery = "select creditnote.id,cnnumber,creationdate,"
                + "if(isopeningbalencecn='1',originalopeningbalancebaseamount,jedetail.amount)as amount,"
                + "isopeningbalencecn,if(isopeningbalencecn='1',openingbalanceamountdue,cnamountdue) as amountdue "
                + "from creditnote left join journalentry  on journalentry.id=creditnote.journalentry "
                + "left join jedetail on jedetail.id= creditnote.centry where creditnote.id=? and creditnote.company=?";

        List list = executeSQLQuery( selQuery, new Object[]{cnId, companyId});
        return list;
    }
    @Override
     public synchronized String updateDeditEntryNumber(Map<String, Object> seqNumberMap) {
        String documnetNumber="";
        try {
             documnetNumber = seqNumberMap.containsKey(Constants.AUTO_ENTRYNUMBER) ? (String)seqNumberMap.get(Constants.AUTO_ENTRYNUMBER) : "";
            int seqNumber = 0;
            if(seqNumberMap.containsKey(Constants.SEQNUMBER) && !StringUtil.isNullObject(seqNumberMap.get(Constants.SEQNUMBER)) && !StringUtil.isNullOrEmpty(seqNumberMap.get(Constants.SEQNUMBER).toString())){
               seqNumber= Integer.parseInt(seqNumberMap.get(Constants.SEQNUMBER).toString());
            }
            String datePrefix = seqNumberMap.containsKey(Constants.DATEPREFIX) ? (String)seqNumberMap.get(Constants.DATEPREFIX) : "";
            String dateSuffix = seqNumberMap.containsKey(Constants.DATESUFFIX) ? (String)seqNumberMap.get(Constants.DATESUFFIX) : "";
            String dateafterPrefix = seqNumberMap.containsKey(Constants.DATEAFTERPREFIX) ? (String) seqNumberMap.get(Constants.DATEAFTERPREFIX) : "";
            String sequenceFormatID = seqNumberMap.containsKey(Constants.SEQUENCEFORMATID) ? (String)seqNumberMap.get(Constants.SEQUENCEFORMATID) : "";
            String documentID = seqNumberMap.containsKey(Constants.DOCUMENTID) ? (String)seqNumberMap.get(Constants.DOCUMENTID) : "";
            String companyID = seqNumberMap.containsKey(Constants.companyKey) ? (String)seqNumberMap.get(Constants.companyKey) : "";
            String query = "update DebitNote set dnnumber=?,seqnumber=?,datePreffixValue=?, dateafterpreffixvalue =? ,dateSuffixValue=?,seqformat.ID=? where ID=? and company.companyID=?";
            int numRows = executeUpdate( query, new Object[]{documnetNumber, seqNumber, datePrefix, dateafterPrefix,dateSuffix,sequenceFormatID, documentID, companyID});
        } catch (Exception e) {
            System.out.println(e);
        }
        return documnetNumber;
    }
      @Override
     public synchronized String updateDNEntryNumberForNA(String prid, String entrynumber) {
        try {
            String query = "update DebitNote set debitNoteNumber = ? where ID=?";
            int numRows = executeUpdate( query, new Object[]{entrynumber, prid});
        } catch (Exception e) {
            System.out.println(e);
        }
        return entrynumber;
    }

     public KwlReturnObject getDebitNotesForJE(HashMap<String, Object> requestParams) throws ServiceException {
        List list = new ArrayList();
        ArrayList params = new ArrayList();
        params.add(requestParams.get("companyid"));
        String hqlQuery = "from DebitNote dn where dn.company.companyID=? and dn.journalEntry is not null";
        list = list = executeQuery( hqlQuery, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    @Override
    public KwlReturnObject checkEntryForTransactionInLinkingTableForForwardReference(String moduleName, String docid) throws ServiceException {
        List list = new ArrayList();
        ArrayList params = new ArrayList();
        params.add(docid);
        /**
         * Removed " and invl.SourceFlag=0 " from query to * To solve DN otherwise case linking
         * Previous query was checking only case mentioned in ERP-19026.
         */
                
        String hqlQuery = "from " + moduleName + "Linking invl where invl.DocID.ID=? ";
        list = executeQuery(hqlQuery, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }
       @Override
    public boolean isDebitNoteLinkedToOtherTransaction(String moduleName, String docid) throws ServiceException {
    
           boolean isDebitNoteLinkedToOtherTransaction = false;
           List list = new ArrayList();
           ArrayList params = new ArrayList();
           params.add(docid);

           DebitNote dnobj = (DebitNote) get(DebitNote.class, docid);
           if (dnobj.getDntype() == Constants.DNAgainstPurchaseInvoice) {
               isDebitNoteLinkedToOtherTransaction = false;
           } else {
               KwlReturnObject res = checkEntryForTransactionInLinkingTableForForwardReference(moduleName, docid);
               List reslist = res.getEntityList();
               if ((reslist != null && !reslist.isEmpty())) {
                   isDebitNoteLinkedToOtherTransaction = true;
               }
           }
           return isDebitNoteLinkedToOtherTransaction;
       }
    
    @Override
    public KwlReturnObject getDeletedLinkedInvoices(DebitNote dn, String linkedDetailIDs, String companyId) throws ServiceException {
        List list = new ArrayList();
        String query= "From DebitNoteDetail dnd where dnd.company.companyID = ? and dnd.debitNote.ID = ? and dnd.goodsReceipt is not NULL ";
        if(!StringUtil.isNullOrEmpty(linkedDetailIDs)) {
           query = query.concat(" and dnd.ID not in ( "+linkedDetailIDs+" )");
        }
        list = executeQuery(query, new Object[]{companyId,dn.getID()});
        return  new KwlReturnObject(true, "", null, list, list.size());
    }
    @Override
    public KwlReturnObject getDeletedLinkedCreditNotes(DebitNote dn, String linkedDetailIDs, String companyId) throws ServiceException {
        List list = new ArrayList();
        String query= "From DebitNoteDetail dnd where dnd.company.companyID = ? and dnd.debitNote.ID = ? and dnd.creditNoteId is not NULL ";
        if(!StringUtil.isNullOrEmpty(linkedDetailIDs)) {
           query = query.concat(" and dnd.ID not in ( "+linkedDetailIDs+" )");
        }
        list = executeQuery(query, new Object[]{companyId,dn.getID()});
        return  new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject deleteSelectedLinkedInvoices(String dnid, String linkedDetailIDs, String companyid, String unlinkedDetailIDs) throws ServiceException {
        String delQuery = "delete from DebitNoteDetail dnd where dnd.debitNote.ID= ? and dnd.company.companyID= ? and dnd.creditNoteId is NULL";
        if (!StringUtil.isNullOrEmpty(linkedDetailIDs)) {
            delQuery = delQuery.concat(" and dnd.id not in (" + linkedDetailIDs + ")");
        }
        if (!StringUtil.isNullOrEmpty(unlinkedDetailIDs)) {
            delQuery = delQuery.concat(" and dnd.id in (" + unlinkedDetailIDs + ")");
        }
        int numRows = executeUpdate( delQuery, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, "Debit Note linked invoices has been deleted successfully", null, null, numRows);
    }
    @Override
    public KwlReturnObject deleteSelectedLinkedCreditNotes(String dnid, String linkedDetailIDs, String companyid, String unlinkedDetailIDs) throws ServiceException {
        String delQuery = "delete from DebitNoteDetail dnd where dnd.debitNote.ID= ? and dnd.company.companyID=?  and dnd.goodsReceipt is NULL";
        if (!StringUtil.isNullOrEmpty(linkedDetailIDs)) {
            delQuery = delQuery.concat(" and dnd.id not in (" + linkedDetailIDs + ")");
        }
        if (!StringUtil.isNullOrEmpty(unlinkedDetailIDs)) {
            delQuery = delQuery.concat(" and dnd.id in (" + unlinkedDetailIDs + ")");
        }
        int numRows = executeUpdate( delQuery, new Object[]{dnid, companyid});
        return new KwlReturnObject(true, "Debit Note linked Credit Note has been deleted successfully", null, null, numRows);
    }

    @Override
    public KwlReturnObject getNormalDebitNotes(HashMap<String, Object> requestParams) throws ServiceException {
        List list = new ArrayList();
        try {
            String companyid = (String) requestParams.get("companyid");
            String query = "from DebitNote dn where dn.company.companyID = ? and dn.normalDN=? ";
            list = executeQuery( query, new Object[]{companyid, true});
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        } finally {
            return new KwlReturnObject(true, "", null, list, list.size());
        }
    }

    @Override
    public KwlReturnObject getAdvanceReceivePaymentIdLinkedWithDebitNote(String noteId) throws ServiceException {
        List params = new ArrayList();
        params.add(noteId);
        String query = "select receipt from linkdetailreceipttodebitnote where debitnote=?";
        List list = executeSQLQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject getLinkDetailReceiptToDebitNote(HashMap<String, Object> reqParams1) throws ServiceException {
        List list=null;
        try {
            String condition="";
            ArrayList params = new ArrayList();
            DateFormat df = (DateFormat) reqParams1.get(Constants.df);                      
             if(reqParams1.containsKey("dnid") && reqParams1.get("dnid") != null){
                   String dnid = (String) reqParams1.get("dnid");
                   condition += " and rd.debitnote.ID=? ";
                   params.add(dnid);
            }
            if(reqParams1.containsKey("receiptid") && reqParams1.get("receiptid") != null){
                   String paymentId = (String) reqParams1.get("receiptid");
                   condition += " and rd.receipt.ID=? ";
                   params.add(paymentId);
            }
            if(reqParams1.containsKey("companyid") && reqParams1.get("companyid")!=null){
                String companyId = (String) reqParams1.get("companyid");
                condition += " and rd.company.companyID=? ";
                params.add(companyId);
            }
            String selQuery = "from LinkDetailReceiptToDebitNote rd  where rd.receipt.deleted=false and rd.receipt.isDishonouredCheque='F' "+condition;
            list = executeQuery( selQuery, params.toArray());
        }catch (Exception ex) {
                Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject saveDebitNoteLinking(HashMap<String, Object> hm) throws ServiceException {
        List list = new ArrayList();
        try {
            String debitnoteid = (String) hm.get("docid");
            DebitNoteLinking dnlinking = new DebitNoteLinking();
            if (hm.containsKey("docid")) {
                DebitNote debitnote = (DebitNote) get(DebitNote.class, debitnoteid);
                dnlinking.setDocID(debitnote);
}
            if (hm.containsKey("moduleid")) {
                dnlinking.setModuleID((Integer) hm.get("moduleid"));
            }
            if (hm.containsKey("linkeddocid")) {
                dnlinking.setLinkedDocID((String) hm.get("linkeddocid"));
            }
            if (hm.containsKey("linkeddocno")) {
                dnlinking.setLinkedDocNo((String) hm.get("linkeddocno"));
            }
            if (hm.containsKey("sourceflag")) {
                dnlinking.setSourceFlag((Integer) hm.get("sourceflag"));
            }
            saveOrUpdate(dnlinking);
            list.add(dnlinking);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accGoodsReceiptImpl.saveVILinking : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject deleteLinkingInformationOfDN(HashMap<String, Object> requestParams) throws ServiceException {
        ArrayList params = new ArrayList();
        int numRows1 = 0, nuRows2 = 0,nuRows3 = 0, numRowsTotal = 0;
        try {
            params.add(requestParams.get("dnid"));

            String delQuery = "delete from GoodsReceiptLinking gr where gr.LinkedDocID=?";
            numRows1 = executeUpdate( delQuery, params.toArray());

            delQuery = "delete from DebitNoteLinking dn where dn.DocID.ID=?";
            nuRows2 = executeUpdate( delQuery, params.toArray());

            delQuery = "delete from CreditNoteLinking cn where cn.LinkedDocID=?";
            nuRows3 = executeUpdate( delQuery, params.toArray());
            
            numRowsTotal = numRows1 + nuRows2 + nuRows3;
        } catch (Exception ex) {
            throw ServiceException.FAILURE("", ex);//+ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, null, numRowsTotal);
    }
    @Override
    public KwlReturnObject deleteLinkingInformationOfDNAginstCN(HashMap<String, Object> requestParams) throws ServiceException {
        ArrayList params = new ArrayList();
        int numRows1 = 0, nuRows2 = 0, numRowsTotal = 0;
        try {
            params.add(requestParams.get("dnid"));

            String delQuery = "delete from CreditNoteLinking cnl where cnl.LinkedDocID=?";
            numRows1 = executeUpdate( delQuery, params.toArray());

            delQuery = "delete from DebitNoteLinking dn where dn.DocID.ID=?";
            nuRows2 = executeUpdate( delQuery, params.toArray());

            numRowsTotal = numRows1 + nuRows2;
        } catch (Exception ex) {
            throw ServiceException.FAILURE("", ex);//+ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, null, numRowsTotal);
    }

    /**
     * Description : Method is used to check entry of debit note in
     * DebitNoteLinking table
     *
     * @param <docid> ID of Debit Note
     * @param <docid> ID of Invoice
     *
     * @return :List
     */
    @Override
    public KwlReturnObject checkEntryForDebitNoteInLinkingTable(String docid, String linkeddocid) throws ServiceException {
        List list = new ArrayList();
        ArrayList params = new ArrayList();
        params.add(docid);
        params.add(linkeddocid);
        String hqlQuery = "from DebitNoteLinking dnl where dnl.DocID.ID=? and dnl.LinkedDocID=?";
        list = executeQuery( hqlQuery, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
        /**
     * Description : Method is used to update credit note approval status
     * @param <cnID> ID of Credit Note
     * @param <companyid> ID of Company
     * @param <status> approval level
     *
     * @return :List
     */
    
    @Override
    public KwlReturnObject approvePendingDebitNote(String dnID, String companyid, int status) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(status);
        params.add(dnID);
        params.add(companyid);
        String query = "update DebitNote set approvestatuslevel = ? where ID=? and company.companyID=?";
        int numRows = executeUpdate( query, params.toArray());
        return new KwlReturnObject(true, "Debit Note has been updated successfully.", null, null, numRows);
    }

        /**
     * Description : Method is used to update credit note approval status
     * @param <cnid> ID of Credit Note
     * @param <companyid> ID of Company
     * 
     * @return :List
     */
    @Override
    public KwlReturnObject rejectPendingDebitNote(String dnid, String companyid) throws ServiceException{
         try {
            String query = "update DebitNote set deleted=true,approvestatuslevel = (-approvestatuslevel) where ID=? and company.companyID=?";
            int numRows = executeUpdate( query, new Object[]{dnid, companyid});
            return new KwlReturnObject(true, "Debit Note has been rejected successfully.", null, null, numRows);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.rejectPendingDebitNote : " + ex.getMessage(), ex);
        }
    }
    /**
     * @param jeid ID for JournalEntry
     * @param companyid ID for Company
     * @return KwlReturnObject
     * @throws com.krawler.common.service.ServiceException
     * @description Function to get Debit Note using Journal Entry ID and company's ID.
     */
    public KwlReturnObject getDebitNoteFromJE(String jeid, String companyid) throws ServiceException {
        String selQuery = "from DebitNote where journalEntry.ID=? and company.companyID=?";
        List list = executeQuery(selQuery, new Object[]{jeid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
     /**
     *
     * @param request
     * @return
     * @throws ServiceException
     * @Description : Advance Search on Detail Table
     */
    public KwlReturnObject getDNDetailsUsingAdvanceSearch(HashMap<String, Object> request) throws ServiceException {
        ArrayList params = new ArrayList();
        if (request.containsKey("Id")) {
            String id = request.get("Id").toString();
            params.add(id);
        }
        boolean lineLevelAmount = true;
        if (request.containsKey("lineLevelAmount")) {
            lineLevelAmount = Boolean.parseBoolean(request.get("lineLevelAmount").toString());
        }
        String appendCase = "and";
        String mySearchFilterString = "";
        String joinString = "";
        String joinString1 = "";
        String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
        if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
            if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                filterConjuctionCriteria = com.krawler.common.util.Constants.or;
            }
        }
        String Searchjson = "";
        if (request.containsKey("searchJson") && request.get("searchJson") != null) {
            Searchjson = request.get("searchJson").toString();

            if (!StringUtil.isNullOrEmpty(Searchjson) && lineLevelAmount) {
                try {
                    JSONObject serachJobj = new JSONObject(Searchjson);
                    JSONArray customSearchFieldArray = new JSONArray();
                    JSONArray defaultSearchFieldArray = new JSONArray();
                    StringUtil.seperateCostomAndDefaultSerachJson(serachJobj, customSearchFieldArray, defaultSearchFieldArray);

                    if (customSearchFieldArray.length() > 0) {
                        try {
                            //Advance search case for Custome field
                            request.put(Constants.Searchjson, Searchjson);
                            request.put(Constants.appendCase, appendCase);
                            request.put("filterConjuctionCriteria", filterConjuctionCriteria);

                            mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(request, true).get(Constants.myResult));
                            if (mySearchFilterString.contains("accjecustomdata")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("accjecustomdata", "dnd.debitNote.journalEntry.accBillInvCustomData");//
//                                joinString1 = " inner join invoice on invoice.id = invoicedetails.invoice  inner join accjecustomdata on accjecustomdata.journalentryId=invoice.journalentry ";
}
                            if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "jed.accJEDetailCustomData");//
//                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "accjedetailcustomdata");//
//                                joinString1 += " left join accjedetailcustomdata  on accjedetailcustomdata.jedetailId=jedetail.id ";
                            }
                            if (mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "jed.accJEDetailsProductCustomData");//    
//                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "accjedetailproductcustomdata");//    
//                                joinString1 += " left join accjedetailproductcustomdata  on accjedetailproductcustomdata.jedetailId=jedetail.id ";
                            }
                            StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                        } catch (ParseException ex) {
                            Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                } catch (JSONException ex) {
                    Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
                }

            }
        }

//        String query = " select DISTINCT invoicedetails from invoicedetails  inner join jedetail jed on jedetail.id=invoicedetails.salesjedid  where invoicedetails.invoice =? " + mySearchFilterString;
        String query = " select DISTINCT  dnd from DebitNoteTaxEntry dnd  inner join dnd.totalJED  jed where dnd.debitNote.ID =? " + mySearchFilterString;
        List list = executeQuery(query, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    /*Checking whether Credit Note is 
     Linked with any DN or not
     */
    @Override
    public boolean checkDNLinking(String DebitnoteID) throws ServiceException {
        try {
            String query = "from DebitNoteLinking dnl where dnl.DocID.ID=?";
            ArrayList params = new ArrayList();
            params.add(DebitnoteID);
            List list = executeQuery(query, params.toArray());
            if (list.size() > 0) {
                return true;
            } else {
                return false;
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accDebitNoteImpl.checkCNLinking : " + ex.getMessage(), ex);
        }

    }
    /*
     * Method for fetching debit notes with tax
     */ 
    @Override
    public KwlReturnObject getDNWithTax(HashMap<String, Object> map) throws ServiceException {
        List list = new ArrayList();
        ArrayList params = new ArrayList();
        String condition = "";
        String companyId = "";
        String currencyToExclude = "";
        if (map.containsKey("companyId") && map.get("companyId")!=null) {
            companyId = map.get("companyId").toString();
            params.add(companyId);
        }
        if (map.containsKey("currencyNotIn") && map.get("currencyNotIn")!=null) {
            currencyToExclude = map.get("currencyNotIn").toString();
            condition += " and dnt.debitNote.currency.currencyID not in (?) ";
            params.add(currencyToExclude);
        }
        String query = "From DebitNoteTaxEntry dnt where dnt.tax is not null and dnt.gstCurrencyRate = 0 and dnt.company.companyID = ? "+condition;
        list = executeQuery(query, params.toArray());
        
        return new KwlReturnObject(true, "", "", list, list.size());
    }
    @Override
    public KwlReturnObject getTDSAppliedDebitNote(Map<String, Object> requestParams) throws ServiceException {
        //Get TDS Applied Goods Receipts
        String conditionQuery = "";
        ArrayList params = new ArrayList();
        String hqlQuery = " select dn.ID from DebitNote dn INNER JOIN dn.dnTaxEntryDetails dnte ";
        
        if (requestParams.containsKey(Constants.companyKey) && requestParams.get(Constants.companyKey) != null && !StringUtil.isNullOrEmpty(requestParams.get(Constants.companyKey).toString())) {
            if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                conditionQuery += " and ";
            }
            conditionQuery += " dn.company.companyID = ? ";
            params.add(requestParams.get(Constants.companyKey));
        }
        if (requestParams.containsKey("isTDSApplied") && requestParams.get("isTDSApplied") != null && !StringUtil.isNullOrEmpty(requestParams.get("isTDSApplied").toString())) {
            if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                conditionQuery += " and ";
            }
            conditionQuery += " dnte.TDSAmount = ? ";
            params.add(requestParams.get("isTDSApplied"));
        }
        int tdsPaymentType = IndiaComplianceConstants.NOTDSPAID;
          if (requestParams.containsKey("tdsPaymentType") && requestParams.get("tdsPaymentType") != "") {
              tdsPaymentType = (int) requestParams.get("tdsPaymentType");
          }
        if (requestParams.containsKey("paymentid") && requestParams.get("paymentid") != null && !StringUtil.isNullOrEmpty(requestParams.get("paymentid").toString())) {
            
            if (tdsPaymentType == IndiaComplianceConstants.TDSPAYMENT || tdsPaymentType == IndiaComplianceConstants.TDSANDTDSINTERESTPAYMENT) {
                if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                    conditionQuery += " and ";
                }
                conditionQuery += " dn.tdsPayment = ? ";
                params.add(requestParams.get("paymentid"));
            }
            if (tdsPaymentType == IndiaComplianceConstants.TDSINTERESTPAYMENT || tdsPaymentType == IndiaComplianceConstants.TDSANDTDSINTERESTPAYMENT) {
                if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                    conditionQuery += " and ";
                }
                conditionQuery += " dn.tdsInterestPayment = ? ";
                params.add(requestParams.get("paymentid"));
            }
        }
        if (requestParams.containsKey("isPayment") && requestParams.get("isPayment") != null && !StringUtil.isNullOrEmpty(requestParams.get("isPayment").toString())) {
          boolean isPayment = Boolean.parseBoolean(requestParams.get("isPayment").toString());
          if (isPayment) {
              if (tdsPaymentType == IndiaComplianceConstants.TDSPAYMENT || tdsPaymentType == IndiaComplianceConstants.TDSANDTDSINTERESTPAYMENT) {
                    if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                        conditionQuery += " and ";
                    }
                  conditionQuery += " dn.tdsPaidFlag = 0 ";
              }
              if (tdsPaymentType == IndiaComplianceConstants.TDSINTERESTPAYMENT || tdsPaymentType == IndiaComplianceConstants.TDSANDTDSINTERESTPAYMENT) {
                  if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                      conditionQuery += " and ";
                  }
                  conditionQuery += " dn.tdsInterestPaidFlag = 0 ";
              }
          }
      }
        // Filters
        if (requestParams.containsKey("vendorId") && requestParams.get("vendorId") != null && !StringUtil.isNullOrEmpty(requestParams.get("vendorId").toString())) {
            if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                conditionQuery += " and ";
            }
            conditionQuery += " dn.vendor.ID = ? ";
            params.add(requestParams.get("vendorId"));
        }
        if (requestParams.containsKey("deducteetype") && requestParams.get("deducteetype") != null && !StringUtil.isNullOrEmpty(requestParams.get("deducteetype").toString())) {
            if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                conditionQuery += " and ";
            }
            conditionQuery += " dn.vendor.deducteeCode = ? ";
            params.add(requestParams.get("deducteetype"));
        }
        if (requestParams.containsKey("nop") && requestParams.get("nop") != null && !StringUtil.isNullOrEmpty(requestParams.get("nop").toString())) {
            if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                conditionQuery += " and ";
            }
            conditionQuery += " dn.vendor.natureOfPayment = ? ";
            params.add(requestParams.get("nop"));
        }




        if (requestParams.containsKey(Constants.df) && requestParams.get(Constants.df) != null
                && requestParams.containsKey(Constants.REQ_startdate) && requestParams.get(Constants.REQ_startdate) != null
                && requestParams.containsKey(Constants.REQ_enddate) && requestParams.get(Constants.REQ_enddate) != null) {
            try {
                String startdate = "", enddate = "";
                DateFormat df = (DateFormat) requestParams.get(Constants.df);

                startdate = requestParams.get("startdate").toString();
                enddate = requestParams.get("enddate").toString();

                Date startDate = df.parse(startdate);
                Date endDate = df.parse(enddate);
                if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                    conditionQuery += " and ";
                }
//                conditionQuery += " ( dn.journalEntry.entryDate >= ? and dn.journalEntry.entryDate <= ? )";
                conditionQuery += " ( dn.creationDate >= ? and dn.creationDate <= ? )";
                params.add(startDate);
                params.add(endDate);
                
//                conditionQuery += " ORDER BY dn.journalEntry.entryDate ";
                conditionQuery += " ORDER BY dn.creationDate ";
            } catch (ParseException ex) {
                Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        if (!StringUtil.isNullOrEmpty(conditionQuery)) {
            hqlQuery += " where " + conditionQuery;
        }
        List list = executeQuery(hqlQuery, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }
     @Override
    public void updateDebitNoteTDSPaidFlag(HashMap reqparams){
        SimpleDateFormat sdf = new SimpleDateFormat("MMMM d, yyyy hh:mm:ss aa");    
        try {
            Date stDate = null,endDate = null;
            int tdspaidflag = 0;
            String setQuery = "", conditionQuery = "";
            List params = new ArrayList();
            
            if(reqparams.containsKey("startdate") && reqparams.get("startdate")!=null && !StringUtil.isNullOrEmpty(reqparams.get("startdate").toString())){
                stDate = sdf.parse(reqparams.get("startdate").toString());
            }
            if(reqparams.containsKey("enddate") && reqparams.get("enddate")!=null && !StringUtil.isNullOrEmpty(reqparams.get("enddate").toString())){
                endDate = sdf.parse(reqparams.get("enddate").toString());
            }
            if(reqparams.containsKey("tdspaidflag") && reqparams.get("tdspaidflag")!=null && !StringUtil.isNullOrEmpty(reqparams.get("tdspaidflag").toString())){
                tdspaidflag = Integer.parseInt(reqparams.get("tdspaidflag").toString());
            }
            if(reqparams.containsKey("paymentid") && reqparams.get("paymentid")!=null && !StringUtil.isNullOrEmpty(reqparams.get("paymentid").toString())){
                if (tdspaidflag == IndiaComplianceConstants.TDSPAYMENT || tdspaidflag == IndiaComplianceConstants.TDSANDTDSINTERESTPAYMENT) {
                    setQuery += " dn.tdspaidflag=1 , dn.tdspayment='" + reqparams.get("paymentid").toString() + "' ";
                }
                if (tdspaidflag == IndiaComplianceConstants.TDSINTERESTPAYMENT || tdspaidflag == IndiaComplianceConstants.TDSANDTDSINTERESTPAYMENT) {
                    if (!StringUtil.isNullOrEmpty(setQuery)) {
                        setQuery += " , dn.tdsinterestpaidflag = 1 , dn.tdsinterestpayment='" + reqparams.get("paymentid").toString() + "' ";
                    } else {
                        setQuery += " dn.tdsinterestpaidflag = 1 , dn.tdsinterestpayment='" + reqparams.get("paymentid").toString() + "' ";
                    }
                }
            }
            conditionQuery += " dntx.istdsamount = "+IndiaComplianceConstants.DEBIT_NOTE_TDS_APPLICABLE+" ";
            if (tdspaidflag == IndiaComplianceConstants.TDSPAYMENT || tdspaidflag == IndiaComplianceConstants.TDSANDTDSINTERESTPAYMENT) {
                if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                    conditionQuery += " and ";
                }
                conditionQuery += " dn.tdspayment IS NULL ";
            }
            if (tdspaidflag == IndiaComplianceConstants.TDSINTERESTPAYMENT || tdspaidflag == IndiaComplianceConstants.TDSANDTDSINTERESTPAYMENT) {
                if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                    conditionQuery += " and ";
                }
                conditionQuery += " dn.tdsinterestpayment IS NULL ";
            }
            if(stDate!= null && endDate!= null){
                if(!StringUtil.isNullOrEmpty(conditionQuery)){
                    conditionQuery += " and ";
                }
                conditionQuery += " je.entrydate >= ? AND je.entrydate <=? ";
                params.add(stDate);
                params.add(endDate);
            }
            if(reqparams.containsKey("companyid") && reqparams.get("companyid")!=null && !StringUtil.isNullOrEmpty(reqparams.get("companyid").toString())){
                if(!StringUtil.isNullOrEmpty(conditionQuery)){
                    conditionQuery += " and ";
                }
                conditionQuery += " dn.company = ? ";
                params.add(reqparams.get("companyid"));
            }
            if (reqparams.containsKey("vendorId") && reqparams.get("vendorId") != null && !StringUtil.isNullOrEmpty(reqparams.get("vendorId").toString())) {
                if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                    conditionQuery += " and ";
                }
                conditionQuery += " vn.id = ? ";
                params.add(reqparams.get("vendorId"));
            }
            if (reqparams.containsKey("deducteecode") && reqparams.get("deducteecode") != null && !StringUtil.isNullOrEmpty(reqparams.get("deducteecode").toString())) {
                if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                    conditionQuery += " and ";
                }
                conditionQuery += " vn.deducteecode = ? ";
                params.add(reqparams.get("deducteecode"));
            }
            if (reqparams.containsKey("nop") && reqparams.get("nop") != null && !StringUtil.isNullOrEmpty(reqparams.get("nop").toString())) {
                if (!StringUtil.isNullOrEmpty(conditionQuery)) {
                    conditionQuery += " and ";
                }
                conditionQuery += " vn.natureOfPayment = ? ";
                params.add(reqparams.get("nop"));
            }
            
            String query = "UPDATE debitnote dn "
                    + " INNER JOIN vendor vn ON dn.vendor = vn.id "
                    + " INNER JOIN dntaxentry dntx ON dntx.debitnote = dn.id "
                    + " INNER JOIN journalentry je ON dn.journalentry = je.id ";
            if(!StringUtil.isNullOrEmpty(setQuery)){
                query += " SET " + setQuery ;
            }
            if(!StringUtil.isNullOrEmpty(conditionQuery)){
                query += " WHERE "+conditionQuery;
            }
            executeSQLUpdate(query,params.toArray());
            
        } catch (Exception ex) {
            Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        }
    }
    @Override
    public void resetDebitNoteTDSPaidFlag(HashMap params) {
        try {
            //To Update TDS Paid Flag.
            String whereClauseTDSQuery = "", setTDSQuery = "", TDSquery = "";
            if (params.containsKey("paymentid")) {
                setTDSQuery = " SET tdspaidflag = 0 ,tdspayment=NULL ";
                whereClauseTDSQuery = " tdspayment='" + params.get("paymentid").toString() + "' ";
            }
            if (!StringUtil.isNullOrEmpty(setTDSQuery)) {
                TDSquery = "UPDATE debitnote  " + setTDSQuery + " WHERE " + whereClauseTDSQuery;
                executeSQLUpdate(TDSquery);
            }
            //To Update TDS Interest Paid Flag.
            String whereClauseTDSInterestQuery = "", setTDSInterestQuery = "", TDSInterestquery = "";
            if (params.containsKey("paymentid")) {
                setTDSInterestQuery = " SET tdsinterestpaidflag = 0 ,tdsinterestpayment=NULL ";
                whereClauseTDSInterestQuery = " tdsinterestpayment='" + params.get("paymentid").toString() + "' ";
            }
            if (!StringUtil.isNullOrEmpty(setTDSInterestQuery)) {
                TDSInterestquery = "UPDATE debitnote  " + setTDSInterestQuery + " WHERE " + whereClauseTDSInterestQuery;
                executeSQLUpdate(TDSInterestquery);
            }
        } catch (Exception ex) {
            Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        }
    }

    public String[] columSort(String Col_Name, String Col_Dir) throws ServiceException {
        String[] String_Sort = new String[5];
        if (Col_Name.equals("personname")) {
            String_Sort[0] = " ORDER BY v.name " + Col_Dir;
            String_Sort[1] = ", je.entrydate as date, v.name ";
        } else if (Col_Name.equals("noteno")) {
            String_Sort[0] = " ORDER BY dn.dnnumber " + Col_Dir;
            String_Sort[1] = ", je.entrydate as date, dn.dnnumber ";
        } else if (Col_Name.equals("entryno")) {
            String_Sort[0] = " ORDER BY je.entryno " + Col_Dir;
            String_Sort[1] = ", je.entrydate as date, je.entryno ";
        } else if (Col_Name.equals("date")) {
            String_Sort[0] = " ORDER BY date " + Col_Dir;
            String_Sort[1] = ", je.entrydate as date ";
        } else {
            String_Sort[0] = " ORDER BY date " + Col_Dir;
            String_Sort[1] = ", je.entrydate as date ";
        }
        return String_Sort;
    }

    @Override
    public KwlReturnObject saveDebitNoteInvoiceMappingInfo(JSONObject json) throws ServiceException {
        List list = new ArrayList();
        try {
            DebitNoteInvoiceMappingInfo debitNoteInvoiceMappingInfo = new DebitNoteInvoiceMappingInfo();
            if (!StringUtil.isNullOrEmpty(json.optString("debitnoteid"))) {
                debitNoteInvoiceMappingInfo.setDebitNote((DebitNote) get(DebitNote.class, json.optString("debitnoteid")));
            }
            if (!StringUtil.isNullOrEmpty(json.optString("goodsReceipt"))) {
                debitNoteInvoiceMappingInfo.setGoodsReceipt((GoodsReceipt) get(GoodsReceipt.class, json.optString("goodsReceipt")));
            }
            if (!StringUtil.isNullOrEmpty(json.optString("invoiceid"))) {
                debitNoteInvoiceMappingInfo.setInvoice((Invoice) get(Invoice.class, json.optString("invoiceid")));
            }
            save(debitNoteInvoiceMappingInfo);
            list.add(debitNoteInvoiceMappingInfo);
        } catch (Exception e) {
            throw ServiceException.FAILURE("accDebitNoteImpl.saveDebitNoteInvoiceMappingInfo", e);
        }
        return new KwlReturnObject(true, "", "", list, list.size());
    }

    @Override
    public KwlReturnObject getDebitNoteInvoiceMappingInfo(JSONObject json) throws ServiceException {
        List list = new ArrayList();
        try {
            List params = new ArrayList();
            StringBuilder hqlQuery = new StringBuilder();
            hqlQuery.append("from DebitNoteInvoiceMappingInfo ");
            if (!StringUtil.isNullOrEmpty(json.optString("debitnoteid", null))) {
                hqlQuery.append(" where debitNote.ID = ? ");
                params.add(json.optString("debitnoteid", null));
            }
            if (!StringUtil.isNullOrEmpty(json.optString("goodsReceipt", null))) {
                hqlQuery.append(hqlQuery.indexOf("where") == -1 ? " where goodsReceipt.ID = ? " : " and goodsReceipt.ID = ? ");
                params.add(json.optString("goodsReceipt", null));
            }
            list = executeQuery(hqlQuery.toString(), params.toArray());
        } catch (Exception e) {
            throw ServiceException.FAILURE("accDebitNoteImpl.getCreditNoteInvoiceMappingInfo", e);
        }
        return new KwlReturnObject(true, "", "", list, list.size());
    }
    
    @Override
    public KwlReturnObject deleteDebitNoteInvoiceMappingInfo(JSONObject json) throws ServiceException {
        ArrayList params = new ArrayList();
        int numRowsTotal = 0;
        try {
            StringBuilder delQuery = new StringBuilder();
            delQuery.append("delete from DebitNoteInvoiceMappingInfo ");
            if(!StringUtil.isNullOrEmpty(json.optString("debitnoteid"))){
                delQuery.append("where debitNote.ID = ?");
                params.add(json.optString("debitnoteid"));
            }
            if(!StringUtil.isNullOrEmpty(json.optString("goodsReceipt"))){
                delQuery.append(delQuery.indexOf("where") == -1 ? " where goodsReceipt.ID = ? " : " and goodsReceipt.ID = ? ");
                params.add(json.optString("goodsReceipt"));
            }
            numRowsTotal = executeUpdate(delQuery.toString(), params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("", ex);//+ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, null, numRowsTotal);
    }
    
        /**
     * Method is used to line level terms and debit note account detail
     * mapping. It is used for INDIAN country for GST taxes.
     *
     * @param dataMap
     * @return
     * @throws ServiceException
     */
    @Override
    public KwlReturnObject saveDebitNoteDetailTermMap(Map<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            DebitNoteDetailTermMap termmap = new DebitNoteDetailTermMap();
            if (dataMap.containsKey("id") && !StringUtil.isNullOrEmpty(dataMap.get("id").toString())) {
                termmap = (DebitNoteDetailTermMap) get(DebitNoteDetailTermMap.class, (String) dataMap.get("id"));
                if (termmap == null) {
                    termmap = new DebitNoteDetailTermMap();
                }
            }
            if (dataMap.containsKey("termamount") && !StringUtil.isNullOrEmpty(dataMap.get("termamount").toString())) {
                termmap.setTermamount(Double.parseDouble(dataMap.get("termamount").toString()));
            }
            if (dataMap.containsKey("termpercentage")) {
                termmap.setPercentage(Double.parseDouble(dataMap.get("termpercentage").toString()));
            }
            if (dataMap.containsKey("userid")) {
                User userid = (User) get(User.class, (String) dataMap.get("userid"));
                termmap.setCreator(userid);
            }
            if (dataMap.containsKey("createdOn") && !StringUtil.isNullOrEmpty(dataMap.get("createdOn").toString())) {
                termmap.setCreatedOn(((Date) dataMap.get("createdOn")).getTime());
            }
            if (dataMap.containsKey("purchasevalueorsalevalue")) {
                termmap.setPurchaseValueOrSaleValue(Double.parseDouble(dataMap.get("purchasevalueorsalevalue").toString()));
            }
            if (dataMap.containsKey("deductionorabatementpercent")) {
                termmap.setDeductionOrAbatementPercent(Double.parseDouble(dataMap.get("deductionorabatementpercent").toString()));
            }
            if (dataMap.containsKey("assessablevalue")) {
                termmap.setAssessablevalue(Double.parseDouble(dataMap.get("assessablevalue").toString()));
            }
            if (dataMap.containsKey("taxtype")) {
                termmap.setTaxType(Integer.parseInt(dataMap.get("taxtype").toString()));
            }
            if (dataMap.containsKey("isDefault")) {
                termmap.setIsGSTApplied(Boolean.parseBoolean(dataMap.get("isDefault").toString()));
            }
            if (dataMap.containsKey("productentitytermid")) {
                EntitybasedLineLevelTermRate term = (EntitybasedLineLevelTermRate) get(EntitybasedLineLevelTermRate.class, (String) dataMap.get("productentitytermid"));
                termmap.setEntitybasedLineLevelTermRate(term);
            }
            if (dataMap.containsKey("debitNoteTaxEntry") && dataMap.get("debitNoteTaxEntry") != null) {
                termmap.setDebitNoteTaxEntry((String) dataMap.get("debitNoteTaxEntry"));
            }
            /**
             * Save Debit Note Line level detail id in line level terms for US Country
             */
            if (dataMap.containsKey("debitnotedetail") && dataMap.get("debitnotedetail") != null) {
                DebitNoteAgainstCustomerGst againstCustomerGst = (DebitNoteAgainstCustomerGst)get(DebitNoteAgainstCustomerGst.class, (String)dataMap.get("debitnotedetail"));
                termmap.setDebitnotedetail(againstCustomerGst);
            }
            saveOrUpdate(termmap);
            list.add(termmap);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accCreditNoteImpl.saveAdvanceDetailsTermMap : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject getDebitNoteDetailTermMap(JSONObject paramObj) throws ServiceException {
        List params = new ArrayList();
        StringBuilder query = new StringBuilder();
        query.append(" from DebitNoteDetailTermMap rm ");
        if (!StringUtil.isNullOrEmpty(paramObj.optString("debitNoteTaxEntry"))) {
            query.append(" where rm.debitNoteTaxEntry = ?");
            params.add(paramObj.optString("debitNoteTaxEntry"));
        }
        /**
         * Get DebitNoteDetailTermMap against Debit note detail in Overcharge and Undercharge
         */
        if (!StringUtil.isNullOrEmpty(paramObj.optString("debitnotedetail"))) {
            query.append(" where rm.debitnotedetail.id = ?");
            params.add(paramObj.optString("debitnotedetail"));
        }
        List list = executeQuery(query.toString(), params.toArray());
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public void deleteDebitNoteDetailTermMap(String debitNoteTaxEntry) throws ServiceException {
        List params = new ArrayList();
        StringBuilder query = new StringBuilder();
        query.append("delete from debitnotedetailtermmap ");
        query.append(" where debitnotetaxentry in ("+debitNoteTaxEntry+")");
        executeSQLUpdate(query.toString());
    }
    /**
     * Delete Debit note detail terms map against Debit note for Overcharge/ Undercharge US Country
     * @param debitNoteID
     * @param companyid
     * @throws ServiceException 
     */
    @Override
    public void deleteDebitNoteDetailTermMapAgainstDebitNote(String debitNoteID, String companyid) throws ServiceException {
        List params = new ArrayList();
        StringBuilder query = new StringBuilder();
        query.append("delete from DebitNoteDetailTermMap dbndtm where dbndtm.debitnotedetail "
                + " in (select dbngst.ID from DebitNoteAgainstCustomerGst dbngst where dbngst.debitNote.ID=? and dbngst.company.companyID=?)");
        params.add(debitNoteID);
        params.add(companyid);
        executeUpdate(query.toString(), params.toArray());
    }
    
    @Override
    public KwlReturnObject deleteDebitNoteForOverchargeDetails(String dnId, String companyId) throws ServiceException {
        String query = " delete from DebitNoteAgainstCustomerGst dngst where dngst.debitNote.ID = ? and dngst.company.companyID = ? ";
        int numRows = executeUpdate(query, new Object[]{dnId, companyId});
        return new KwlReturnObject(true, null, null, null, numRows);
    }
    public void deleteGstTaxClassDetails(String docrefid) throws ServiceException {
        if (!StringUtil.isNullOrEmpty(docrefid)) {
            String delQuery = " delete from gsttaxclasshistory where refdocid IN (select id from dntaxentry where debitnote=?)";
            executeSQLUpdate(delQuery, new Object[]{docrefid});
        }
    }

    public void deleteGstDocHistoryDetails(String docrefid) throws ServiceException {
        if (!StringUtil.isNullOrEmpty(docrefid)) {
            String delQuery = " delete from gstdocumenthistory where refdocid=?";
            executeSQLUpdate(delQuery, new Object[]{docrefid});
        }
    }
    
    public List getDNKnockOffTransactions(Map<String, Object> requestParams) throws ServiceException{
        List ll = null;
        try {
            String companyid = (String) requestParams.get(Constants.companyKey);
            String customerid = (String) requestParams.get("custVendorID");
            boolean isAgedDetailsReport = requestParams.containsKey("isAgedDetailsReport") ? (Boolean)requestParams.get("isAgedDetailsReport"): false;
            boolean isSalesPersonAgedReport = requestParams.containsKey("isSalesPersonAgedReport") ? (Boolean)requestParams.get("isSalesPersonAgedReport"): false;
            
            int datefilter = requestParams.containsKey("datefilter") && requestParams.get("datefilter") != null ? Integer.parseInt(requestParams.get("datefilter").toString()) : 0;
            String custQuery = "";
            boolean includeExcludeChildCmb=false;
            if (requestParams.containsKey("includeExcludeChildCmb") && requestParams.get("includeExcludeChildCmb") != null) {
                includeExcludeChildCmb = (Boolean) requestParams.get("includeExcludeChildCmb");
            }
            if (!StringUtil.isNullOrEmpty(customerid) && !customerid.equals("All")) {
                String[] customers = customerid.split(",");
                StringBuilder custValues = new StringBuilder();
                for (String customer : customers) {
                    custValues.append("'").append(customer).append("',");
                }
                String custStr = custValues.substring(0, custValues.lastIndexOf(","));
                if (isSalesPersonAgedReport) {
                    custQuery += " and masteritem.id IN (" + custStr + ")";
                } else if (includeExcludeChildCmb) {
                    custQuery += " and (cust.id IN (" + custStr + ") or cust.parent IN (" + custStr + "))";
                } else {
                    custQuery += " and cust.id IN (" + custStr + ")";
                }
            }else if(!includeExcludeChildCmb){
                custQuery += " and cust.parent is  null";
            }
            DateFormat origdf = authHandler.getDateOnlyFormat();
            String duedateStr = (String)requestParams.get("enddate");
            String asofdateStr= (requestParams.containsKey("asofdate") && requestParams.get("asofdate") != null) ? (String) requestParams.get("asofdate") : duedateStr;
            Date duedate = origdf.parse(duedateStr);
            Date asofdate = origdf.parse(asofdateStr);
            DateFormat mysqldf = new SimpleDateFormat("yyyy-MM-dd");
            duedateStr = mysqldf.format(duedate);
            ArrayList paramsAdvSearch = new ArrayList();
            ArrayList paramsAdvSearch1= new ArrayList();
            requestParams.remove("isOpeningBalanceDN");
            JSONObject advSearchQueryObj = getAdvanceSearchForCustomQuery(requestParams, paramsAdvSearch1, paramsAdvSearch, "");            
            String jeid = " jedetail.id = debitnote.centry";
            if(advSearchQueryObj.has("jeid") && !StringUtil.isNullOrEmpty(advSearchQueryObj.getString("jeid"))){
                jeid= advSearchQueryObj.getString("jeid");
            }
            String joinString1 = advSearchQueryObj.getString("joinString1");
            String mySearchFilterString = custQuery +advSearchQueryObj.getString("mySearchFilterString");
            ArrayList params = new ArrayList();
            params.add(companyid);
            params.add(duedate);
            params.addAll(paramsAdvSearch);
            
            params.add(asofdate);
            params.add(companyid);
            params.add(duedate);
            
            params.add(asofdate);
            params.add(companyid);
            params.add(duedate);
            
            params.add(asofdate);
            params.add(companyid);
            params.add(duedate);
            
            String conditionSQL="";
            if (requestParams.containsKey("groupcombo") && requestParams.get("groupcombo") != null && requestParams.containsKey(Constants.globalCurrencyKey) && requestParams.get(Constants.globalCurrencyKey) != null) {
                int groupcombo = (Integer) requestParams.get("groupcombo");
                if (groupcombo == Constants.AgedPayableBaseCurrency) {
                    conditionSQL += " where dn.doccurrency=" + Integer.parseInt((String) requestParams.get(Constants.globalCurrencyKey));
                } else if (groupcombo == Constants.AgedPayableOtherthanBaseCurrency) {
                    conditionSQL += " where dn.doccurrency!=" + Integer.parseInt((String) requestParams.get(Constants.globalCurrencyKey));
                }
            }
            //global search
            String ss = (requestParams.containsKey("ss") && requestParams.get("ss") != null) ? (String) requestParams.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                try {
                    String[] searchcol = new String[]{"dn.customername","dn.custaliasname","dn.custcode", "dn.docnumber", "dn.accountname"};
                    Map map = StringUtil.insertParamSearchStringMap(params, ss, 5); 
                    StringUtil.insertParamSearchString(map);
                    String queryStart = "and";
                    if(StringUtil.isNullOrEmpty(conditionSQL)){
                        queryStart = "where";
                    }
                    String searchQuery = StringUtil.getSearchString(ss, queryStart, searchcol);
                    conditionSQL += searchQuery + " AND dn.custcode IS NOT NULL ";
                } catch (SQLException ex) {
                    Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            
            String salesPerosnJoinType = "left join";
            if (isSalesPersonAgedReport) {
                salesPerosnJoinType = "inner join";
            } 
            String sql = "select dn.docid, dn.docnumber, SUM(dn.amount), SUM(dn.amountinbase), SUM(dn.koamt), SUM(dn.koamtbase), dn.doctype, dn.docterm, dn.creationdate, dn.duedate, dn.salespersonname, dn.salespersoncode, dn.salespersonid, dn.entryno, dn.entrydate, dn.isOpeningBalanceTransaction, dn.customerid, dn.customername, dn.custaliasname, dn.custcode, dn.customertermname, dn.customertermid, dn.customercreditlimit, dn.memo, dn.exchangerate,dn.doccurrency, dn.doccurrencyname, dn.doccurrencycode, dn.doccurrencysymbol,dn.companyname,dn.shipdate,dn.basecurrencysymbol, dn.accountname from (\n"
                    + "SELECT  debitnote.id as docid, debitnote.dnnumber as docnumber, jedetail.amount as amount, jedetail.amountinbase,0 as koamtbase,0 as koamt, 'Debit Note' as doctype, ' ' as docterm, debitnote.creationdate, debitnote.creationdate as duedate, COALESCE(masteritem.value,' ') as salespersonname, COALESCE(masteritem.code,' ') as salespersoncode, COALESCE(masteritem.id,' ') as salespersonid, je.entryno, je.entrydate, '0' as isOpeningBalanceTransaction, cust.id as customerid, cust.name as customername, cust.aliasname as custaliasname, cust.acccode as custcode, custcredit.termname as customertermname, custcredit.termid as customertermid, cust.creditlimit as customercreditlimit, debitnote.memo,if(je.externalcurrencyrate=0,exchangerate_calc(debitnote.company,debitnote.creationdate,debitnote.currency,company.currency),je.externalcurrencyrate) as exchangerate,debitnote.currency as doccurrency, dncurr.name as doccurrencyname, dncurr.currencycode as doccurrencycode, dncurr.symbol as doccurrencysymbol,company.companyname, ' ' as shipdate, compcurr.symbol as basecurrencysymbol, account.name as accountname\n"
                    + "from debitnote \n"
                    + "INNER JOIN journalentry je ON debitnote.journalentry=je.id \n"
                    + "inner join jedetail on "+jeid+" \n"
                    + "INNER JOIN customer cust ON cust.id=debitnote.customer \n"
                    + "LEFT JOIN account ON account.id=debitnote.account \n"
                    +  salesPerosnJoinType +" masteritem on masteritem.id = debitnote.salesperson\n"
                    + "inner join creditterm custcredit on cust.creditterm = custcredit.termid\n"
                    + "INNER JOIN company on debitnote.company = company.companyid \n"
                    + "INNER JOIN currency compcurr on company.currency = compcurr.currencyid \n"
                    + "INNER JOIN currency dncurr on debitnote.currency = dncurr.currencyid \n"
                    +joinString1
                    + "where debitnote.company = ? and debitnote.creationdate <= ? and debitnote.approvestatuslevel = '11' and debitnote.deleteflag='F' and (debitnote.dntype=4 or debitnote.dntype=5) \n"
                    + mySearchFilterString
                    + " \n"
                    + "group by debitnote.dnnumber \n"
                    + " UNION \n"
                    + "SELECT  debitnote.id as docid, debitnote.dnnumber as docnumber, 0 as amount, 0 as amountinbase,SUM(ldr.amountindncurrency/COALESCE(if(je.externalcurrencyrate=0,exchangerate_calc(debitnote.company,debitnote.creationdate,debitnote.currency,company.currency),je.externalcurrencyrate),1)) as koamtbase,SUM(ldr.amountindncurrency) as koamt, null as doctype, null as docterm, null as creationdate, null as duedate, null as salespersonname, null as salespersoncode, null as salespersonid, null as entryno, null as entrydate, null as isOpeningBalanceTransaction, null as customerid, null as customername, null as custaliasname, null as custcode, null as customertermname, null as customertermid, null as customercreditlimit, null as memo,null as exchangerate,null as doccurrency, null as doccurrencyname, null as doccurrencycode, null as doccurrencysymbol,null as companyname, null as shipdate, null as basecurrencysymbol, null as accountname\n"
                    + "from debitnote \n"
                    + "INNER JOIN journalentry je ON debitnote.journalentry=je.id \n"
                    + "inner join jedetail on "+jeid+" \n"
                    + "INNER JOIN customer cust ON cust.id=debitnote.customer \n"
                    + "INNER JOIN company on debitnote.company = company.companyid \n"
                    + "INNER JOIN linkdetailreceipttodebitnote ldr on ldr.debitnote=debitnote.id and ldr.receiptlinkdate<=? and ldr.company=debitnote.company \n"
                    + "where debitnote.company = ? and debitnote.creationdate <= ? and debitnote.approvestatuslevel = '11' and debitnote.deleteflag='F' and (debitnote.dntype=4 or debitnote.dntype=5) \n"
                    + " \n"
                    + "group by debitnote.dnnumber \n"
                    + " UNION \n"
                    + "SELECT  debitnote.id as docid, debitnote.dnnumber as docnumber, 0 as amount, 0 as amountinbase,SUM(dnp.amountinbasecurrency) as koamtbase, SUM(dnp.amountinbasecurrency/if(debitnote.exchangerateforopeningtransaction = 0, exchangerate_calc(debitnote.company,debitnote.creationdate,debitnote.currency, company.currency),if(debitnote.isconversionratefromcurrencytobase=1,debitnote.exchangerateforopeningtransaction, 1/debitnote.exchangerateforopeningtransaction))) as koamt, null as doctype, null as docterm, null as creationdate, null as duedate, null as salespersonname, null as salespersoncode, null as salespersonid, null as entryno, null as entrydate, null as isOpeningBalanceTransaction, null as customerid, null as customername, null as custaliasname, null as custcode, null as customertermname, null as customertermid, null as customercreditlimit, null as memo,null as exchangerate,null as doccurrency, null as doccurrencyname, null as doccurrencycode, null as doccurrencysymbol,null as companyname, null as shipdate, null as basecurrencysymbol, null as accountname\n"
                    + "from debitnote \n"
                    + "INNER JOIN journalentry je ON debitnote.journalentry=je.id \n"
                    + "inner join jedetail on "+jeid+" \n"
                    + "INNER JOIN customer cust ON cust.id=debitnote.customer \n"
                    + "INNER JOIN company on debitnote.company = company.companyid \n"
                    + "INNER JOIN debitnotepayment dnp on dnp.dnid = debitnote.id \n"
                    + "INNER JOIN receipt rt on dnp.receiptid = rt.id and rt.creationdate <= ?\n"
                    + "where debitnote.company = ? and debitnote.creationdate <= ? and debitnote.approvestatuslevel = '11' and debitnote.deleteflag='F' and (debitnote.dntype=4 or debitnote.dntype=5) \n"
                    + " \n"
                    + "group by debitnote.dnnumber \n"
                    + " UNION \n"
                    + "SELECT  debitnote.id as docid, debitnote.dnnumber as docnumber, 0 as amount, 0 as amountinbase,SUM((if(discount.inpercent='T',((discount.origamount * discount.discount) / 100),discount.discount))/COALESCE(if(je.externalcurrencyrate=0,exchangerate_calc(debitnote.company,debitnote.creationdate,debitnote.currency,company.currency),je.externalcurrencyrate),1)) as koamtbase,SUM(COALESCE(if(discount.inpercent='T',((discount.origamount * discount.discount) / 100),discount.discount),0)) as koamt, null as doctype, null as docterm, null as creationdate, null as duedate, null as salespersonname, null as salespersoncode, null as salespersonid, null as entryno, null as entrydate, null as isOpeningBalanceTransaction, null as customerid, null as customername, null as custaliasname, null as custcode, null as customertermname, null as customertermid, null as customercreditlimit, null as memo,null as exchangerate,null as doccurrency, null as doccurrencyname, null as doccurrencycode, null as doccurrencysymbol,null as companyname, null as shipdate, null as basecurrencysymbol, null as accountname\n"
                    + "from debitnote \n"
                    + "INNER JOIN journalentry je ON debitnote.journalentry=je.id \n"
                    + "inner join jedetail on "+jeid+" \n"
                    + "INNER JOIN customer cust ON cust.id=debitnote.customer \n"
                    + "INNER JOIN company on debitnote.company = company.companyid \n"
                    + "INNER JOIN cndetails cnd on cnd.debitnoteid=debitnote.id and cnd.company=debitnote.company and cnd.invoicelinkdate<=?\n"
                    + "INNER JOIN discount on cnd.discount=discount.id \n"
                    + "where debitnote.company = ? and debitnote.creationdate <= ? and debitnote.approvestatuslevel = '11' and debitnote.deleteflag='F' and (debitnote.dntype=4 or debitnote.dntype=5) \n"
                    + " \n"
                    + "group by debitnote.dnnumber \n"
                    + ") dn " + conditionSQL +" group by dn.docnumber order by dn.creationdate desc";;
            
            ll = executeSQLQuery(sql, params.toArray());
        } catch (Exception ex) {
            ex.printStackTrace();
            throw ServiceException.FAILURE("error", ex);
        }
        return ll;
    }
    
    public List getOpeningDNKnockOffTransactions(Map<String, Object> requestParams) throws ServiceException{
        List ll = null;
        try {
            String companyid = (String) requestParams.get(Constants.companyKey);
            String customerid = (String) requestParams.get("custVendorID");
            boolean isAgedDetailsReport = requestParams.containsKey("isAgedDetailsReport") ? (Boolean)requestParams.get("isAgedDetailsReport"): false;
            boolean isSalesPersonAgedReport = requestParams.containsKey("isSalesPersonAgedReport") ? (Boolean)requestParams.get("isSalesPersonAgedReport"): false;
            
            int datefilter = requestParams.containsKey("datefilter") && requestParams.get("datefilter") != null ? Integer.parseInt(requestParams.get("datefilter").toString()) : 0;
            String custQuery = "";
            boolean includeExcludeChildCmb=false;
            if (requestParams.containsKey("includeExcludeChildCmb") && requestParams.get("includeExcludeChildCmb") != null) {
                includeExcludeChildCmb = (Boolean) requestParams.get("includeExcludeChildCmb");
            }
            if (!StringUtil.isNullOrEmpty(customerid) && !customerid.equals("All")) {
                String[] customers = customerid.split(",");
                StringBuilder custValues = new StringBuilder();
                for (String customer : customers) {
                    custValues.append("'").append(customer).append("',");
                }
                String custStr = custValues.substring(0, custValues.lastIndexOf(","));
                if (isSalesPersonAgedReport) {
                    custQuery += " and masteritem.id IN (" + custStr + ")";
                } else if (includeExcludeChildCmb) {
                    custQuery += " and (cust.id IN (" + custStr + ") or cust.parent IN (" + custStr + "))";
                } else {
                    custQuery += " and cust.id IN (" + custStr + ")";
                }
            }else if(!includeExcludeChildCmb){
                custQuery += " and cust.parent is  null";
            }
            DateFormat origdf = authHandler.getDateOnlyFormat();
            String duedateStr = (String)requestParams.get("enddate");
            String asofdateStr= (requestParams.containsKey("asofdate") && requestParams.get("asofdate") != null) ? (String) requestParams.get("asofdate") : duedateStr;
            Date duedate = origdf.parse(duedateStr);
            Date asofdate = origdf.parse(asofdateStr);
            DateFormat mysqldf = new SimpleDateFormat("yyyy-MM-dd");
            duedateStr = mysqldf.format(duedate);
            ArrayList paramsAdvSearch = new ArrayList();
            ArrayList paramsAdvSearch1= new ArrayList();
            requestParams.put("isOpeningBalanceDN",true);
            JSONObject advSearchQueryObj = getAdvanceSearchForCustomQuery(requestParams, paramsAdvSearch1, paramsAdvSearch, "");            
            String joinString1 = advSearchQueryObj.getString("joinString1");
            String mySearchFilterString = custQuery +advSearchQueryObj.getString("mySearchFilterString");
            ArrayList params = new ArrayList();
            params.add(companyid);
            params.add(duedate);
            params.addAll(paramsAdvSearch);
            
            params.add(asofdate);
            params.add(companyid);
            params.add(duedate);
            
            params.add(asofdate);
            params.add(companyid);
            params.add(duedate);
            
            params.add(asofdate);
            params.add(companyid);
            params.add(duedate);
            
            String conditionSQL="";
            if (requestParams.containsKey("groupcombo") && requestParams.get("groupcombo") != null && requestParams.containsKey(Constants.globalCurrencyKey) && requestParams.get(Constants.globalCurrencyKey) != null) {
                int groupcombo = (Integer) requestParams.get("groupcombo");
                if (groupcombo == Constants.AgedPayableBaseCurrency) {
                    conditionSQL += " where dn.doccurrency=" + Integer.parseInt((String) requestParams.get(Constants.globalCurrencyKey));
                } else if (groupcombo == Constants.AgedPayableOtherthanBaseCurrency) {
                    conditionSQL += " where dn.doccurrency!=" + Integer.parseInt((String) requestParams.get(Constants.globalCurrencyKey));
                }
            }
            //global search
            String ss = (requestParams.containsKey("ss") && requestParams.get("ss") != null) ? (String) requestParams.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                try {
                    String[] searchcol = new String[]{"dn.customername","dn.custaliasname","dn.custcode", "dn.docnumber", "dn.accountname"};
                    Map map = StringUtil.insertParamSearchStringMap(params, ss, 5); 
                    StringUtil.insertParamSearchString(map);
                    String queryStart = "and";
                    if(StringUtil.isNullOrEmpty(conditionSQL)){
                        queryStart = "where";
                    }
                    String searchQuery = StringUtil.getSearchString(ss, queryStart, searchcol);
                    conditionSQL += searchQuery + " AND dn.custcode IS NOT NULL ";
                } catch (SQLException ex) {
                    Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            String salesPerosnJoinType = "left join";
            if (isSalesPersonAgedReport) {
                salesPerosnJoinType = "inner join";
            } 
            
            String sql = "select dn.docid, dn.docnumber, SUM(dn.amount), SUM(dn.amountinbase), SUM(dn.koamt), SUM(dn.koamtbase), dn.doctype, dn.docterm, dn.creationdate, dn.duedate, dn.salespersonname, dn.salespersoncode, dn.salespersonid, dn.entryno, dn.entrydate, dn.isOpeningBalanceTransaction, dn.customerid, dn.customername, dn.custaliasname, dn.custcode, dn.customertermname, dn.customertermid, dn.customercreditlimit, dn.memo, dn.exchangerate,dn.doccurrency, dn.doccurrencyname, dn.doccurrencycode, dn.doccurrencysymbol,dn.companyname,dn.shipdate,dn.basecurrencysymbol, dn.accountname from (\n"
                    + "SELECT debitnote.id as docid, debitnote.dnnumber as docnumber, debitnote.dnamount as amount, debitnote.originalopeningbalancebaseamount as amountinbase,0 as koamtbase,0 as koamt, 'Debit Note' as doctype, ' ' as docterm, debitnote.creationdate, debitnote.creationdate as duedate, COALESCE(masteritem.value,' ') as salespersonname, COALESCE(masteritem.code,' ') as salespersoncode, COALESCE(masteritem.id,' ') as salespersonid, ' ' as entryno, ' ' as entrydate, '0' as isOpeningBalanceTransaction, cust.id as customerid, cust.name as customername, cust.aliasname as custaliasname, cust.acccode as custcode, custcredit.termname as customertermname, custcredit.termid as customertermid, cust.creditlimit as customercreditlimit, debitnote.memo,if(debitnote.isconversionratefromcurrencytobase=1,debitnote.exchangerateforopeningtransaction, 1/debitnote.exchangerateforopeningtransaction) as exchangerate,debitnote.currency as doccurrency, dncurr.name as doccurrencyname, dncurr.currencycode as doccurrencycode, dncurr.symbol as doccurrencysymbol,company.companyname, ' ' as shipdate, compcurr.symbol as basecurrencysymbol, account.name as accountname\n"
                    + "from debitnote\n"
                    + "INNER JOIN company on debitnote.company = company.companyid \n"
                    + "INNER JOIN currency compcurr on company.currency = compcurr.currencyid \n"
                    + "INNER JOIN customer cust on cust.id = debitnote.customer \n"
                    + "LEFT JOIN account ON account.id=debitnote.account \n"
                    +  salesPerosnJoinType +" masteritem on masteritem.id = debitnote.salesperson\n"
                    + "inner join creditterm custcredit on cust.creditterm = custcredit.termid\n"
                    + "INNER JOIN currency dncurr on debitnote.currency = dncurr.currencyid \n"
                    +joinString1
                    + "where debitnote.isopeningbalencedn=1 and debitnote.isdnforvendor=0 and debitnote.deleteflag='F' and debitnote.company = ?  and debitnote.creationdate <= ? \n"
                    + mySearchFilterString+ " \n"
                    + "group by debitnote.dnnumber \n"
                    + "\n"
                    + " UNION \n"
                    + "SELECT  debitnote.id as docid, debitnote.dnnumber as docnumber, 0 as amount, 0 as amountinbase,SUM(dnp.amountinbasecurrency) as koamtbase, SUM(dnp.amountinbasecurrency/if(debitnote.isconversionratefromcurrencytobase=1,debitnote.exchangerateforopeningtransaction, 1/debitnote.exchangerateforopeningtransaction)) as koamt, null as doctype, null as docterm, null as creationdate, null as duedate, null as salespersonname, null as salespersoncode, null as salespersonid, null as entryno, null as entrydate, null as isOpeningBalanceTransaction, null as customerid, null as customername, null as custaliasname, null as custcode, null as customertermname, null as customertermid, null as customercreditlimit, null as memo,null as exchangerate,null as doccurrency, null as doccurrencyname, null as doccurrencycode, null as doccurrencysymbol,null as companyname, null as shipdate, null as basecurrencysymbol, null as accountname\n"
                    + "from debitnote\n"
                    + "INNER JOIN company on debitnote.company = company.companyid \n"
                    + "INNER JOIN customer cust on cust.id = debitnote.customer \n"
                    + "INNER JOIN debitnotepayment dnp on dnp.dnid = debitnote.id \n"
                    + "INNER JOIN receipt rt on rt.id = dnp.receiptid and rt.creationdate <= ?\n"
                    + "where debitnote.isopeningbalencedn=1 and debitnote.isdnforvendor=0 and debitnote.deleteflag='F' and debitnote.company = ?  and debitnote.creationdate <= ? \n"
                    + "group by debitnote.dnnumber \n"
                    + "\n"
                    + " UNION \n"
                    + "SELECT  debitnote.id as docid, debitnote.dnnumber as docnumber, 0 as amount, 0 as amountinbase,SUM((if(discount.inpercent='T',((discount.origamount * discount.discount) / 100),discount.discount))*if(debitnote.isconversionratefromcurrencytobase=1,debitnote.exchangerateforopeningtransaction, 1/debitnote.exchangerateforopeningtransaction)) as koamtbase,SUM(COALESCE(if(discount.inpercent='T',((discount.origamount * discount.discount) / 100),discount.discount),0)) as koamt, null as doctype, null as docterm, null as creationdate, null as duedate, null as salespersonname, null as salespersoncode, null as salespersonid, null as entryno, null as entrydate, null as isOpeningBalanceTransaction, null as customerid, null as customername, null as custaliasname, null as custcode, null as customertermname, null as customertermid, null as customercreditlimit, null as memo,null as exchangerate,null as doccurrency, null as doccurrencyname, null as doccurrencycode, null as doccurrencysymbol,null as companyname, null as shipdate, null as basecurrencysymbol, null as accountname\n"
                    + "from debitnote\n"
                    + "INNER JOIN company on debitnote.company = company.companyid \n"
                    + "INNER JOIN customer cust on cust.id = debitnote.customer \n"
                    + "INNER JOIN cndetails cnd on cnd.debitnoteid=debitnote.id and cnd.company=debitnote.company and cnd.invoicelinkdate<=?\n"
                    + "INNER JOIN currency dncurr on debitnote.currency = dncurr.currencyid \n"
                    + "INNER JOIN discount on cnd.discount=discount.id \n"
                    + "where debitnote.isopeningbalencedn=1 and debitnote.isdnforvendor=0 and debitnote.deleteflag='F' and debitnote.company = ?  and debitnote.creationdate <= ?\n"
                    + "group by debitnote.dnnumber \n"
                    + "\n"
                    + " UNION \n"
                    + "SELECT  debitnote.id as docid, debitnote.dnnumber as docnumber, 0 as amount, 0 as amountinbase,SUM(ldr.amountindncurrency*if(debitnote.isconversionratefromcurrencytobase=1,debitnote.exchangerateforopeningtransaction, 1/debitnote.exchangerateforopeningtransaction)) as koamtbase,SUM(ldr.amountindncurrency) as koamt, null as doctype, null as docterm, null as creationdate, null as duedate, null as salespersonname, null as salespersoncode, null as salespersonid, null as entryno, null as entrydate, null as isOpeningBalanceTransaction, null as customerid, null as customername, null as custaliasname, null as custcode, null as customertermname, null as customertermid, null as customercreditlimit, null as memo,null as exchangerate,null as doccurrency, null as doccurrencyname, null as doccurrencycode, null as doccurrencysymbol,null as companyname, null as shipdate, null as basecurrencysymbol, null as accountname\n"
                    + "from debitnote\n"
                    + "INNER JOIN company on debitnote.company = company.companyid \n"
                    + "INNER JOIN customer cust on cust.id = debitnote.customer \n"
                    + "INNER JOIN linkdetailreceipttodebitnote ldr on ldr.debitnote=debitnote.id and ldr.receiptlinkdate<=? and ldr.company=debitnote.company\n"
                    + "where debitnote.isopeningbalencedn=1 and debitnote.isdnforvendor=0 and debitnote.deleteflag='F' and debitnote.company = ?  and debitnote.creationdate <= ?\n"
                    + "group by debitnote.dnnumber \n"
                    + ") dn " + conditionSQL +" group by dn.docnumber order by dn.creationdate desc";
            
            ll = executeSQLQuery(sql, params.toArray());
        } catch (Exception ex) {
            ex.printStackTrace();
            throw ServiceException.FAILURE("error", ex);
        }
        return ll;
    }
    
    private JSONObject getAdvanceSearchForCustomQuery(Map<String, Object> request, ArrayList params, ArrayList paramsSQLWithoutInv, String searchDefaultFieldSQL) throws JSONException, ServiceException {
        JSONObject returnObj = new JSONObject();
        boolean isOpeningBalanceDN = false;
        if (request.get("isOpeningBalanceDN") != null) {
            isOpeningBalanceDN = (Boolean)request.get("isOpeningBalanceDN");
        }
        String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
        if (request.containsKey("filterConjuctionCriteria") && request.get("filterConjuctionCriteria") != null) {
            if (request.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                filterConjuctionCriteria = com.krawler.common.util.Constants.or;
            }
        }
        String mySearchFilterString = "";
        String joinString1 = "";
        String jeid = "";
        String Searchjson = "";
       try{
        if (request.containsKey("searchJson") && request.get("searchJson") != null) {
            if(request.containsKey("searchJsonDebitNote") && request.get("searchJsonDebitNote") != null)
            {
                Searchjson = StringUtil.DecodeText(request.get("searchJsonDebitNote").toString());
            } 
            else
            {
                Searchjson = StringUtil.DecodeText(request.get("searchJson").toString());
            }

            if (!StringUtil.isNullOrEmpty(Searchjson)) {
                JSONObject serachJobj = new JSONObject(Searchjson);
                JSONArray customSearchFieldArray = new JSONArray();
                JSONArray defaultSearchFieldArray = new JSONArray();
                StringUtil.seperateCostomAndDefaultSerachJson(serachJobj, customSearchFieldArray, defaultSearchFieldArray);

                if (customSearchFieldArray.length() > 0) {
                        /*
                         Advance Search For Custom fields
                         */
                        request.put(Constants.Searchjson, Searchjson);
                    request.put(Constants.appendCase, "and");
                        request.put("filterConjuctionCriteria", filterConjuctionCriteria);
                            request.put(Constants.moduleid, Constants.Acc_Debit_Note_ModuleId);
                            request.put("isOpeningBalance", isOpeningBalanceDN);
                        if (isOpeningBalanceDN) {
                            mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(request, true).get(Constants.myResult));
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "openingbalancedebitnotecustomdata");//    
                            mySearchFilterString = mySearchFilterString.replaceAll("OpeningBalanceDebitNoteCustomData", "openingbalancedebitnotecustomdata");//    
//                        mySearchFilterStringforOpeningTransaction = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
                            joinString1 = " inner join openingbalancedebitnotecustomdata on openingbalancedebitnotecustomdata.openingbalancedebitnoteid=debitnote.id ";                            
                        } else {
                            mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(request, true).get(Constants.myResult));
//                            mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
                            if (mySearchFilterString.contains("accjecustomdata") || mySearchFilterString.contains("AccJECustomData")) {
                                joinString1 = " inner join accjecustomdata on accjecustomdata.journalentryId=debitnote.journalentry ";
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJECustomData", "accjecustomdata");//    
                            }
                            StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                            if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "accjedetailcustomdata");//    
                                joinString1 += " left join accjedetailcustomdata  on accjedetailcustomdata.jedetailId=jedetail.id ";
                                jeid = " jedetail.journalentry = debitnote.journalentry ";
                            }
                            if (mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "accjedetailproductcustomdata");//    
                                joinString1 += " left join accjedetailproductcustomdata  on accjedetailproductcustomdata.jedetailId=jedetail.id ";
                                jeid = " jedetail.journalentry = debitnote.journalentry ";
                            }
                            if (mySearchFilterString.contains("CustomerCustomData")) {
                                joinString1 += " left join customercustomdata  on customercustomdata.customerId=customer.id ";
                                mySearchFilterString = mySearchFilterString.replaceAll("CustomerCustomData", "customercustomdata");
                            }
                        }
                        StringUtil.insertParamAdvanceSearchString1(paramsSQLWithoutInv, Searchjson);
                    }
                mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(searchDefaultFieldSQL, mySearchFilterString, filterConjuctionCriteria);
            }
        }
        returnObj.put("jeid", jeid);
        returnObj.put("joinString1", joinString1);
        returnObj.put("mySearchFilterString", mySearchFilterString);
         } catch (Exception ex) {
            Logger.getLogger(accDebitNoteImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accDebitNoteImpl.getAdvanceSearchForCustomQuery:" + ex.getMessage(), ex);
        }
        return returnObj;
    }
}
