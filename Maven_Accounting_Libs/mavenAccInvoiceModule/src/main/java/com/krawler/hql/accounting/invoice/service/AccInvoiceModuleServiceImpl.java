/*
 * Copyright (C) 2012  Krawler Information Systems Pvt Ltd
 * All rights reserved.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package com.krawler.hql.accounting.invoice.service;

import com.krawler.accounting.integration.common.IntegrationCommonService;
import com.krawler.accounting.integration.common.IntegrationConstants;
import com.krawler.common.admin.AuditAction;
import com.krawler.common.admin.*;
import com.krawler.common.service.ServiceException;
import com.krawler.common.session.SessionExpiredException;
import com.krawler.common.util.Constants;
import com.krawler.common.util.CsvReader;
import com.krawler.common.util.DataInvalidateException;
import com.krawler.common.util.StringUtil;
import com.krawler.common.util.ValuationMethod;
import com.krawler.spring.common.fieldDataManager;
import com.krawler.esp.handlers.SendMailHandler;
import com.krawler.esp.handlers.StorageHandler;
import com.krawler.hql.accounting.*;
import com.krawler.inventory.model.approval.ApprovalStatus;
import com.krawler.inventory.model.approval.consignment.Consignment;
import com.krawler.inventory.model.approval.consignment.ConsignmentApprovalDetails;
import com.krawler.inventory.model.location.Location;
import com.krawler.inventory.model.location.LocationService;
import com.krawler.inventory.model.stock.StockService;
import com.krawler.inventory.model.stockmovement.*;
import com.krawler.inventory.model.store.Store;
import com.krawler.spring.accounting.companypreferances.accCompanyPreferencesDAO;
import com.krawler.spring.accounting.currency.accCurrencyDAO;
import com.krawler.spring.accounting.customer.accCustomerDAO;
import com.krawler.spring.accounting.discount.accDiscountDAO;
import com.krawler.spring.accounting.handler.AccountingHandlerDAO;
import com.krawler.spring.accounting.handler.AccountingManager;
import com.krawler.spring.accounting.invoice.accInvoiceController;
import com.krawler.spring.accounting.invoice.accInvoiceDAO;
import com.krawler.spring.accounting.journalentry.JournalEntryConstants;
import com.krawler.spring.accounting.journalentry.accJournalEntryDAO;
import com.krawler.spring.accounting.masteritems.accMasterItemsDAO;
import com.krawler.spring.accounting.multiLevelApprovalRule.AccMultiLevelApprovalDAO;
import com.krawler.spring.accounting.payment.accPaymentDAO;
import com.krawler.spring.accounting.product.accProductDAO;
import com.krawler.spring.accounting.salesorder.accSalesOrderDAO;
import com.krawler.spring.accounting.tax.accTaxDAO;
import com.krawler.spring.auditTrailModule.auditTrailDAO;
import com.krawler.spring.authHandler.authHandler;
import com.krawler.spring.authHandler.authHandlerDAO;
import com.krawler.spring.common.AccCommonTablesDAO;
import com.krawler.spring.common.CommonFnController;
import com.krawler.spring.common.KwlReturnObject;
import com.krawler.spring.importFunctionality.ImportDAO;
import com.krawler.spring.importFunctionality.ImportHandler;
import com.krawler.spring.sessionHandler.sessionHandlerImpl;
import com.krawler.spring.storageHandler.storageHandlerImpl;
import com.krawler.esp.handlers.APICallHandlerService;
import com.krawler.inventory.exception.InventoryException;
import com.krawler.inventory.model.stock.StockDAO;
import com.krawler.inventory.model.stockout.StockAdjustment;
import com.krawler.spring.accounting.bankreconciliation.accBankReconciliationDAO;
import com.krawler.spring.accounting.companypreferances.CompanyPreferencesCMN;
import com.krawler.spring.accounting.companypreferances.CompanyPreferencesConstants;
import com.krawler.spring.accounting.invoice.InvoiceConstants;
import com.krawler.spring.accounting.invoice.accInvoiceImpl;
import com.krawler.spring.accounting.product.PVBSorter;
import com.krawler.spring.accounting.product.TransactionBatch;
import com.krawler.spring.accounting.productmodule.service.AccProductModuleService;
import com.krawler.spring.accounting.salesorder.accSalesOrderService;

import com.krawler.utils.json.base.JSONArray;
import com.krawler.utils.json.base.JSONException;
import com.krawler.utils.json.base.JSONObject;
import java.io.*;
import java.math.BigInteger;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.mail.MessagingException;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;
import javax.servlet.ServletContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.springframework.context.MessageSource;
import org.springframework.context.MessageSourceAware;
import org.springframework.orm.hibernate3.HibernateTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionException;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.web.servlet.support.RequestContextUtils;
import static com.krawler.common.util.Constants.Acc_ConsignmentDeliveryOrder_ModuleId;
import static com.krawler.common.util.Constants.Acc_ConsignmentInvoice_ModuleId;
import static com.krawler.common.util.Constants.Acc_Invoice_ModuleId;
import static com.krawler.common.util.Constants.LEASE_INVOICE_MODULEID;
import com.krawler.common.util.URLUtil;
import static com.krawler.esp.web.resource.Links.loginpageFull;
import com.krawler.inventory.exception.SeqFormatException;
import com.krawler.inventory.model.ist.DODQCISTMapping;
import com.krawler.inventory.model.ist.DeliveryDetailInterStoreLocationMapping;
import com.krawler.inventory.model.ist.ISTDetail;
import com.krawler.inventory.model.ist.InterStoreTransferRequest;
import com.krawler.inventory.model.ist.InterStoreTransferService;
import com.krawler.inventory.model.ist.InterStoreTransferStatus;
import com.krawler.inventory.model.sequence.ModuleConst;
import com.krawler.inventory.model.sequence.SeqFormat;
import com.krawler.inventory.model.sequence.SeqService;
import com.krawler.inventory.model.stockout.StockAdjustmentDetail;
import com.krawler.inventory.model.stockout.StockAdjustmentService;
import com.krawler.inventory.model.store.StoreService;
import com.krawler.spring.accounting.account.accAccountDAO;
import com.krawler.spring.accounting.handler.AccountingHandlerService;
import com.krawler.spring.accounting.journalentry.accJournalEntryController;
import com.krawler.spring.common.fieldManagerDAO;
import com.krawler.spring.common.CommonFnControllerService;
import com.krawler.spring.common.kwlCommonTablesDAO;
import com.krawler.spring.permissionHandler.permissionHandlerDAO;

/**
 *
 * @author krawler
 */
public class AccInvoiceModuleServiceImpl implements AccInvoiceModuleService, MessageSourceAware {

    private HibernateTransactionManager txnManager;
    private AccMultiLevelApprovalDAO accMultiLevelApprovalDAOObj;
    private authHandlerDAO authHandlerDAOObj;
    private accInvoiceDAO accInvoiceDAOobj;
    private accJournalEntryDAO accJournalEntryobj;
    private accProductDAO accProductObj;
    private accDiscountDAO accDiscountobj;
    private accCurrencyDAO accCurrencyDAOobj;
    private accCompanyPreferencesDAO accCompanyPreferencesObj;
    private fieldDataManager fieldDataManagercntrl;
    private fieldManagerDAO fieldManagerDAOobj;
    private AccountingHandlerDAO accountingHandlerDAOobj;
    private accTaxDAO accTaxObj;
    private String successView;
    private MessageSource messageSource;
    private auditTrailDAO auditTrailObj;
    public ImportHandler importHandler;
    public accCustomerDAO accCustomerDAOObj;
    private ImportDAO importDao;
    private accMasterItemsDAO accMasterItemsDAOobj;
    private accSalesOrderDAO accSalesOrderDAOObj;
    private AccCommonTablesDAO accCommonTablesDAO;
    private LocationService locationService;
    private StockMovementService stockMovementService;
    private accPaymentDAO accPaymentDAOobj;
    private APICallHandlerService apiCallHandlerService;
    private StockDAO stockDAO;
    private StockService stockService;
    private AccProductModuleService accProductModuleService;
    private accSalesOrderService accSalesOrderServiceobj;
    private accBankReconciliationDAO accBankReconciliationObj;
    String recId = "";
    String tranID = "";
    private accAccountDAO accAccountDAOobj;
    private InterStoreTransferService istService;
    private SeqService seqService;
    private StoreService storeService;
    private StockAdjustmentService stockAdjustmentService;
    private IntegrationCommonService integrationCommonService;
    private kwlCommonTablesDAO kwlCommonTablesDAOObj;
    private CommonFnControllerService commonFnControllerService;
    private permissionHandlerDAO permissionHandlerDAOObj;
    
    public void setIntegrationCommonService(IntegrationCommonService integrationCommonService) {
        this.integrationCommonService = integrationCommonService;
    }
     
    public void setStockDAO(StockDAO stockDAO) {
        this.stockDAO = stockDAO;
    }

    public void setMessageSource(MessageSource ms) {
        this.messageSource = ms;
    }
    
    public void setaccMultiLevelApprovalDAOObj(AccMultiLevelApprovalDAO accMultiLevelApprovalDAO) {
        this.accMultiLevelApprovalDAOObj = accMultiLevelApprovalDAO;
    }

    public void setauthHandlerDAO(authHandlerDAO authHandlerDAOObj1) {
        this.authHandlerDAOObj = authHandlerDAOObj1;
    }

    public void setauditTrailDAO(auditTrailDAO auditTrailDAOObj) {
        this.auditTrailObj = auditTrailDAOObj;
    }
    
    public void setIstService(InterStoreTransferService istService) {
        this.istService = istService;
    }
    public void setSeqService(SeqService seqService) {
        this.seqService = seqService;
    }
    public void setStoreService(StoreService storeService) {
        this.storeService = storeService;
    }
    public void setStockAdjustmentService(StockAdjustmentService stockAdjustmentService) {
        this.stockAdjustmentService = stockAdjustmentService;
    }
    public void setAccCustomerDAO(accCustomerDAO accCustomerDAOObj) {
        this.accCustomerDAOObj = accCustomerDAOObj;
    }

    public void setTxnManager(HibernateTransactionManager txManager) {
        this.txnManager = txManager;
    }

    public void setaccInvoiceDAO(accInvoiceDAO accInvoiceDAOobj) {
        this.accInvoiceDAOobj = accInvoiceDAOobj;
    }

    public void setaccJournalEntryDAO(accJournalEntryDAO accJournalEntryobj) {
        this.accJournalEntryobj = accJournalEntryobj;
    }

    public void setaccProductDAO(accProductDAO accProductObj) {
        this.accProductObj = accProductObj;
    }

    public void setaccDiscountDAO(accDiscountDAO accDiscountobj) {
        this.accDiscountobj = accDiscountobj;
    }

    public void setaccCurrencyDAO(accCurrencyDAO accCurrencyDAOobj) {
        this.accCurrencyDAOobj = accCurrencyDAOobj;
    }

    public void setaccCompanyPreferencesDAO(accCompanyPreferencesDAO accCompanyPreferencesObj) {
        this.accCompanyPreferencesObj = accCompanyPreferencesObj;
    }

    public void setaccountingHandlerDAO(AccountingHandlerDAO AccountingHandlerDAOobj) {
        this.accountingHandlerDAOobj = AccountingHandlerDAOobj;
    }

    public String getSuccessView() {
        return successView;
    }

    public void setSuccessView(String successView) {
        this.successView = successView;
    }

    public void setaccTaxDAO(accTaxDAO accTaxObj) {
        this.accTaxObj = accTaxObj;
    }

    public void setFieldDataManager(fieldDataManager fieldDataManagercntrl) {
        this.fieldDataManagercntrl = fieldDataManagercntrl;
    }
    
     public void setFieldManagerDAO(fieldManagerDAO fieldManagerDAOobj) {
        this.fieldManagerDAOobj = fieldManagerDAOobj;
    }

    public void setimportHandler(ImportHandler importHandler) {
        this.importHandler = importHandler;
    }

    public void setimportDAO(ImportDAO importDao) {
        this.importDao = importDao;
    }

    public void setaccCommonTablesDAO(AccCommonTablesDAO accCommonTablesDAO) {
        this.accCommonTablesDAO = accCommonTablesDAO;
    }

    public void setaccMasterItemsDAO(accMasterItemsDAO accMasterItemsDAOobj) {
        this.accMasterItemsDAOobj = accMasterItemsDAOobj;
    }

    public void setAccSalesOrderDAO(accSalesOrderDAO accSalesOrderDAOObj) {
        this.accSalesOrderDAOObj = accSalesOrderDAOObj;
    }

    public void setLocationService(LocationService locationService) {
        this.locationService = locationService;
    }

    public void setStockMovementService(StockMovementService stockMovementService) {
        this.stockMovementService = stockMovementService;
    }

    public void setaccPaymentDAO(accPaymentDAO accPaymentDAOobj) {
        this.accPaymentDAOobj = accPaymentDAOobj;
    }

    public void setApiCallHandlerService(APICallHandlerService apiCallHandlerService) {
        this.apiCallHandlerService = apiCallHandlerService;
    }

    public void setStockService(StockService stockService) {
        this.stockService = stockService;
    }
    public void setAccProductModuleService(AccProductModuleService accProductModuleService) {
        this.accProductModuleService = accProductModuleService;
    }
    public void setAccSalesOrderServiceobj(accSalesOrderService accSalesOrderServiceobj) {
        this.accSalesOrderServiceobj = accSalesOrderServiceobj;
    }
    
    public void setaccBankReconciliationDAO(accBankReconciliationDAO accBankReconciliationObj) {
        this.accBankReconciliationObj = accBankReconciliationObj;
    }
    
    public void setaccAccountDAO(accAccountDAO accAccountDAOobj) {
        this.accAccountDAOobj = accAccountDAOobj;
    }
    
    public void setkwlCommonTablesDAO(kwlCommonTablesDAO kwlCommonTablesDAOObj1) {
        this.kwlCommonTablesDAOObj = kwlCommonTablesDAOObj1;
    }
    
    public void setCommonFnControllerService(CommonFnControllerService commonFnControllerService) {
        this.commonFnControllerService = commonFnControllerService;
    }
    
    public void setpermissionHandlerDAO(permissionHandlerDAO permissionHandlerDAOObj1) {
        this.permissionHandlerDAOObj = permissionHandlerDAOObj1;
    }
    
    public JSONObject saveInvoice(HttpServletRequest request, HttpServletResponse response) {
        String msg = "";
        boolean issuccess = true;
        JSONObject jobj = new JSONObject();
        try {
            JSONObject paramJObj = new JSONObject();
            Enumeration<String> attributes = request.getAttributeNames();
            while (attributes.hasMoreElements()) {
                String attribute = attributes.nextElement();
                paramJObj.put(attribute, request.getAttribute(attribute));
            }
            Enumeration<String> parameters = request.getParameterNames();
            while (parameters.hasMoreElements()) {
                String parameter = parameters.nextElement();
                paramJObj.put(parameter, request.getParameter(parameter));
            }

            String companyid = sessionHandlerImpl.getCompanyid(request);
            String userDateFormat = sessionHandlerImpl.getUserDateFormat(request);
            paramJObj.put(Constants.companyKey, companyid);
            String currencyid = sessionHandlerImpl.getCurrencyID(request);
            paramJObj.put(Constants.currencyKey, currencyid);
            paramJObj.put(Constants.globalCurrencyKey, currencyid);
            String userfullname = sessionHandlerImpl.getUserFullName(request);
            paramJObj.put(Constants.userfullname, userfullname);
            paramJObj.put(Constants.userdateformat, userDateFormat);
            String userId = sessionHandlerImpl.getUserid(request);
            paramJObj.put(Constants.useridKey, userId);
            paramJObj.put(Constants.lid, userId);
            ServletContext context = request.getSession().getServletContext();
            String crmURL = context.getInitParameter(Constants.crmURL);
            paramJObj.put("crmurl", crmURL);
            paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
            paramJObj.put(Constants.PAGE_URL, URLUtil.getPageURL(request, loginpageFull));
            jobj = saveCustomerInvoiceJson(paramJObj);

        } catch (JSONException | SessionExpiredException | ServiceException e) {
            msg = e.getMessage();
            issuccess = false;
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, e);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return jobj;
    }

    public List mapInvoiceTerms(String InvoiceTerms, String invoiceID, String userid) throws ServiceException {
        List ll = new ArrayList();
        try {
            JSONArray termsArr = new JSONArray(InvoiceTerms);
            for (int cnt = 0; cnt < termsArr.length(); cnt++) {
                JSONObject temp = termsArr.getJSONObject(cnt);
                HashMap<String, Object> termMap = new HashMap<String, Object>();
                termMap.put("term", temp.getString(Constants.Acc_id));
                termMap.put("termamount", Double.parseDouble(temp.getString("termamount")));
                int percentage = 0;
                if (!StringUtil.isNullOrEmpty(temp.getString("termpercentage"))) {
                    percentage = Integer.parseInt(temp.getString("termpercentage"));
                }
                termMap.put("termpercentage", percentage);
                termMap.put("invoice", invoiceID);
                termMap.put("creationdate", new Date());
                termMap.put(Constants.useridKey, userid);
                accInvoiceDAOobj.saveInvoiceTermMap(termMap);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return ll;
    }

    public JSONObject importOpeningBalanceInvoice(HttpServletRequest request, HttpServletResponse response) throws ServiceException {
        JSONObject jobj = new JSONObject();
        String msg = "";
        boolean issuccess = false;
        try {
            String doAction = request.getParameter("do");
            System.out.println("A(( " + doAction + " start : " + new Date());

            JSONObject datajobj = new JSONObject();

            if (doAction.compareToIgnoreCase("getMapCSV") == 0) {
                datajobj = importHandler.getMappingCSVHeader(request);
                JSONArray jSONArray = datajobj.getJSONArray("Header");
                validateHeaders(jSONArray);

                jobj = importOeningTransactionsRecords(request, datajobj);
//                msg = "All records are imported successfully.";
                issuccess = true;
            }
        } catch (Exception ex) {
            issuccess = false;
            msg = "" + ex.getMessage();

            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
            } catch (JSONException e) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, e.getMessage(), e);
            }

            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        }
        return jobj;
    }

    public List saveInvoiceJson(JSONObject paramJobj) throws ServiceException, AccountingException, SessionExpiredException, UnsupportedEncodingException {
        String id = null;
        List ll = new ArrayList();
        String jeentryNumber = null;
        Invoice invoice = null;
        DeliveryOrder doObj = null;
        ArrayList discountArr = new ArrayList();
        String oldjeid = null;
        String invoiceid = null;
        JSONObject invjson = null;
        Date billdateVal = null;
        String entryNumber = null;
        String currencyid = null;
        String custId = null;
        String porefnumber = null;
        String termid = null;
        String salesPerson = null;
        try {
            int istemplate = (paramJobj.has("istemplate") && paramJobj.get("istemplate")!=null)? Integer.parseInt(paramJobj.get("istemplate").toString()) : 0;                    
            KwlReturnObject result = null;
            String sequenceformat = (paramJobj.has(Constants.sequenceformat) && paramJobj.get(Constants.sequenceformat) != null) ? paramJobj.getString(Constants.sequenceformat) : "NA";
            int nocount;
            HashMap<String, Object> requestParams = AccountingManager.getGlobalParamsJson(paramJobj);
            for (String key : requestParams.keySet()) {
                paramJobj.put(key, requestParams.get(key));
            }
            DateFormat df = authHandler.getDateOnlyFormat();
            String companyid = paramJobj.getString(Constants.companyKey);
            try {
                billdateVal = df.parse(paramJobj.optString(Constants.BillDate, null));
            } catch (ParseException ex) {
                boolean isIPhone = paramJobj.optString("isIPhone", null) != null ? Boolean.parseBoolean(paramJobj.get("isIPhone").toString()) : false;
                if (isIPhone && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.BillDate,null))) {
                    billdateVal = authHandler.getDateOnlyFormat().parse(paramJobj.get(Constants.BillDate).toString());
                } else {
                    Calendar cal = Calendar.getInstance();
                    long billdateValue = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                    cal.setTimeInMillis(billdateValue);
                    Date calDate = null;
                    try {
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);

                    } catch (ParseException pex) {
                        calDate = cal.getTime();
                        Logger.getLogger(accInvoiceImpl.class.getName()).log(Level.SEVERE, null, pex);
                    }
                    billdateVal = calDate;
                    billdateVal = authHandler.getDateOnlyFormat().parse(authHandler.getGlobalDateFormat().format(billdateVal));
                }
            }
            String deliveryOrderid = (paramJobj.has("doid") && paramJobj.get("doid") != null) ? paramJobj.getString("doid") : null;

            String jeid = null;
            String customfield = (paramJobj.has(Constants.customfield) && paramJobj.get(Constants.customfield) != null) ? paramJobj.getString(Constants.customfield) : null;
            boolean jeautogenflag = false;
            Customer customer = null;
            boolean isFixedAsset = (paramJobj.has(Constants.isFixedAsset) && paramJobj.get(Constants.isFixedAsset) != null) ? paramJobj.getBoolean(Constants.isFixedAsset) : false;
            boolean isLeaseFixedAsset = (paramJobj.has(Constants.isLeaseFixedAsset) && paramJobj.get(Constants.isLeaseFixedAsset) != null) ? paramJobj.getBoolean(Constants.isLeaseFixedAsset) : false;
            boolean gstIncluded =false ; 
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                custId = (paramJobj.has("CustomerName") && paramJobj.get("CustomerName") != null) ? paramJobj.getString("CustomerName") : null;
                currencyid = paramJobj.optString(Constants.currencyName, null);
                entryNumber = paramJobj.optString("invoiceNumber", "");
                porefnumber = paramJobj.optString("poRefNumber", null);
                termid = (paramJobj.has("terms") && paramJobj.get("terms") != null) ? paramJobj.getString("terms") : null;
                salesPerson = paramJobj.optString(Constants.salesperson, null);
                invoiceid = (paramJobj.has(Constants.billid) && paramJobj.get(Constants.billid) != null) ? paramJobj.getString(Constants.billid) : null;
                gstIncluded=(StringUtil.isNullOrEmpty(paramJobj.optString("gstIncluded",null)))?false:Boolean.parseBoolean(paramJobj.getString("gstIncluded"));
            } else {
                custId = (paramJobj.has("customer") && paramJobj.get("customer") != null) ? paramJobj.getString("customer") : null;
                currencyid = paramJobj.optString(Constants.currencyKey, null);
                entryNumber = paramJobj.optString("number", "");
                porefnumber = paramJobj.optString("porefno", null);
                termid = (paramJobj.has("termid") && paramJobj.get("termid") != null) ? paramJobj.getString("termid") : null;
                salesPerson = paramJobj.optString("salesPerson", null);
                invoiceid = (paramJobj.has("invoiceid") && paramJobj.get("invoiceid") != null) ? paramJobj.getString("invoiceid") : null;
                gstIncluded=(StringUtil.isNullOrEmpty(paramJobj.optString("gstIncluded",null)))?true:Boolean.parseBoolean(paramJobj.getString("gstIncluded"));
            }
            recId = invoiceid;

            if (StringUtil.isNullOrEmpty(custId)) {
                String acccode = (paramJobj.has("acccode") && paramJobj.get("acccode") != null) ? paramJobj.getString("acccode") : null;
                custId = accInvoiceDAOobj.getCustomerId(companyid, acccode);
            }
            if (StringUtil.isNullOrEmpty(custId)) {
                custId = accInvoiceDAOobj.getCustomerIdForPOS(companyid);

            }
            String accountid = custId;
            KwlReturnObject custresult = null;
            if (!StringUtil.isNullOrEmpty(custId)) {
                custresult = accountingHandlerDAOobj.getObject(Customer.class.getName(), custId);
                customer = (Customer) custresult.getEntityList().get(0);
                if (customer.getAccount() != null) {
                    accountid = customer.getAccount().getID();
                }
            }
            if (StringUtil.isNullOrEmpty(termid)) {
                termid = customer !=null?customer.getCreditTerm().getID():"";
            }
            String createdby = (paramJobj.has(Constants.lid)  && paramJobj.get(Constants.lid) != null)? paramJobj.getString(Constants.lid) : ((paramJobj.has(Constants.useridKey)  && paramJobj.get(Constants.useridKey) != null)?paramJobj.getString(Constants.useridKey):null) ;
            String modifiedby = createdby;
            long createdon = System.currentTimeMillis();
            long updatedon = System.currentTimeMillis();


            if (!StringUtil.isNullOrEmpty(invoiceid)) {
                KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                invoice = (Invoice) invObj.getEntityList().get(0);
                tranID = invoice.getID();
                oldjeid = invoice.getJournalEntry().getID();
                jeautogenflag = invoice.getJournalEntry().isAutoGenerated();
                Map<String, Object> addressParams = new HashMap<String, Object>();
                String billingAddress = (paramJobj.has(Constants.BILLING_ADDRESS)  && paramJobj.get(Constants.BILLING_ADDRESS) != null)? paramJobj.getString(Constants.BILLING_ADDRESS) : null;
                if (!StringUtil.isNullOrEmpty(billingAddress)) {
                    addressParams = AccountingAddressManager.getAddressParamsJson(paramJobj,false);
                } else {//handling the cases when no address coming in edit case 
                    addressParams = AccountingAddressManager.getDefaultCustomerAddressParams(customer.getID(), companyid, accountingHandlerDAOobj);// addressParams = getCustomerDefaultAddressParams(customer,companyid);
                }
                BillingShippingAddresses bsa = invoice.getBillingShippingAddresses();//used to update billing shipping addresses
                addressParams.put(Constants.Acc_id, bsa != null ? bsa.getID() : "");
                KwlReturnObject addressresult = accountingHandlerDAOobj.saveAddressDetail(addressParams, companyid);
                bsa = (BillingShippingAddresses) addressresult.getEntityList().get(0);
                String addressid = bsa.getID();

                // delete asset details
                if (invoice.isFixedAssetInvoice() || invoice.isFixedAssetLeaseInvoice()) {
                   boolean updateFlag=true;
                    deleteAssetDetails(invoice, companyid,updateFlag);
                    if (invoice.isFixedAssetLeaseInvoice()) {
                        deleteInvoiceContractMappings(invoice, companyid);
                    }
                }

                result = accInvoiceDAOobj.getInvoiceInventory(invoiceid);
                //deleting Delivery order row
                if (!StringUtil.isNullOrEmpty(deliveryOrderid)) {
                    
                    // UPDATE THE SO BALANCE QTY - BEFORE EDITING AUTO DO (REF SDP-6947)
                    List<DeliveryOrderDetail> dodetails = Collections.EMPTY_LIST;
                    HashMap<String, Object> doRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList();
                    filter_names.add("deliveryOrder.ID");
                    filter_params.add(deliveryOrderid);
                    doRequestParams.put(Constants.filterNamesKey, filter_names);
                    doRequestParams.put(Constants.filterParamsKey, filter_params);
                    KwlReturnObject podresult = accInvoiceDAOobj.getDeliveryOrderDetails(doRequestParams);
                    dodetails = podresult.getEntityList();
                    if (dodetails != null && !dodetails.isEmpty()) { //update balance quantity to po when creating gr link to pi and pi link to po
                        for (DeliveryOrderDetail cnt : dodetails) {
                            if (cnt.getCidetails() != null && cnt.getCidetails().getSalesorderdetail() != null) {
                                KwlReturnObject Autordresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), cnt.getCidetails().getSalesorderdetail().getID());
                                SalesOrderDetail salesorderdetails = (SalesOrderDetail) Autordresult.getEntityList().get(0);
                                HashMap soMap = new HashMap();
                                soMap.put("sodetails", salesorderdetails.getID());
                                soMap.put(Constants.companyKey, salesorderdetails.getCompany().getCompanyID());
                                soMap.put("balanceqty", cnt.getDeliveredQuantity());
                                soMap.put("add", true);
                                accCommonTablesDAO.updateSalesorderOrderStatus(soMap);
                            }
                        }
                    }
                    
                    KwlReturnObject DOObj = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), deliveryOrderid);
                    doObj = (DeliveryOrder) DOObj.getEntityList().get(0);
                    paramJobj.put("DOSeqNum", doObj.getSeqnumber());
//                    request.setAttribute("DOSeqNum", doObj.getSeqnumber());
                    HashMap<String, Object> DeliveryorderMap = new HashMap<String, Object>();
                    DeliveryorderMap.put("doid", deliveryOrderid);
                    DeliveryorderMap.put(Constants.companyKey, companyid);
                    accInvoiceDAOobj.deleteDeliveryOrdersBatchSerialDetails(DeliveryorderMap);
                    accInvoiceDAOobj.deleteDeliveryOrdersPermanent(DeliveryorderMap);
                }
                //deleting invoice row
                accInvoiceDAOobj.deleteInvoiceDtails(invoiceid, companyid);
                List list = result.getEntityList();
                Iterator itr = list.iterator();
                while (itr.hasNext()) {
                    String inventoryid = (String) itr.next();
                    accProductObj.deleteInventory(inventoryid, companyid);
                }

                ////Deleting all Invoice Detail discount
                result = accInvoiceDAOobj.getInvoiceDetailsDiscount(invoiceid);
                list = result.getEntityList();
                itr = list.iterator();
                while (itr.hasNext()) {
                    String discountid = (String) itr.next();
                    if (StringUtil.isNullOrEmpty(discountid)) {
                        discountArr.add(discountid);
                    }
                }
                String discountid = (invoice.getDiscount() == null ? null : invoice.getDiscount().getID());
                invoice.setDiscount(null);
                if (StringUtil.isNullOrEmpty(discountid)) {
                    discountArr.add(discountid);
                }
                ////Deleting Invoice Detail Journalentry Detail
                String nl = null;
                HashMap<String, Object> dataMap = new HashMap<String, Object>();

                dataMap.put("termid", termid);
                dataMap.put("invoiceid", invoiceid);
                dataMap.put("otherentryid", nl);
                dataMap.put("shipentryid", nl);
                dataMap.put("taxid", nl);
                dataMap.put("taxentryid", nl);
                dataMap.put("customerentryid", nl);
                dataMap.put("accountid", accountid);
                dataMap.put("createdby", createdby);
                dataMap.put("modifiedby", modifiedby);
                dataMap.put("createdon", createdon);
                dataMap.put("updatedon", updatedon);
                dataMap.put("incash", paramJobj.opt("incash"));
                dataMap.put("billshipAddressid", addressid);
                KwlReturnObject uresult = accInvoiceDAOobj.saveInvoice(dataMap);
                invoice = (Invoice) uresult.getEntityList().get(0);
                jeentryNumber = invoice.getJournalEntry().getEntryNumber();

                //Delete old entries and insert new entries again from optimized table in edit case.
                accJournalEntryobj.deleteOnEditAccountJEs_optimized(oldjeid);
                deleteJEDetailsCustomData(oldjeid);

                // Delete Invoice Term Map
                HashMap<String, Object> termReqMap = new HashMap<String, Object>();
                termReqMap.put("invoiceid", invoiceid);
                accInvoiceDAOobj.deleteInvoiceTermMap(termReqMap);
            } //Edit_if
            String taxid = paramJobj.optString("taxid", null);
            String costCenterId = paramJobj.optString(Constants.costcenter, null);
            double taxamount = 0.0;
            double externalCurrencyRate = StringUtil.getDouble(paramJobj.optString("externalcurrencyrate", "1"));
            Discount discount = null;
            double discValue = 0.0;
            double shippingCharges = StringUtil.getDouble(paramJobj.optString("shipping", null));
            double otherCharges = StringUtil.getDouble(paramJobj.optString("othercharges", null));
            boolean inCash = Boolean.parseBoolean(paramJobj.optString("incash"));
            boolean isFromPOS = false;
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);

            KwlReturnObject cmp = accountingHandlerDAOobj.getObject(Company.class.getName(), companyid);
            Company company = (Company) cmp.getEntityList().get(0);

            PayDetail paydetail = null;

            if (!StringUtil.isNullOrEmpty(paramJobj.optString("fromPOS", null))) {
                isFromPOS = true;
                HashMap<String, Object> pymtParams = new HashMap<String, Object>();
                pymtParams.put(Constants.companyKey, companyid);
                pymtParams.put("paymentAccountType", "0");  //cash in hand type
                result = accPaymentDAOobj.getPaymentMethod(pymtParams);
                PaymentMethod payMethod = (PaymentMethod) result.getEntityList().get(0);
                HashMap pdetailhm = new HashMap();
                if (payMethod != null) {
                    pdetailhm.put("paymethodid", payMethod.getID());
                    pdetailhm.put(Constants.companyKey, companyid);
                }
                KwlReturnObject payresult = accPaymentDAOobj.addPayDetail(pdetailhm);
                paydetail = (PayDetail) payresult.getEntityList().get(0);

                Map<String, Object> filterParams = new HashMap<String, Object>();
                filterParams.put(Constants.companyKey, companyid);
                filterParams.put("modulename", inCash ? Constants.autocashsales : Constants.autoinvoice); //    ERP-12109
                filterParams.put("ischecked", true);                       //is for active sequence format
                KwlReturnObject result1 = accCompanyPreferencesObj.getSequenceFormat(filterParams);
                List<SequenceFormat> sequencelist = result1.getEntityList();
                for (SequenceFormat seqFormat : sequencelist) {
                    if (seqFormat.isIsdefaultformat()) {
                        sequenceformat = seqFormat.getID();
                    }
                }
                if ((sequenceformat.equals("NA") || StringUtil.isNullOrEmpty(sequenceformat)) && result1.getEntityList().size() > 0) {
                    SequenceFormat seqFormat = (SequenceFormat) result1.getEntityList().get(0);
                    sequenceformat = seqFormat.getID();
                }
                if (sequenceformat.equals("NA") || StringUtil.isNullOrEmpty(sequenceformat)) {
                    throw new AccountingException("Sequence format is not set for customer Invoice");
                }
            } else if (inCash && paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                HashMap pdetailhm = new HashMap();
                String paymentmethodid = paramJobj.optString("paymentmethodid", null);
                if (!StringUtil.isNullOrEmpty(paymentmethodid)) {
                    pdetailhm.put("paymethodid", paymentmethodid);
                    pdetailhm.put(Constants.companyKey, companyid);
                    KwlReturnObject payresult = accPaymentDAOobj.addPayDetail(pdetailhm);
                    paydetail = (PayDetail) payresult.getEntityList().get(0);
                }
            }
            String contractId = paramJobj.optString("contractId", null);
            recId = entryNumber;
            String customerid = custId;
            invjson = new JSONObject();
            if (isFromPOS) {
                invjson.put("gstIncluded", gstIncluded);
            }
            if (!isFromPOS) {
                taxamount = StringUtil.getDouble(paramJobj.optString("taxamount", null));
            }
            invjson.put("invoiceid", invoiceid);
            invjson.put("accountid", accountid);
            invjson.put(Constants.customerid, customerid);
            if (StringUtil.isNullOrEmpty(invoiceid)) {
                String msg = checkSOUsedFlagJson(paramJobj, 2);
                if (!StringUtil.isNullOrEmpty(msg)) {//Check if SO is already used in DO or not.
                    throw new AccountingException(msg);
                }
            }

            synchronized (this) {
                SequenceFormat prevSeqFormat = null;
                String nextAutoNo = "";
                String nextAutoNoInt = "";
                String datePrefix = "";
                String dateafterPrefix = "";
                String dateSuffix = "";

                if (!StringUtil.isNullOrEmpty(invoiceid)) {//in edit case checks duplicate     
                    result = accInvoiceDAOobj.getDuplicateInvoiceNumberForEdit(entryNumber, companyid, invoiceid);
                    nocount = result.getRecordTotalCount();
                    if (nocount > 0) {
                        if (inCash) {
                            throw ServiceException.FAILURE("Sales receipt number '" + entryNumber + "' already exists.", "erp12{" + entryNumber + "}", false);
                        } else {
                            throw ServiceException.FAILURE("Invoice number '" + entryNumber + "' already exists.", "erp13{" + entryNumber + "}", false);
                        }
                    } else {
                        KwlReturnObject rst = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                        Invoice inv = (Invoice) rst.getEntityList().get(0);
                        prevSeqFormat = inv.getSeqformat();
                        if (!sequenceformat.equals("NA")) {
                            nextAutoNo = entryNumber;
                        }
                    }
                } else { // create new case checks duplicate
                    result = accInvoiceDAOobj.getInvoiceCount(entryNumber, companyid);
                    nocount = result.getRecordTotalCount();
                    if (nocount > 0) {
                        if (inCash) {
                            throw ServiceException.FAILURE("Sales receipt number '" + entryNumber + "' already exists.", "erp12{" + entryNumber + "}", false);
                        } else {
                            throw ServiceException.FAILURE("Invoice number '" + entryNumber + "' already exists.", "erp13{" + entryNumber + "}", false);
                        }
                    }
                }

                if (!sequenceformat.equals("NA") && prevSeqFormat == null) {
                    int from = StaticValues.AUTONUM_INVOICE;
                    if (inCash) {
                        from = StaticValues.AUTONUM_CASHSALE;
                    }
                    boolean seqformat_oldflag = StringUtil.getBoolean(paramJobj.optString("seqformat_oldflag", "false"));
                    if (seqformat_oldflag) {
                        nextAutoNo = accCompanyPreferencesObj.getNextAutoNumber(companyid, from, sequenceformat);
                    } else {
                        Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                        seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, from, sequenceformat, seqformat_oldflag, billdateVal);
                        nextAutoNo = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                        nextAutoNoInt = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                        datePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                        dateafterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                        dateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part

                        invjson.put(Constants.SEQFORMAT, sequenceformat);
                        invjson.put(Constants.SEQNUMBER, nextAutoNoInt);
                        invjson.put(Constants.DATEPREFIX, datePrefix);
                        invjson.put(Constants.DATEAFTERPREFIX, dateafterPrefix);
                        invjson.put(Constants.DATESUFFIX, dateSuffix);
                    }
                    entryNumber = nextAutoNo;
                }
                invjson.put("entrynumber", entryNumber);
                invjson.put("autogenerated", nextAutoNo.equals(entryNumber));
            }

            if (StringUtil.isNullOrEmpty(paramJobj.optString("shipaddress"))) {
                invjson.put("shipaddress", customer.getShippingAddress());
            } else {
                invjson.put("shipaddress", paramJobj.getString("shipaddress"));
            }
            invjson.put("isfavourite", paramJobj.optString("isfavourite", null));
            invjson.put(Constants.isFixedAsset, isFixedAsset);
            invjson.put(Constants.isLeaseFixedAsset, isLeaseFixedAsset);
            invjson.put(Constants.memo, isFromPOS ? paramJobj.optString("POSWarehouse", null) : paramJobj.optString(Constants.memo, null));
            invjson.put("billto", paramJobj.optString("billto", null));
            if (paramJobj.optString(Constants.shipdate, null) != null && !StringUtil.isNullOrEmpty(paramJobj.getString(Constants.shipdate))) {
                try {
                    invjson.put(Constants.shipdate, df.parse(paramJobj.getString(Constants.shipdate)));
                } catch (ParseException ex) {
                    Calendar cal = Calendar.getInstance();
                    long shipDateValue = (long) Long.parseLong(paramJobj.get(Constants.shipdate).toString());
                    cal.setTimeInMillis(shipDateValue);
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    Date calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    Date shipDateVal = calDate;
                    invjson.put(Constants.shipdate, shipDateVal);
                }
            }
            invjson.put("porefno", porefnumber);
            if (paramJobj.optString(Constants.duedate, null) != null) {
                try {
                    invjson.put(Constants.duedate, df.parse(paramJobj.getString(Constants.duedate)));
                } catch (ParseException ex) {
                    Calendar cal = Calendar.getInstance();
                    long dueDateValue = (long) Long.parseLong(paramJobj.get(Constants.duedate).toString());
                    cal.setTimeInMillis(dueDateValue);
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    Date calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    Date dueDateVal = calDate;
                    invjson.put(Constants.duedate, dueDateVal);
                }
            } else {
                Calendar cal = Calendar.getInstance();
                Date calDate = null;
                String CalString = "";
                try {
                    Date billDate = df.parse(paramJobj.optString(Constants.BillDate));
                    cal.setTime(billDate);
                    cal.add(Calendar.DATE, 15);
                    CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    invjson.put(Constants.duedate, calDate);
                } catch (ParseException ex) {
                    boolean isIPhone = paramJobj.optString("isIPhone", null) != null ? Boolean.parseBoolean(paramJobj.get("isIPhone").toString()) : false;
                    if (isIPhone && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.BillDate))) {
                        Date billdate = authHandler.getDateOnlyFormat().parse(paramJobj.get(Constants.BillDate).toString());
                        billdate = new DateTime().plusDays(15).toDate();
                        invjson.put(Constants.duedate, billdate);
                    } else {
                        long billDateValue = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                        cal.setTimeInMillis(billDateValue);
                        cal.add(Calendar.DATE, 15);
                        CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                        invjson.put(Constants.duedate, calDate);
                    }
                }
            }

            invjson.put("template", paramJobj.optString("template", null));
            invjson.put(Constants.companyKey, companyid);
            invjson.put(Constants.currencyKey, currencyid);
            invjson.put("externalCurrencyRate", externalCurrencyRate);
            invjson.put("salesPerson", salesPerson);
            invjson.put(Constants.shipvia, paramJobj.optString(Constants.shipvia, null));
            invjson.put(Constants.fob, paramJobj.optString(Constants.fob, null));
            invjson.put("createdby", createdby);
            invjson.put("modifiedby", modifiedby);
            invjson.put("createdon", createdon);
            invjson.put("updatedon", updatedon);
            if (!StringUtil.isNullOrEmpty(termid)) {
                invjson.put("termid", termid);
            }
            invjson.put("partialinv", (paramJobj.optString("partialinv", null) != null) ? Boolean.parseBoolean(paramJobj.get("partialinv").toString()) : false);
// Create Journal Entry 
            if (StringUtil.isNullOrEmpty(oldjeid)) {
                String nextJEAutoNo = accCompanyPreferencesObj.getNextAutoNumber(companyid, StaticValues.AUTONUM_JOURNALENTRY);
                jeentryNumber = nextJEAutoNo;// + "/" + entryNumber;
                jeautogenflag = true;
            }
            Map<String, Object> jeDataMap = AccountingManager.getGlobalParamsJson(paramJobj);
            jeDataMap.put("entrynumber", jeentryNumber);
            jeDataMap.put("autogenerated", jeautogenflag);
            jeDataMap.put("entrydate", billdateVal);
            if (!StringUtil.isNullOrEmpty(currencyid) && !currencyid.equalsIgnoreCase(paramJobj.optString(Constants.currencyKey, null))) {
                requestParams.put(Constants.globalCurrencyKey, paramJobj.optString(Constants.currencyKey, null));
                externalCurrencyRate = accCurrencyDAOobj.getCurrencyToBaseRate(requestParams, currencyid, billdateVal);
                invjson.put("externalCurrencyRate", externalCurrencyRate);
            }
            jeDataMap.put(Constants.companyKey, companyid);
            jeDataMap.put(Constants.memo, paramJobj.optString(Constants.memo, null));
            invjson.put(Constants.posttext, paramJobj.optString(Constants.posttext, null));
            jeDataMap.put(Constants.currencyKey, currencyid);
            jeDataMap.put("costcenterid", costCenterId);
            HashSet jeDetails = new HashSet();
            KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Create Journal entry without JEdetails
            JournalEntry journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
            jeid = journalEntry.getID();
            invjson.put("journalerentryid", jeid);
            jeDataMap.put("jeid", jeid);

            String invoiceDetails = paramJobj.optString(Constants.detail, "[]");
            List dll = saveInvoiceRows(paramJobj, invoiceDetails, jeid, company, jeDetails, currencyid, externalCurrencyRate);
            double[] totals = (double[]) dll.get(0);
            HashSet<InvoiceDetail> invcdetails = (HashSet<InvoiceDetail>) dll.get(1);
            ArrayList<String> prodList = (ArrayList<String>) dll.get(2);
            double disc = 0;
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("discount", "0"))) {
                disc = StringUtil.getDouble(paramJobj.optString("discount", null));
            }

            if (disc > 0) {
                JSONObject discjson = new JSONObject();
                discjson.put("discount", disc);
                discjson.put("inpercent", Boolean.parseBoolean(paramJobj.optString("perdiscount", null)));
                discjson.put("originalamount", totals[1] - totals[0] + totals[2]);
                discjson.put(Constants.companyKey, companyid);
                KwlReturnObject dscresult = accDiscountobj.addDiscount(discjson);
                discount = (Discount) dscresult.getEntityList().get(0);
                invjson.put("discountid", discount.getID());
                discValue = discount.getDiscountValue();
            }
            discValue += totals[0];

            /*
             * If invoice terms applied then add mapping in against invoice
             */
            double termTotalAmount = 0;
            HashMap<String, Double> termAcc = new HashMap<String, Double>();
            String InvoiceTerms = paramJobj.optString("invoicetermsmap", null);
            if (!StringUtil.isNullOrEmpty(InvoiceTerms)) {
                JSONArray termsArr = new JSONArray(InvoiceTerms);
                for (int cnt = 0; cnt < termsArr.length(); cnt++) {
                    double termamount = termsArr.getJSONObject(cnt).getDouble("termamount");
                    termTotalAmount += termamount;
                    if (termAcc.containsKey(termsArr.getJSONObject(cnt).getString("glaccount"))) {
                        double tempAmount = termAcc.get(termsArr.getJSONObject(cnt).getString("glaccount"));
                        termAcc.put(termsArr.getJSONObject(cnt).getString("glaccount"), termamount + tempAmount);
                    } else {
                        termAcc.put(termsArr.getJSONObject(cnt).getString("glaccount"), termamount);
                    }
                }
            }
//              

            if (inCash) {
                accountid = preferences.getCashAccount().getID();
            }
            double totalInvAmount =0.0d;
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {//we are sending same taxamount from product as well as global level
                totalInvAmount = totals[1] + shippingCharges + otherCharges - discValue + termTotalAmount +taxamount;
            } else {
                totalInvAmount = totals[1] + shippingCharges + otherCharges - discValue + termTotalAmount + taxamount + totals[2];
            }
 
            Date calDate = null;
            Date originalcalDate = null;
            try {
                Calendar cal = Calendar.getInstance();
                long billdateValue = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                cal.setTimeInMillis(billdateValue);
                originalcalDate = cal.getTime();
                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                calDate = df.parse(CalString);
                billdateVal = calDate;
            } catch (Exception pe) {
                billdateVal = originalcalDate;
                boolean isIPhone = paramJobj.optString("isIPhone", null) != null ? Boolean.parseBoolean(paramJobj.get("isIPhone").toString()) : false;
                if (isIPhone && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.BillDate))) {
                    billdateVal = authHandler.getDateOnlyFormat().parse(paramJobj.get(Constants.BillDate).toString());
                } else if (paramJobj.has(Constants.BillDate)) {
                    calDate = df.parse(paramJobj.getString(Constants.BillDate));
                    billdateVal = calDate;
                } else {
                    pe.printStackTrace();
                }
            }
            KwlReturnObject bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, totalInvAmount, currencyid, billdateVal, externalCurrencyRate);
            double totalInvAmountinBase = (Double) bAmt.getEntityList().get(0);

            ArrayList amountApprove = (accountingHandlerDAOobj.getApprovalFlagForAmount(totalInvAmountinBase, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_AMOUNT, companyid));
            boolean amountExceed = (Boolean) amountApprove.get(0);

            ArrayList prodApprove = (accountingHandlerDAOobj.getApprovalFlagForProducts(prodList, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_PRODUCT, companyid));
            boolean prodExists = (Boolean) prodApprove.get(0);
            boolean pendingApprovalFlagForDisc = false;
            int approvalLevelForDisc = 1;

            for (InvoiceDetail ivd:invcdetails) {
                Discount discount1 = ivd.getDiscount();
                String productId = ivd.getInventory().getProduct().getID();
                if (discount1 != null) {
                    double discountVal = discount1.getDiscountValue();
                    try {
                        Calendar cal = Calendar.getInstance();
                        long billdateValue = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                        cal.setTimeInMillis(billdateValue);
                        originalcalDate = cal.getTime();
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = df.parse(CalString);
                        billdateVal = calDate;
                    } catch (Exception pe) {
                        billdateVal = originalcalDate;
                        boolean isIPhone = paramJobj.optString("isIPhone", null) != null ? Boolean.parseBoolean(paramJobj.get("isIPhone").toString()) : false;
                        if (isIPhone && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.BillDate))) {
                            Calendar cal = Calendar.getInstance();
                            billdateVal = authHandler.getDateOnlyFormat().parse(paramJobj.get(Constants.BillDate).toString());
                        } else if (paramJobj.has(Constants.BillDate)) {
                            calDate = df.parse(paramJobj.getString(Constants.BillDate));
                            billdateVal = calDate;
                        } else {
                            pe.printStackTrace();
                        }
                    }
                    KwlReturnObject dAmount = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, discountVal, currencyid, billdateVal, externalCurrencyRate);
                    double discAmountinBase = (Double) dAmount.getEntityList().get(0);
                    ArrayList prodApproveDisc = (accountingHandlerDAOobj.getApprovalFlagForProductsDiscount(discAmountinBase, productId, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_DISCOUNT, companyid, pendingApprovalFlagForDisc, approvalLevelForDisc));
                    pendingApprovalFlagForDisc = (Boolean) prodApproveDisc.get(0);
                    approvalLevelForDisc = (Integer) prodApproveDisc.get(1);
                }

            }

            int pendingApprovalFlag = (istemplate != 2 ? ((amountExceed || prodExists || pendingApprovalFlagForDisc) ? 1 : 0) : 0);//No need of approval if transaction is created as only template
            if (isFixedAsset || isLeaseFixedAsset) {
                pendingApprovalFlag = 0;
            }
            int approvalLevel = ((Integer) (amountApprove.get(1)) > (Integer) (prodApprove.get(1))) ? (Integer) (amountApprove.get(1)) : (Integer) (prodApprove.get(1));
            if (approvalLevelForDisc > approvalLevel) {
                approvalLevel = approvalLevelForDisc;
            }
            JSONObject jedjson = new JSONObject();
            jedjson.put("srno", jeDetails.size() + 1);
            jedjson.put(Constants.companyKey, companyid);
            jedjson.put("amount", totalInvAmount);
            jedjson.put("accountid", accountid);
            jedjson.put("debit", true);
            jedjson.put("jeid", jeid);
            KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
            JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
            jeDetails.add(jed);
            invjson.put("customerentryid", jed.getID());
            invjson.put(Constants.invoiceamountdue, totalInvAmount);
            invjson.put(Constants.invoiceamountdueinbase, totalInvAmountinBase);
            invjson.put(Constants.invoiceamount, totalInvAmount);
            invjson.put(Constants.invoiceamountinbase, totalInvAmountinBase);
            if (discValue > 0) {
                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", discValue);
                jedjson.put("accountid", preferences.getDiscountGiven().getID());
                jedjson.put("debit", true);
                jedjson.put("jeid", jeid);
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);
            }
            if (shippingCharges > 0) {
                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", shippingCharges);
                jedjson.put("accountid", preferences.getShippingCharges().getID());
                jedjson.put("debit", false);
                jedjson.put("jeid", jeid);
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);
                invjson.put("shipentryid", jed.getID());

            }
            if (termAcc.size() > 0) {
                for (Map.Entry<String, Double> entry : termAcc.entrySet()) {
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", entry.getValue() > 0 ? entry.getValue() : (entry.getValue() * (-1)));
                    jedjson.put("accountid", entry.getKey());
                    jedjson.put("debit", entry.getValue() > 0 ? false : true);
                    jedjson.put("jeid", jeid);
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                }
            }

            if (!StringUtil.isNullOrEmpty(taxid)) {
                KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), taxid); // (Tax)session.get(Tax.class, taxid);
                Tax tax = (Tax) txresult.getEntityList().get(0);
                if (tax == null) {
                    throw new AccountingException(messageSource.getMessage("acc.so.taxcode", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
                if (!isFromPOS) {
                    invjson.put("taxid", taxid);
                }
                if (taxamount > 0) {
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", taxamount);
                    jedjson.put("accountid", tax.getAccount().getID());
                    jedjson.put("debit", false);
                    jedjson.put("jeid", jeid);
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    invjson.put("taxentryid", jed.getID());
                }
            }

            jeDataMap.put("jedetails", jeDetails);
            jeDataMap.put("pendingapproval", pendingApprovalFlag);
            jeDataMap.put("istemplate", istemplate);
            jeDataMap.put("externalCurrencyRate", externalCurrencyRate);
            jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Add Journal entry details
            journalEntry = (JournalEntry) jeresult.getEntityList().get(0);

            if (!StringUtil.isNullOrEmpty(customfield)) {
                JSONArray jcustomarray = new JSONArray(customfield);
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                customrequestParams.put("customarray", jcustomarray);
                customrequestParams.put("modulename", Constants.Acc_JE_modulename);
                customrequestParams.put("moduleprimarykey", Constants.Acc_JEid);
                customrequestParams.put("modulerecid", journalEntry.getID());
                customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("customdataclasspath", Constants.Acc_BillInv_custom_data_classpath);
                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                    jeDataMap.put("accjecustomdataref", journalEntry.getID());
                    jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);
                }
            }

            try {
                Calendar cal = Calendar.getInstance();
                long billdateValue = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                cal.setTimeInMillis(billdateValue);
                originalcalDate = cal.getTime();
                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                calDate = df.parse(CalString);
                billdateVal = calDate;

            } catch (Exception pe) {
                billdateVal = originalcalDate;
                boolean isIPhone = paramJobj.optString("isIPhone", null) != null ? Boolean.parseBoolean(paramJobj.get("isIPhone").toString()) : false;
                if (isIPhone && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.BillDate))) {
                    billdateVal = authHandler.getDateOnlyFormat().parse(paramJobj.get(Constants.BillDate).toString());
                } else if (paramJobj.has(Constants.BillDate)) {
                    calDate = df.parse(paramJobj.getString(Constants.BillDate));
                    billdateVal = calDate;
                } else {
                    pe.printStackTrace();
                }
            }
            KwlReturnObject ERresult = accCurrencyDAOobj.getExcDetailID(requestParams, currencyid, billdateVal, null);
            ExchangeRateDetails erd = (ExchangeRateDetails) ERresult.getEntityList().get(0);
            String erdid = (erd == null) ? null : erd.getID();
            invjson.put("erdid", erdid);

            invjson.put("pendingapproval", pendingApprovalFlag);
            invjson.put("istemplate", istemplate);
            invjson.put("approvallevel", approvalLevel);
            invjson.put("incash", isFromPOS ? "true" : paramJobj.optString("incash", null));
            if ((isFromPOS||paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) && paydetail != null) {
                invjson.put("paydetailsid", paydetail.getID());
            }
            invjson.put("isFromPOS", isFromPOS);

            if (StringUtil.isNullOrEmpty(invoiceid)) {// Used to save billing and shipping addresses 
                boolean isDefaultAddress = paramJobj.optString("defaultAdress", null) != null ? Boolean.parseBoolean(paramJobj.get("defaultAdress").toString()) : false;
                Map<String, Object> addressParams = new HashMap<String, Object>();
                if (isDefaultAddress) {
                    addressParams = AccountingAddressManager.getDefaultCustomerAddressParams(customer.getID(), companyid, accountingHandlerDAOobj);// addressParams = getCustomerDefaultAddressParams(customer,companyid);
                } else {
                    addressParams = AccountingAddressManager.getAddressParamsJson(paramJobj, false);
                }
                KwlReturnObject addressresult = accountingHandlerDAOobj.saveAddressDetail(addressParams, companyid);
                BillingShippingAddresses bsa = (BillingShippingAddresses) addressresult.getEntityList().get(0);
                invjson.put("billshipAddressid", bsa.getID());
            }
            invjson.put(Constants.Checklocktransactiondate, df.parse(paramJobj.getString(Constants.BillDate)));
            //put Cash Received value in invoice json object
            invjson.put(Constants.CASH_RECEIVED, paramJobj.optDouble(Constants.CASH_RECEIVED, 0.0));
            result = accInvoiceDAOobj.addInvoice(invjson, new HashSet());
            invoice = (Invoice) result.getEntityList().get(0);//Create Invoice without invoice-details.
            for (InvoiceDetail ivd :invcdetails) {
                if ((pendingApprovalFlag == 1 || istemplate == 2) && ivd.getInventory().isInvrecord()) {
                    Inventory invtry = ivd.getInventory();
                    invtry.setActquantity(invtry.getQuantity());
                    invtry.setQuantity(0);
                }
                ivd.setInvoice(invoice);
            }
            invjson.put("invoiceid", invoice.getID());
            result = accInvoiceDAOobj.updateInvoice(invjson, invcdetails);
            if (isFromPOS) {
                JSONObject jeJobj = new JSONObject();
                HashSet<JournalEntryDetail> details = new HashSet<JournalEntryDetail>();
                jeJobj.put("jeid", journalEntry.getID());
                jeJobj.put(JournalEntryConstants.COMPANYID, journalEntry.getCompany().getCompanyID());
                jeJobj.put("transactionId", invoice.getID());
                jeJobj.put("transactionModuleid", Constants.Acc_Cash_Sales_ModuleId);
                accJournalEntryobj.updateJournalEntry(jeJobj, details);
            }
            invoice = (Invoice) result.getEntityList().get(0);//Add invoice details 
            // save contract mapping with invoice
            String linkMode = paramJobj.optString("fromLinkCombo", null);
            if (!StringUtil.isNullOrEmpty(linkMode)) {
                if (linkMode.equalsIgnoreCase(Constants.Delivery_Order) && isLeaseFixedAsset) {// save contract detail mapping in case of lease fixed asset.
                    Set<InvoiceContractMapping> contractMappings = getInvoiceContractMappings(paramJobj, invoice);
                    HashMap<String, Object> doDataMap = new HashMap<String, Object>();
                    if (!contractMappings.isEmpty()) {
                        doDataMap.put(Constants.Acc_id, invoice.getID());
                        doDataMap.put("contractMappings", contractMappings);
                        accInvoiceDAOobj.updateInvoiceUsingSet(doDataMap);
                    }
                }
            } else if (!StringUtil.isNullOrEmpty(contractId)) {
                Set<InvoiceContractMapping> contractMappings = getInvoiceContractMappingsWithoutDO(invoice, contractId);
                HashMap<String, Object> doDataMap = new HashMap<String, Object>();
                if (!contractMappings.isEmpty()) {
                    doDataMap.put(Constants.Acc_id, invoice.getID());
                    doDataMap.put("contractMappings", contractMappings);
                    accInvoiceDAOobj.updateInvoiceUsingSet(doDataMap);
                }
            }

            if (paramJobj.optString("linkNumber", null) != null) {
                String[] linkNumbers = paramJobj.getString("linkNumber").split(","); // array of linknumbers for multiple sales order
                if (!StringUtil.isNullOrEmpty(linkMode) && linkNumbers.length > 0) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                        for (int i = 0; i < linkNumbers.length; i++) {
                            if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkNumbers[i]);
                                SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                                HashMap hMap = new HashMap();
                                hMap.put("salesOrder", salesOrder);
                                hMap.put("value", "1");
                                accInvoiceDAOobj.updateSOLinkflag(hMap);
                            }
                        }
                    }
                }
            }

            //Insert new entries again in optimized table.
            accJournalEntryobj.saveAccountJEs_optimized(jeid);
            id = invoice.getID();

            String personalid = invoice.getCustomer().getAccount().getID();
            String accname = invoice.getCustomer().getAccount().getName();
            String invoiceno = invoice.getInvoiceNumber();
            String address = invoice.getCustomer().getBillingAddress();
            ll.add(new String[]{id, oldjeid});
            ll.add(discountArr);
            ll.add((pendingApprovalFlag == 1) ? "Pending Approval" : "Approved");
            ll.add(personalid);
            ll.add(accname);
            ll.add(invoiceno);
            ll.add(address);
            ll.add(totalInvAmount);
            ll.add(journalEntry.getEntryNumber());
            ll.add(journalEntry.getID());
            ll.add(invoice.getID());
            if (pendingApprovalFlag == 1 && preferences.isSendapprovalmail()) { //this for send approval email                
                String[] emails = {};
                String invoiceNumber = invoice.getInvoiceNumber();
                String userName = paramJobj.optString(Constants.userfullname, null);
                String moduleName = "Customer Invoice";
                emails = accountingHandlerDAOobj.getApprovalUserListJson(paramJobj, moduleName, 1);
                if (!StringUtil.isNullOrEmpty(preferences.getApprovalEmails())) {
                    String[] compPrefMailIds = preferences.getApprovalEmails().split(",");
                    emails = AccountingManager.getMergedMailIds(emails, compPrefMailIds);
                }
                String fromEmailId = (!company.isEmailFromCompanyCreator()) ? Constants.ADMIN_EMAILID : authHandlerDAOObj.getSysEmailIdByCompanyID(company.getCompanyID());
                /**
                 * parameters required for sending mail
                 */
                Map<String, Object> mailParameters = new HashMap();
                mailParameters.put(Constants.companyid, companyid);
                mailParameters.put(Constants.prNumber, invoiceNumber);
                mailParameters.put(Constants.modulename, moduleName);
                mailParameters.put(Constants.fromName, userName);
                mailParameters.put(Constants.fromEmailID, fromEmailId);
                mailParameters.put(Constants.PAGE_URL, paramJobj.optString(Constants.PAGE_URL));
                mailParameters.put(Constants.emails, emails); 
                accountingHandlerDAOobj.sendApprovalEmails(mailParameters);
            }

            //Save record as template
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("templatename")) && (istemplate == 1 || istemplate == 2)) {
                HashMap<String, Object> hashMap = new HashMap<String, Object>();
                String moduletemplateid = paramJobj.getString("moduletemplateid");
                hashMap.put("templatename", paramJobj.getString("templatename"));
                if (!StringUtil.isNullOrEmpty(moduletemplateid)) {
                    hashMap.put("moduletemplateid", paramJobj.getString("moduletemplateid"));
                }
                if (inCash) {
                    hashMap.put(Constants.moduleid, Constants.Acc_Cash_Sales_ModuleId);
                } else {
                    hashMap.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                }
                hashMap.put("modulerecordid", invoice.getID());
                hashMap.put(Constants.companyKey, companyid);
                if(!StringUtil.isNullOrEmpty(paramJobj.optString("companyunitid",null))){
                    hashMap.put("companyunitid", paramJobj.getString("companyunitid")); // Added Unit ID if it is present in request
                }
                /**
                 * checks the template name is already exist in create and edit template case
                 */
                KwlReturnObject templateResult = accountingHandlerDAOobj.getModuleTemplateForTemplatename(hashMap);
                nocount = templateResult.getRecordTotalCount();
                if (nocount > 0) {
                    throw new AccountingException(messageSource.getMessage("acc.tmp.templateNameAlreadyExists", null,Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
                accountingHandlerDAOobj.saveModuleTemplate(hashMap);
            }

            if (preferences.isInventoryAccountingIntegration() && (!preferences.isWithInvUpdate() || inCash)) {

                String action = "17";
                boolean isDirectUpdateInvFlag = false;
                if (preferences.isUpdateInvLevel()) {
                    isDirectUpdateInvFlag = true;
                    action = "19";//Direct Inventory Update action
                }

                JSONArray productArray = new JSONArray();
                if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.detail, null))) {
                    JSONArray jArr = new JSONArray(paramJobj.getString(Constants.detail));
                    for (int i = 0; i < jArr.length(); i++) {
                        JSONObject jobj = jArr.getJSONObject(i);
                        KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                        Product product = (Product) proresult.getEntityList().get(0);

                        JSONObject productObject = new JSONObject();
                        if (!StringUtil.isNullOrEmpty(invoiceid)) {
                            if (jobj.optDouble("changedQuantity", 0) != 0) {
                                productObject.put("itemUomId", jobj.getString("uomid"));
                                productObject.put("itemBaseUomRate", jobj.getDouble("baseuomrate"));
                                productObject.put("itemQuantity", jobj.getDouble("changedQuantity"));
                                productObject.put("quantity", jobj.getDouble("changedQuantity"));
                                productObject.put("itemCode", product.getProductid());
                                if (isDirectUpdateInvFlag) {
                                    productObject.put("storeid", jobj.optString("invstore"));
                                    productObject.put("locationid", jobj.optString("invlocation"));
                                    productObject.put("rate", jobj.optDouble("rate", 0));
                                }
                                productArray.put(productObject);
                            }
                        } else {
                            productObject.put("itemUomId", jobj.getString("uomid"));
                            productObject.put("itemBaseUomRate", jobj.getDouble("baseuomrate"));
                            productObject.put("itemQuantity", jobj.getDouble("baseuomquantity") * (-1));
                            productObject.put("quantity", jobj.getDouble("quantity") * (-1));
                            productObject.put("itemCode", product.getProductid());
                            if (isDirectUpdateInvFlag) {
                                productObject.put("storeid", jobj.optString("invstore"));
                                productObject.put("locationid", jobj.optString("invlocation"));
                                productObject.put("rate", jobj.optDouble("rate", 0));
                            }
                            productArray.put(productObject);
                        }
                    }

                    if (!StringUtil.isNullOrEmpty(invoiceid)) {
                        if (!StringUtil.isNullOrEmpty(paramJobj.optString("deletedData"))) {
                            JSONArray deleteArr = new JSONArray(paramJobj.getString("deletedData"));
                            for (int i = 0; i < deleteArr.length(); i++) {
                                JSONObject jobj = deleteArr.getJSONObject(i);

                                KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                                Product product = (Product) proresult.getEntityList().get(0);

                                JSONObject productObject = new JSONObject();
                                productObject.put("itemUomId", jobj.getString("productuomid"));
                                productObject.put("itemBaseUomRate", jobj.getDouble("productbaseuomrate"));
                                productObject.put("itemQuantity", jobj.getDouble("productbaseuomquantity"));
                                productObject.put("quantity", jobj.getDouble("productquantity"));
                                productObject.put("itemCode", product.getProductid());
                                if (isDirectUpdateInvFlag) {
                                    productObject.put("storeid", jobj.optString("productinvstore"));
                                    productObject.put("locationid", jobj.optString("productinvlocation"));
                                    productObject.put("rate", jobj.optDouble("productrate", 0));
                                }
                                productArray.put(productObject);
                            }
                        }
                    }

                    if (productArray.length() > 0) {
                        Date dateobj = null;
                        String sendDateFormat = Constants.yyyyMMdd;
                        DateFormat dateformat = new SimpleDateFormat(sendDateFormat);
                        try {
                            dateobj = df.parse(paramJobj.get(Constants.BillDate).toString());
                        } catch (ParseException pe) {
                            Calendar cal = Calendar.getInstance();
                            long dateval = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                            cal.setTimeInMillis(dateval);
                            try {
                                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                                calDate = authHandler.getDateOnlyFormat().parse(CalString);
                            } catch (ParseException ex) {
                                calDate = cal.getTime();
                            }

                            dateobj = calDate;
                        }
                        String stringDate = dateformat.format(dateobj);
                        JSONObject jSONObject = new JSONObject();
                        jSONObject.put("deliveryDate", stringDate);
                        jSONObject.put("dateFormat", sendDateFormat);
                        jSONObject.put("details", productArray);
                        jSONObject.put("orderNumber", entryNumber);
                        jSONObject.put("selling", true);

                        String url = storageHandlerImpl.GetinventoryURL();
                        CommonFnController cfc = new CommonFnController();
                        cfc.updateInventoryLevelJson(paramJobj, jSONObject, url, action);
                    }
                }
            }
            Map<String, Object> auditTrailMap = new HashMap<String, Object>();
            auditTrailMap.put(Constants.useridKey, paramJobj.has(Constants.lid) && paramJobj.get(Constants.lid) != null ? paramJobj.getString(Constants.lid) : paramJobj.getString(Constants.useridKey));
            if (invoiceid != null) {
                auditTrailObj.insertAuditLog(AuditAction.INVOICE_CREATED, "User " + paramJobj.optString(Constants.userfullname, null) + " has added a new customer Invoice " + recId, auditTrailMap, tranID);

            } else if (entryNumber != null) {
                auditTrailObj.insertAuditLog(AuditAction.CASH_SALES_CREATED, "User " + paramJobj.optString(Constants.userfullname, null) + " has added a new cash sales " + recId, auditTrailMap, tranID);
            }
        } catch (JSONException ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new AccountingException(ex.getMessage());
        }

        return ll;
    }

    @Override
    public JSONObject saveCustomerInvoiceJson(JSONObject paramJobj) throws ServiceException, JSONException {
        JSONObject jobj = new JSONObject();
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("IC_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        TransactionStatus status = txnManager.getTransaction(def);
        try {
            boolean issuccess = false;

            String msg = "";
            String invoiceNumBer = "";
            String JENumBer = "";
            int approvedLevel = 0;
            Date generatedDate = null;

            List li = saveInvoiceJson(paramJobj);

            if (li.get(5) != null) {
                invoiceNumBer = li.get(5).toString();
            }
            if (li.get(8) != null) {
                JENumBer = li.get(8).toString();
            }

            boolean pendingApprovalFlag = false;
            boolean isAutoCreateDO = false;
            isAutoCreateDO = Boolean.parseBoolean(paramJobj.optString("isAutoCreateDO", "false"));

            String[] id = (String[]) li.get(0);
            String autoCreateDOMsg = "";
            if (isAutoCreateDO) {
                DeliveryOrder deliveryOrder = saveDeliveryOrderJson(paramJobj, id[0]); //To Auto create DO
                approvedLevel = deliveryOrder.getApprovestatuslevel();
                autoCreateDOMsg = messageSource.getMessage("acc.field.Invoice/CashSalewithDeliveryOrder", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + "<b> (" + deliveryOrder.getDeliveryOrderNumber() + ")</b>" + messageSource.getMessage("acc.field.hasbeensavedsuccessfully", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + "<br/>" + messageSource.getMessage("acc.field.DocumentNo", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + invoiceNumBer + ",</b> " + messageSource.getMessage("acc.field.JENo", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + JENumBer + "</b>";
            }
            String companyid = paramJobj.getString(Constants.companyKey);
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isGeneratedRecurringInvoice",null))) {
                int isGeneratedRecurringInvoice = Integer.parseInt(paramJobj.optString("isGeneratedRecurringInvoice", "0"));
                HashMap<String, Object> requestParams = new HashMap<String, Object>();
                DateFormat df = (DateFormat) authHandler.getDateOnlyFormat();
                try {
                    generatedDate = (Date) df.parse(paramJobj.get("generatedDate").toString());
                } catch (ParseException pe) {
                    Calendar cal = Calendar.getInstance();
                    long generatedDateVal = (long) Long.parseLong(paramJobj.get("generatedDate").toString());
                    cal.setTimeInMillis(generatedDateVal);
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());

                    try {
                        Date calDate = authHandler.getDateOnlyFormat().parse(CalString);
                        generatedDate = calDate;
                    } catch (ParseException ex) {
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
                requestParams.put("invoice", paramJobj.optString("Oldinvoiceid", null));
                requestParams.put("excludeOrGenerate", isGeneratedRecurringInvoice);
                requestParams.put("generatedDate", generatedDate);
                requestParams.put(Constants.companyKey, companyid);
                KwlReturnObject Excludeinv = accInvoiceDAOobj.saveExcludedRecords(requestParams);
            }
            /*
             * If invoice terms applied then add mapping in against invoice
             */
            String InvoiceTerms = paramJobj.optString("invoicetermsmap", null);
            if (StringUtil.isAsciiString(InvoiceTerms)) {
                mapInvoiceTerms(InvoiceTerms, id[0], paramJobj.getString(Constants.lid));
            }
            Boolean cash = Boolean.parseBoolean(paramJobj.optString("incash", "false"));
            ArrayList discountArr = (ArrayList) li.get(1);
            jobj.put("invoiceid", id[0]);

            String pendingstatus = (String) li.get(2);
            if (StringUtil.equal("Pending Approval", pendingstatus)) {
                if (approvedLevel != 11 && isAutoCreateDO) {
                    pendingstatus = messageSource.getMessage("acc.field.butBothPendingForApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))); // " but both pending for Approval."
                } else {
                    pendingstatus = messageSource.getMessage("acc.field.butCustomerInvoicePendingForApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))); // " but Customer Invoice pending for Approval.";
                }
                pendingApprovalFlag = true;
            } else {
                if (approvedLevel != 11 && isAutoCreateDO) {
                    pendingstatus = messageSource.getMessage("acc.field.butDeliveryOrderPendingForApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))); // " but Delivery Order pending for Approval.";
                } else {
                    pendingstatus = ".";
                }
            }
            jobj.put("accountid", li.get(3));
            jobj.put("accountName", li.get(4));
            jobj.put("invoiceNo", li.get(5));
            jobj.put("address", li.get(6));
            jobj.put("amount", li.get(7));
            jobj.put("jeid", li.get(9));
            jobj.put("jeno", li.get(8));
            jobj.put("invoiceid", li.get(10));
            int istemplate = 0;
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("istemplate",null))) {
                istemplate = Integer.parseInt(paramJobj.getString("istemplate"));
            }
            if (istemplate == 1) {
                msg = (cash ? messageSource.getMessage("acc.field.SalesReceiptandTemplatehasbeensavedsuccessfully", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.field.CustomerInvoiceandTemplatehasbeensavedsuccessfully", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)))) + (pendingApprovalFlag ? (messageSource.getMessage("acc.field.but", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + (cash ? messageSource.getMessage("acc.field.SalesReceipt", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.field.CustomerInvoice", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)))) + messageSource.getMessage("acc.field.ispendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)))) : ".");
            } else if (istemplate == 2) {
                msg = (cash ? messageSource.getMessage("acc.templateinv.2", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.templateinv.1", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
            } else {
                msg = (cash ? messageSource.getMessage("acc.inv.2", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.inv.1", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)))) + pendingstatus + "<br/>" + messageSource.getMessage("acc.field.DocumentNo", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + invoiceNumBer + ",</b> " + messageSource.getMessage("acc.field.JENo", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + JENumBer + "</b>";
            }
//            msg += pendingstatus;

            if (isAutoCreateDO) {
                msg = autoCreateDOMsg + pendingstatus;
            }
            issuccess = true;
            jobj.put("pendingApproval", pendingApprovalFlag);
            jobj.put(Constants.RES_msg, msg);
            jobj.put(Constants.RES_success, issuccess);
            txnManager.commit(status);
            status = txnManager.getTransaction(def);
            deleteJEArray(id[1], companyid);
            txnManager.commit(status);
            status = txnManager.getTransaction(def);
            deleteEditedInvoiceDiscount(discountArr, companyid);
            txnManager.commit(status);
        } catch (AccountingException e) {
            txnManager.rollback(status);
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, e);
            throw ServiceException.FAILURE(e.getMessage(), e);
        } catch (UnsupportedEncodingException ex) {
            txnManager.rollback(status);
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        } catch (SessionExpiredException e) {
            txnManager.rollback(status);
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, e);
            throw ServiceException.FAILURE(e.getMessage(), e);
        } catch (ServiceException ex) {
            txnManager.rollback(status);
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ex;
        } catch (JSONException e) {
            txnManager.rollback(status);
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, e);
            throw new JSONException(e);
        }
        return jobj;
    }

    private List saveInvoiceRows(JSONObject paramJobj, String invoiceDetails, String jeid, Company company, HashSet jeDetails, String currencyid, Double externalCurrencyRate) throws ServiceException, SessionExpiredException, AccountingException, UnsupportedEncodingException, ParseException {
        HashSet rows = new HashSet();
        ArrayList<String> prodList = new ArrayList<String>();
        double totaldiscount = 0, totalamount = 0, taxamount = 0;
        List ll = new ArrayList();
        try {
            DateFormat df = authHandler.getDateOnlyFormat();
            HashMap<String, Object> GlobalParams = AccountingManager.getGlobalParamsJson(paramJobj);
            String companyid = company.getCompanyID();
            boolean inCash = Boolean.parseBoolean(paramJobj.get("incash").toString());
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            KwlReturnObject cap1 = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extarPreferences = (ExtraCompanyPreferences) cap1.getEntityList().get(0);

            boolean partialInv = (paramJobj.optString("partialinv", null) != null) ? Boolean.parseBoolean(paramJobj.get("partialinv").toString()) : false;

            JSONArray jArr = new JSONArray(invoiceDetails);
            for (int i = 0; i < jArr.length(); i++) {

                JSONObject jobj = jArr.getJSONObject(i);
                InvoiceDetail row = new InvoiceDetail();
                JournalEntryDetail jed;
                row.setSrno(i + 1);
                row.setWasRowTaxFieldEditable(true);// this field has been added after making row tax field editable its value will be set always true from its implementation. i.e from 28-jan-2014.REASON -  when Row Tax Amount field was not editable then tax calculation was taking place according to tax percent, as selected From Tax combo in JS Side.
                if (!StringUtil.isNullOrEmpty(jobj.optString("desc",null))) {
                   // try {
                        row.setDescription(StringUtil.DecodeText(jobj.optString("desc")));
                    /*} catch (UnsupportedEncodingException ex) {
                        row.setDescription(jobj.getString("desc"));
                    }*/
                }

                if (preferences.isInventoryAccountingIntegration() && (!preferences.isWithInvUpdate() || inCash) && preferences.isUpdateInvLevel()) {
                    if (!StringUtil.isNullOrEmpty(jobj.optString("invstore"))) {
                        row.setInvstoreid(jobj.optString("invstore"));
                    } else {
                        row.setInvstoreid("");
                    }

                    if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                        row.setInvlocid(jobj.optString("invlocation"));
                    } else {
                        row.setInvlocid("");
                    }
                }

                if (extarPreferences.isIsPOSIntegration() && inCash) {
                    if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                        row.setInvlocid(jobj.optString("invlocation"));
                    } else {
                        row.setInvlocid("");
                    }
                }
                String linkMode = paramJobj.optString("fromLinkCombo", null);
                boolean updateInventoryFlag = (preferences.isWithInvUpdate()) ? false : true;

                double partamount = (jobj.has("partamount") && (!StringUtil.isNullOrEmpty(jobj.get("partamount").toString()))) ? jobj.getDouble("partamount") : 0.0;
                row.setPartamount(partamount);

                if (!StringUtil.isNullOrEmpty(linkMode)) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : ((jobj.getString("savedrowid")) != null ? jobj.getString("savedrowid") : ""));
                        SalesOrderDetail rd = (SalesOrderDetail) rdresult.getEntityList().get(0);
                        row.setSalesorderdetail(rd);

                        if (updateInventoryFlag && partialInv) {
                            double sodAmount = rd.getQuantity() * 100;

                            double invDetailAmount = getInvoiceDetailAMount(rd);
                            invDetailAmount += jobj.getDouble("quantity") * partamount;
                            if (sodAmount > invDetailAmount) {
                                updateInventoryFlag = false;
                            }
                        }
                    } else if (linkMode.equalsIgnoreCase(Constants.Delivery_Order)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        DeliveryOrderDetail deliveryOrderDetail = (DeliveryOrderDetail) rdresult.getEntityList().get(0);
                        row.setDeliveryOrderDetail(deliveryOrderDetail);
                    } else if (linkMode.equalsIgnoreCase(Constants.CUSTOMER_QUOTATION)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(QuotationDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        QuotationDetail quotationDetail = (QuotationDetail) rdresult.getEntityList().get(0);
                        row.setQuotationDetail(quotationDetail);
                    }
                }
                row.setCompany(company);
                row.setRate(jobj.getDouble("rate"));
                String productid = "";
                if (StringUtil.isNullOrEmpty(jobj.optString(Constants.productid,null))) {
                    String productcode = jobj.getString("productcode");
                    productid = accInvoiceDAOobj.getproductId(companyid, productcode);
                } else {
                    productid = jobj.getString(Constants.productid);
                }
                KwlReturnObject prdresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
                Product product = (Product) prdresult.getEntityList().get(0);

                prodList.add(productid);

                JSONObject inventoryjson = new JSONObject();
                inventoryjson.put(Constants.productid, productid);
                double quantity = 1;
                if (jobj.has("quantity")) {
                    quantity = jobj.getDouble("quantity");
                }
                inventoryjson.put("quantity", quantity);
                
                if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                  if (jobj.has("uomname")) {
                        inventoryjson.put("uomid", jobj.getString("uomname"));
                    }
                }else{
                    if (jobj.has("uomid")) {
                        inventoryjson.put("uomid", jobj.getString("uomid"));
                    }
                }
                
                if (jobj.has("baseuomquantity") && jobj.get("baseuomquantity") != null) {
                    inventoryjson.put("baseuomquantity", updateInventoryFlag ? jobj.getDouble("baseuomquantity") : 0);
                    inventoryjson.put("actquantity", updateInventoryFlag ? 0 : jobj.getDouble("baseuomquantity"));
                    inventoryjson.put("baseuomrate", jobj.has("baseuomrate") ? jobj.getDouble("baseuomrate") : 0.0);
                } else {
                    inventoryjson.put("baseuomquantity", updateInventoryFlag ? quantity : 0);
                    inventoryjson.put("actquantity", updateInventoryFlag ? 0 : quantity);
                    inventoryjson.put("baseuomrate", jobj.has("baseuomrate") ? jobj.getDouble("baseuomrate") : 0.0);
                }
                inventoryjson.put("invrecord", updateInventoryFlag ? true : false);

                if (jobj.has("desc")) {
                    inventoryjson.put("description", jobj.getString("desc"));
                }
                inventoryjson.put("carryin", false);
                inventoryjson.put("defective", false);
                inventoryjson.put("newinventory", false);
                inventoryjson.put(Constants.companyKey, companyid);
                Date calDate = null;
                try {
                    inventoryjson.put("updatedate", authHandler.getDateOnlyFormat().parse(paramJobj.get(Constants.BillDate).toString()));
                } catch (ParseException e) {
                    Calendar cal = Calendar.getInstance();
                    long dateValue = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                    cal.setTimeInMillis(dateValue);
                    try {
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    } catch (ParseException ex) {
                        calDate = cal.getTime();
                    }

                    Date date = calDate;
                    inventoryjson.put("updatedate", date);
                }

                KwlReturnObject invresult = accProductObj.addInventory(inventoryjson);
                Inventory inventory = (Inventory) invresult.getEntityList().get(0);

                row.setInventory(inventory);

                double rowAmount = authHandler.round(row.getRate() * quantity, companyid);
                double rowdiscount = 0;
                boolean isFromPOS = !StringUtil.isNullOrEmpty(paramJobj.optString("fromPOS",null));
                Date entryDate = new Date();
                Tax taxObject = null;
                double taxPercentage = 0.0;
                double rowAmountWithoutTax = 0.0;
                rowAmountWithoutTax = rowAmount;
                if (isFromPOS) {
                    entryDate = df.parse(paramJobj.get(Constants.BillDate).toString());
                    String taxCodeToBeApplied = "GST(SR)@7.00%";
                    taxCodeToBeApplied = StringUtil.isNullOrEmpty(paramJobj.optString("taxCodeToBeApplied",null)) ? taxCodeToBeApplied : paramJobj.getString("taxCodeToBeApplied");
                    HashMap<String, Object> taxParams = new HashMap<>();
                    taxParams.put("transactiondate", entryDate);
                    taxParams.put("taxcode", taxCodeToBeApplied);
                    taxParams.put(Constants.companyKey, companyid);
                    KwlReturnObject taxResult = accTaxObj.getTax(taxParams);
                    Object[] taxRow = (Object[]) taxResult.getEntityList().get(0);
                    taxObject = (Tax) taxRow[0];
                    taxPercentage = (double) taxRow[1];

                    if (taxObject != null) {
                        jobj.put("prtaxid", taxObject.getID());
                        jobj.put("taxpercent", taxPercentage);
                        rowAmountWithoutTax = (rowAmount * 100) / (100 + taxPercentage);
                        rowAmountWithoutTax = authHandler.round(rowAmountWithoutTax, companyid);
                        jobj.put("taxamount", rowAmount - rowAmountWithoutTax);
                        jobj.put("rateIncludingGst", rowAmount);
                        row.setRate(rowAmountWithoutTax);
                    }

                }
                if (partamount != 0.0) {
                    rowAmount = rowAmount * (partamount / 100);
                }
                totalamount += rowAmountWithoutTax;
                Discount discount = null;
                double disc = 0;
                int rowdisc = 0;

                if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                    if (jobj.has("discount")) {
                        disc = Double.parseDouble(jobj.getString("discount"));
                    }
                    if (jobj.has("discountType")) {
                        rowdisc = Integer.parseInt(jobj.getString("discountType"));
                    }
                } else {
                    if (jobj.has("prdiscount")) {
                        disc = jobj.getDouble("prdiscount");
                    }
                    if (jobj.has("discountispercent")) {
                        rowdisc = jobj.getInt("discountispercent");
                    }
                }

                if (jobj.has("rateIncludingGst")) {
                    row.setRateincludegst(jobj.optDouble("rateIncludingGst", 0));
                }
                /*
                * Below code is used to post JE for each discount and mapped or applied to product
                * if user applies discount manually then the JE will posted against the account which is mapped in discount given goes to in company preferences
                */
                double discountAmt = 0.0;
                if (disc != 0.0) {
                    JSONArray discountJArr = new JSONArray();
                    String discountjsonStr = "";
                    double quantityForDiscount = jobj.optDouble("quantity", 0);
                    double rate = jobj.optDouble("rate", 0);
                    JSONObject discountmasterObj = null;
                    if (jobj.has("discountjson")) {
                        discountjsonStr = jobj.getString("discountjson");
                    }
                    if (!StringUtil.isNullOrEmpty(discountjsonStr)) {
                        discountjsonStr = StringUtil.DecodeText(discountjsonStr);
                        discountmasterObj = new JSONObject(discountjsonStr);
                    }
                    if (discountmasterObj != null && discountmasterObj.has("data")) {
                        discountJArr = discountmasterObj.getJSONArray("data");
                    }
                    JSONObject jedjson = new JSONObject();
                    KwlReturnObject jedresult = null;
                    if (discountJArr.length() > 0) {
                        for (int j = 0; j < discountJArr.length(); j++) {
                            JSONObject discountMasterJObj = discountJArr.getJSONObject(j);
                            discountAmt = discountMasterJObj.optInt("discounttype") == 1 ? ((rate * quantityForDiscount) * (discountMasterJObj.optDouble("discountvalue") / 100)) : discountMasterJObj.optDouble("discountvalue");
                            discountAmt = authHandler.round(discountAmt, companyid);
                            jedjson.put("srno", jeDetails.size() + 1);
                            jedjson.put(Constants.companyKey, companyid);
                            jedjson.put("amount", discountAmt);
                            jedjson.put("accountid", discountMasterJObj.optString("discountaccount"));
                            jedjson.put("debit", true);
                            jedjson.put("jeid", jeid);
                            jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                            jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                            jeDetails.add(jed);
                        }
                    } else {
                        jedjson = new JSONObject();
                        jedjson.put("srno", jeDetails.size() + 1);
                        jedjson.put(Constants.companyKey, companyid);
                        jedjson.put("amount", disc);
                        jedjson.put("accountid", preferences.getDiscountGiven().getID());
                        jedjson.put("debit", true);
                        jedjson.put("jeid", jeid);
                        jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                        jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                        jeDetails.add(jed);
                    }
                    JSONObject discjson = new JSONObject();
                    discjson.put("discount", disc);
                    discjson.put("inpercent", (rowdisc == 1) ? true : false);
                    discjson.put("originalamount", rowAmount);
                    discjson.put(Constants.companyKey, companyid);
                    KwlReturnObject dscresult = accDiscountobj.addDiscount(discjson);
                    discount = (Discount) dscresult.getEntityList().get(0);
                    row.setDiscount(discount);
                    rowdiscount = discount.getDiscountValue();
                    totaldiscount += rowdiscount;
                }

                JSONObject jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", rowAmountWithoutTax);
                jedjson.put("accountid", product.getSalesAccount().getID());
                jedjson.put("debit", false);
                jedjson.put("jeid", jeid);
                KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);

                row.setDeferredJeDetailId(jed.getID());
                JSONArray jcustomarray = null;
                boolean customfieldArrayflag = true;
                String customfieldArray = jobj.optString("customfieldArray", ""); //Custom Data from other Project
                customfieldArray = StringUtil.DecodeText(customfieldArray);
                if (!StringUtil.isNullOrEmpty(customfieldArray)) {
                    HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                    String mapWithFieldType = paramJobj.optString("mapWithFieldType", null);
                    customrequestParams.put("customarray", customfieldArray);
                    customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                    customrequestParams.put(Constants.companyKey, companyid);
                    customrequestParams.put("mapWithFieldType", mapWithFieldType);
                    jcustomarray = fieldDataManagercntrl.createJSONArrForCustomFieldValueFromOtherSource(customrequestParams);
                    customfieldArrayflag = false;
                }
                // Add Custom fields details 
                if (!StringUtil.isNullOrEmpty(jobj.optString(Constants.customfield, "")) || !StringUtil.isNullOrEmpty(customfieldArray)) {
                    if (customfieldArrayflag) {
                        jcustomarray = new JSONArray(jobj.optString(Constants.customfield, "[]"));
                    }
                    HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                    customrequestParams.put("customarray", jcustomarray);
                    customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
                    customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);// Constants.Acc_JEDetail_recdetailId
                    customrequestParams.put("modulerecid", jed.getID());
                    customrequestParams.put("recdetailId", row.getInventory().getID());
                    customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                    customrequestParams.put(Constants.companyKey, companyid);
                    customrequestParams.put("customdataclasspath", Constants.Acc_BillInvDetail_custom_data_classpath);
                    KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                    if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                        jedjson.put("accjedetailcustomdata", jed.getID());
                        jedjson.put("jedid", jed.getID());
                        jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                    }
                }
                // Add Custom fields details for Product
                if (!StringUtil.isNullOrEmpty(jobj.optString("productcustomfield", ""))) {
                    jcustomarray = new JSONArray(jobj.optString("productcustomfield", "[]"));
                    HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                    customrequestParams.put("customarray", jcustomarray);
                    customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
                    customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);
                    customrequestParams.put("modulerecid", jed.getID());
                    customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                    customrequestParams.put("recdetailId", inventory.getID());
                    customrequestParams.put("productId", row.getInventory().getProduct().getID());
                    customrequestParams.put(Constants.companyKey, companyid);
                    customrequestParams.put("customdataclasspath", Constants.Acc_JEDetail_Productcustom_data_classpath);
                    KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                    if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                        jedjson.put("accjedetailproductcustomdataref", jed.getID());
                        jedjson.put("jedid", jed.getID());
                        jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                    }
                }

                String rowtaxid = "";
                if (!StringUtil.isNullOrEmpty(jobj.optString("prtaxid", null)) && jobj.optString("prtaxid").equalsIgnoreCase("None")) {
                    rowtaxid = null;
                } else {
                    rowtaxid = jobj.optString("prtaxid",null);
                }
                if (!StringUtil.isNullOrEmpty(rowtaxid)) {
                    boolean taxExist = false;
                    KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), rowtaxid);
                    Tax rowtax = (Tax) txresult.getEntityList().get(0);
                    if (rowtax == null) {
                        throw new AccountingException(messageSource.getMessage("acc.so.taxcode", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    } else {
                        row.setTax(rowtax);
                        double rowtaxamount = StringUtil.getDouble(jobj.getString("taxamount"));
                        rowtaxamount = authHandler.round(rowtaxamount, companyid);
                        row.setRowTaxAmount(rowtaxamount);
                        taxamount += rowtaxamount;
                        if (taxamount > 0) {
                            Iterator itr = jeDetails.iterator();
                            while (itr.hasNext()) {
                                jed = (JournalEntryDetail) itr.next();
                                if (jed.getAccount() == rowtax.getAccount()) {
                                    jedjson = new JSONObject();
                                    jedjson.put("jedid", jed.getID());
                                    jedjson.put("amount", jed.getAmount() + rowtaxamount);
                                    jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                    taxExist = true;
                                    break;
                                }
                            }
                            if (!taxExist) {
                                jedjson = new JSONObject();
                                jedjson = new JSONObject();
                                jedjson.put("srno", jeDetails.size() + 1);
                                jedjson.put(Constants.companyKey, companyid);
                                jedjson.put("amount", rowtaxamount);
                                jedjson.put("accountid", rowtax.getAccount().getID());
                                jedjson.put("debit", false);
                                jedjson.put("jeid", jeid);
                                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                jeDetails.add(jed);

                            }
                        }
                    }
                }
                rows.add(row);
            }
        } catch (JSONException ex) {
            throw ServiceException.FAILURE("saveInvoiceRows : " + ex.getMessage(), ex);
        }
        ll.add(new double[]{totaldiscount, totalamount, taxamount});
        ll.add(rows);
        ll.add(prodList);
        return ll;
    }

    public double getInvoiceDetailAMount(SalesOrderDetail sod) throws ServiceException {

        KwlReturnObject idresult = accInvoiceDAOobj.getIDFromSOD(sod.getID());
        List list = idresult.getEntityList();
        Iterator ite1 = list.iterator();
        double quantPartTtInv = 0.0;
        while (ite1.hasNext()) {
            InvoiceDetail ge = (InvoiceDetail) ite1.next();
            if (ge.getInvoice().isPartialinv()) {
                double quantity = ge.getInventory().getQuantity();
                quantPartTtInv += quantity * ge.getPartamount();
            }
        }

        return quantPartTtInv;
    }

    public String checkSOUsedFlag(HttpServletRequest request, int linkflag) throws ServiceException {
        String msg = null;
        try {
            JSONObject paramJObj = new JSONObject();
            try {
                Enumeration<String> attributes = request.getAttributeNames();
                while (attributes.hasMoreElements()) {
                    String attribute = attributes.nextElement();
                    paramJObj.put(attribute, request.getAttribute(attribute));
                }
                Enumeration<String> parameters = request.getParameterNames();
                while (parameters.hasMoreElements()) {
                    String parameter = parameters.nextElement();
                    paramJObj.put(parameter, request.getParameter(parameter));
                }
            } catch (JSONException e) {
                e.printStackTrace();
            }
            String companyid = sessionHandlerImpl.getCompanyid(request);
            String userDateFormat = sessionHandlerImpl.getUserDateFormat(request);
            paramJObj.put(Constants.companyKey, companyid);
            String currencyid = sessionHandlerImpl.getCurrencyID(request);
            paramJObj.put(Constants.currencyKey, currencyid);
            paramJObj.put(Constants.globalCurrencyKey, currencyid);
            String userfullname = sessionHandlerImpl.getUserFullName(request);
            paramJObj.put(Constants.userfullname, userfullname);
            paramJObj.put(Constants.userdateformat, userDateFormat);
            String userId = sessionHandlerImpl.getUserid(request);
            paramJObj.put(Constants.useridKey, userId);
            paramJObj.put(Constants.lid, userId);
            paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
            msg = checkSOUsedFlagJson(paramJObj, linkflag);

        } catch (SessionExpiredException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } catch (JSONException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return msg;
    }

    public String checkSOUsedFlagJson(JSONObject paramJobj, int linkflag) throws ServiceException {
        String msg = "";
        try {
            String linkMode = paramJobj.optString("fromLinkCombo", null); //When adding Sales order link for Delivery Order update link flag(2) in sale order.
            if (!StringUtil.isNullOrEmpty(linkMode) && !StringUtil.isNullOrEmpty(paramJobj.optString("linkNumber", null))) {
                String[] linkNumbers = paramJobj.getString("linkNumber").split(",");
                if (linkNumbers.length > 0) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                        for (int i = 0; i < linkNumbers.length; i++) {
                            if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkNumbers[i]);
                                SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                                if (salesOrder.getLinkflag() == linkflag) {
                                    msg += salesOrder.getSalesOrderNumber() + ", ";
                                }
                            }
                        }
                        if (!StringUtil.isNullOrEmpty(msg)) {
                            String usedIn = "Customer Invoice";
                            if (linkflag == 2) {
                                usedIn = Constants.Delivery_Order;
                            }
//                            msg = "Selected Sales Order(s) are already used in " + usedIn + ".<BR />" + msg.substring(0, msg.length() - 2);
                            msg = messageSource.getMessage("acc.field.SelectedSalesOrdersarealreadyusedin", null,Locale.forLanguageTag(paramJobj.getString(Constants.language))) + usedIn + ".<BR />" + msg.substring(0, msg.length() - 2);
                        }
                    }
                }
            }//outer If
        }//try
        catch (Exception ex) {
            throw ServiceException.FAILURE("checkSOUsedFlag : " + ex.getMessage(), ex);
        }
        return msg;
    }

    private void deleteJEDetailsCustomData(String jeid) throws ServiceException {
        KwlReturnObject cap = accountingHandlerDAOobj.getObject(JournalEntry.class.getName(), jeid);
        JournalEntry salesOrderDetails = (JournalEntry) cap.getEntityList().get(0);
        Set<JournalEntryDetail> journalEntryDetails = salesOrderDetails.getDetails();
        for (JournalEntryDetail journalEntryDetail : journalEntryDetails) {
            String jeDetailsId = journalEntryDetail.getID();
            KwlReturnObject jedresult1 = accJournalEntryobj.deleteJEDetailsCustomData(jeDetailsId);
        }
    }

    @Override
    public DeliveryOrder saveDeliveryOrder(HttpServletRequest request, String invoiceid) throws SessionExpiredException, ServiceException, AccountingException, JSONException, UnsupportedEncodingException {
        DeliveryOrder deliveryOrder = null;
        JSONObject paramJObj = new JSONObject();
        try {
            Enumeration<String> attributes = request.getAttributeNames();
            while (attributes.hasMoreElements()) {
                String attribute = attributes.nextElement();
                paramJObj.put(attribute, request.getAttribute(attribute));
            }
            Enumeration<String> parameters = request.getParameterNames();
            while (parameters.hasMoreElements()) {
                String parameter = parameters.nextElement();
                paramJObj.put(parameter, request.getParameter(parameter));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }
        String companyid = sessionHandlerImpl.getCompanyid(request);
        String userDateFormat = sessionHandlerImpl.getUserDateFormat(request);
        paramJObj.put(Constants.companyKey, companyid);
        String currencyid = sessionHandlerImpl.getCurrencyID(request);
        paramJObj.put(Constants.currencyKey, currencyid);
        paramJObj.put(Constants.globalCurrencyKey, currencyid);
        String userfullname = sessionHandlerImpl.getUserFullName(request);
        paramJObj.put(Constants.userfullname, userfullname);
        paramJObj.put(Constants.userdateformat, userDateFormat);
        String userId = sessionHandlerImpl.getUserid(request);
        paramJObj.put(Constants.useridKey, userId);
        paramJObj.put(Constants.lid, userId);
        ServletContext context = request.getSession().getServletContext();
        String crmURL = context.getInitParameter(Constants.crmURL);
        paramJObj.put(Constants.crmURL, crmURL);
        paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
        paramJObj.put(Constants.PAGE_URL, URLUtil.getPageURL(request, loginpageFull));
        deliveryOrder = saveDeliveryOrderJson(paramJObj, invoiceid);
        return deliveryOrder;
    }

    public DeliveryOrder saveDeliveryOrderJson(JSONObject paramJobj, String invoiceid) throws SessionExpiredException, ServiceException, AccountingException, JSONException, UnsupportedEncodingException {
        DeliveryOrder deliveryOrder = null;
        String entryNumber = "";
        try {
            String companyid = paramJobj.getString(Constants.companyKey);
            String currencyid = paramJobj.optString(Constants.currencyKey, null);
            entryNumber = paramJobj.optString("numberDo", null) != null ? paramJobj.getString("numberDo") : paramJobj.optString("number", null);
            boolean seqformat_oldflag = StringUtil.getBoolean(paramJobj.optString("seqformat_oldflagDo", null) != null ? paramJobj.get("seqformat_oldflagDo").toString() : "");
            String costCenterId = paramJobj.optString(Constants.costcenter, null);
            String status = paramJobj.optString("statuscombo", null);
            String doid = paramJobj.optString("doid", null);
            int DOSeqNum = paramJobj.optInt("DOSeqNum", 0);
            String doDatePrefix = paramJobj.optString(Constants.DATEPREFIX, "");
            String doAfterDatePrefix = paramJobj.optString(Constants.DATEAFTERPREFIX, "");
            String doDateSuffix = paramJobj.optString(Constants.DATESUFFIX, "");
            String sequenceformat = paramJobj.optString(Constants.sequenceformatDo, null) != null ? paramJobj.getString(Constants.sequenceformatDo) : "";
            String isfavourite = paramJobj.optString("isfavourite", null);
            String createdby = paramJobj.getString(Constants.lid);
            String modifiedby = createdby;
            long createdon = System.currentTimeMillis();
            long updatedon = System.currentTimeMillis();
            boolean isAutoCreateDO = false;
            String nextAutoNumber = "";
            boolean isFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isFixedAsset,null))) ? Boolean.parseBoolean(paramJobj.get(Constants.isFixedAsset).toString()) : false;
            boolean isLeaseFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isLeaseFixedAsset,null))) ? Boolean.parseBoolean(paramJobj.get(Constants.isLeaseFixedAsset).toString()) : false;
            String custId = paramJobj.optString("customer", null);
            String creditTerm = "";
            boolean isFromPOS = false;

            if (!StringUtil.isNullOrEmpty(paramJobj.optString("fromPOS",null))) {
                isFromPOS = true;
                custId = accInvoiceDAOobj.getCustomerIdForPOS(companyid);
                KwlReturnObject cus = accountingHandlerDAOobj.getObject(Customer.class.getName(), custId);
                Customer customer = (Customer) cus.getEntityList().get(0);
                creditTerm = customer.getCreditTerm() != null ? customer.getCreditTerm().getID() : "";
                Map<String, Object> filterParams = new HashMap<String, Object>();
                filterParams.put(Constants.companyKey, companyid);
                filterParams.put("modulename", "autodo");
                filterParams.put("ischecked", true);         //is for active sequence format
                KwlReturnObject result1 = accCompanyPreferencesObj.getSequenceFormat(filterParams);
                Iterator itr = result1.getEntityList().iterator();
                while (itr.hasNext()) {
                    SequenceFormat seqFormat = (SequenceFormat) itr.next();
                    if (seqFormat.isIsdefaultformat()) {
                        sequenceformat = seqFormat.getID();
                    }
                }
                if (StringUtil.isNullOrEmpty(sequenceformat) && result1.getEntityList().size() > 0) {
                    SequenceFormat seqFormat = (SequenceFormat) result1.getEntityList().get(0);
                    sequenceformat = seqFormat.getID();
                }
                if (StringUtil.isNullOrEmpty(sequenceformat)) {
                    throw new AccountingException("Sequence format is not set for Delivery Order");
                }
            }
            List doDetailsReturnList = null;

            HashMap<String, Object> doDataMap = new HashMap<String, Object>();

            String linkMode = paramJobj.optString("fromLinkCombo", null);

            isAutoCreateDO = Boolean.parseBoolean(paramJobj.optString("isAutoCreateDO", "false"));

            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);

            if (!isAutoCreateDO) {//No need to check SO linked with invoice or not while creating DO as auto DO from Invoice form.
                String msg = checkSOUsedFlagJson(paramJobj, 1);
                if (!StringUtil.isNullOrEmpty(msg)) {//Check if SO is already used in Invoice or not.
                    throw new AccountingException(msg);
                }
            }
            DateFormat df = authHandler.getDateOnlyFormat();
            
            Date orderdateVal = null;
            try {
                orderdateVal = df.parse(paramJobj.get(Constants.BillDate).toString());
            } catch (ParseException pe) {
                Calendar cal = Calendar.getInstance();
                long orderdate = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                cal.setTimeInMillis(orderdate);
                Date calDate = null;
                try {
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    calDate = authHandler.getDateOnlyFormat().parse(CalString);
                } catch (ParseException ex) {
                    calDate = cal.getTime();
                }
                orderdateVal = calDate;
            }
            synchronized (this) {
                KwlReturnObject socnt = accInvoiceDAOobj.getDeliveryOrderCount(entryNumber, companyid);
                if (socnt.getRecordTotalCount() > 0) {
                    if (StringUtil.isNullOrEmpty(doid)) {
                        if (sequenceformat.equals("NA")) {
                            throw new AccountingException("Delivery Order number '" + entryNumber + "' already exists.");
                        }
                    } else {
                        nextAutoNumber = entryNumber;
                        doDataMap.put(Constants.Acc_id, doid);
                        KwlReturnObject doObj = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);
                        DeliveryOrder deliveryOrder1 = (DeliveryOrder) doObj.getEntityList().get(0);
                        // delete asset details 
                        if (deliveryOrder1.isFixedAssetDO() || deliveryOrder1.isLeaseDO()) {
                            deleteAssetDetailsForDO(doid, companyid);
                            if (deliveryOrder1.isLeaseDO()) {
                                deleteDOContractMappings(doid, companyid);
                            }
                        }

                        KwlReturnObject result = accInvoiceDAOobj.getDeliveryOrderInventory(doid);
                        accInvoiceDAOobj.deleteDeliveryOrderDetails(doid, companyid);
                        List list = result.getEntityList();
                        Iterator itr = list.iterator();
                        while (itr.hasNext()) {
                            String inventoryid = (String) itr.next();
                            accProductObj.deleteInventory(inventoryid, companyid);
                        }
                    }
                } else {
                    if (!sequenceformat.equals("NA")) {
                        String nextAutoNoInt = "";
                        String datePrefix = "";
                        String dateafterPrefix = "";
                        String dateSuffix = "";
                        if (seqformat_oldflag) {
                            nextAutoNumber = accCompanyPreferencesObj.getNextAutoNumber(companyid, StaticValues.AUTONUM_DELIVERYORDER, sequenceformat);
                        } else {
                            Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_DELIVERYORDER, sequenceformat, seqformat_oldflag, orderdateVal);
                            nextAutoNumber = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                            nextAutoNoInt = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                            datePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                            dateafterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                            dateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                            doDataMap.put(Constants.SEQFORMAT, sequenceformat);
                            if (DOSeqNum != 0) {
                                doDataMap.put(Constants.SEQNUMBER, DOSeqNum);
                                doDataMap.put(Constants.DATEPREFIX, doDatePrefix);
                                doDataMap.put(Constants.DATEAFTERPREFIX, doAfterDatePrefix);
                                doDataMap.put(Constants.DATESUFFIX, doDateSuffix);
                            } else {
                                doDataMap.put(Constants.SEQNUMBER, nextAutoNoInt);
                                doDataMap.put(Constants.DATEPREFIX, datePrefix);
                                doDataMap.put(Constants.DATEAFTERPREFIX, dateafterPrefix);
                                doDataMap.put(Constants.DATESUFFIX, dateSuffix);
                            }
                        }
                        if (!sequenceformat.equals("NA") && StringUtil.isNullOrEmpty(doid)) {
                            entryNumber = nextAutoNumber;
                        }
                    }
                }
            }
            boolean autogen = nextAutoNumber.equals(entryNumber);
            if (DOSeqNum != 0) {
                autogen = true;
            }
            doDataMap.put("entrynumber", entryNumber);
            doDataMap.put("autogenerated", autogen);
            doDataMap.put(Constants.memo, isFromPOS ? paramJobj.get("POSWarehouse") : paramJobj.get(Constants.memo));
            doDataMap.put(Constants.posttext, paramJobj.get(Constants.posttext) == null ? "" : paramJobj.get(Constants.posttext));
            doDataMap.put(Constants.customerid, paramJobj.get("customer"));
            if (paramJobj.optString(Constants.shipdate, null) != null && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.shipdate))) {
                try {
                    doDataMap.put(Constants.shipdate, df.parse(paramJobj.get(Constants.shipdate).toString()));
                } catch (ParseException pe) {
                    Calendar cal = Calendar.getInstance();
                    long shipDateValue = (long) Long.parseLong(paramJobj.get(Constants.shipdate).toString());
                    cal.setTimeInMillis(shipDateValue);
                    Date calDate = null;
                    try {
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    } catch (ParseException ex) {
                        calDate = cal.getTime();
                    }
                    Date shipDateVal = calDate;
                    doDataMap.put(Constants.shipdate, shipDateVal);
                }
            }
            doDataMap.put(Constants.shipvia, paramJobj.has(Constants.shipvia) ? paramJobj.get(Constants.shipvia) : null);
            doDataMap.put(Constants.fob, paramJobj.has(Constants.fob) ? paramJobj.get(Constants.fob) : null);
            doDataMap.put("orderdate", orderdateVal);
            doDataMap.put("status", status);
            doDataMap.put("isfavourite", isfavourite);
            doDataMap.put(Constants.isFixedAsset, isFixedAsset);
            doDataMap.put(Constants.isLeaseFixedAsset, isLeaseFixedAsset);
            doDataMap.put("createdby", createdby);
            doDataMap.put("modifiedby", modifiedby);
            doDataMap.put("createdon", createdon);
            doDataMap.put("updatedon", updatedon);
            if (!StringUtil.isNullOrEmpty(costCenterId)) {
                doDataMap.put("costCenterId", costCenterId);
            }
            doDataMap.put(Constants.companyKey, companyid);
            doDataMap.put(Constants.currencyKey, currencyid);
            doDataMap.put(Constants.customerid, custId);
            doDataMap.put("termid", creditTerm);
            doDataMap.put("isFromPOS", isFromPOS);
            if (isAutoCreateDO) {
                doDataMap.put("isautogenerateddo", true); // true if do is generated from invoice side
            }
            KwlReturnObject doresult = accInvoiceDAOobj.saveDeliveryOrder(doDataMap);
            deliveryOrder = (DeliveryOrder) doresult.getEntityList().get(0);
            
            if (!isAutoCreateDO) {//If DO is auto generated from Invoice form.
                linkMode = paramJobj.optString("fromLinkCombo", null); //When adding Sales order link for Delivery Order update link flag(2) in sale order.
                String[] linkNumbers = paramJobj.getString("linkNumber").split(",");
                if (!StringUtil.isNullOrEmpty(linkMode) && linkNumbers.length > 0) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                        for (int i = 0; i < linkNumbers.length; i++) {
                            if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkNumbers[i]);
                                SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                                HashMap hMap = new HashMap();
                                hMap.put("salesOrder", salesOrder);
                                hMap.put("value", "2");
                                accInvoiceDAOobj.updateSOLinkflag(hMap);
                            }
                        }
                    }
                }
            }

            if (!StringUtil.isNullOrEmpty(linkMode)) {
                if (linkMode.equalsIgnoreCase(Constants.SALESORDER) && isLeaseFixedAsset) {// save contract detail mapping in case of lease fixed asset.
                    Set<DOContractMapping> contractMappings = getDOContractMappings(paramJobj, deliveryOrder);
                    if (!contractMappings.isEmpty()) {
                        doDataMap.put(Constants.Acc_id, deliveryOrder.getID());
                        doDataMap.put("contractMappings", contractMappings);
                        accInvoiceDAOobj.saveDeliveryOrder(doDataMap);
                    }
                }
            }

            if (isAutoCreateDO) {
                linkMode = paramJobj.optString(Constants.fromLinkComboAutoDO, null);
            }
            ExtraCompanyPreferences extraCompanyPreferences = null;
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), paramJobj.getString(Constants.companyKey));
            extraCompanyPreferences = (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0);
            String oldjeid = null;
            String jeentryNumber = null;
            String jeid = null;
            if (!StringUtil.isNullOrEmpty(linkMode)) {
                if (linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase("Sales Invoice")) {
                    if (deliveryOrder != null && deliveryOrder.getJournalEntry() != null) {
                        oldjeid = deliveryOrder.getJournalEntry().getID();
                        jeentryNumber = deliveryOrder.getJournalEntry().getEntryNumber();
                        deliveryOrder.setJournalEntry(null);
                        accInvoiceDAOobj.updateDeliveryOrderSetNull(deliveryOrder);
                        accJournalEntryobj.deleteJournalEntryPermanent(oldjeid, companyid);
                    }
                }
            }

            if (!StringUtil.isNullOrEmpty(linkMode)) {
                if ((linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase("Sales Invoice")) && extraCompanyPreferences != null && extraCompanyPreferences.isDeferredRevenueRecognition()) {
                    JSONArray jArr = new JSONArray(paramJobj.getString(Constants.detail));
                    List listDeferred = new ArrayList();
                    List tempDeferred = new ArrayList();
                    boolean allowProductDeferred = false;
                    for (int i = 0; i < jArr.length(); i++) {
                        JSONObject jobj = jArr.getJSONObject(i);
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(InvoiceDetail.class.getName(), jobj.getString("rowid"));
                        InvoiceDetail invoiceDetail = (InvoiceDetail) rdresult.getEntityList().get(0);
                        if (invoiceDetail != null) {
                            Invoice invoice = invoiceDetail.getInvoice();
                            KwlReturnObject resultDeferred = accInvoiceDAOobj.getInvoiceDetailWithDeferredJE(invoice);
                            tempDeferred = resultDeferred.getEntityList();
                        }
                        KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                        Product product = (Product) proresult.getEntityList().get(0);
                        if (product.isRevenueRecognitionProcess()) {
                            allowProductDeferred = true;
                        }
                        if (!tempDeferred.isEmpty()) {
                            listDeferred.addAll(tempDeferred);
                        }
                    }
                    if (((listDeferred != null && !listDeferred.isEmpty()) || isAutoCreateDO) && allowProductDeferred) {

                        boolean jeautogenflag = false;
                        if (StringUtil.isNullOrEmpty(oldjeid)) {
                            String nextJEAutoNo = accCompanyPreferencesObj.getNextAutoNumber(companyid, StaticValues.AUTONUM_JOURNALENTRY);
                            jeentryNumber = nextJEAutoNo;// + "/" + entryNumber;
                            jeautogenflag = true;
                        }
                        Map<String, Object> jeDataMap = AccountingManager.getGlobalParamsJson(paramJobj);
                        jeDataMap.put("entrynumber", jeentryNumber);
                        jeDataMap.put("autogenerated", jeautogenflag);
                        try {
                            jeDataMap.put("entrydate", df.parse(paramJobj.get(Constants.BillDate).toString()));
                        } catch (ParseException pe) {
                            Calendar cal = Calendar.getInstance();
                            long entrydate = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                            cal.setTimeInMillis(entrydate);
                            Date calDate = null;
                            try {
                                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                                calDate = authHandler.getDateOnlyFormat().parse(CalString);
                            } catch (ParseException ex) {
                                calDate = cal.getTime();
                            }
                            Date entrydateVal = calDate;
                            doDataMap.put("orderdate", entrydateVal);
                        }
                        jeDataMap.put(Constants.companyKey, companyid);
                        jeDataMap.put(Constants.memo, paramJobj.optString(Constants.memo, null));
                        jeDataMap.put(Constants.currencyKey, currencyid);
                        jeDataMap.put("costcenterid", costCenterId);
                        HashSet jeDetails = new HashSet();
                        KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Create Journal entry without JEdetails
                        JournalEntry journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
                        jeid = journalEntry.getID();
                        jeDataMap.put("jeid", jeid);

                        doDataMap.put(Constants.Acc_id, deliveryOrder.getID());
                        paramJobj.put("jeDetails", jeDetails);
                        paramJobj.put("jeid", jeid);
                        doDetailsReturnList = new ArrayList(saveDeliveryOrderRowsJson(paramJobj, deliveryOrder, companyid, isAutoCreateDO, invoiceid, listDeferred, jeDetails, jeid));
                        deliveryOrder.setJournalEntry(journalEntry);
                        accInvoiceDAOobj.updateDeliveryOrder(deliveryOrder);
                        jeDataMap.put("jedetails", jeDetails);
                        jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Add Journal entry details
                        journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
                    }
                }
            }
            HashSet h = saveDeliveryOrderRowsJson(paramJobj, deliveryOrder, companyid, isAutoCreateDO, invoiceid, new ArrayList(), null, jeid);
            Iterator doDetailsItr = h.iterator();
            Map<String, Object> mailParameters = new HashMap();
            mailParameters.put(Constants.Delivery_Order_Key, deliveryOrder);
            mailParameters.put(Constants.companyKey, paramJobj.getString(Constants.companyKey));
            mailParameters.put(Constants.Acc_level, deliveryOrder.getApprovestatuslevel());
            mailParameters.put(Constants.amount, String.valueOf(0.0));
            mailParameters.put(Constants.PAGE_URL, paramJobj.optString(Constants.PAGE_URL));
            
            int approvedlevel = approveDO(mailParameters);
            deliveryOrder.setApprovestatuslevel(approvedlevel);

            int pendingApprovalFlag = (deliveryOrder.getApprovestatuslevel() != 11) ? 1 : 0;
            if (pendingApprovalFlag == 1) {
                while (doDetailsItr.hasNext()) {
                    DeliveryOrderDetail doDetail = (DeliveryOrderDetail) doDetailsItr.next();
                    Inventory inventory = doDetail.getInventory();
                    if (inventory.isInvrecord()) {
                        inventory.setActquantity(inventory.getBaseuomquantity());
                        inventory.setBaseuomquantity(0.0);
                    }
                }
            }

            Map<String, Object> auditTrailMap = new HashMap<String, Object>();
            auditTrailMap.put(Constants.useridKey, paramJobj.getString(Constants.lid));
            auditTrailObj.insertAuditLog(AuditAction.DELIVERY_ORDER, "User " + paramJobj.optString(Constants.userfullname, null) + " has made a Delivery Order " + deliveryOrder.getDeliveryOrderNumber(), auditTrailMap, deliveryOrder.getID());

            String customfield = paramJobj.optString(Constants.customfield, null);
            if (!StringUtil.isNullOrEmpty(customfield)) {
                JSONArray jcustomarray = new JSONArray(customfield);
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                customrequestParams.put("customarray", jcustomarray);
                customrequestParams.put("modulename", Constants.Acc_DeliveryOrder_modulename);
                customrequestParams.put("moduleprimarykey", Constants.Acc_DeliveryOrderid);
                customrequestParams.put("modulerecid", deliveryOrder.getID());
                customrequestParams.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("customdataclasspath", Constants.Acc_DeliveryOrder_custom_data_classpath);
                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                    doDataMap.put("accadeliveryordercustomdataref", deliveryOrder.getID());
                    KwlReturnObject accresult = accInvoiceDAOobj.updateDeliveryOrderCustomData(doDataMap);
                }
            }

            if (preferences.isInventoryAccountingIntegration() && preferences.isWithInvUpdate()) {

                String action = "17";
                boolean isDirectUpdateInvFlag = false;
                if (preferences.isUpdateInvLevel()) {
                    isDirectUpdateInvFlag = true;
                    action = "19";//Direct Inventory Update action
                }

                JSONArray productArray = new JSONArray();
                if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.detail,null))) {
                    JSONArray jArr = new JSONArray(paramJobj.getString(Constants.detail));
                    for (int i = 0; i < jArr.length(); i++) {
                        JSONObject jobj = jArr.getJSONObject(i);
                        KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                        Product product = (Product) proresult.getEntityList().get(0);

                        JSONObject productObject = new JSONObject();

                        double productRate = 0;
                        if (!jobj.isNull("rowid") && !StringUtil.isNullOrEmpty(jobj.getString("rowid")) && !jobj.getString("rowid").equalsIgnoreCase("undefined")) {
                            productRate = getProductPriceJson(paramJobj, jobj.getString("rowid"));
                        }

                        if (!StringUtil.isNullOrEmpty(doid)) {
                            if (jobj.optDouble("changedQuantity", 0) != 0) {
                                if (!StringUtil.isNullOrEmpty(paramJobj.optString("deletedData"))) {
                                    productObject.put("itemUomId", jobj.getString("uomid"));
                                    productObject.put("itemBaseUomRate", jobj.getDouble("baseuomrate"));
                                    productObject.put("quantity", jobj.getDouble("quantity") * (-1));
                                    if (isAutoCreateDO) {
                                        productObject.put("itemQuantity", jobj.getInt("quantity") * jobj.getDouble("baseuomrate") * (-1));
                                    } else {
                                        productObject.put("itemQuantity", jobj.getInt("dquantity") * jobj.getDouble("baseuomrate") * (-1));
                                    }
                                    productObject.put("itemCode", product.getProductid());
                                    if (isDirectUpdateInvFlag) {
                                        productObject.put("storeid", jobj.optString("invstore"));
                                        productObject.put("locationid", jobj.optString("invlocation"));
                                        productObject.put("rate", productRate);
                                    }
                                    productArray.put(productObject);
                                } else {
                                    productObject.put("itemUomId", jobj.getString("uomid"));
                                    productObject.put("itemBaseUomRate", jobj.getDouble("baseuomrate"));
                                    productObject.put("itemQuantity", jobj.getDouble("changedQuantity"));
                                    productObject.put("quantity", jobj.getDouble("changedQuantity"));
                                    productObject.put("itemCode", product.getProductid());
                                    if (isDirectUpdateInvFlag) {
                                        productObject.put("storeid", jobj.optString("invstore"));
                                        productObject.put("locationid", jobj.optString("invlocation"));
                                        productObject.put("rate", productRate);
                                    }
                                    productArray.put(productObject);
                                }
                            }
                        } else {
                            productObject.put("itemUomId", jobj.getString("uomid"));
                            productObject.put("itemBaseUomRate", jobj.getDouble("baseuomrate"));
                            productObject.put("quantity", jobj.getDouble("quantity") * (-1));
                            if (isAutoCreateDO) {
                                productObject.put("itemQuantity", jobj.getInt("quantity") * jobj.getDouble("baseuomrate") * (-1));
                            } else {
                                productObject.put("itemQuantity", jobj.getInt("dquantity") * jobj.getDouble("baseuomrate") * (-1));
                            }
                            productObject.put("itemCode", product.getProductid());
                            if (isDirectUpdateInvFlag) {
                                productObject.put("storeid", jobj.optString("invstore"));
                                productObject.put("locationid", jobj.optString("invlocation"));
                            }
                            productArray.put(productObject);
                        }
                    }

                    if (!StringUtil.isNullOrEmpty(doid)) {
                        if (!StringUtil.isNullOrEmpty(paramJobj.optString("deletedData"))) {
                            JSONArray deleteArr = new JSONArray(paramJobj.getString("deletedData"));
                            for (int i = 0; i < deleteArr.length(); i++) {
                                JSONObject jobj = deleteArr.getJSONObject(i);

                                KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                                Product product = (Product) proresult.getEntityList().get(0);

                                double productRate = 0;
                                if (!jobj.isNull("rowid") && !StringUtil.isNullOrEmpty(jobj.getString("rowid")) && !jobj.getString("rowid").equalsIgnoreCase("undefined")) {
                                    productRate = getProductPriceJson(paramJobj, jobj.getString("rowid"));
                                }

                                JSONObject productObject = new JSONObject();
                                productObject.put("itemUomId", jobj.getString("productuomid"));
                                productObject.put("itemBaseUomRate", jobj.getDouble("productbaseuomrate"));
                                productObject.put("itemQuantity", jobj.getDouble("productbaseuomquantity"));
                                productObject.put("quantity", jobj.getDouble("productquantity"));
                                productObject.put("itemCode", product.getProductid());
                                if (isDirectUpdateInvFlag) {
                                    productObject.put("storeid", jobj.optString("productinvstore"));
                                    productObject.put("locationid", jobj.optString("productinvlocation"));
                                    productObject.put("rate", productRate);
                                }
                                productArray.put(productObject);
                            }
                        }
                    }

                    if (productArray.length() > 0) {
                        String stringDateval = null;
                        String sendDateFormat = Constants.yyyyMMdd;
                        DateFormat dateformat = new SimpleDateFormat(sendDateFormat);
                        try {
                            Date dateval = df.parse(paramJobj.get(Constants.BillDate).toString());
                        } catch (ParseException pe) {
                            Calendar cal = Calendar.getInstance();
                            long dateval = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                            cal.setTimeInMillis(dateval);
                            Date calDate = null;
                            try {
                                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                                calDate = authHandler.getDateOnlyFormat().parse(CalString);
                            } catch (ParseException ex) {
                                calDate = cal.getTime();
                            }
                            Date datevalue = calDate;
                            stringDateval = dateformat.format(datevalue);
                        }
                        JSONObject jSONObject = new JSONObject();
                        jSONObject.put("deliveryDate", stringDateval);
                        jSONObject.put("dateFormat", sendDateFormat);
                        jSONObject.put("details", productArray);
                        jSONObject.put("orderNumber", entryNumber);
                        jSONObject.put("selling", true);

                        String url = storageHandlerImpl.GetinventoryURL();
                        CommonFnController cfc = new CommonFnController();
                        cfc.updateInventoryLevelJson(paramJobj, jSONObject, url, action);
                    }
                }
            }

            if (isLeaseFixedAsset) {
                if (!doDetailsReturnList.isEmpty()) {
                    JSONArray crmArray = (JSONArray) doDetailsReturnList.get(1);// crm array to send CRM Side for updating status of Replacement request. i.e. it is closed or open
                    sendRequestToCRMForUpdatingProductReplacementStatus(paramJobj, crmArray);
                }
            }
            if (isAutoCreateDO) {
                if (!StringUtil.isNullOrEmpty(invoiceid)) {
                    KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                    Invoice invoice = (Invoice) rdresult.getEntityList().get(0);
                    HashMap hMap = new HashMap();
                    hMap.put("invoice", invoice);
                    boolean isSOOpen = false;
                    hMap.put("isOpenDO", isSOOpen);
                    accInvoiceDAOobj.updateInvoiceLinkflag(hMap);

                    /*
                     * saving linking informaion of Sales Invoice while linking
                     * with Delivery Order
                     */
                    HashMap<String, Object> requestParamsLinking = new HashMap<String, Object>();
                    requestParamsLinking.put("linkeddocid", deliveryOrder.getID());
                    requestParamsLinking.put("docid", invoice.getID());
                    requestParamsLinking.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                    requestParamsLinking.put("linkeddocno", entryNumber);
                    requestParamsLinking.put("sourceflag", 0);
                    KwlReturnObject result3 = accInvoiceDAOobj.saveInvoiceLinking(requestParamsLinking);


                    /*
                     * saving linking informaion of Delivery Order while linking
                     * with Sales Invoice
                     */
                    requestParamsLinking.put("linkeddocid", invoice.getID());
                    requestParamsLinking.put("docid", deliveryOrder.getID());
                    requestParamsLinking.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                    requestParamsLinking.put("linkeddocno", invoice.getInvoiceNumber());
                    requestParamsLinking.put("sourceflag", 1);
                    result3 = accInvoiceDAOobj.saveDeliveryOrderLinking(requestParamsLinking);

                }
            }
        } catch (AccountingException ex) {
            throw new AccountingException(ex.getMessage());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("saveDeliveryOrder : " + ex.getMessage(), ex);
        }
        return deliveryOrder;
    }

    public void deleteJEArray(String oldjeid, String companyid) throws ServiceException, AccountingException, SessionExpiredException {
        try {      //delete old invoice
            JournalEntryDetail jed = null;
            if (!StringUtil.isNullOrEmpty(oldjeid)) {
                KwlReturnObject result = accJournalEntryobj.getJournalEntryDetail(oldjeid, companyid);
                List list = result.getEntityList();
                Iterator itr = list.iterator();
                while (itr.hasNext()) {
                    jed = (JournalEntryDetail) itr.next();
                    //Sagar - No need to revert entry from optimized table as entries are already reverted from calling main function in edit case.
                    result = accJournalEntryobj.deleteJournalEntryDetailRow(jed.getID(), companyid);
                }
                result = accJournalEntryobj.permanentDeleteJournalEntry(oldjeid, companyid);

            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
    }
    /**
     * @param mailParameters(DeliveryOrder doObj, String companyid, int level, String amount, String PAGE_URL)
     * @return
     * @throws SessionExpiredException
     * @throws AccountingException
     * @throws ServiceException
     * @throws ScriptException
     * @throws MessagingException 
     */
    public int approveDO(Map<String, Object> mailParameters) throws SessionExpiredException, AccountingException, ServiceException, ScriptException, MessagingException {
        DeliveryOrder doObj = null;
        if(mailParameters.containsKey(Constants.Delivery_Order_Key)){
            doObj = (DeliveryOrder) mailParameters.get(Constants.Delivery_Order_Key);
        }
        String companyid = "";
        if(mailParameters.containsKey(Constants.companyKey)){
            companyid = (String) mailParameters.get(Constants.companyKey);
        }
        int level = 0;
        if(mailParameters.containsKey(Constants.Acc_level)){
            level = (int) mailParameters.get(Constants.Acc_level);
        }
        String amount = "0.0";
        if(mailParameters.containsKey(Constants.amount)){
            amount = (String) mailParameters.get(Constants.amount);
        }
        Map<String, Object> filterMap = new HashMap();
        filterMap.put("companyID", companyid);
        String companyName = (String) kwlCommonTablesDAOObj.getRequestedObjectFields(Company.class, new String[]{"companyName"}, filterMap);
        String pageURL = "";
        if(mailParameters.containsKey(Constants.PAGE_URL)){
            pageURL = (String) mailParameters.get(Constants.PAGE_URL);
        }
        ScriptEngineManager mgr = new ScriptEngineManager();
        ScriptEngine engine = mgr.getEngineByName("JavaScript");
        String requisitionApprovalSubject = "Delivery Order: %s - Approval Notification";
        String requisitionApprovalHtmlMsg = "<html><head><title>Deskera Accounting - Your Deskera Account</title></head><style type='text/css'>"
                + "a:link, a:visited, a:active {\n"
                + " 	color: #03C;"
                + "}\n"
                + "body {\n"
                + "	font-family: Arial, Helvetica, sans-serif;"
                + "	color: #000;"
                + "	font-size: 13px;"
                + "}\n"
                + "</style><body>"
                + "<p>Hi All,</p>"
                + "<p></p>"
                + "<p>%s has created delivery order %S and sent it to you for approval. at level "+(level+1)+"</p>"
                + "<p>Please review and approve it (Delivery Order Number: %s).</p>"
                + "<p></p>"
                + "<p>Company Name:- %s</p>"
                + "<p>Please check on Url:- %s</p>"
                + "<p>Thanks</p>"
                + "<p>This is an auto generated email. Do not reply<br>";
        String requisitionApprovalPlainMsg = "Hi All,\n\n"
                + "%s has created delivery order %S and sent it to you for approval. at level "+(level+1)+" \n"
                + "Please review and approve it (Delivery Order Number: %s).\n\n"
                + "Company Name:- %s"
                + "Please check on Url:- %s"
                + "Thanks\n\n"
                + "This is an auto generated email. Do not reply\n";
        int approvalStatus = 11;
        KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
        CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
        String prNumber = doObj.getDeliveryOrderNumber();
        String doID = doObj.getID();
        HashMap<String, Object> qdDataMap = new HashMap<String, Object>();
        qdDataMap.put(Constants.companyKey, companyid);
        qdDataMap.put("level", level + 1);
        qdDataMap.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
        KwlReturnObject flowresult = accMultiLevelApprovalDAOObj.getMultiApprovalRuleData(qdDataMap);
        Iterator itr = flowresult.getEntityList().iterator();

        KwlReturnObject returnObject = accountingHandlerDAOobj.getObject(Company.class.getName(), companyid);
        Company company = (Company) returnObject.getEntityList().get(0);
        Map<String, Object> smtpConfigMap = authHandler.getSMTPConfigMap(company);

        while (itr.hasNext()) {
            Object[] row = (Object[]) itr.next();
            String rule = row[2].toString();
            rule = rule.replaceAll("[$$]+", amount);
            if (StringUtil.isNullOrEmpty(rule) || (!StringUtil.isNullOrEmpty(rule) && Boolean.parseBoolean(engine.eval(rule).toString()))) {
                // send emails
                try {
                    if (Boolean.parseBoolean(row[3].toString()) && preferences.isSendapprovalmail()) {//If allow to send approval mail in company account preferences
                        String fromName = "User";
                        String fromEmailId = (!company.isEmailFromCompanyCreator()) ? Constants.ADMIN_EMAILID : authHandlerDAOObj.getSysEmailIdByCompanyID(company.getCompanyID());
                        fromName = doObj.getCreatedby().getFirstName().concat(" ").concat(doObj.getCreatedby().getLastName());
                        String subject = String.format(requisitionApprovalSubject, prNumber);
                        String htmlMsg = String.format(requisitionApprovalHtmlMsg, fromName, prNumber, prNumber, companyName, pageURL);
                        String plainMsg = String.format(requisitionApprovalPlainMsg, fromName, prNumber, prNumber, companyName, pageURL);
                        ArrayList<String> emailArray = new ArrayList<String>();
                        String[] emails = {};
                        qdDataMap.put("ruleid", row[0].toString());
                        KwlReturnObject userResult = accMultiLevelApprovalDAOObj.getApprovalRuleTargetUsers(qdDataMap);
                        Iterator useritr = userResult.getEntityList().iterator();
                        while (useritr.hasNext()) {
                            Object[] userrow = (Object[]) useritr.next();
                            emailArray.add(userrow[3].toString());
                        }
                        emails = emailArray.toArray(emails);
                        if (!StringUtil.isNullOrEmpty(preferences.getApprovalEmails())) {
                            String[] compPrefMailIds = preferences.getApprovalEmails().split(",");
                            emails = AccountingManager.getMergedMailIds(emails, compPrefMailIds);
                        }
                        if (emails.length > 0) {
                            SendMailHandler.postMail(emails, subject, htmlMsg, plainMsg, fromEmailId, smtpConfigMap);
                        }
                    }
                } catch (MessagingException ex) {
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
                approvalStatus = level + 1;
            }
        }
        accInvoiceDAOobj.approvePendingDO(doID, companyid, approvalStatus);
        return approvalStatus;
    }

    public void deleteEditedInvoiceDiscount(ArrayList discArr, String companyid) throws ServiceException, AccountingException, SessionExpiredException {
        try {
            for (int i = 0; i < discArr.size(); i++) {
                if (discArr.get(i) != null) {
                    accDiscountobj.deleteDiscount(discArr.get(i).toString(), companyid);
                }
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
    }

    @Override
    public double getProductPrice(HttpServletRequest request, String rowid) throws SessionExpiredException, ServiceException, JSONException {

        JSONObject paramJObj = new JSONObject();
        try {
            Enumeration<String> attributes = request.getAttributeNames();
            while (attributes.hasMoreElements()) {
                String attribute = attributes.nextElement();
                paramJObj.put(attribute, request.getAttribute(attribute));
            }
            Enumeration<String> parameters = request.getParameterNames();
            while (parameters.hasMoreElements()) {
                String parameter = parameters.nextElement();
                paramJObj.put(parameter, request.getParameter(parameter));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }

        String companyid = sessionHandlerImpl.getCompanyid(request);
        String userDateFormat = sessionHandlerImpl.getUserDateFormat(request);
        paramJObj.put(Constants.companyKey, companyid);
        String currencyid = sessionHandlerImpl.getCurrencyID(request);
        paramJObj.put(Constants.currencyKey, currencyid);
        paramJObj.put(Constants.globalCurrencyKey, currencyid);
        String userfullname = sessionHandlerImpl.getUserFullName(request);
        paramJObj.put(Constants.userfullname, userfullname);
        paramJObj.put(Constants.userdateformat, userDateFormat);
        String userId = sessionHandlerImpl.getUserid(request);
        paramJObj.put(Constants.useridKey, userId);
        paramJObj.put(Constants.lid, userId);

        paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
        double productPrice = getProductPriceJson(paramJObj, rowid);
        return productPrice;
    }

    @Override
    public double getProductPriceJson(JSONObject jobj, String rowid) throws ServiceException {
        double productPrice = 0.0;
        try {
            String linkMode = jobj.optString("fromLinkCombo", null);
            if (!StringUtil.isNullOrEmpty(linkMode) && !StringUtil.isNullOrEmpty(rowid)) {

                if (linkMode.equalsIgnoreCase(Constants.SALESORDER) || linkMode.equalsIgnoreCase("Lease Order")) {
                    KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), rowid);
                    SalesOrderDetail sod = (SalesOrderDetail) rdresult.getEntityList().get(0);
                    if (sod != null) {
                        productPrice = sod.getRate();
                    }
                } else if (linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase(Constants.CUSTOMER_INVOICE)) {
                    KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(InvoiceDetail.class.getName(), rowid);
                    InvoiceDetail id = (InvoiceDetail) rdresult.getEntityList().get(0);
                    if (id != null) {
                        productPrice = id.getRate();
                    }
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accInvoiceController.getProductPrice() -: " + ex.getMessage(), ex);
        }
        return productPrice;
    }

    @Override
    public String getDeliveryReturnStatus(DeliveryOrder so, String salesreturnId) throws ServiceException {
        Set<DeliveryOrderDetail> orderDetail = so.getRows();
        Iterator ite = orderDetail.iterator();

        String result = "Closed";
        while (ite.hasNext()) {
            DeliveryOrderDetail soDetail = (DeliveryOrderDetail) ite.next();
            KwlReturnObject idresult = accInvoiceDAOobj.getDODIDFromSRD(soDetail.getID(), salesreturnId);
            List list = idresult.getEntityList();
            Iterator ite1 = list.iterator();
            double qua = 0;
            int poupdatedcount = 0;
            while (ite1.hasNext()) {
                SalesReturnDetail ge = (SalesReturnDetail) ite1.next();
                qua += ge.getInventory().getQuantity();
            }
            if (soDetail != null) {
                if (soDetail.getSodetails() != null && !StringUtil.isNullOrEmpty(soDetail.getSodetails().getID())) {
                    HashMap hMap = new HashMap();
                    hMap.put("sodetails", soDetail.getSodetails().getID());
                    hMap.put(Constants.companyKey, soDetail.getCompany().getCompanyID());
                    hMap.put("balanceqty", qua);
                    hMap.put("add", true);
                    accCommonTablesDAO.updateSalesorderOrderStatus(hMap);
                    poupdatedcount++;
                    if (poupdatedcount > 0) {
                        HashMap poMap = new HashMap();
                        if (soDetail.getSodetails().getSalesOrder() != null && !StringUtil.isNullOrEmpty(soDetail.getSodetails().getSalesOrder().getID())) {
                            hMap.put("salesOrder", soDetail.getSodetails().getSalesOrder());
                            hMap.put("value", "2");
                            if (soDetail.getSodetails().getBalanceqty() > 0) {
                                hMap.put("isSOOpen", true);
                            } else {
                                hMap.put("isSOOpen", false);
                            }
                            accInvoiceDAOobj.updateSOLinkflag(hMap);
                        }
                    }
                }
            }
            if (qua < soDetail.getActualQuantity()) {
                result = "Open";
                break;
            }
        }
        return result;
    }

    public HashSet saveDeliveryOrderRows(HttpServletRequest request, DeliveryOrder deliveryOrder, String companyid, boolean isAutoCreateDO, String invoiceid) throws ServiceException, AccountingException, SessionExpiredException, ParseException, JSONException {

        JSONObject paramJObj = new JSONObject();
        try {
            Enumeration<String> attributes = request.getAttributeNames();
            while (attributes.hasMoreElements()) {
                String attribute = attributes.nextElement();
                paramJObj.put(attribute, request.getAttribute(attribute));
            }
            Enumeration<String> parameters = request.getParameterNames();
            while (parameters.hasMoreElements()) {
                String parameter = parameters.nextElement();
                paramJObj.put(parameter, request.getParameter(parameter));
            }
        } catch (JSONException e) {
            e.printStackTrace();
        }

        String userDateFormat = sessionHandlerImpl.getUserDateFormat(request);
        paramJObj.put(Constants.companyKey, companyid);
        String currencyid = sessionHandlerImpl.getCurrencyID(request);
        paramJObj.put(Constants.currencyKey, currencyid);
        paramJObj.put(Constants.globalCurrencyKey, currencyid);
        String userfullname = sessionHandlerImpl.getUserFullName(request);
        paramJObj.put(Constants.userfullname, userfullname);
        paramJObj.put(Constants.userdateformat, userDateFormat);
        String userId = sessionHandlerImpl.getUserid(request);
        paramJObj.put(Constants.useridKey, userId);
        paramJObj.put(Constants.lid, userId);
        paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
        HashSet rows = saveDeliveryOrderRowsJson(paramJObj, deliveryOrder, companyid, isAutoCreateDO, invoiceid, null, null, recId);
        return rows;
    }

    public HashSet saveDeliveryOrderRowsJson(JSONObject paramJobj, DeliveryOrder deliveryOrder, String companyid, boolean isAutoCreateDO, String invoiceid, List listDeferred, HashSet jeDetails, String jeid) throws ServiceException, AccountingException, SessionExpiredException, ParseException {
        HashSet rows = new HashSet();
        try {
            JSONArray jArr = new JSONArray(paramJobj.getString(Constants.detail));
            HashSet<InvoiceDetail> invcdetails = new HashSet();
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            KwlReturnObject extracap = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extracap.getEntityList().get(0);

            if (isAutoCreateDO) {
                if (!StringUtil.isNullOrEmpty(invoiceid)) {
                    HashMap<String, Object> invRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList();
                    filter_names.add("invoice.ID");
                    invRequestParams.put("filter_names", filter_names);
                    invRequestParams.put("filter_params", filter_params);
                    filter_params.clear();
                    filter_params.add(invoiceid);
                    KwlReturnObject idresult = accInvoiceDAOobj.getInvoiceDetails(invRequestParams);
                    Iterator itr = idresult.getEntityList().iterator();
                    int index = 0;
                    while (itr.hasNext()) {
                        InvoiceDetail row = (InvoiceDetail) itr.next();
                        jArr.getJSONObject(index).put("rowid", row.getID());
                        index++;
                    }

                }
            }
            List<StockMovement> stockMovementsList = new ArrayList<StockMovement>();
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jobj = jArr.getJSONObject(i);
                HashMap<String, Object> dodDataMap = new HashMap<String, Object>();
                dodDataMap.put("srno", i + 1);
                dodDataMap.put(Constants.companyKey, companyid);
                dodDataMap.put("doid", deliveryOrder.getID());
                dodDataMap.put(Constants.productid, jobj.getString(Constants.productid));
                String linkMode = paramJobj.optString("fromLinkCombo", null);
                String description = "";
                double baseuomrate = 1;
                double quantity = jobj.getDouble("quantity");
                double dquantity = 0;
                if (jobj.has("baseuomrate") && jobj.get("baseuomrate") != null) {
                    baseuomrate = jobj.getDouble("baseuomrate");
                }
                if (jobj.has("uomid")) {
                    dodDataMap.put("uomid", jobj.getString("uomid"));
                }
                if (isAutoCreateDO) {
                    dquantity = quantity;
                    description = jobj.has("desc") ? jobj.getString("desc") : "";
                    dodDataMap.put("description", description);
                    dodDataMap.put("deliveredquantity", dquantity);
                    dodDataMap.put("baseuomdeliveredquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                    dodDataMap.put("partno", "");
                    linkMode = paramJobj.optString(Constants.fromLinkComboAutoDO, null);
                } else {
                    dquantity = jobj.getDouble("dquantity");
                    description = jobj.optString("description");
                    dodDataMap.put("description", description);
                    dodDataMap.put("deliveredquantity", dquantity);
                    dodDataMap.put("baseuomdeliveredquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                    dodDataMap.put("partno", jobj.optString("partno"));
                }
                dodDataMap.put("baseuomrate", baseuomrate);
                dodDataMap.put("baseuomquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                dodDataMap.put("quantity", quantity);
                dodDataMap.put("remark", jobj.optString("remark"));
                dodDataMap.put("reason", jobj.optString("reason"));

                if (preferences.isInventoryAccountingIntegration() && preferences.isWithInvUpdate() && preferences.isUpdateInvLevel()) {
                    if (!StringUtil.isNullOrEmpty(jobj.optString("invstore"))) {
                        dodDataMap.put("invstoreid", jobj.optString("invstore"));
                    } else {
                        dodDataMap.put("invstoreid", "");
                    }
                    if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                        dodDataMap.put("invlocationid", jobj.optString("invlocation"));
                    } else {
                        dodDataMap.put("invlocationid", "");
                    }
                }

                KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                Product product = (Product) proresult.getEntityList().get(0);

                if (!StringUtil.isNullOrEmpty(linkMode)) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid")); //for link
                        SalesOrderDetail sod = (SalesOrderDetail) rdresult.getEntityList().get(0);
                        dodDataMap.put("SalesOrderDetail", sod);
                    } else if (linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase(Constants.CUSTOMER_INVOICE)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(InvoiceDetail.class.getName(), jobj.getString("rowid"));
                        InvoiceDetail id = (InvoiceDetail) rdresult.getEntityList().get(0);
                        dodDataMap.put("InvoiceDetail", id);

                        if (jeDetails != null && jeid != null && extraCompanyPreferences != null && extraCompanyPreferences.isDeferredRevenueRecognition() && (!listDeferred.isEmpty() || isAutoCreateDO)) {
                            if (id.getDeferredJeDetailId() != null && product.isRevenueRecognitionProcess()) {

                                KwlReturnObject resultJeDeffered = accountingHandlerDAOobj.getObject(JournalEntryDetail.class.getName(), id.getDeferredJeDetailId());
                                JournalEntryDetail journalEntryDetail = (JournalEntryDetail) resultJeDeffered.getEntityList().get(0);
                                JSONObject jedjson = new JSONObject();
                                jedjson.put("srno", jeDetails.size() + 1);
                                jedjson.put(Constants.companyKey, companyid);
                                jedjson.put("amount", journalEntryDetail.getAmount());
                                jedjson.put("accountid", journalEntryDetail.getAccount() != null ? journalEntryDetail.getAccount().getID() : (product.getSalesAccount() != null ? product.getSalesAccount().getID() : extraCompanyPreferences.getSalesAccount()));
                                jedjson.put("debit", true);
                                jedjson.put("jeid", jeid);
                                KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                jeDetails.add(jed);

                                jedjson.put("srno", jeDetails.size() + 1);
                                jedjson.put(Constants.companyKey, companyid);
                                jedjson.put("amount", journalEntryDetail.getAmount());
                                jedjson.put("accountid", product.getSalesRevenueRecognitionAccount() != null ? product.getSalesRevenueRecognitionAccount().getID() : extraCompanyPreferences.getSalesRevenueRecognitionAccount());
                                jedjson.put("debit", false);
                                jedjson.put("jeid", jeid);
                                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                jeDetails.add(jed);
                            }
                        }
                    }
                }

                JSONObject inventoryjson = new JSONObject();
                inventoryjson.put(Constants.productid, jobj.getString(Constants.productid));
                inventoryjson.put("quantity", dquantity);
                inventoryjson.put("description", description);
                if (jobj.has("uomid")) {
                    inventoryjson.put("uomid", jobj.getString("uomid"));
                }

                inventoryjson.put("baseuomrate", baseuomrate);
                inventoryjson.put("baseuomquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                inventoryjson.put("carryin", false);
                inventoryjson.put("defective", false);
                inventoryjson.put("newinventory", false);
                inventoryjson.put(Constants.companyKey, companyid);
                try {
                    inventoryjson.put("updatedate", authHandler.getDateOnlyFormat().parse(paramJobj.get(Constants.BillDate).toString()));
                } catch (ParseException ex) {
                    Calendar cal = Calendar.getInstance();
                    long billDate = (long) Long.parseLong(paramJobj.get(Constants.BillDate).toString());
                    cal.setTimeInMillis(billDate);
                    Date calDate = null;
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    calDate = authHandler.getDateOnlyFormat().parse(CalString);

                    Date updatebillDate = calDate;
                    inventoryjson.put("updatedate", updatebillDate);
                }//catch

                KwlReturnObject invresult = accProductObj.addInventory(inventoryjson);
                Inventory inventory = (Inventory) invresult.getEntityList().get(0);

                dodDataMap.put("Inventory", inventory);
                if (jobj.has("rate")) {
                    dodDataMap.put("rate", jobj.getString("rate"));
                }
                KwlReturnObject result = accInvoiceDAOobj.saveDeliveryOrderDetails(dodDataMap);
                DeliveryOrderDetail row = (DeliveryOrderDetail) result.getEntityList().get(0);
                if (!StringUtil.isNullOrEmpty(paramJobj.optString("fromPOS"))) {

                    KwlReturnObject warehouseObj = accountingHandlerDAOobj.getObject(InventoryWarehouse.class.getName(), paramJobj.optString("POSwarehouseID", null));
                    InventoryWarehouse store = (InventoryWarehouse) warehouseObj.getEntityList().get(0);
                    inventory.getProduct().setWarehouse(store);
                    jobj.put("batchdetails", getdefaultBatchJson(inventory.getProduct(), null, row.getID(), inventory.getQuantity()));
                    if (jobj.has("batchdetails") && jobj.getString("batchdetails") != null) {
                        String batchDetails = jobj.getString("batchdetails");
                        
                        if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true && product.isIsBatchForProduct() && product.isIsSerialForProduct()) {
                            JSONObject jsobj = accProductModuleService.manipulateBatchDetailsforMobileApps(batchDetails, inventory.getProduct().getID(), paramJobj);
                            if (jsobj.get("batchdetails") != null && !StringUtil.isNullOrEmpty(jsobj.optString("batchdetails", null))) {
                                batchDetails = jsobj.getString("batchdetails");
                            }
                        }
                        
                        if (!StringUtil.isNullOrEmpty(batchDetails)) {
                            try {
                                saveDONewBatchJson(batchDetails, inventory, paramJobj, row, stockMovementsList, false, false, false, "");
                            } catch (UnsupportedEncodingException ex) {
                                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }
                    }
                } else {

                    if (jobj.has("batchdetails") && jobj.getString("batchdetails") != null) {
                        String batchDetails = jobj.getString("batchdetails");
                        
                        if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true && product.isIsBatchForProduct() && product.isIsSerialForProduct()) {
                            JSONObject jsobj = accProductModuleService.manipulateBatchDetailsforMobileApps(batchDetails, inventory.getProduct().getID(), paramJobj);
                            if (jsobj.get("batchdetails") != null && !StringUtil.isNullOrEmpty(jsobj.optString("batchdetails", null))) {
                                batchDetails = jsobj.getString("batchdetails");
                            }
                        }
                        
                        if (!StringUtil.isNullOrEmpty(batchDetails)) {
                            ProductBatch productBatch = saveDOBatch(batchDetails, inventory, null);
                            if (productBatch != null) {
                                dodDataMap.put("batch", productBatch.getId());
                                dodDataMap.put(Constants.Acc_id, row.getID());
                                result = accInvoiceDAOobj.saveDeliveryOrderDetails(dodDataMap);
                                row = (DeliveryOrderDetail) result.getEntityList().get(0);
                            }
                        }
                    }
                }
                String customfield = jobj.has(Constants.customfield) ? jobj.getString(Constants.customfield) : "";
                if (!StringUtil.isNullOrEmpty(customfield)) {
                    HashMap<String, Object> DOMap = new HashMap<String, Object>();
                    JSONArray jcustomarray = new JSONArray(customfield);

                    HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                    customrequestParams.put("customarray", jcustomarray);
                    customrequestParams.put("modulename", "DeliveryOrderDetail");
                    customrequestParams.put("moduleprimarykey", "DeliveryOrderDetailId");
                    customrequestParams.put("modulerecid", row.getID());
                    customrequestParams.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                    customrequestParams.put(Constants.companyKey, companyid);
                    DOMap.put(Constants.Acc_id, row.getID());
                    customrequestParams.put("customdataclasspath", Constants.Acc_DeliveryOrderDetail_custom_data_classpath);
                    KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                    if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                        DOMap.put("dodetailscustomdataref", row.getID());
                        accInvoiceDAOobj.updateDODetailsCustomData(DOMap);
                    }
                }

                rows.add(row);
            }
            if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateInventoryTab() && !stockMovementsList.isEmpty() && !StringUtil.isNullOrEmpty(paramJobj.optString("fromPOS"))) {
                stockMovementService.addOrUpdateBulkStockMovement(deliveryOrder.getCompany(), deliveryOrder.getID(), stockMovementsList);
            }
            JSONObject invjson = new JSONObject();
            invjson.put("invoiceid", invoiceid);
            accInvoiceDAOobj.updateInvoice(invjson, invcdetails);
        } catch (JSONException ex) {
            throw ServiceException.FAILURE("saveDeliveryOrderRows : " + ex.getMessage(), ex);
        } catch (ParseException ex) {
            throw ServiceException.FAILURE("saveDeliveryOrder : " + ex.getMessage(), ex);
        }
        return rows;
    }

    public ProductBatch saveDOBatch(String batchJSON, Inventory inventory, HttpServletRequest request) throws JSONException, ParseException, SessionExpiredException, ServiceException {
        JSONArray jArr = new JSONArray(batchJSON);

        KwlReturnObject kmsg = null;
        String purchasebatchid = "";
        DateFormat df = authHandler.getDateOnlyFormat(request);
        for (int i = 0; i < 1; i++) {
            HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
            pdfTemplateMap.put("name", jSONObject.getString("batch"));
            if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                pdfTemplateMap.put("mfgdate", df.parse(jSONObject.getString("mfgdate")));
            }
            if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                pdfTemplateMap.put("expdate", df.parse(jSONObject.getString("expdate")));
            }
            pdfTemplateMap.put("quantity", jSONObject.getString("quantity"));
            pdfTemplateMap.put("balance", jSONObject.getString("balance"));
            pdfTemplateMap.put("location", jSONObject.getString("location"));
            pdfTemplateMap.put("product", inventory.getProduct().getID());
            pdfTemplateMap.put("warehouse", jSONObject.getString("warehouse"));
            purchasebatchid = jSONObject.getString("purchasebatchid");
            pdfTemplateMap.put("isopening", false);
            pdfTemplateMap.put("transactiontype", "3");//This is DO Type Tranction 
            pdfTemplateMap.put("ispurchase", false);
            kmsg = accCommonTablesDAO.saveBatchForProduct(pdfTemplateMap);
        }
        ProductBatch productBatch = null;
        String productBatchId = "";
        if (kmsg.getEntityList().size() != 0) {
            productBatch = (ProductBatch) kmsg.getEntityList().get(0);
            productBatchId = productBatch.getId();
            HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
            pdfTemplateMap.put("purchasebatchid", purchasebatchid);
            pdfTemplateMap.put("salesbatchid", productBatch.getId());
            kmsg = accCommonTablesDAO.saveBatchMapping(pdfTemplateMap);
        }

        for (int i = 0; i < jArr.length(); i++) {
            HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            pdfTemplateMap.put(Constants.Acc_id, jSONObject.getString("serialnoid"));
            pdfTemplateMap.put("name", jSONObject.getString("serialno"));
            if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                pdfTemplateMap.put("expfromdate", df.parse(jSONObject.getString("expstart")));
            }
            if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                pdfTemplateMap.put("exptodate", df.parse(jSONObject.getString("expend")));
            }
            pdfTemplateMap.put("batch", productBatchId);
            kmsg = accCommonTablesDAO.saveSerialForBatch(pdfTemplateMap);

            if (kmsg.getEntityList().size() != 0) {
                BatchSerial batchSerial = (BatchSerial) kmsg.getEntityList().get(0);
                String salesSerial = batchSerial.getId();
                pdfTemplateMap = new HashMap<String, Object>();
                pdfTemplateMap.put("purchaseserialid", jSONObject.getString("purchaseserialid"));
                pdfTemplateMap.put("salesserialid", salesSerial);
                kmsg = accCommonTablesDAO.saveSalesPurchaseSerialMapping(pdfTemplateMap);
            }

        }
        return productBatch;
    }

    private void deleteAssetDetailsForDO(String doId, String companyId) throws ServiceException {
        HashMap<String, Object> requestMap = new HashMap<String, Object>();
        requestMap.put(Constants.companyKey, companyId);
        requestMap.put("doid", doId);
        requestMap.put("deleteMappingAlso", true);
        accInvoiceDAOobj.deleteAssetDetailsLinkedWithDeliveryOrder(requestMap);
    }

    private void deleteDOContractMappings(String doId, String companyId) throws ServiceException {
        HashMap<String, Object> requestMap = new HashMap<String, Object>();
        requestMap.put(Constants.companyKey, companyId);
        requestMap.put("doid", doId);
        accInvoiceDAOobj.deleteDOContractMappings(requestMap);
    }

    private Set<DOContractMapping> getDOContractMappings(JSONObject paramJobj, DeliveryOrder deliveryOrder) throws ServiceException, AccountingException, JSONException {
        String[] salesOrderIds = paramJobj.getString("linkNumber").split(",");
        Set<DOContractMapping> contractMappings = new HashSet<DOContractMapping>();
        for (int i = 0; i < salesOrderIds.length; i++) {
            if (!StringUtil.isNullOrEmpty(salesOrderIds[i])) {
                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), salesOrderIds[i]);
                SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);

                // Check if sales order is created by linking with Replacement, if it is then fetch Linked replacement Object and put it in docontractmapping
                ProductReplacement productReplacement = null;
                if (salesOrder.isIsReplacementSO()) {
                    HashMap<String, Object> soMap = new HashMap<String, Object>();
                    soMap.put("salesOrderId", salesOrder.getID());
                    KwlReturnObject productReplacementObj = accSalesOrderDAOObj.getProductReplacementsLinkedWithSalesOrder(soMap);

                    List productReplacementList = productReplacementObj.getEntityList();

                    if (!productReplacementList.isEmpty()) {
                        KwlReturnObject productReplacementObj1 = accountingHandlerDAOobj.getObject(ProductReplacement.class.getName(), (String) productReplacementList.get(0));
                        productReplacement = (ProductReplacement) productReplacementObj1.getEntityList().get(0);
                        System.out.println(productReplacement.getReplacementRequestNumber());
                    }
                }
                Contract contract = salesOrder.getContract();
                Company company = salesOrder.getCompany();
                if (contract != null) {
                    DOContractMapping contractMapping = new DOContractMapping();
                    contractMapping.setCompany(company);
                    contractMapping.setContract(contract);
                    contractMapping.setDeliveryOrder(deliveryOrder);
                    contractMapping.setSalesOrder(salesOrder);

                    if (productReplacement != null) {
                        contractMapping.setProductReplacement(productReplacement);
                    }

                    contractMappings.add(contractMapping);
                }
            }
        }
        return contractMappings;
    }

    public void sendRequestToCRMForUpdatingProductReplacementStatus(JSONObject paramJobj, JSONArray crmArray) throws JSONException, SessionExpiredException , ServiceException{
        if (crmArray.length() > 0) {
            String companyid = paramJobj.getString(Constants.companyKey);
            JSONObject crmJson = new JSONObject();
            crmJson.put(Constants.data, crmArray);
            JSONObject userData = new JSONObject();
            userData.put("iscommit", true);
            userData.put("remoteapikey", StorageHandler.GetRemoteAPIKey());
            userData.put(Constants.useridKey, paramJobj.getString(Constants.lid));
            userData.put(Constants.companyKey, companyid);
            userData.put("requestStatusDetails", crmArray);
//            String crmURL = paramJobj.getString(Constants.crmURL);
            String crmURL = URLUtil.buildRestURL(Constants.crmURL);
            crmURL = crmURL + "master/replacementformstatus";            
            apiCallHandlerService.restPostMethod(crmURL, userData.toString());
//            try {
//                JSONObject resObj = apiCallHandlerService.callApp(crmURL, userData, companyid, "204");
//            } catch (Exception ex) {
//                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
//            }
        }
    }

    public void validateHeaders(JSONArray validateJArray) throws AccountingException, ServiceException {
        try {

            List<String> list = new ArrayList<String>();
            list.add("Transaction Number");
            list.add("Transaction Date");
            list.add("Amount");
            list.add("Due Date");
            list.add("Customer Code");
            list.add("Currency");

            List<String> fileHeaderList = new ArrayList<String>();

            for (int i = 0; i < validateJArray.length(); i++) {
                String header = validateJArray.getJSONObject(i).getString("header").trim();
                fileHeaderList.add(header);
            }

            // iterating for manadatory columns
            for (String manadatoryField : list) {
                if (!fileHeaderList.contains(manadatoryField)) {
                    throw new AccountingException(manadatoryField + " column is not availabe in file");
                }
            }

        } catch (JSONException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
    }

    public JSONObject importOeningTransactionsRecords(HttpServletRequest request, JSONObject jobj) throws AccountingException, IOException, SessionExpiredException, JSONException {

        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("import_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = txnManager.getTransaction(def);
        boolean commitedEx = false;
        boolean issuccess = true;
        String msg = "";
        FileInputStream fileInputStream = null;
        BufferedReader br = null;
        int total = 0, failed = 0;
        String companyid = sessionHandlerImpl.getCompanyid(request);
        String gcurrencyId = sessionHandlerImpl.getCurrencyID(request);
        String userId = sessionHandlerImpl.getUserid(request);
        String fileName = jobj.getString("name");

        JSONObject returnObj = new JSONObject();

        try {

            String dateFormat = null, dateFormatId = request.getParameter("dateFormat");
            if (!StringUtil.isNullOrEmpty(dateFormatId)) {

                KwlReturnObject kdfObj = accountingHandlerDAOobj.getObject(KWLDateFormat.class.getName(), dateFormatId);
                KWLDateFormat kdf = (KWLDateFormat) kdfObj.getEntityList().get(0);

                dateFormat = kdf != null ? kdf.getJavaForm() : null;
            }

            DateFormat df = new SimpleDateFormat(dateFormat);

            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);

            fileInputStream = new FileInputStream(jobj.getString("FilePath"));
            br = new BufferedReader(new InputStreamReader(fileInputStream));
            String record = "";
            int cnt = 0;

            double externalCurrencyRate = 0d;

            StringBuilder failedRecords = new StringBuilder();

            JSONArray jSONArray = jobj.getJSONArray("Header");
            List headArrayList = new ArrayList();
            for (int i = 0; i < jSONArray.length(); i++) {
                JSONObject jSONObject = jSONArray.getJSONObject(i);
                headArrayList.add(jSONObject.get("header"));
            }

            failedRecords.append(createCSVrecord(headArrayList.toArray()) + "\"Error Message\"");//failedRecords.append("\"Row No.\","+createCSVrecord(fileData)+"\"Error Message\"");

            HashMap<String, Object> requestParams = AccountingManager.getGlobalParams(request);

            while ((record = br.readLine()) != null) {
                if (cnt != 0) {

                    String[] recarr = record.split(",");
                    try {
                        double exchangeRateForOpeningTransaction = 1;

                        int customerCodeIndex = headArrayList.indexOf("Customer Code");

                        String customerCode = recarr[customerCodeIndex].trim();
                        if (!StringUtil.isNullOrEmpty(customerCode)) {
                            customerCode = customerCode.replaceAll("\"", "");
                        } else {
                            throw new AccountingException("Customer Code is not available");
                        }

                        String accountId = "";
                        String customerId = "";
                        Customer customer = getCustomerByCode(customerCode, companyid);
                        if (customer != null) {
                            accountId = customer.getAccount().getID();
                            customerId = customer.getID();
                        } else {
                            throw new AccountingException("Customer is not found for Customer Code " + customerCode);
                        }

                        HashMap currencyMap = getCurrencyMap();

                        int invoiceNumberIndex = headArrayList.indexOf("Transaction Number");

                        String invoiceNumber = recarr[invoiceNumberIndex].trim();
                        if (!StringUtil.isNullOrEmpty(invoiceNumber)) {
                            invoiceNumber = invoiceNumber.replaceAll("\"", "");
                        } else {
                            throw new AccountingException("Transaction Number is not available");
                        }

                        int transactionDateIndex = headArrayList.indexOf("Transaction Date");

                        String transactionDateStr = recarr[transactionDateIndex].trim();
                        if (!StringUtil.isNullOrEmpty(transactionDateStr)) {
                            transactionDateStr = transactionDateStr.replaceAll("\"", "");
                        } else {
                            throw new AccountingException("Transaction Date is not available");
                        }

                        Date transactionDate = null;

                        if (!StringUtil.isNullOrEmpty(transactionDateStr)) {
                            transactionDate = df.parse(transactionDateStr);
                        }

                        if (transactionDate.after(preferences.getFinancialYearFrom()) || transactionDate.equals(preferences.getFinancialYearFrom())) {
                            throw new AccountingException("Transaction date must be before Financial Year Start Date.");
                        }

                        int transactionAmountIndex = headArrayList.indexOf("Amount");

                        String transactionAmountStr = recarr[transactionAmountIndex].trim();
                        if (!StringUtil.isNullOrEmpty(transactionAmountStr)) {
                            transactionAmountStr = transactionAmountStr.replaceAll("\"", "");
                        } else {
                            throw new AccountingException("Transaction Amount is not available");
                        }

                        int dueDateIndex = headArrayList.indexOf("Due Date");

                        String dueDateStr = recarr[dueDateIndex].trim();
                        if (!StringUtil.isNullOrEmpty(dueDateStr)) {
                            dueDateStr = dueDateStr.replaceAll("\"", "");
                        } else {
                            throw new AccountingException("Due Date is not available");
                        }

                        int exchangeRateIndex = headArrayList.indexOf("Exchange Rate");

                        String exchangeRateForOpeningTransactionStr = "";
                        if (exchangeRateIndex > 0) {
                            exchangeRateForOpeningTransactionStr = recarr[exchangeRateIndex].trim();

                            if (!StringUtil.isNullOrEmpty(exchangeRateForOpeningTransactionStr)) {
                                exchangeRateForOpeningTransactionStr = exchangeRateForOpeningTransactionStr.replaceAll("\"", "");
                            }
                        }

                        int currencyIndex = headArrayList.indexOf("Currency");

                        String currencyStr = recarr[currencyIndex].trim();
                        if (!StringUtil.isNullOrEmpty(currencyStr)) {
                            currencyStr = currencyStr.replaceAll("\"", "");
                        } else {
                            throw new AccountingException("Currency is not available");
                        }

                        String currencyId = getCurrencyId(currencyStr, currencyMap);

                        if (StringUtil.isNullOrEmpty(currencyId)) {
                            throw new AccountingException("Currency format you entered is not correct. it should be like \"SG Dollar (SGD)\"");
                        }

                        int porefIndex = headArrayList.indexOf("Purchase Order Number");

                        String porefNo = "";

                        if (porefIndex > 0) {
                            String porefStr = recarr[porefIndex].trim();
                            if (!StringUtil.isNullOrEmpty(porefStr)) {
                                porefNo = porefStr.replaceAll("\"", "");
                            }
                        }

                        int porefDateIndex = headArrayList.indexOf("Purchase Order Date");

                        Date poRefDate = transactionDate;

                        if (porefDateIndex > 0) {
                            String porefStr = recarr[porefDateIndex].trim();
                            if (!StringUtil.isNullOrEmpty(porefStr)) {
                                poRefDate = df.parse(porefStr);
                            }
                        }

                        if (poRefDate.after(preferences.getFinancialYearFrom()) || poRefDate.equals(preferences.getFinancialYearFrom())) {
                            throw new AccountingException("Purchase order date must be before Financial Year Start Date.");
                        }

                        Date lastModifiedDate = df.parse(df.format(new Date()));
                        Date dueDate = df.parse(df.format(new Date()));

                        if (!StringUtil.isNullOrEmpty(dueDateStr)) {
                            dueDate = df.parse(dueDateStr);
                        }

                        if (!StringUtil.isNullOrEmpty(exchangeRateForOpeningTransactionStr)) {
                            exchangeRateForOpeningTransaction = Double.parseDouble(exchangeRateForOpeningTransactionStr);
                        } else {
                            Map<String, Object> currMap = new HashMap<String, Object>();
                            Date finYrStartDate = preferences.getFinancialYearFrom();
                            Calendar cal = Calendar.getInstance();
                            cal.setTime(finYrStartDate);
                            cal.add(Calendar.DATE, -1);

                            Date calDate = null;
                            try {
                                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                                calDate = authHandler.getDateOnlyFormat().parse(CalString);
                            } catch (ParseException e) {
                                calDate = cal.getTime();
                            }
                            Date applyDate = calDate;

                            currMap.put("applydate", applyDate);
                            currMap.put(Constants.globalCurrencyKey, gcurrencyId);
                            currMap.put(Constants.companyKey, companyid);
                            KwlReturnObject retObj = accCurrencyDAOobj.getExcDetailID(currMap, currencyId, applyDate, null);
                            if (retObj != null) {
                                List li = retObj.getEntityList();
                                if (!li.isEmpty()) {
                                    Iterator itr = li.iterator();
                                    ExchangeRateDetails erd = (ExchangeRateDetails) itr.next();
                                    if (erd != null) {
                                        exchangeRateForOpeningTransaction = erd.getExchangeRate();
                                    }
                                }
                            }
                        }

                        if (exchangeRateForOpeningTransaction <= 0) {
                            throw new AccountingException("Exchange Rate cannot be zero or negative");
                        }

                        double transactionAmount = 0d;
                        if (!StringUtil.isNullOrEmpty(transactionAmountStr)) {
                            transactionAmount = Double.parseDouble(transactionAmountStr);
                        }

                        // creating invoice json
                        JSONObject invjson = new JSONObject();

                        KwlReturnObject result = accInvoiceDAOobj.getInvoiceCount(invoiceNumber, companyid);
                        int nocount = result.getRecordTotalCount();
                        if (nocount > 0) {
                            throw new AccountingException("Invoice number '" + invoiceNumber + "' already exists.");
                        }

                        invjson.put("entrynumber", invoiceNumber);
                        invjson.put("autogenerated", false);

                        KwlReturnObject ERresult = accCurrencyDAOobj.getExcDetailID(requestParams, currencyId, transactionDate, null);
                        ExchangeRateDetails erd = (ExchangeRateDetails) ERresult.getEntityList().get(0);
                        String erdid = (erd == null) ? null : erd.getID();
                        invjson.put("erdid", erdid);
                        invjson.put("shipaddress", "");
                        invjson.put("porefno", porefNo);
                        invjson.put(Constants.duedate, dueDate);
                        invjson.put("poRefDate", poRefDate);
                        invjson.put(Constants.companyKey, companyid);
                        invjson.put(Constants.currencyKey, currencyId);
                        invjson.put("externalCurrencyRate", externalCurrencyRate);
                        invjson.put("partialinv", false);
                        invjson.put(Constants.customerid, customerId);
                        invjson.put("accountid", accountId);
                        invjson.put("billto", "");
                        invjson.put("creationDate", transactionDate);
                        invjson.put("lastModifiedDate", lastModifiedDate);
                        invjson.put("isOpeningBalenceInvoice", true);
                        invjson.put("isNormalInvoice", false);
                        invjson.put("originalOpeningBalanceAmount", transactionAmount);
                        invjson.put("openingBalanceAmountDue", transactionAmount);
                        invjson.put(Constants.originalOpeningBalanceBaseAmount, authHandler.round(transactionAmount * externalCurrencyRate, companyid));
                        invjson.put(Constants.openingBalanceBaseAmountDue, authHandler.round(transactionAmount * externalCurrencyRate, companyid));
                        invjson.put("exchangeRateForOpeningTransaction", exchangeRateForOpeningTransaction);

                        invjson.put(Constants.Checklocktransactiondate, request.getParameter(Constants.BillDate));
                        accInvoiceDAOobj.addInvoice(invjson, new HashSet());
                    } catch (Exception ex) {
                        failed++;
                        String errorMsg = ex.getMessage();
                        try {
                            JSONObject errorLog = new JSONObject(errorMsg);
                            errorMsg = errorLog.getString("errorMsg");
                        } catch (JSONException jex) {
                        }
                        failedRecords.append("\n" + createCSVrecord(recarr) + "\"" + errorMsg.replaceAll("\"", "") + "\"");
                    }
                    total++;
                }
                cnt++;
            }

            if (failed > 0) {
                createFailureFiles(fileName, failedRecords, ".csv");
            }

            int success = total - failed;
            if (total == 0) {
                msg = messageSource.getMessage("acc.field.Emptyfile", null, RequestContextUtils.getLocale(request));
            } else if (success == 0) {
                msg = messageSource.getMessage("acc.rem.169", null, RequestContextUtils.getLocale(request));
            } else if (success == total) {
                msg = messageSource.getMessage("acc.rem.168", null, RequestContextUtils.getLocale(request));
            } else {
                msg = messageSource.getMessage("acc.field.Imported", null, RequestContextUtils.getLocale(request)) + success + messageSource.getMessage("acc.field.record", null, RequestContextUtils.getLocale(request)) + (success > 1 ? "s" : "") + messageSource.getMessage("acc.field.successfully.", null, RequestContextUtils.getLocale(request));
                msg += (failed == 0 ? "." : messageSource.getMessage("acc.field.andfailedtoimport", null, RequestContextUtils.getLocale(request)) + failed + messageSource.getMessage("acc.field.record", null, RequestContextUtils.getLocale(request)) + (failed > 1 ? "s" : "") + ".");
            }

            try {
                txnManager.commit(status);
            } catch (Exception ex) {
                commitedEx = true;
                throw ex;
            }
        } catch (Exception ex) {
            if (!commitedEx) { //if exception occurs during commit then dont call rollback
                txnManager.rollback(status);
            }
            issuccess = false;
            msg = "" + ex.getMessage();

            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw new AccountingException("Error While Importing Records.");
        } finally {
            fileInputStream.close();
            br.close();

            DefaultTransactionDefinition ldef = new DefaultTransactionDefinition();
            ldef.setName("import_Tx");
            ldef.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
            TransactionStatus lstatus = txnManager.getTransaction(ldef);
            try {
                //Insert Integration log
                HashMap<String, Object> logDataMap = new HashMap<String, Object>();
                logDataMap.put("FileName", getActualFileName(fileName));
                logDataMap.put("StorageName", fileName);
                logDataMap.put("Log", msg);
                logDataMap.put("Type", "csv");
                logDataMap.put("FailureFileType", failed > 0 ? "csv" : "");
                logDataMap.put("TotalRecs", total);
                logDataMap.put("Rejected", failed);
                logDataMap.put("Module", "2");
                logDataMap.put("ImportDate", new Date());
                logDataMap.put("User", userId);
                logDataMap.put("Company", companyid);
                importDao.saveImportLog(logDataMap);
                txnManager.commit(lstatus);
            } catch (Exception ex) {
                txnManager.rollback(lstatus);
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }

            try {
                returnObj.put(Constants.RES_success, issuccess);
                returnObj.put(Constants.RES_msg, msg);
                returnObj.put("totalrecords", total);
                returnObj.put("successrecords", total - failed);
                returnObj.put("failedrecords", failed);
                returnObj.put("filename", getActualFileName(fileName));
            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        return returnObj;
    }

    public String createCSVrecord(Object[] listArray) {
        String rec = "";
        for (int i = 0; i < listArray.length; i++) {    //Discard columns id at index 0 and isvalid,invalidColumns, validationlog at last 3 indexes.
            rec += "\"" + (listArray[i] == null ? "" : listArray[i].toString().replaceAll("\"", "")) + "\",";
        }
        return rec;
    }

    public static String getActualFileName(String storageName) {
        String ext = storageName.substring(storageName.lastIndexOf("."));
        String actualName = storageName.substring(0, storageName.lastIndexOf("_"));
        actualName = actualName + ext;
        return actualName;
    }

    @Override 
    public Customer getCustomerByCode(String customerCode, String companyID) {
        Customer customer = null;
        try {
            if (!StringUtil.isNullOrEmpty(customerCode) && !StringUtil.isNullOrEmpty(companyID)) {
                KwlReturnObject retObj = accCustomerDAOObj.getCustomerByCode(customerCode, companyID);
                if (retObj != null && !retObj.getEntityList().isEmpty()) {
                    customer = (Customer) retObj.getEntityList().get(0);
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            try {
                throw new AccountingException("System Failure while fetching customer");
            } catch (AccountingException ex1) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex1);
            }
        }
        return customer;
    }

    public HashMap getCurrencyMap() throws ServiceException {
        HashMap currencyMap = new HashMap();
        KwlReturnObject returnObject = accCurrencyDAOobj.getCurrencies(currencyMap);
        List currencyList = returnObject.getEntityList();

        if (currencyList != null && !currencyList.isEmpty()) {
            Iterator iterator = currencyList.iterator();
            while (iterator.hasNext()) {
                KWLCurrency currency = (KWLCurrency) iterator.next();
                currencyMap.put(currency.getName(), currency.getCurrencyID());
            }
        }
        return currencyMap;
    }

    private String getCurrencyId(String currencyName, HashMap currencyMap) {
        String currencyId = "";
        if (currencyMap != null && currencyMap.containsKey(currencyName)) {
            currencyId = currencyMap.get(currencyName).toString();
        }
        return currencyId;
    }

    public void createFailureFiles(String filename, StringBuilder failedRecords, String ext) {
        String destinationDirectory;
        try {
            destinationDirectory = storageHandlerImpl.GetDocStorePath() + "importplans";
            if (StringUtil.isNullOrEmpty(ext)) {
                ext = filename.substring(filename.lastIndexOf("."));
            }
            filename = filename.substring(0, filename.lastIndexOf("."));

            java.io.FileOutputStream failurefileOut = new java.io.FileOutputStream(destinationDirectory + "/" + filename + ImportLog.failureTag + ext);
            failurefileOut.write(failedRecords.toString().getBytes());
            failurefileOut.flush();
            failurefileOut.close();
        } catch (Exception ex) {
            System.out.println("\nError file write [success/failed] " + ex);
        }
    }

    private Set<InvoiceContractMapping> getInvoiceContractMappings(JSONObject jobj, Invoice invoice) throws ServiceException, JSONException {
        String[] deliveryOrderIds = jobj.getString("linkNumber").split(",");
        Set<InvoiceContractMapping> contractMappings = new HashSet<InvoiceContractMapping>();
        for (int i = 0; i < deliveryOrderIds.length; i++) {
            if (!StringUtil.isNullOrEmpty(deliveryOrderIds[i])) {
                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), deliveryOrderIds[i]);
                DeliveryOrder deliveryOrder = (DeliveryOrder) rdresult.getEntityList().get(0);

                Set<DOContractMapping> dOContractMappings = deliveryOrder.getdOContractMappings();
                if (!dOContractMappings.isEmpty()) {
                    List<String> contractMappingDuplicateCheckList = new ArrayList<String>();

                    /*
                     * DO can be create by linking with multiple sales order.
                     * and each sales order may point to different Contract. so
                     * for a single DO there may be multiple Contracts. and
                     * docontractmapping table may contain duplicate values of
                     * contract.
                     */
                    for (DOContractMapping contractMapping : dOContractMappings) {
                        if (!contractMappingDuplicateCheckList.contains(contractMapping.getContract().getID())) {
                            contractMappingDuplicateCheckList.add(contractMapping.getContract().getID());
                            InvoiceContractMapping invoiceContractMapping = new InvoiceContractMapping();
                            invoiceContractMapping.setCompany(invoice.getCompany());
                            invoiceContractMapping.setContract(contractMapping.getContract());
                            invoiceContractMapping.setDeliveryOrder(deliveryOrder);
                            invoiceContractMapping.setInvoice(invoice);
                            contractMappings.add(invoiceContractMapping);
                        }
                    }
                }
            }
        }
        return contractMappings;
    }

    private Set<InvoiceContractMapping> getInvoiceContractMappings(HttpServletRequest request, Invoice invoice) throws ServiceException {
        String[] deliveryOrderIds = request.getParameter("linkNumber").split(",");
        Set<InvoiceContractMapping> contractMappings = new HashSet<InvoiceContractMapping>();
        for (int i = 0; i < deliveryOrderIds.length; i++) {
            if (!StringUtil.isNullOrEmpty(deliveryOrderIds[i])) {
                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), deliveryOrderIds[i]);
                DeliveryOrder deliveryOrder = (DeliveryOrder) rdresult.getEntityList().get(0);

                Set<DOContractMapping> dOContractMappings = deliveryOrder.getdOContractMappings();
                if (!dOContractMappings.isEmpty()) {
                    List<String> contractMappingDuplicateCheckList = new ArrayList<String>();

                    /*
                     * DO can be create by linking with multiple sales order.
                     * and each sales order may point to different Contract. so
                     * for a single DO there may be multiple Contracts. and
                     * docontractmapping table may contain duplicate values of
                     * contract.
                     */
                    for (DOContractMapping contractMapping : dOContractMappings) {
                        if (!contractMappingDuplicateCheckList.contains(contractMapping.getContract().getID())) {
                            contractMappingDuplicateCheckList.add(contractMapping.getContract().getID());
                            InvoiceContractMapping invoiceContractMapping = new InvoiceContractMapping();
                            invoiceContractMapping.setCompany(invoice.getCompany());
                            invoiceContractMapping.setContract(contractMapping.getContract());
                            invoiceContractMapping.setDeliveryOrder(deliveryOrder);
                            invoiceContractMapping.setInvoice(invoice);
                            contractMappings.add(invoiceContractMapping);
                        }
                    }
                }
            }
        }
        return contractMappings;
    }

    private void deleteAssetDetails(Invoice invoice, String companyId,boolean updateFlag) throws ServiceException {
        HashMap<String, Object> requestMap = new HashMap<String, Object>();
        requestMap.put(Constants.companyKey, companyId);
        requestMap.put("invoiceid", invoice.getID());
        requestMap.put("deleteMappingAlso", true);
        requestMap.put("updateFlag", updateFlag);
        accInvoiceDAOobj.deleteAssetDetailsLinkedWithInvoice(requestMap);
    }

    private void deleteInvoiceContractMappings(Invoice invoice, String companyId) throws ServiceException {
        HashMap<String, Object> requestMap = new HashMap<String, Object>();
        requestMap.put(Constants.companyKey, companyId);
        requestMap.put("invoiceid", invoice.getID());
        accInvoiceDAOobj.deleteInvoiceContractMappings(requestMap);
    }

    private Set<InvoiceContractMapping> getInvoiceContractMappingsWithoutDO(Invoice invoice, String contractId) throws ServiceException {
        Set<InvoiceContractMapping> contractMappings = new HashSet<InvoiceContractMapping>();

        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(Contract.class.getName(), contractId);
        if (!rdresult.getEntityList().isEmpty()) {
            Contract contract = (Contract) rdresult.getEntityList().get(0);
            InvoiceContractMapping invoiceContractMapping = new InvoiceContractMapping();
            invoiceContractMapping.setCompany(invoice.getCompany());
            invoiceContractMapping.setContract(contract);
            invoiceContractMapping.setInvoice(invoice);
            contractMappings.add(invoiceContractMapping);

        }
        return contractMappings;
    }

    private Set<InvoiceContractMapping> getInvoiceContractMappingsWithoutDO(HttpServletRequest request, Invoice invoice, String contractId) throws ServiceException {
        Set<InvoiceContractMapping> contractMappings = new HashSet<InvoiceContractMapping>();

        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(Contract.class.getName(), contractId);
        if (!rdresult.getEntityList().isEmpty()) {
            Contract contract = (Contract) rdresult.getEntityList().get(0);
            InvoiceContractMapping invoiceContractMapping = new InvoiceContractMapping();
            invoiceContractMapping.setCompany(invoice.getCompany());
            invoiceContractMapping.setContract(contract);
            invoiceContractMapping.setInvoice(invoice);
            contractMappings.add(invoiceContractMapping);

        }
        return contractMappings;
    }

    @Override
    public JSONObject deleteInvoice(HttpServletRequest request, HttpServletResponse response) {
        JSONObject paramJObj = new JSONObject();
        JSONObject jobj = new JSONObject();
        String msg = "";
        boolean issuccess = true;
        try {
            try {
                Enumeration<String> attributes = request.getAttributeNames();
                while (attributes.hasMoreElements()) {
                    String attribute = attributes.nextElement();
                    paramJObj.put(attribute, request.getAttribute(attribute));
                }
                Enumeration<String> parameters = request.getParameterNames();
                while (parameters.hasMoreElements()) {
                    String parameter = parameters.nextElement();
                    paramJObj.put(parameter, request.getParameter(parameter));
                }
            } catch (JSONException e) {
                e.printStackTrace();
            }
            String companyid = sessionHandlerImpl.getCompanyid(request);
            paramJObj.put(Constants.companyKey, companyid);
            paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
            jobj = deleteInvoiceJson(paramJObj);

        } catch (SessionExpiredException ex) {
            msg = ex.getMessage();
            issuccess = false;
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            issuccess = false;
            msg = "" + (ex.getMessage() != null ? ex.getMessage() : ex.getCause().getMessage());
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
                jobj.put("linkedTransaction", "");
            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return jobj;
    }

    @Override
    public JSONObject deleteInvoiceJson(JSONObject paramJObj) throws JSONException, ServiceException {
        JSONObject jobj = new JSONObject();
        String msg = "";
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("R_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        String linkedTransaction = "";
        TransactionStatus status = txnManager.getTransaction(def);
        try {
            linkedTransaction = deleteInvoicePermanentJson(paramJObj);
            txnManager.commit(status);
            if (StringUtil.isNullOrEmpty(linkedTransaction)) {
                msg = messageSource.getMessage("acc.rem.179", null, Locale.forLanguageTag(paramJObj.getString(Constants.language))); //"Invoice(s) has been deleted successfully";
            } else {
                msg = messageSource.getMessage("acc.field.Invoicesexcept", null, Locale.forLanguageTag(paramJObj.getString(Constants.language))) + " " + linkedTransaction.substring(0, linkedTransaction.length() - 2) + " " + messageSource.getMessage("acc.field.hasbeendeletedsuccessfully", null, Locale.forLanguageTag(paramJObj.getString(Constants.language)));
            }
            jobj.put(Constants.RES_msg, msg);
            jobj.put(Constants.RES_success, true);
            jobj.put("linkedTransaction", linkedTransaction);
        } catch (SessionExpiredException ex) {
            txnManager.rollback(status);
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        } catch (JSONException ex) {
            txnManager.rollback(status);
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw new JSONException(ex.getMessage());
        } catch (Exception ex) {
            txnManager.rollback(status);
            msg = "" + (ex.getMessage() != null ? ex.getMessage() : ex.getCause().getMessage());
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return jobj;
    }

    @Override
    public void saveNewConsignSRBatch(String batchJSON, Inventory inventory, HttpServletRequest request, SalesReturnDetail salesReturnDetail, List<Consignment> ConsignmentList, List<StockMovement> stockMovementsListForConsignment) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        double ActbatchQty = 1;
        double batchQty = 0;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        boolean isConsignment = false;
        String purchaseBatchId = "";
        String purchaseSerialId = "";
        String batchWarehouse = "";
        String batchLocation = "";
        String dobatchId = "";
        DateFormat df = authHandler.getDateOnlyFormat(request);
        String companyid = sessionHandlerImpl.getCompanyid(request);
        if (!StringUtil.isNullOrEmpty(request.getParameter(Constants.isConsignment))) {
            isConsignment = Boolean.parseBoolean(request.getParameter(Constants.isConsignment));
        }
        boolean isQAinspection = false;
        if (!StringUtil.isNullOrEmpty(request.getParameter("isQAinspection"))) {//this flag is for saving consignment return and it will true if return quantity will go through QA Inspection process otherwise it will be false
            isQAinspection = Boolean.parseBoolean(request.getParameter("isQAinspection"));
        }
        ConsignmentApprovalDetails cad = null;
        Consignment consignmentobj = new Consignment();
        Set<ConsignmentApprovalDetails> consignDetailsSet = new HashSet<ConsignmentApprovalDetails>();
        StockMovementDetail smd = null;
        StockMovement stockMovement = null;
        Map<Store, StockMovement> storeWiseStockMovement = new HashMap<Store, StockMovement>();
        if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), inventory.getProduct().getID());
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
        }

        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        String batchname = "";

        if (isWarehouseForProduct && isLocationForProduct) {

            consignmentobj.setCompany(inventory.getCompany());
            consignmentobj.setProduct(inventory.getProduct());
            consignmentobj.setUom(inventory.getProduct().getUnitOfMeasure());
            consignmentobj.setReturnQuantity(authHandler.calculateBaseUOMQuatity(salesReturnDetail.getReturnQuantity(), salesReturnDetail.getBaseuomrate(), companyid));
            consignmentobj.setTransactionNo(salesReturnDetail.getSalesReturn().getSalesReturnNumber());
            consignmentobj.setCustomer(salesReturnDetail.getSalesReturn().getCustomer());
            consignmentobj.setDocumentid(salesReturnDetail.getID());
            consignmentobj.setModuleRefId(salesReturnDetail.getSalesReturn().getID());
            consignmentobj.setUnitPrice(salesReturnDetail.getRate() / salesReturnDetail.getBaseuomrate());
        }
        for (int i = 0; i < jArr.length(); i++) {
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            if (jSONObject.has("quantity") && !jSONObject.getString("quantity").equals("undefined") && !jSONObject.getString("quantity").isEmpty()) {
                ActbatchQty = jSONObject.getDouble("quantity");
            }
            NewProductBatch neproductbatch = null;

            if (!StringUtil.isNullOrEmpty(jSONObject.getString("purchasebatchid")) && !StringUtil.isNullOrEmpty(jSONObject.getString("batch"))) {
                purchaseBatchId = accCommonTablesDAO.getpurchaseBatchIdForSR(jSONObject.getString("purchasebatchid"), StringUtil.DecodeText(jSONObject.optString("batch")));
                KwlReturnObject capresult = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), purchaseBatchId);
                neproductbatch = (NewProductBatch) capresult.getEntityList().get(0);
                if (neproductbatch != null) {
                    batchLocation = neproductbatch.getLocation() != null ? neproductbatch.getLocation().getId() : "";
                    batchWarehouse = neproductbatch.getWarehouse() != null ? neproductbatch.getWarehouse().getId() : "";
                }
            } else if (!StringUtil.isNullOrEmpty(jSONObject.getString("purchasebatchid")) && isConsignment && StringUtil.isNullOrEmpty(jSONObject.getString("batch"))) {
                purchaseBatchId = jSONObject.getString("purchasebatchid");
                dobatchId = accCommonTablesDAO.getpurchaseBatchIdForNonbatch(jSONObject.getString("purchasebatchid"), StringUtil.DecodeText(jSONObject.optString("batch")), jSONObject.getString(Constants.productid));
                if (!StringUtil.isNullOrEmpty(dobatchId)) {
                    KwlReturnObject capresult = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), dobatchId);
                    neproductbatch = (NewProductBatch) capresult.getEntityList().get(0);
                    if (neproductbatch != null) {
                        batchLocation = neproductbatch.getLocation() != null ? neproductbatch.getLocation().getId() : "";
                        batchWarehouse = neproductbatch.getWarehouse() != null ? neproductbatch.getWarehouse().getId() : "";
                    }
                }
            }
            KwlReturnObject warehouseObj = null;
            Location locationObj = null;
            Store store = null;
            if (!StringUtil.isNullOrEmpty(batchWarehouse)) {
                warehouseObj = accountingHandlerDAOobj.getObject(Store.class.getName(), batchWarehouse);
                store = (Store) warehouseObj.getEntityList().get(0);
            }
            if (store != null) {
                consignmentobj.setStore(store);
            } else {
                if (salesReturnDetail.getDodetails() != null) {
                    String doDetailId = salesReturnDetail.getDodetails().getID();
                    String storeId = null;
                    if (!StringUtil.isNullOrEmpty(doDetailId)) {
                        storeId = accCommonTablesDAO.getStoreIdForNonbatchSerialByDODetailId(companyid, doDetailId);
                        if (!StringUtil.isNullOrEmpty(storeId)) {
                            warehouseObj = accountingHandlerDAOobj.getObject(Store.class.getName(), storeId);
                            store = (Store) warehouseObj.getEntityList().get(0);
                            consignmentobj.setStore(store);
                        }
                        String locationId = null;
                        locationId = accCommonTablesDAO.getLocationIdForNonbatchSerialByDODetailId(companyid, doDetailId);
                        if (!StringUtil.isNullOrEmpty(locationId)) {
                            KwlReturnObject locationdetails = accountingHandlerDAOobj.getObject(Location.class.getName(), locationId);
                            locationObj = (Location) locationdetails.getEntityList().get(0);
                        }
                    }
                }
            }

            if (batchQty == 0) {
                batchQty = jSONObject.getDouble("quantity");
                if (StringUtil.isNullOrEmpty(batchWarehouse)) {
                    batchWarehouse = jSONObject.getString("warehouse");
                }
                if (isWarehouseForProduct && isLocationForProduct) {
                    if (storeWiseStockMovement.containsKey(store)) {
                        stockMovement = storeWiseStockMovement.get(store);
                        stockMovement.setQuantity(stockMovement.getQuantity() + jSONObject.optDouble("quantity", 0.0));
                    } else {
                        stockMovement = new StockMovement();
                        if (store != null) {
                            stockMovement.setStore(store);
                        }
                        stockMovement.setCompany(inventory.getCompany());
                        stockMovement.setProduct(inventory.getProduct());
                        stockMovement.setStockUoM(inventory.getProduct().getUnitOfMeasure());
                        stockMovement.setPricePerUnit(salesReturnDetail.getRate() / salesReturnDetail.getBaseuomrate());
                        stockMovement.setQuantity(jSONObject.optDouble("quantity", 0.0));
                        stockMovement.setTransactionDate(salesReturnDetail.getSalesReturn().getOrderDate());
                        stockMovement.setModuleRefId(salesReturnDetail.getSalesReturn().getID());
                        stockMovement.setModuleRefDetailId(salesReturnDetail.getID());
                        stockMovement.setCustomer(salesReturnDetail.getSalesReturn().getCustomer());
                        stockMovement.setCostCenter(salesReturnDetail.getSalesReturn().getCostcenter());
                        stockMovement.setTransactionNo(salesReturnDetail.getSalesReturn().getSalesReturnNumber());
                        stockMovement.setTransactionModule(TransactionModule.ERP_SALES_RETURN);
                        stockMovement.setTransactionType(TransactionType.IN);
                        stockMovement.setMemo(salesReturnDetail.getSalesReturn().getMemo());
                        storeWiseStockMovement.put(store, stockMovement);
                    }
                }
            }
            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) && (batchQty == ActbatchQty)) {
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.getString("quantity"));
                documentMap.put("batchmapid", purchaseBatchId);
                documentMap.put("documentid", salesReturnDetail.getID());
                documentMap.put("transactiontype", "29");//This is GRN Type Tranction  
                documentMap.put(Constants.isConsignment, isConsignment);  // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                    documentMap.put("mfgdate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                    documentMap.put("expdate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("expdate")));
                }

                if (!StringUtil.isNullOrEmpty(batchLocation)) {
                    KwlReturnObject locationUpdate = accountingHandlerDAOobj.getObject(Location.class.getName(), batchLocation);
                    locationObj = (Location) locationUpdate.getEntityList().get(0);
                } else if (isWarehouseForProduct && isLocationForProduct && !isBatchForProduct && !isSerialForProduct && locationObj == null) {//taking Default location in this case of 
                    locationObj = locationService.getDefaultLocation(inventory.getCompany());
                }
                if (isWarehouseForProduct && isLocationForProduct) {
                    smd = new StockMovementDetail();
                    if (locationObj != null) {
                        smd.setLocation(locationObj);
                    }
                    if (isRowForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("row"));
                        StoreMaster row = (StoreMaster) krObject.getEntityList().get(0);
                        smd.setRow(row);
                    }
                    if (isRackForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("rack"));
                        StoreMaster rack = (StoreMaster) krObject.getEntityList().get(0);
                        smd.setRack(rack);
                    }
                    if (isBinForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("bin"));
                        StoreMaster bin = (StoreMaster) krObject.getEntityList().get(0);
                        smd.setBin(bin);
                    }
                    smd.setQuantity(Double.parseDouble(jSONObject.getString("quantity")));
                    smd.setBatchName("");
                    smd.setStockMovement(stockMovement);
                    stockMovement.getStockMovementDetails().add(smd);
                }

                if (!isBatchForProduct && !isSerialForProduct) {
                    HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                    filter_names.add("company.companyID");
                    filter_params.add(sessionHandlerImpl.getCompanyid(request));

                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("warehouse"))) {
                        String warehouse = jSONObject.getString("warehouse");
                        filter_names.add("warehouse.id");
                        filter_params.add(warehouse);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("location"))) {
                        String location = jSONObject.getString("location");
                        filter_names.add("location.id");
                        filter_params.add(location);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("row"))) {
                        String row = jSONObject.getString("row");
                        filter_names.add("row.id");
                        filter_params.add(row);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("rack"))) {
                        String rack = jSONObject.getString("rack");
                        filter_names.add("rack.id");
                        filter_params.add(rack);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("bin"))) {
                        String bin = jSONObject.getString("bin");
                        filter_names.add("bin.id");
                        filter_params.add(bin);
                    }

                    filter_names.add("product");
                    filter_params.add(inventory.getProduct().getID());
                    filterRequestParams.put("filter_names", filter_names);
                    filterRequestParams.put("filter_params", filter_params);
                    filterRequestParams.put("order_by", order_by);
                    filterRequestParams.put("order_type", order_type);
                    KwlReturnObject result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                    List listResult = result.getEntityList();
                    Iterator itrResult = listResult.iterator();
                    Double quantityToDue = ActbatchQty;
                    while (itrResult.hasNext()) {
                        NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                        if (quantityToDue > 0) {
                            double Qty = newProductBatch.getQuantity();
                            double dueQty = newProductBatch.getQuantitydue();
                            HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                            batchUpdateQtyMap.put(Constants.Acc_id, newProductBatch.getId());
                            if ((Qty - dueQty) > 0) {
                                if (quantityToDue > (Qty - dueQty)) {
                                    batchUpdateQtyMap.put("qty", String.valueOf(((Qty - dueQty))));
                                    quantityToDue = quantityToDue - (Qty - dueQty);
                                } else {
                                    batchUpdateQtyMap.put("qty", String.valueOf((quantityToDue)));
                                    quantityToDue = quantityToDue - quantityToDue;
                                }
                                documentMap.put("batchmapid", newProductBatch.getId());
                                accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);

                            }
                        }

                    }
                } else {
//To QA 
                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                    batchUpdateQtyMap.put("qty", isQAinspection ? "0" : String.valueOf((Double.parseDouble(jSONObject.getString("quantity")))));
                    batchUpdateQtyMap.put(Constants.Acc_id, purchaseBatchId);
                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                    if (!StringUtil.isNullOrEmpty(purchaseBatchId)) {
                        KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), purchaseBatchId);
                        NewProductBatch newProductBatch1 = (NewProductBatch) batchObj.getEntityList().get(0);
                        if (isWarehouseForProduct && isLocationForProduct) {
                            smd.setBatchName(newProductBatch1.getBatchname());
                        }
                    }
                }

                accCommonTablesDAO.saveBatchDocumentMapping(documentMap);

            } else if (isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) {
                if (!StringUtil.isNullOrEmpty(batchLocation)) {
                    KwlReturnObject locationUpdate = accountingHandlerDAOobj.getObject(Location.class.getName(), batchLocation);
                    locationObj = (Location) locationUpdate.getEntityList().get(0);
                }
            }
            batchQty--;

            if (isSerialForProduct) {  //if serial no option is on then only save the serial no details 

                if (!StringUtil.isNullOrEmpty(jSONObject.getString("purchaseserialid")) && !StringUtil.isNullOrEmpty(jSONObject.getString("serialno"))) {
                    purchaseSerialId = accCommonTablesDAO.getpurchaseSerialIdForSR(jSONObject.getString("purchaseserialid"), StringUtil.DecodeText(jSONObject.optString("serialno")));
                }
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", 1);
                documentMap.put("serialmapid", purchaseSerialId);
                documentMap.put("documentid", salesReturnDetail.getID());
                if (isConsignment) {
                    documentMap.put("transactiontype", "53");
                } else {
                    documentMap.put("transactiontype", "29");
                }
                documentMap.put(Constants.isConsignment, isConsignment); // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("expend")));
                }
                if (jSONObject.has("reusablecount") && !StringUtil.isNullOrEmpty(jSONObject.getString("reusablecount"))) {
                    documentMap.put("reusablecount", jSONObject.getString("reusablecount"));
                }
                KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), purchaseSerialId);
                NewBatchSerial nbs = (NewBatchSerial) batchObj.getEntityList().get(0);
                if (isSerialForProduct) {
                    cad = new ConsignmentApprovalDetails();
                    cad.setLocation(locationObj);
                    cad.setQuantity(1);
                    cad.setSerialName(nbs.getSerialname());
                    cad.setBatch(neproductbatch);
                    if (neproductbatch != null) {
                        batchname = neproductbatch.getBatchname();
                        cad.setBatchName(batchname);
                    } else {
                        cad.setBatchName(batchname);
                    }
                    cad.setConsignment(consignmentobj);
                    cad.setApprovalStatus(ApprovalStatus.PENDING);
                    cad.setPurchaseSerialId(nbs);
                    consignDetailsSet.add(cad);
                }
                accCommonTablesDAO.saveSerialDocumentMapping(documentMap);
                HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                serialUpdateQtyMap.put("qty", "1");
                serialUpdateQtyMap.put(Constants.Acc_id, purchaseSerialId);
                serialUpdateQtyMap.put("isQAinspection", isQAinspection);
                serialUpdateQtyMap.put("consignquantity", "-1");
                accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);
                KwlReturnObject serialObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), jSONObject.getString("purchaseserialid"));
                NewBatchSerial newBatchSerial = (NewBatchSerial) serialObj.getEntityList().get(0);
                if (newBatchSerial != null) {
                    if (isWarehouseForProduct && isLocationForProduct) {
                        smd.addSerialName(newBatchSerial.getSerialname());
                    }
                }
            } else {

                if (isWarehouseForProduct && isLocationForProduct && !isBatchForProduct && !isSerialForProduct && locationObj == null) {//taking Default location in this case of 
                    locationObj = locationService.getDefaultLocation(inventory.getCompany());
                    locationObj = locationService.getDefaultLocation(inventory.getCompany());
                }
                cad = new ConsignmentApprovalDetails();
                cad.setLocation(locationObj);
                cad.setQuantity(ActbatchQty);
                cad.setConsignment(consignmentobj);
                cad.setApprovalStatus(ApprovalStatus.PENDING);
                cad.setBatch(neproductbatch);
                if (isBatchForProduct) {
                    if (neproductbatch != null) {
                        batchname = neproductbatch.getBatchname();
                        cad.setBatchName(batchname);
                    } else {
                        cad.setBatchName(batchname);
                    }
                }
                consignDetailsSet.add(cad);
                batchQty = 0;
            }
        }
        if (isWarehouseForProduct && isLocationForProduct) {
            for (Map.Entry<Store, StockMovement> entry : storeWiseStockMovement.entrySet()) {
                stockMovementsListForConsignment.add(entry.getValue());
            }
        }
        consignmentobj.setConsignmentApprovalDetails(consignDetailsSet);
        ConsignmentList.add(consignmentobj);
    }


    @Override
    public Set<AssetDetails> saveAssetDetails(JSONObject paramJobj, String productId, String assetDetails, int assetSoldFlag, boolean isUsedFlag, boolean isFromInvoice, boolean isLeaseFixedAsset, boolean isFromSalesReturn, boolean isFixedAsset, boolean isFromPurchaseReturn, double profitLossAmt) throws SessionExpiredException, AccountingException, UnsupportedEncodingException {
        Set<AssetDetails> assetDetailsSet = new HashSet<AssetDetails>();
        try {
            JSONArray jArr = new JSONArray(assetDetails);
            String companyId = paramJobj.optString(Constants.companyKey);
            Date billdate = null;
            if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.BillDate))) {
                billdate = authHandler.getDateOnlyFormatter(paramJobj).parse(paramJobj.optString(Constants.BillDate));
            }
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jobj = jArr.getJSONObject(i);
                String assetId = StringUtil.DecodeText(jobj.optString("assetId"));
                double sellAmt = jobj.optDouble("sellAmount", 0);

                HashMap<String, Object> dataMap = new HashMap<String, Object>();

                KwlReturnObject DOObj = accountingHandlerDAOobj.getObject(AssetDetails.class.getName(), assetId);
                AssetDetails assetDetail = (AssetDetails) DOObj.getEntityList().get(0);
                String assetName = StringUtil.isNullOrEmpty(assetDetail.getAssetId()) ? "" : assetDetail.getAssetId();

                if (isFromSalesReturn && isFixedAsset) {
                    dataMap.put("assetDetailId", assetId);
                    dataMap.put("productId", productId);
                    dataMap.put("isSalesReturn", true); // in case of sales return return flag will be 1
                } else if (isFromPurchaseReturn && isFixedAsset) {
                    dataMap.put("assetDetailId", assetId);
                    dataMap.put("productId", productId);
                    dataMap.put("isPurchaseReturn", true); // in case of purchase return return flag will be 1
                } else if (isFromSalesReturn && isLeaseFixedAsset) {
                    dataMap.put("assetDetailId", assetId);
                    dataMap.put("productId", productId);
                    dataMap.put("isLinkedToLeaseSO", false);// in case of lease sales return flag will be 0
                } else {
                    if (isLeaseFixedAsset) {
                        if (isFromInvoice) {
                            dataMap.put("isLeaseInvoiceCreated", true);
                        } else {
                            dataMap.put("isLeaseDOCreated", true);
                        }
                    } else {
                        dataMap.put("isUsedFlag", isUsedFlag);// this flag is only for normal FA INVOICE AND FA DO
                    }
                    dataMap.put("assetDetailId", assetId);
                    dataMap.put("sellAmount", sellAmt);
                    dataMap.put("productId", productId);
                    dataMap.put("invrecord", true);
                    if(isFromInvoice && (assetSoldFlag==Constants.ASSET_SOLD_FROM_CI || assetSoldFlag==Constants.ASSET_SOLD_FROM_DO)){
                        dataMap.put("disposalProfitLoss", profitLossAmt);
                    }
                    dataMap.put("assetSoldFlag", assetSoldFlag);
                    if(billdate!=null){
                        dataMap.put("disposalDate", billdate);
                    }
                }
                dataMap.put("companyId", companyId);

                KwlReturnObject result = accProductObj.updateAssetDetails(dataMap);

                if (!isFromInvoice && jobj.has("batchdetails") && jobj.getString("batchdetails") != null) {
                    String batchDetails = jobj.getString("batchdetails");
                    if (!StringUtil.isNullOrEmpty(batchDetails) && !batchDetails.equalsIgnoreCase("null")) {
                        String assetMainId = assetId;
                        dataMap.put("assetDetailId", assetMainId);
                        ProductBatch productBatch = null;

                        if (isFromSalesReturn) {
                            productBatch = saveAssetSRBatch(batchDetails, assetMainId, productId, paramJobj);
                        } else {
                            saveAssetNewBatch(batchDetails, assetMainId, assetName, productId, isFromSalesReturn, isFromInvoice, assetId, paramJobj);
                        }
                    }
                }

                assetDetail = (AssetDetails) result.getEntityList().get(0);

                assetDetailsSet.add(assetDetail);

            }
        } catch (ServiceException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw new AccountingException("Error While Processing Data");
        } catch (ParseException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw new AccountingException("Error While Processing Data");
        } catch (JSONException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw new AccountingException("Error While Processing Data");
        }
        return assetDetailsSet;
    }

    public String deleteInvoicePermanent(HttpServletRequest request) throws ServiceException, AccountingException, SessionExpiredException, ParseException {
        JSONObject paramJObj = new JSONObject();
        try {
            Enumeration<String> attributes = request.getAttributeNames();
            while (attributes.hasMoreElements()) {
                String attribute = attributes.nextElement();
                paramJObj.put(attribute, request.getAttribute(attribute));
            }
            Enumeration<String> parameters = request.getParameterNames();
            while (parameters.hasMoreElements()) {
                String parameter = parameters.nextElement();
                paramJObj.put(parameter, request.getParameter(parameter));
            }
            paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
        } catch (JSONException e) {
            e.printStackTrace();
        }

        String linkedTransaction = deleteInvoicePermanentJson(paramJObj);
        return linkedTransaction;
    }

    public JSONArray getSalesCommissionProductDetailReportJson(JSONObject paramJobj) throws SessionExpiredException, ServiceException {
        JSONArray jArr = new JSONArray();
        try {
            HashMap requestParams = AccountingManager.getGlobalParams(paramJobj);
//            KwlReturnObject curresult = accountingHandlerDAOobj.getObject(KWLCurrency.class.getName(), AccountingManager.getGlobalCurrencyidFromRequest(request));
//            KWLCurrency currency = (KWLCurrency) curresult.getEntityList().get(0);
            String companyid = paramJobj.optString(Constants.companyKey);
            DateFormat df = authHandler.getDateFormatter(paramJobj);
//            HashMap requestParams = AccountingManager.getGlobalParams(request);
            String salesPersonIds = "";
            HashMap<String, Object> filterRequestParams1 = new HashMap<String, Object>();
            ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
            String salesPersonID = paramJobj.optString("salesPersonID", "");
            String[] salesPersonIdArray = salesPersonID.split(",");
            String start = paramJobj.optString(Constants.start);
            String limit = paramJobj.optString(Constants.limit);
            if (!StringUtil.isNullOrEmpty(salesPersonID) && !salesPersonID.equalsIgnoreCase("All")) {
                
                for (int i = 0; i < salesPersonIdArray.length; i++) {
                    salesPersonIds += "'" + salesPersonIdArray[i] + "',";
                }
                salesPersonIds = salesPersonIds.substring(0, salesPersonIds.length() - 1);
                requestParams.put("salesPersonIds", salesPersonIds);
            }
            String groupid="15";
            filter_names.add("masterGroup.ID");
            filter_params.add(groupid);
             if (!StringUtil.isNullOrEmpty(salesPersonID) && !salesPersonID.equalsIgnoreCase("All")) {
                 if(salesPersonIdArray.length > 1){
                 filter_names.add("INID");
                 filter_params.add(salesPersonIds);
                 } else {
                 filter_names.add("ID");
                 filter_params.add(salesPersonID);
                 }
             }
            
            filter_names.add("company.companyID");
            filter_params.add(companyid);
            order_by.add("value");
            order_type.add("asc");
            filterRequestParams1.put("filter_names", filter_names);
            filterRequestParams1.put("filter_params", filter_params);
            filterRequestParams1.put("order_by", order_by);
            filterRequestParams1.put("order_type", order_type);
            /*
            Add to get sales person for the company 
            */
            KwlReturnObject result = accMasterItemsDAOobj.getMasterItems(filterRequestParams1);
            List<MasterItem>listsalespersons = result.getEntityList();
            JSONArray salesComissionScehmaArr = new JSONArray();
            
            String productId = "";
            String customerID = "";
            String customerIDs = "";
            
            productId=paramJobj.optString("productID","");
            customerID=paramJobj.optString("customerID","");
            String[] customerIDArray = customerID.split(",");
            if (!StringUtil.isNullOrEmpty(customerID)) {
                
                for (int i = 0; i < customerIDArray.length; i++) {
                    customerIDs += "'" + customerIDArray[i] + "',";
                }
                customerIDs = customerIDs.substring(0, customerIDs.length() - 1);
                requestParams.put("customerID", customerIDs);
            }
            
            for(MasterItem masteritems :listsalespersons){
            HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
            int commissiontype=paramJobj.optInt("commissiontype");
            salesComissionScehmaArr = new JSONArray();
            double grandtotalquantity = 0.0;
            double grandcommissionAmount = 0.0;
            double grandcommissionAmountcommissionAmountInDoc = 0.0;
            double grandunitprice = 0.0;
            double grandgrouptotal = 0.0;
            ArrayList filter_names1 = new ArrayList(), filter_params1 = new ArrayList(), order_by1 = new ArrayList(), order_type1 = new ArrayList();
            filter_names1.add("company.companyID");
            filter_params1.add(companyid);
//            if(!StringUtil.isNullOrEmpty(salesPersonID) && !salesPersonID.equalsIgnoreCase("All")){
            filter_names1.add("INschemaItem");
            String x = masteritems.getID();
            String y= "'"+x+"'";
            filter_params1.add(y);
            
            filter_names1.add("commissiontype");
            filter_params1.add(commissiontype);
            order_by1.add("lowerlimit");
            order_by1.add("upperlimit");
            order_type1.add("asc");
            order_type1.add("asc");
            filterRequestParams.put("filter_names", filter_names1);
            filterRequestParams.put("filter_params", filter_params1);
            filterRequestParams.put("order_by", order_by1);
            filterRequestParams.put("order_type", order_type1);
            /*
            Add to get product commission schema set for sales person 
            */
            KwlReturnObject salesCommissionResult = accMasterItemsDAOobj.getsalesComissionScehma(filterRequestParams);
            List<SalesComissionScehma> listSales = salesCommissionResult.getEntityList();
            for (SalesComissionScehma salesComissionScehma : listSales) {
//                salesComissionScehmaArr = new JSONArray();
                
                requestParams.put(InvoiceConstants.deleted, paramJobj.optString(InvoiceConstants.deleted));
                requestParams.put(InvoiceConstants.nondeleted, paramJobj.optString(InvoiceConstants.nondeleted));
                requestParams.put(Constants.ss, paramJobj.optString(Constants.ss));
                requestParams.put(Constants.REQ_startdate, paramJobj.optString(Constants.REQ_startdate));
                requestParams.put(Constants.REQ_enddate, paramJobj.optString(Constants.REQ_enddate));
//                requestParams.put(Constants.start, request.getParameter(Constants.start));
//                requestParams.put(Constants.limit, request.getParameter(Constants.limit));
                requestParams.put("commissiontype", commissiontype);
                requestParams.put("itemid", salesComissionScehma.getSchemaItem());
                /*
                Add to get invoices for sales person  
                */
                KwlReturnObject invResult = accInvoiceDAOobj.getInvoicesForSalesCommission(requestParams);
                List<Invoice> invList = invResult.getEntityList();
                for (Invoice inv : invList) {
                    Set<InvoiceDetail> invoiceDetails = inv.getRows();
                    for (InvoiceDetail invoiceDetail : invoiceDetails) {
                        String salescommisionproductid = salesComissionScehma.getProductId();
                        String invoiceProductId = invoiceDetail.getInventory().getProduct().getID();
                        double commissionpercentage = salesComissionScehma.getAmount();
                        if (!StringUtil.isNullOrEmpty(productId) && !productId.contains(invoiceProductId)) {
                            continue;
                        }
                        /*
                        check will be true when invoice product id and commission rule set for product are matching
                        json will be created in that case only
                        */
                        if (invoiceProductId.equalsIgnoreCase(salescommisionproductid)) {
                            double commissionAmount = 0.0;
                            double quantity = invoiceDetail.getInventory().getQuantity();
                            double unitprice = invoiceDetail.getRate();
                            double total=0.0;
                            double totalinbasecurrency=0.0;
                            double unitpriceinbase=0.0;
                            String tranCurrencyId=inv.getCurrency()!= null?inv.getCurrency().getCurrencyID():"" ;
//                            double exchangerate = 0.0;
                            double rowexcludinggstamountinbase = invoiceDetail.getRowExcludingGstAmountInBase();
                            Date invoiceCreationDate = inv.getCreationDate();
                            JSONObject obj = new JSONObject();
                            obj.put("invoiceID", inv.getID());
                            obj.put("invoiceNo", inv.getInvoiceNumber());
                            obj.put("invoiceDate", (inv.getCreationDate() != null) ? df.format(inv.getCreationDate()) : "");
                            obj.put("jeID", (inv.getJournalEntry() != null) ? inv.getJournalEntry().getID() : "");
                            obj.put("jeNo", (inv.getJournalEntry() != null) ? inv.getJournalEntry().getEntryNumber() : "");

                            obj.put("customer", (inv.getCustomer() != null) ? inv.getCustomer().getName() : "");
                            obj.put("salesPerson", (inv.getMasterSalesPerson() != null) ? inv.getMasterSalesPerson().getValue() : "");
                            obj.put(Constants.currencyKey,inv.getCurrency().getCurrencyID());
                            obj.put("currencysymbol", inv.getCurrency().getSymbol());
                            obj.put("currencysymboltransaction", inv.getCurrency() != null ? inv.getCurrency().getSymbol() : "");
                            obj.put("productName", invoiceDetail.getInventory().getProduct().getName());
                            obj.put("uomname",invoiceDetail.getInventory().getUom().getName());
                            obj.put("quantity", authHandler.round(quantity,companyid));
                            HashMap<String, Object> requestparam = new HashMap();
                            requestparam.put(Constants.companyid, companyid);
                            requestparam.put("invoiceid", inv.getID());
                            requestparam.put(Constants.globalCurrencyKey,paramJobj.optString(Constants.globalCurrencyKey));
                            if(!tranCurrencyId.equalsIgnoreCase(paramJobj.optString(Constants.globalCurrencyKey))){
                            KwlReturnObject bamt=accCurrencyDAOobj.getCurrencyToBaseAmount(requestparam, unitprice, tranCurrencyId, invoiceCreationDate, 0);
                            unitpriceinbase = authHandler.round((Double) bamt.getEntityList().get(0), companyid);
                            } else {
                                unitpriceinbase=unitprice;
                            }
                            obj.put("unitprice", authHandler.round(unitprice,companyid));
                            obj.put("salesPerson", inv.getMasterSalesPerson().getValue());
//                                     obj.put("productName", invoiceDetail.getInventory().getProduct().getName());
                            total=quantity * unitprice;
                            totalinbasecurrency=quantity * unitpriceinbase;
                            commissionAmount = commissionAmount + (totalinbasecurrency * commissionpercentage) / 100.00;
                            
                            obj.put("total", authHandler.round(total,companyid));
//                                    obj.put("totalCommissionAmount", commissionAmount);
                            HashMap<String, Object> requestParam = new HashMap();
                            requestParam.put("invoiceid", inv.getID());
                            requestParam.put(Constants.companyid, companyid);
                            requestParam.put(Constants.globalCurrencyKey,paramJobj.optString(Constants.globalCurrencyKey));
                            KwlReturnObject bAmt1 = accCurrencyDAOobj.getBaseToCurrencyAmount(requestParam, commissionAmount, inv.getCurrency().getCurrencyID(), invoiceCreationDate, 0);
                            double commissionAmountInDoc = authHandler.round((Double) bAmt1.getEntityList().get(0), companyid);
                            obj.put("totalCommissionAmount", authHandler.round(commissionAmount, companyid));
                            obj.put("totalCommissionAmountInDoc", commissionAmountInDoc);
                            obj.put("categoryName", "Grand");
                            grandtotalquantity += quantity;
                            grandcommissionAmount+=commissionAmount;
                            grandcommissionAmountcommissionAmountInDoc+=commissionAmountInDoc;
                            grandunitprice+=unitprice;
                            grandgrouptotal+=total;
//                            obj.put("grandtotalquantity", grandtotalquantity);
                            salesComissionScehmaArr.put(obj);
                        }
                    }
                }

            }
                for (int jObjCount = 0; jObjCount < salesComissionScehmaArr.length(); jObjCount++) {
                    JSONObject oldObject = (JSONObject) salesComissionScehmaArr.get(jObjCount);
                    oldObject.put("grandtotalquantity", grandtotalquantity);
                    oldObject.put("grandcommissionAmount", grandcommissionAmount);
                    oldObject.put("grandcommissionAmountInDoc", grandcommissionAmountcommissionAmountInDoc);
                    oldObject.put("grandunitprice", grandunitprice);
                    oldObject.put("grandgrouptotal", grandgrouptotal);
//                    oldObject.put("grandtotalquantity", grandtotalquantity);
                    jArr.put(oldObject);
                }
            }
        } catch (Exception ex) {

            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
        return jArr;
    }
    public String deleteInvoicePermanentJson(JSONObject paramJobj) throws ServiceException, AccountingException, SessionExpiredException, ParseException {
        String linkedTransaction = "";
        try {
            JSONArray jArr = paramJobj.getJSONArray(Constants.data);
            String companyid = paramJobj.getString(Constants.companyKey);
            String invoiceid = "", journalentryid = "", entryno = "", invoiceno = "";
            boolean isFixedAsset = false;
            boolean isLeaseFixedAsset = false;
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jobj = jArr.getJSONObject(i);
                invoiceno = jobj.getString("invoiceno");
                invoiceid = accInvoiceDAOobj.getInvoiceId(companyid, invoiceno);
                KwlReturnObject res = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                Invoice invoice = (Invoice) res.getEntityList().get(0);
                if (invoice != null) {
                    entryno = invoice.getJournalEntry().getEntryNumber();
                    invoiceno = invoice.getInvoiceNumber();
                    journalentryid = invoice.getJournalEntry().getID();
                    Date entryDateForLock = null;
                    entryDateForLock = invoice.getJournalEntry().getEntryDate();
                    HashMap<String, Object> requestParams = new HashMap<String, Object>();
                    requestParams.put("invoiceid", invoiceid);
                    requestParams.put(Constants.companyKey, companyid);
                    requestParams.put("entryno", entryno);
                    requestParams.put("journalentryid", journalentryid);
                    requestParams.put(Constants.isFixedAsset, isFixedAsset);
                    requestParams.put(Constants.isLeaseFixedAsset, isLeaseFixedAsset);
                    if (entryDateForLock != null) {
                        requestParams.put("entrydate", entryDateForLock);
                    }
                    KwlReturnObject result;
                    if (!StringUtil.isNullOrEmpty(invoiceid)) {

                        List list = new ArrayList();
                        result = accInvoiceDAOobj.getReceiptFromInvoice(invoiceid, companyid);
                        list = result.getEntityList();
                        if (!list.isEmpty()) {
                            linkedTransaction += invoiceno + ", ";
                            continue;
                        }

                        result = accJournalEntryobj.permanentDeleteJournalEntryDetailReval(invoiceid, companyid);
                        result = accJournalEntryobj.permanentDeleteJournalEntryReval(invoiceid, companyid);
                        accInvoiceDAOobj.deleteInvoicePermanent(requestParams);
                    }
                }
            }
        } catch (JSONException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw new AccountingException("Cannot extract data from client");
        }
        return linkedTransaction;
    }

    @Override
    public Set<AssetInvoiceDetailMapping> saveAssetInvoiceDetailMapping(String invoiceDetailId, Set<AssetDetails> assetDetailsSet, String companyId, int moduleId) throws AccountingException {
        Set<AssetInvoiceDetailMapping> assetInvoiceDetailMappings = new HashSet<AssetInvoiceDetailMapping>();
        try {
            for (AssetDetails assetDetails : assetDetailsSet) {
                HashMap<String, Object> dataMap = new HashMap<String, Object>();
                dataMap.put("invoiceDetail", invoiceDetailId);
                dataMap.put("moduleId", moduleId);
                dataMap.put("assetDetails", assetDetails.getId());
                dataMap.put("company", companyId);
                KwlReturnObject object = accProductObj.saveAssetInvoiceDetailMapping(dataMap);

                AssetInvoiceDetailMapping detailMapping = (AssetInvoiceDetailMapping) object.getEntityList().get(0);
                assetInvoiceDetailMappings.add(detailMapping);
            }
        } catch (ServiceException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw new AccountingException("Error while processing data.");
        }
        return assetInvoiceDetailMappings;
    }

    public ProductBatch saveAssetSRBatch(String batchJSON, String assetId, String productId,JSONObject paramJobj) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException {
        JSONArray jArr = new JSONArray(batchJSON);

        KwlReturnObject kmsg = null;
        String purchasebatchid = "";
        boolean isSerialForProduct = false;
        DateFormat df = authHandler.getDateOnlyFormat();
        String companyId = paramJobj.optString(Constants.companyKey);

        for (int i = 0; i < jArr.length(); i++) {
            HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            pdfTemplateMap.put(Constants.companyKey, companyId);
            pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("batch")));
            if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                pdfTemplateMap.put("mfgdate", df.parse(jSONObject.getString("mfgdate")));
            }
            if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                pdfTemplateMap.put("expdate", df.parse(jSONObject.getString("expdate")));
            }
            pdfTemplateMap.put("quantity", jSONObject.getString("quantity"));
            pdfTemplateMap.put("balance", jSONObject.getString("balance"));
            pdfTemplateMap.put("location", jSONObject.getString("location"));
            pdfTemplateMap.put("product", productId);
            pdfTemplateMap.put("asset", assetId);   //stored the assetid of the 
            pdfTemplateMap.put("warehouse", jSONObject.getString("warehouse"));
            purchasebatchid = jSONObject.getString("purchasebatchid");
            pdfTemplateMap.put("isopening", false);
            pdfTemplateMap.put("transactiontype", "4");//This is DO Type Tranction 
            pdfTemplateMap.put("ispurchase", false);
            kmsg = accCommonTablesDAO.saveBatchForProduct(pdfTemplateMap);
        }
        ProductBatch productBatch = null;
        String productBatchId = "";
        if (kmsg!=null && !(kmsg.getEntityList().isEmpty())) {
            productBatch = (ProductBatch) kmsg.getEntityList().get(0);
            productBatchId = productBatch.getId();
            HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
            pdfTemplateMap.put("batchtomap", purchasebatchid);
            pdfTemplateMap.put("batchmap", productBatch.getId());
            pdfTemplateMap.put("returntype", "1");
            kmsg = accCommonTablesDAO.saveReturnBatchMapping(pdfTemplateMap);
        }
        if (isSerialForProduct) {
            for (int i = 0; i < jArr.length(); i++) {
                HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
                pdfTemplateMap.put(Constants.Acc_id, jSONObject.getString("serialnoid"));
                pdfTemplateMap.put(Constants.companyKey, companyId);
                pdfTemplateMap.put("product", productId);
                pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("serialno")));
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                    pdfTemplateMap.put("expfromdate", df.parse(jSONObject.getString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                    pdfTemplateMap.put("exptodate", df.parse(jSONObject.getString("expend")));
                }
                pdfTemplateMap.put("batch", productBatchId);
                pdfTemplateMap.put("transactiontype", "4");//This is DO Type Tranction 
                pdfTemplateMap.put("ispurchase", false);
                kmsg = accCommonTablesDAO.saveSerialForBatch(pdfTemplateMap);

                if (kmsg.getEntityList().size() != 0) {
                    BatchSerial batchSerial = (BatchSerial) kmsg.getEntityList().get(0);
                    String salesSerial = batchSerial.getId();
                    pdfTemplateMap = new HashMap<String, Object>();
                    pdfTemplateMap.put("maptoserialid", jSONObject.getString("purchaseserialid"));
                    pdfTemplateMap.put("mapserialid", salesSerial);
                    pdfTemplateMap.put("returntype", "1");
                    kmsg = accCommonTablesDAO.saveReturnSerialMapping(pdfTemplateMap);
                    accCommonTablesDAO.deleteSalesPurchaseSerialMapping(jSONObject.getString("purchaseserialid"));
                }

            }
        }
        return productBatch;
    }

    public void saveAssetNewBatch(String batchJSON, String assetId, String assetName, String productId, boolean isFromSalesReturn, boolean isFromInvoice, String documentId, JSONObject paramJobj) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        double ActbatchQty = 1;
        double batchQty = 0;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        DateFormat df = authHandler.getDateOnlyFormat();
        String companyid = paramJobj.optString(Constants.companyKey);
        String transType = "0";
        if (!StringUtil.isNullOrEmpty(paramJobj.optString("transType",null))) {
            transType = paramJobj.optString("transType");
        }

        KwlReturnObject capresult = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
        CompanyAccountPreferences preferences = (CompanyAccountPreferences) capresult.getEntityList().get(0);

        if (!StringUtil.isNullOrEmpty(productId)) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), productId);
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
        }

        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        for (int i = 0; i < jArr.length(); i++) {
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            if (jSONObject.has("quantity") && !jSONObject.getString("quantity").equals("undefined") && !jSONObject.getString("quantity").isEmpty()) {
                ActbatchQty = jSONObject.getDouble("quantity");
            }
            if (batchQty == 0) {
                batchQty = jSONObject.getDouble("quantity");
            }
            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) && (batchQty == ActbatchQty)) {
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.getString("quantity"));

                documentMap.put("documentid", documentId);
                documentMap.put("transactiontype", transType);//This is DO Type Tranction  
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                    documentMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                    documentMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expdate")));
                }
                documentMap.put("batchmapid", jSONObject.getString("purchasebatchid"));

                if (!isBatchForProduct && !isSerialForProduct) {
                    HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                    filter_names.add("company.companyID");
                    filter_params.add(companyid);

                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("warehouse"))) {
                        String warehouse = jSONObject.getString("warehouse");
                        filter_names.add("warehouse.id");
                        filter_params.add(warehouse);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("location"))) {
                        String location = jSONObject.getString("location");
                        filter_names.add("location.id");
                        filter_params.add(location);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("row"))) {
                        String row = jSONObject.getString("row");
                        filter_names.add("row.id");
                        filter_params.add(row);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("rack"))) {
                        String rack = jSONObject.getString("rack");
                        filter_names.add("rack.id");
                        filter_params.add(rack);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("bin"))) {
                        String bin = jSONObject.getString("bin");
                        filter_names.add("bin.id");
                        filter_params.add(bin);
                    }

                    filter_names.add("product");
                    filter_params.add(productId);
                    if (!StringUtil.isNullOrEmpty(assetId)) {
                        filter_names.add("asset");
                        filter_params.add(assetId);
                    }

                    filterRequestParams.put("filter_names", filter_names);
                    filterRequestParams.put("filter_params", filter_params);
                    filterRequestParams.put("order_by", order_by);
                    filterRequestParams.put("order_type", order_type);
                    KwlReturnObject result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                    List listResult = result.getEntityList();
                    Iterator itrResult = listResult.iterator();
                    Double quantityToDue = ActbatchQty;
                    while (itrResult.hasNext()) {
                        NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                        if (quantityToDue > 0) {
                            double dueQty = newProductBatch.getQuantitydue();
                            HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                            batchUpdateQtyMap.put(Constants.Acc_id, newProductBatch.getId());
                            if (dueQty > 0) {
                                if (quantityToDue > dueQty) {
                                    batchUpdateQtyMap.put("qty", String.valueOf(-(dueQty)));
                                    quantityToDue = quantityToDue - dueQty;

                                } else {
                                    batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));
                                    quantityToDue = quantityToDue - quantityToDue;

                                }
                                documentMap.put("batchmapid", newProductBatch.getId());
                                accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);

                            }
                        }

                    }
                } else {

                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                    batchUpdateQtyMap.put("qty", String.valueOf(-(Double.parseDouble(jSONObject.getString("quantity")))));
                    batchUpdateQtyMap.put(Constants.Acc_id, jSONObject.getString("purchasebatchid"));
                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);

                }
                accCommonTablesDAO.saveBatchDocumentMapping(documentMap);
            }
            batchQty--;

            if (isSerialForProduct) {  //if serial no option is on then only save the serial no details 

                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", 1);
                documentMap.put("serialmapid", jSONObject.getString("purchaseserialid"));
                documentMap.put("documentid", documentId);
                documentMap.put("transactiontype", transType);//This is GRN Type Tranction  
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expend")));
                }

                KwlReturnObject krObj = accCommonTablesDAO.saveSerialDocumentMapping(documentMap);
                SerialDocumentMapping serialDocumentMapping = (SerialDocumentMapping) krObj.getEntityList().get(0);
                if (jSONObject.has(Constants.customfield)) {
                    String customfield = jSONObject.getString(Constants.customfield);
                    if (!StringUtil.isNullOrEmpty(customfield)) {
                        HashMap<String, Object> DOMap = new HashMap<String, Object>();
                        JSONArray jcustomarray = new JSONArray(customfield);

                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        customrequestParams.put("customarray", jcustomarray);
                        customrequestParams.put("modulename", "SerialDocumentMapping");
                        customrequestParams.put("moduleprimarykey", "SerialDocumentMappingId");
                        customrequestParams.put("modulerecid", serialDocumentMapping.getId());
                        customrequestParams.put(Constants.moduleid, Constants.SerialWindow_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        DOMap.put(Constants.Acc_id, serialDocumentMapping.getId());
                        customrequestParams.put("customdataclasspath", Constants.Acc_Serial_custom_data_classpath);
                        KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                        if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                            DOMap.put("serialcustomdataref", serialDocumentMapping.getId());
                            accCommonTablesDAO.updateserialcustomdata(DOMap);
                        }
                    }
                }
                HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                serialUpdateQtyMap.put("qty", "-1");

                serialUpdateQtyMap.put(Constants.Acc_id, jSONObject.getString("purchaseserialid"));
                accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);

            } else {
                batchQty = 0;
            }
        }

    }

    @Override
    public void saveNewSRBatch(String batchJSON, Inventory inventory, HttpServletRequest request, SalesReturnDetail salesReturnDetail, List<StockMovement> stockMovementsList) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        double ActbatchQty = 1;
        double batchQty = 0;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        boolean isConsignment = false;
        boolean isnegativestockforlocwar = false;
        KwlReturnObject kmsg = null;
        DateFormat df = authHandler.getDateOnlyFormat(request);
        String companyid = sessionHandlerImpl.getCompanyid(request);
        if (!StringUtil.isNullOrEmpty(request.getParameter(Constants.isConsignment))) {
            isConsignment = Boolean.parseBoolean(request.getParameter(Constants.isConsignment));
        }
        boolean isQAinspection = false;
        if (!StringUtil.isNullOrEmpty(request.getParameter("isQAinspection"))) {//this flag is for saving consignment return and it will true if return quantity will go through QA Inspection process otherwise it will be false
            isQAinspection = Boolean.parseBoolean(request.getParameter("isQAinspection"));
        }
        ExtraCompanyPreferences extraCompanyPreferences = null;
        KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), sessionHandlerImpl.getCompanyid(request));
        extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
        isnegativestockforlocwar = extraCompanyPreferences.isIsnegativestockforlocwar();

        if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), inventory.getProduct().getID());
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
        }

        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        StockMovementDetail smd = null;
        StockMovement stockMovement = null;
        NewProductBatch productBatch = null;
        String productBatchId = "";
        Map<Store, StockMovement> storeWiseStockMovement = new HashMap<Store, StockMovement>();
        for (int i = 0; i < jArr.length(); i++) {
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            if (jSONObject.has("quantity") && !jSONObject.getString("quantity").equals("undefined") && !jSONObject.getString("quantity").isEmpty()) {
                ActbatchQty = jSONObject.getDouble("quantity");
            }
            String stockType = jSONObject.has("stocktype") ? jSONObject.getString("stocktype") : "";
            if (batchQty == 0) {
                batchQty = jSONObject.getDouble("quantity");

                KwlReturnObject warehouseObj = accountingHandlerDAOobj.getObject(Store.class.getName(), jSONObject.getString("warehouse"));
                Store store = (Store) warehouseObj.getEntityList().get(0);
                if (isWarehouseForProduct && isLocationForProduct) {
                    if (storeWiseStockMovement.containsKey(store)) {
                        stockMovement = storeWiseStockMovement.get(store);
                        stockMovement.setQuantity(stockMovement.getQuantity() + jSONObject.optDouble("quantity", 0.0));
                    } else {
                        stockMovement = new StockMovement();
                        if (store != null) {
                            stockMovement.setStore(store);
                        }
                        stockMovement.setCompany(inventory.getCompany());
                        stockMovement.setProduct(inventory.getProduct());
                        stockMovement.setStockUoM(inventory.getProduct().getUnitOfMeasure());
                        stockMovement.setPricePerUnit(salesReturnDetail.getRate() / salesReturnDetail.getBaseuomrate());
                        stockMovement.setQuantity(jSONObject.optDouble("quantity", 0.0));
                        stockMovement.setTransactionDate(salesReturnDetail.getSalesReturn().getOrderDate());
                        stockMovement.setModuleRefId(salesReturnDetail.getSalesReturn().getID());
                        stockMovement.setModuleRefDetailId(salesReturnDetail.getID());
                        stockMovement.setCustomer(salesReturnDetail.getSalesReturn().getCustomer());
                        stockMovement.setCostCenter(salesReturnDetail.getSalesReturn().getCostcenter());
                        stockMovement.setTransactionNo(salesReturnDetail.getSalesReturn().getSalesReturnNumber());
                        stockMovement.setTransactionModule(TransactionModule.ERP_SALES_RETURN);
                        stockMovement.setTransactionType(TransactionType.IN);
                        stockMovement.setMemo(salesReturnDetail.getSalesReturn().getMemo());
                        storeWiseStockMovement.put(store, stockMovement);
                    }
                }
            }
            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) && (batchQty == ActbatchQty)) {
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.getString("quantity"));
                documentMap.put("batchmapid", jSONObject.getString("purchasebatchid"));
                documentMap.put("documentid", salesReturnDetail.getID());
                documentMap.put(Constants.isConsignment, false);  // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                if (isConsignment) {
                    documentMap.put("transactiontype", "53");
                } else {
                    documentMap.put("transactiontype", "29");
                }
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                    documentMap.put("mfgdate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                    documentMap.put("expdate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("expdate")));
                }

                KwlReturnObject locationUpdate = accountingHandlerDAOobj.getObject(Location.class.getName(), jSONObject.getString("location"));
                Location locationObj = (Location) locationUpdate.getEntityList().get(0);
                if (isWarehouseForProduct && isLocationForProduct) {
                    smd = new StockMovementDetail();
                    if (locationObj != null) {
                        smd.setLocation(locationObj);
                    }
                    if (isRowForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("row"));
                        StoreMaster row = (StoreMaster) krObject.getEntityList().get(0);
                        smd.setRow(row);
                    }
                    if (isRackForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("rack"));
                        StoreMaster rack = (StoreMaster) krObject.getEntityList().get(0);
                        smd.setRack(rack);
                    }
                    if (isBinForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("bin"));
                        StoreMaster bin = (StoreMaster) krObject.getEntityList().get(0);
                        smd.setBin(bin);
                    }
                    smd.setQuantity(Double.parseDouble(jSONObject.getString("quantity")));
                    smd.setBatchName("");
                    smd.setStockMovement(stockMovement);
                    stockMovement.getStockMovementDetails().add(smd);
                }
                if (!isBatchForProduct && !isSerialForProduct) {
                    HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                    filter_names.add("company.companyID");
                    filter_params.add(sessionHandlerImpl.getCompanyid(request));

                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("warehouse"))) {
                        String warehouse = jSONObject.getString("warehouse");
                        filter_names.add("warehouse.id");
                        filter_params.add(warehouse);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("location"))) {
                        String location = jSONObject.getString("location");
                        filter_names.add("location.id");
                        filter_params.add(location);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("row"))) {
                        String row = jSONObject.getString("row");
                        filter_names.add("row.id");
                        filter_params.add(row);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("rack"))) {
                        String rack = jSONObject.getString("rack");
                        filter_names.add("rack.id");
                        filter_params.add(rack);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("bin"))) {
                        String bin = jSONObject.getString("bin");
                        filter_names.add("bin.id");
                        filter_params.add(bin);
                    }

                    filter_names.add("product");
                    filter_params.add(inventory.getProduct().getID());
                    filterRequestParams.put("filter_names", filter_names);
                    filterRequestParams.put("filter_params", filter_params);
                    filterRequestParams.put("order_by", order_by);
                    filterRequestParams.put("order_type", order_type);
                    KwlReturnObject result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                    List listResult = result.getEntityList();
                    if ((isnegativestockforlocwar && !(isBatchForProduct || isSerialForProduct)) && listResult.isEmpty()) {
                        HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                        pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
                        pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("batch")));
                        if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                            pdfTemplateMap.put("mfgdate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("mfgdate")));
                        }
                        if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                            pdfTemplateMap.put("expdate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("expdate")));
                        }
                        pdfTemplateMap.put("quantity", jSONObject.optString("quantity"));
                        pdfTemplateMap.put("balance", jSONObject.getString("balance"));
                        pdfTemplateMap.put("location", jSONObject.getString("location"));
                        pdfTemplateMap.put("product", inventory.getProduct().getID());
                        pdfTemplateMap.put("warehouse", jSONObject.getString("warehouse"));

                        pdfTemplateMap.put("row", jSONObject.getString("row"));
                        pdfTemplateMap.put("rack", jSONObject.getString("rack"));
                        pdfTemplateMap.put("bin", jSONObject.getString("bin"));

                        pdfTemplateMap.put("isopening", false);
                        pdfTemplateMap.put("transactiontype", "28");//This is GRN Type Tranction  
                        pdfTemplateMap.put("ispurchase", true);
                        kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);

                        if (kmsg != null && kmsg.getEntityList().size() != 0) {
                            productBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                            productBatchId = productBatch.getId();
                        }
                        documentMap.put("batchmapid", productBatchId);
                    } else {
                        Iterator itrResult = listResult.iterator();
                        Double quantityToDue = ActbatchQty;
                        while (itrResult.hasNext()) {
                            NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                            if (quantityToDue > 0) {
                                double Qty = newProductBatch.getQuantity();
                                double dueQty = newProductBatch.getQuantitydue();
                                HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                                batchUpdateQtyMap.put(Constants.Acc_id, newProductBatch.getId());
                                if ((Qty - dueQty) > 0) {
                                    if (quantityToDue > (Qty - dueQty)) {
                                        if (isConsignment) {
                                            batchUpdateQtyMap.put("consignquantity", String.valueOf((-(Qty - dueQty))));//in do we are adding consignquantity and for return removing consignquantity
                                            batchUpdateQtyMap.put("qty", String.valueOf((-(Qty - dueQty))));
                                        } else {
                                            batchUpdateQtyMap.put("qty", String.valueOf(((Qty - dueQty))));
                                        }
                                        quantityToDue = quantityToDue - (Qty - dueQty);

                                    } else {
                                        if (isConsignment) {
                                            batchUpdateQtyMap.put("consignquantity", String.valueOf((-(quantityToDue))));//in do we are adding consignquantity and for return removing consignquantity
                                            batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));
                                        } else {
                                            batchUpdateQtyMap.put("qty", String.valueOf((quantityToDue)));
                                        }
                                        quantityToDue = quantityToDue - quantityToDue;
                                    }
                                    documentMap.put("batchmapid", newProductBatch.getId());
                                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);

                                } else if (isnegativestockforlocwar && !(isBatchForProduct || isSerialForProduct)) {
                                    batchUpdateQtyMap.put("qty", String.valueOf((quantityToDue)));
                                    batchUpdateQtyMap.put("quantity", String.valueOf((quantityToDue)));

                                    documentMap.put("batchmapid", newProductBatch.getId());
                                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                                }
                            }
                        }
                    }
                } else {

                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                    if (isConsignment) {
                        batchUpdateQtyMap.put("consignquantity", String.valueOf(-(Double.parseDouble(jSONObject.getString("quantity")))));
                        batchUpdateQtyMap.put("qty", String.valueOf(-(Double.parseDouble(jSONObject.getString("quantity")))));
                    } else {
                        batchUpdateQtyMap.put("qty", String.valueOf((Double.parseDouble(jSONObject.getString("quantity")))));
                    }
                    batchUpdateQtyMap.put(Constants.Acc_id, jSONObject.getString("purchasebatchid"));
                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                    //Code to Send Batch
                    KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), jSONObject.getString("purchasebatchid"));
                    NewProductBatch newProductBatch1 = (NewProductBatch) batchObj.getEntityList().get(0);
                    if (isWarehouseForProduct && isLocationForProduct) {
                        smd.setBatchName(newProductBatch1.getBatchname());
                    }
                }

                accCommonTablesDAO.saveBatchDocumentMapping(documentMap);

            }
            batchQty--;

            if (isSerialForProduct) {  //if serial no option is on then only save the serial no details 

                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", 1);
                documentMap.put("serialmapid", jSONObject.getString("purchaseserialid"));
                documentMap.put("documentid", salesReturnDetail.getID());
                if (isConsignment) {
                    documentMap.put("transactiontype", "53");
                } else {
                    documentMap.put("transactiontype", "29");
                }
                documentMap.put(Constants.isConsignment, false);  // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat(request).parse(jSONObject.getString("expend")));
                }

                KwlReturnObject krObj = accCommonTablesDAO.saveSerialDocumentMapping(documentMap);
                SerialDocumentMapping serialDocumentMapping = (SerialDocumentMapping) krObj.getEntityList().get(0);
                if (jSONObject.has(Constants.customfield)) {
                    String customfield = jSONObject.getString(Constants.customfield);
                    if (!StringUtil.isNullOrEmpty(customfield)) {
                        HashMap<String, Object> DOMap = new HashMap<String, Object>();
                        JSONArray jcustomarray = new JSONArray(customfield);

                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        customrequestParams.put("customarray", jcustomarray);
                        customrequestParams.put("modulename", "SerialDocumentMapping");
                        customrequestParams.put("moduleprimarykey", "SerialDocumentMappingId");
                        customrequestParams.put("modulerecid", serialDocumentMapping.getId());
                        customrequestParams.put(Constants.moduleid, Constants.SerialWindow_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        DOMap.put(Constants.Acc_id, serialDocumentMapping.getId());
                        customrequestParams.put("customdataclasspath", Constants.Acc_Serial_custom_data_classpath);
                        KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                        if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                            DOMap.put("serialcustomdataref", serialDocumentMapping.getId());
                            accCommonTablesDAO.updateserialcustomdata(DOMap);
                        }
                    }
                }
                HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                if (isConsignment) {
                    serialUpdateQtyMap.put("qty", "-1"); //
                    serialUpdateQtyMap.put("consignquantity", "-1");
                } else {
                    serialUpdateQtyMap.put("qty", "1");
                }
                serialUpdateQtyMap.put(Constants.Acc_id, jSONObject.getString("purchaseserialid"));
                serialUpdateQtyMap.put("isQAinspection", isQAinspection);
                accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);
                //Code to Send Serial Numbers to Inventory
                KwlReturnObject serialObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), jSONObject.getString("purchaseserialid"));
                NewBatchSerial newBatchSerial = (NewBatchSerial) serialObj.getEntityList().get(0);
                if (newBatchSerial != null) {
                    if (isWarehouseForProduct && isLocationForProduct) {
                        smd.addSerialName(newBatchSerial.getSerialname());
                    }
                }

            } else {
                batchQty = 0;
            }
        }
        if (isWarehouseForProduct && isLocationForProduct) {
            for (Map.Entry<Store, StockMovement> entry : storeWiseStockMovement.entrySet()) {
                stockMovementsList.add(entry.getValue());
            }
        }

    }

    @Override
    public JSONObject saveInvoiceFromLMS(HttpServletRequest request, HttpServletResponse response) {
        JSONObject jobj = new JSONObject();
        JSONArray array = new JSONArray();
        boolean issuccess = false;
        String msg = "";
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("IC_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = txnManager.getTransaction(def);
        try {
            int counter = 0;
            JSONArray jarr = new JSONArray(request.getParameter("invoicedata"));
            for (int i = 0; i < jarr.length(); i++) {
                JSONObject dataMap = jarr.getJSONObject(i);
                try {
                    Invoice invoice = saveInvoiceFromLMS(request, dataMap, counter);
                    invoice.setApprovestatuslevel(11);
                    JSONObject jobj1 = new JSONObject();
                    jobj1.put("invoiceid", invoice.getID());
                    jobj1.put("jeno", invoice.getJournalEntry().getEntryNumber());
                    jobj1.put("jeid", invoice.getJournalEntry().getID());
                    jobj1.put("number", dataMap.optString("number"));
                    jobj1.put("itemid", dataMap.optString("itemid"));
                    array.put(jobj1);
                } catch (Exception e) {
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, e);
                }
            }
            issuccess = true;
            txnManager.commit(status);
        } catch (Exception ex) {
            txnManager.rollback(status);
            msg = "" + ex.getMessage();
            if (ex.getMessage() == null) {
                msg = ex.getCause().getMessage();
            }
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
                jobj.put("invoicedata", array);
            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return jobj;
    }

    @Override
    public Invoice saveInvoiceFromLMS(HttpServletRequest request, JSONObject dataMap1, int counter) throws ServiceException, AccountingException, SessionExpiredException, UnsupportedEncodingException {
        String id = null;
        List ll = new ArrayList();
        String jeentryNumber = null;
        Invoice invoice = null;
        String invoiceid = null;
        JSONObject invjson = null;
        Date billdateVal = null;
        String entryNumber = null;
        try {
            int istemplate = 0;
            KwlReturnObject result = null;
            String sequenceformat = "NA";
            int nocount;
            HashMap<String, Object> requestParams = AccountingManager.getGlobalParams(request);
            DateFormat df = new SimpleDateFormat(Constants.yyyyMMdd);
            String companyid = sessionHandlerImpl.getCompanyid(request);
            invoiceid = dataMap1.optString("invoiceid", "");
            String termid = dataMap1.optString("termid");
            recId = invoiceid;
            String jeid = null;
            boolean jeautogenflag = false;
            Customer customer = null;
            String custId = dataMap1.optString("customer");
            if (StringUtil.isNullOrEmpty(custId)) {
                String acccode = dataMap1.optString("acccode");
                custId = accInvoiceDAOobj.getCustomerId(companyid, acccode);
            }
            if (StringUtil.isNullOrEmpty(custId)) {
                custId = accInvoiceDAOobj.getCustomerIdForPOS(companyid);
            }
            String accountid = custId;
            KwlReturnObject custresult = null;
            if (!StringUtil.isNullOrEmpty(custId)) {
                custresult = accountingHandlerDAOobj.getObject(Customer.class.getName(), custId);
                customer = (Customer) custresult.getEntityList().get(0);
                if (customer.getAccount() != null) {
                    accountid = customer.getAccount().getID();
                }
            }
            if (StringUtil.isNullOrEmpty(termid)) {
                termid = customer.getCreditTerm().getID();
            }
            String createdby = sessionHandlerImpl.getUserid(request);
            String modifiedby = sessionHandlerImpl.getUserid(request);
            long createdon = System.currentTimeMillis();
            long updatedon = System.currentTimeMillis();

            String taxid = dataMap1.optString("taxid");
            String costCenterId = dataMap1.optString(Constants.costcenter);
            double taxamount = StringUtil.getDouble(dataMap1.optString("taxamount"));
            double externalCurrencyRate = StringUtil.getDouble(dataMap1.optString("externalcurrencyrate"));
            Discount discount = null;
            double discValue = 0.0;
            double shippingCharges = StringUtil.getDouble(dataMap1.optString("shipping"));
            double otherCharges = StringUtil.getDouble(dataMap1.optString("othercharges"));
            boolean inCash = Boolean.parseBoolean(dataMap1.optString("incash"));
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            KwlReturnObject cmp = accountingHandlerDAOobj.getObject(Company.class.getName(), companyid);
            Company company = (Company) cmp.getEntityList().get(0);
            String currencyid = (dataMap1.getString(Constants.currencyKey) == null ? sessionHandlerImpl.getCurrencyID(request) : dataMap1.optString(Constants.currencyKey));
            entryNumber = dataMap1.optString("number", "");
            recId = entryNumber;
            String customerid = custId;
            invjson = new JSONObject();
            invjson.put("invoiceid", invoiceid);
            invjson.put("accountid", accountid);
            invjson.put(Constants.customerid, customerid);
            if (StringUtil.isNullOrEmpty(invoiceid)) {
                String msg = checkSOUsedFlag(request, 2);
                if (!StringUtil.isNullOrEmpty(msg)) {//Check if SO is already used in DO or not.
                    throw new AccountingException(msg);
                }
            }
            
            try {
                billdateVal =  df.parse(dataMap1.optString("billdateStr"));
            } catch (ParseException ex) {
                Calendar cal = Calendar.getInstance();
                try {
                    Date billdateValue = df.parse(dataMap1.optString("billdateStr"));
                    cal.setTime(billdateValue);
                    billdateVal = cal.getTime();
                    billdateVal = df.parse(df.format(billdateVal));
                } catch (ParseException ex1) {
                }
            }
            
            synchronized (this) {
                SequenceFormat prevSeqFormat = null;
                String nextAutoNo = "";
                String nextAutoNoInt = "";
                String datePrefix = "";
                String dateafterPrefix = "";
                String dateSuffix = "";

                if (!StringUtil.isNullOrEmpty(invoiceid)) {//in edit case checks duplicate     
                    result = accInvoiceDAOobj.getDuplicateInvoiceNumberForEdit(entryNumber, companyid, invoiceid);
                    nocount = result.getRecordTotalCount();
                    if (nocount > 0) {
                        if (inCash) {
                            throw new AccountingException("Sales receipt number '" + entryNumber + "' already exists.");
                        } else {
                            throw new AccountingException("Invoice number '" + entryNumber + "' already exists.");
                        }
                    } else {
                        KwlReturnObject rst = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                        Invoice inv = (Invoice) rst.getEntityList().get(0);
                        prevSeqFormat = inv.getSeqformat();
                        if (!sequenceformat.equals("NA")) {
                            nextAutoNo = entryNumber;
                        }
                    }
                } else { // create new case checks duplicate
                    result = accInvoiceDAOobj.getInvoiceCount(entryNumber, companyid);
                    nocount = result.getRecordTotalCount();
                    if (nocount > 0) {
                        if (inCash) {
                            throw new AccountingException("Sales receipt number '" + entryNumber + "' already exists.");
                        } else {
                            throw new AccountingException("Invoice number '" + entryNumber + "' already exists.");
                        }
                    }
                }
                if (!sequenceformat.equals("NA") && prevSeqFormat == null) {
                    int from = StaticValues.AUTONUM_INVOICE;
                    if (inCash) {
                        from = StaticValues.AUTONUM_CASHSALE;
                    }
                    boolean seqformat_oldflag = StringUtil.getBoolean(dataMap1.optString("seqformat_oldflag"));
                    if (seqformat_oldflag) {
                        nextAutoNo = accCompanyPreferencesObj.getNextAutoNumber(companyid, from, sequenceformat);
                    } else {
                        Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                        seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, from, sequenceformat, seqformat_oldflag, billdateVal);
                        nextAutoNo = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                        nextAutoNoInt = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                        datePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                        dateafterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                        dateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                        invjson.put(Constants.SEQFORMAT, sequenceformat);
                        invjson.put(Constants.SEQNUMBER, nextAutoNoInt);
                        invjson.put(Constants.DATEPREFIX, datePrefix);
                        invjson.put(Constants.DATEAFTERPREFIX, dateafterPrefix);
                        invjson.put(Constants.DATESUFFIX, dateSuffix);

                    }
                    entryNumber = nextAutoNo;
                }
                invjson.put("entrynumber", entryNumber);
                invjson.put("autogenerated", nextAutoNo.equals(entryNumber));
            }
            if (StringUtil.isNullOrEmpty(dataMap1.optString("shipaddress"))) {
                invjson.put("shipaddress", customer.getShippingAddress());
            } else {
                invjson.put("shipaddress", dataMap1.optString("shipaddress"));
            }
            invjson.put("isfavourite", dataMap1.optString("isfavourite"));
            invjson.put(Constants.isFixedAsset, false);
            invjson.put(Constants.isLeaseFixedAsset, false);
            invjson.put(Constants.memo, dataMap1.optString(Constants.memo));
            invjson.put("billto", dataMap1.optString("billto"));
            if (dataMap1.optString(Constants.shipdate) != null && !StringUtil.isNullOrEmpty(dataMap1.optString(Constants.shipdate))) {
                try {
                    invjson.put(Constants.shipdate, df.parse(dataMap1.optString("shipdateStr")));
                } catch (ParseException ex) {
                    try {
                        Calendar cal = Calendar.getInstance();
                        Date shipDateValue = df.parse(dataMap1.optString("shipdateStr"));
                        cal.setTime(shipDateValue);
                        Date calDate = null;
                        try {
                            String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                            calDate = authHandler.getDateOnlyFormat().parse(CalString);
                        } catch (ParseException e) {
                            calDate = cal.getTime();
                        }
                        Date shipDateVal = calDate;
                        invjson.put(Constants.shipdate, shipDateVal);
                    } catch (ParseException ex1) {
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex1);
                    }
                }
            }
            invjson.put("porefno", dataMap1.optString("porefno"));
            if (dataMap1.optString(Constants.duedate) != null) {
                try {
                    invjson.put(Constants.duedate, df.parse(dataMap1.optString("duedateStr")));
                } catch (ParseException ex) {
                    try {
                        Calendar cal = Calendar.getInstance();
                        Date dueDateValue = df.parse(dataMap1.optString("duedateStr"));
                        cal.setTime(dueDateValue);

                        Date calDate = null;
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                        Date dueDateVal = calDate;
                        invjson.put(Constants.duedate, dueDateVal);
                    } catch (ParseException ex1) {
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex1);
                    }
                }
            } else {
                Calendar cal = Calendar.getInstance();
                Date calDate = null;
                try {
                    Date billDate = df.parse(dataMap1.optString("billdateStr"));
                    cal.setTime(billDate);
                    cal.add(Calendar.DATE, 15);
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    invjson.put(Constants.duedate, calDate);
                } catch (ParseException ex) {
                    try {
                        Date billdateValue = df.parse(dataMap1.optString("billdateStr"));
                        cal.setTime(billdateValue);
                        cal.add(Calendar.DATE, 15);
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                        invjson.put(Constants.duedate, calDate);
                    } catch (ParseException ex1) {
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex1);
                    }
                }
            }
            invjson.put("template", dataMap1.optString("template"));
            invjson.put(Constants.companyKey, companyid);
            invjson.put(Constants.currencyKey, currencyid);
            invjson.put("externalCurrencyRate", externalCurrencyRate);
            invjson.put("salesPerson", dataMap1.optString("salesPerson"));
            invjson.put(Constants.shipvia, dataMap1.optString(Constants.shipvia));
            invjson.put(Constants.fob, dataMap1.optString(Constants.fob));
            invjson.put("createdby", createdby);
            invjson.put("modifiedby", modifiedby);
            invjson.put("createdon", createdon);
            invjson.put("updatedon", updatedon);
            if (!StringUtil.isNullOrEmpty(termid)) {
                invjson.put("termid", termid);
            }
            invjson.put("partialinv", (dataMap1.optString("partialinv") != null) ? Boolean.parseBoolean(dataMap1.optString("partialinv")) : false);
            // Create Journal Entry
            Map<String, Object> jeDataMap = AccountingManager.getGlobalParams(request);
            String jeSeqFormatId = "";
            synchronized (this) {
                try {
                    HashMap<String, Object> JEFormatParams = new HashMap<String, Object>();
                    JEFormatParams.put(Constants.moduleid, Constants.Acc_GENERAL_LEDGER_ModuleId);
                    JEFormatParams.put("modulename", "autojournalentry");
                    JEFormatParams.put(Constants.companyKey, companyid);
                    JEFormatParams.put("isdefaultFormat", true);

                    KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                    SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
                    Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                    seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, format.getID(), false, billdateVal);
                    String nextAutoNoTemp = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                    int sequence = Integer.parseInt((String) seqNumberMap.get(Constants.SEQNUMBER));
                    String jeDatePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                    String jeDateAfterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                    String jeDateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                    sequence = sequence + counter;
                    String number = "" + sequence;
                    String action = "" + (sequence - counter);
                    nextAutoNoTemp.replaceAll(action, number);
                    jeentryNumber = nextAutoNoTemp.replaceAll(action, number);  //next auto generated number
                    jeSeqFormatId = format.getID();
                    jeautogenflag = true;

                    jeDataMap.put("entrynumber", jeentryNumber);
                    jeDataMap.put("autogenerated", jeautogenflag);
                    jeDataMap.put(Constants.SEQFORMAT, jeSeqFormatId);
                    jeDataMap.put(Constants.SEQNUMBER, number);
                    jeDataMap.put(Constants.DATEPREFIX, jeDatePrefix);
                    jeDataMap.put(Constants.DATEAFTERPREFIX, jeDateAfterPrefix);
                    jeDataMap.put(Constants.DATESUFFIX, jeDateSuffix);
                } catch (ServiceException ex) {
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            jeDataMap.put("entrydate", billdateVal);
            if (!StringUtil.isNullOrEmpty(currencyid) && !currencyid.equalsIgnoreCase(sessionHandlerImpl.getCurrencyID(request))) {
                requestParams.put(Constants.globalCurrencyKey, sessionHandlerImpl.getCurrencyID(request));
                externalCurrencyRate = accCurrencyDAOobj.getCurrencyToBaseRate(requestParams, currencyid, billdateVal);
                invjson.put("externalCurrencyRate", externalCurrencyRate);
            }
            jeDataMap.put(Constants.companyKey, companyid);
            jeDataMap.put(Constants.memo, dataMap1.optString(Constants.memo));
            invjson.put(Constants.posttext, dataMap1.optString(Constants.posttext));
            jeDataMap.put(Constants.currencyKey, currencyid);
            jeDataMap.put("costcenterid", costCenterId);
            HashSet jeDetails = new HashSet();
            KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Create Journal entry without JEdetails
            JournalEntry journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
            jeid = journalEntry.getID();
            invjson.put("journalerentryid", jeid);
            jeDataMap.put("jeid", jeid);
            String invoiceDetails = dataMap1.optString(Constants.detail);
            List dll = saveInvoiceRowsFromLMS(request, invoiceDetails, jeid, company, jeDetails, currencyid, externalCurrencyRate, dataMap1);
            double[] totals = (double[]) dll.get(0);
            HashSet<InvoiceDetail> invcdetails = (HashSet<InvoiceDetail>) dll.get(1);
            ArrayList<String> prodList = (ArrayList<String>) dll.get(2);
            double disc = 0;
            if (!StringUtil.isNullOrEmpty(dataMap1.optString("discount"))) {
                disc = StringUtil.getDouble(dataMap1.optString("discount"));
            }
            if (disc > 0) {
                JSONObject discjson = new JSONObject();
                discjson.put("discount", disc);
                discjson.put("inpercent", Boolean.parseBoolean(dataMap1.optString("perdiscount")));
                discjson.put("originalamount", totals[1] - totals[0] + totals[2]);
                discjson.put(Constants.companyKey, companyid);
                KwlReturnObject dscresult = accDiscountobj.addDiscount(discjson);
                discount = (Discount) dscresult.getEntityList().get(0);
                invjson.put("discountid", discount.getID());
                discValue = discount.getDiscountValue();
            }
            discValue += totals[0];

            if (inCash) {
                accountid = preferences.getCashAccount().getID();
            }
            double totalInvAmount = totals[1] + shippingCharges + otherCharges - discValue + taxamount + totals[2];
            try {
                Calendar cal = Calendar.getInstance();
                Date billdateValue = df.parse(dataMap1.optString("billdateStr"));
                cal.setTime(billdateValue);
                Date calDate = null;
                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                calDate = authHandler.getDateOnlyFormat().parse(CalString);
                billdateVal = calDate;
            } catch (Exception ep) {
                ep.printStackTrace();
            }
            KwlReturnObject bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, totalInvAmount, currencyid, billdateVal, externalCurrencyRate);
            double totalInvAmountinBase = (Double) bAmt.getEntityList().get(0);
            ArrayList amountApprove = (accountingHandlerDAOobj.getApprovalFlagForAmount(totalInvAmountinBase, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_AMOUNT, companyid));
            boolean amountExceed = (Boolean) amountApprove.get(0);
            ArrayList prodApprove = (accountingHandlerDAOobj.getApprovalFlagForProducts(prodList, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_PRODUCT, companyid));
            boolean prodExists = (Boolean) prodApprove.get(0);
            boolean pendingApprovalFlagForDisc = false;
            int approvalLevelForDisc = 1;
            Iterator invitr = invcdetails.iterator();
            while (invitr.hasNext()) {
                InvoiceDetail ivd = (InvoiceDetail) invitr.next();
                Discount discount1 = ivd.getDiscount();
                String productId = ivd.getInventory().getProduct().getID();
                if (discount1 != null) {
                    double discountVal = discount1.getDiscountValue();
                    try {
                        Calendar cal = Calendar.getInstance();
                        Date billdateValue = df.parse(dataMap1.optString("billdateStr"));
                        cal.setTime(billdateValue);
                        Date calDate = null;
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                        billdateVal = calDate;
                    } catch (Exception et) {
                        et.printStackTrace();
                    }
                    KwlReturnObject dAmount = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, discountVal, currencyid, billdateVal, externalCurrencyRate);
                    double discAmountinBase = (Double) dAmount.getEntityList().get(0);
                    ArrayList prodApproveDisc = (accountingHandlerDAOobj.getApprovalFlagForProductsDiscount(discAmountinBase, productId, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_DISCOUNT, companyid, pendingApprovalFlagForDisc, approvalLevelForDisc));
                    pendingApprovalFlagForDisc = (Boolean) prodApproveDisc.get(0);
                    approvalLevelForDisc = (Integer) prodApproveDisc.get(1);
                }
            }
            int pendingApprovalFlag = (istemplate != 2 ? ((amountExceed || prodExists || pendingApprovalFlagForDisc) ? 1 : 0) : 0);//No need of approval if transaction is created as only template
            int approvalLevel = ((Integer) (amountApprove.get(1)) > (Integer) (prodApprove.get(1))) ? (Integer) (amountApprove.get(1)) : (Integer) (prodApprove.get(1));
            if (approvalLevelForDisc > approvalLevel) {
                approvalLevel = approvalLevelForDisc;
            }
            JSONObject jedjson = new JSONObject();
            jedjson.put("srno", jeDetails.size() + 1);
            jedjson.put(Constants.companyKey, companyid);
            jedjson.put("amount", totalInvAmount);
            jedjson.put("accountid", accountid);
            jedjson.put("debit", true);
            jedjson.put("jeid", jeid);
            KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
            JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
            jeDetails.add(jed);
            invjson.put("customerentryid", jed.getID());
            invjson.put(Constants.invoiceamountdue, totalInvAmount);
            invjson.put(Constants.invoiceamountdueinbase, totalInvAmountinBase);
            invjson.put(Constants.invoiceamount, totalInvAmount);
            invjson.put(Constants.invoiceamountinbase, totalInvAmountinBase);
            if (discValue > 0) {
                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", discValue);
                jedjson.put("accountid", preferences.getDiscountGiven().getID());
                jedjson.put("debit", true);
                jedjson.put("jeid", jeid);
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);
            }
            if (shippingCharges > 0) {
                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", shippingCharges);
                jedjson.put("accountid", preferences.getShippingCharges().getID());
                jedjson.put("debit", false);
                jedjson.put("jeid", jeid);
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);
                invjson.put("shipentryid", jed.getID());
            }
            if (!StringUtil.isNullOrEmpty(taxid)) {
                KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), taxid); // (Tax)session.get(Tax.class, taxid);
                Tax tax = (Tax) txresult.getEntityList().get(0);
                if (tax == null) {
                    throw new AccountingException(messageSource.getMessage("acc.so.taxcode", null, RequestContextUtils.getLocale(request)));
                }
                invjson.put("taxid", taxid);
                if (taxamount > 0) {
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", taxamount);
                    jedjson.put("accountid", tax.getAccount().getID());
                    jedjson.put("debit", false);
                    jedjson.put("jeid", jeid);
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    invjson.put("taxentryid", jed.getID());
                }
            }
            jeDataMap.put("jedetails", jeDetails);
            jeDataMap.put("pendingapproval", pendingApprovalFlag);
            jeDataMap.put("istemplate", istemplate);
            jeDataMap.put("externalCurrencyRate", externalCurrencyRate);
            jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Add Journal entry details
            journalEntry = (JournalEntry) jeresult.getEntityList().get(0);

            JSONArray jcustomarray = null;
            boolean customfieldArrayflag = true;
            String customfieldArray = dataMap1.optString("customfieldArray", ""); //Custom Data from other Project
            customfieldArray = StringUtil.DecodeText(customfieldArray);
            if (!StringUtil.isNullOrEmpty(customfieldArray)) {
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                String mapWithFieldType = dataMap1.optString("mapWithFieldType");
                customrequestParams.put("customarray", customfieldArray);
                customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("mapWithFieldType", mapWithFieldType);
                jcustomarray = fieldDataManagercntrl.createJSONArrForCustomFieldValueFromOtherSource(customrequestParams);
                customfieldArrayflag = false;
            }
            // Add Custom fields details 
            if (!StringUtil.isNullOrEmpty(dataMap1.optString(Constants.customfield, "")) || !StringUtil.isNullOrEmpty(customfieldArray)) {
                if (customfieldArrayflag) {
                    jcustomarray = new JSONArray(dataMap1.optString(Constants.customfield, "[]"));
                }
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                customrequestParams.put("customarray", jcustomarray);
                customrequestParams.put("modulename", Constants.Acc_JE_modulename);
                customrequestParams.put("moduleprimarykey", Constants.Acc_JEid);
                customrequestParams.put("modulerecid", journalEntry.getID());
                customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("customdataclasspath", Constants.Acc_BillInv_custom_data_classpath);
                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                    jeDataMap.put("accjecustomdataref", journalEntry.getID());
                    jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);
                }
            }

            try {
                Calendar cal = Calendar.getInstance();
                Date billdateValue = df.parse(dataMap1.optString("billdateStr"));
                cal.setTime(billdateValue);
                Date calDate = null;
                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                calDate = authHandler.getDateOnlyFormat().parse(CalString);
                billdateVal = calDate;
            } catch (Exception ep) {
                ep.printStackTrace();
            }
            KwlReturnObject ERresult = accCurrencyDAOobj.getExcDetailID(requestParams, currencyid, billdateVal, null);
            ExchangeRateDetails erd = (ExchangeRateDetails) ERresult.getEntityList().get(0);
            String erdid = (erd == null) ? null : erd.getID();
            invjson.put("erdid", erdid);
            invjson.put("pendingapproval", pendingApprovalFlag);
            invjson.put("istemplate", istemplate);
            invjson.put("approvallevel", approvalLevel);
            invjson.put("incash", dataMap1.optString("incash"));
            if (StringUtil.isNullOrEmpty(invoiceid)) {// Used to save billing and shipping addresses 
                boolean isDefaultAddress = true;
                Map<String, Object> addressParams = new HashMap<String, Object>();
                if (isDefaultAddress) {
                    addressParams = AccountingAddressManager.getDefaultCustomerAddressParams(customer.getID(), companyid, accountingHandlerDAOobj);// addressParams = getCustomerDefaultAddressParams(customer,companyid);
                } else {
                    addressParams = AccountingAddressManager.getAddressParams(request, false);
                }
                KwlReturnObject addressresult = accountingHandlerDAOobj.saveAddressDetail(addressParams, companyid);
                BillingShippingAddresses bsa = (BillingShippingAddresses) addressresult.getEntityList().get(0);
                invjson.put("billshipAddressid", bsa.getID());
            }
            invjson.put(Constants.Checklocktransactiondate, request.getParameter(Constants.BillDate));
            result = accInvoiceDAOobj.addInvoice(invjson, new HashSet());
            invoice = (Invoice) result.getEntityList().get(0);//Create Invoice without invoice-details.
            Iterator itr = invcdetails.iterator();
            while (itr.hasNext()) {
                InvoiceDetail ivd = (InvoiceDetail) itr.next();
                if ((pendingApprovalFlag == 1 || istemplate == 2) && ivd.getInventory().isInvrecord()) {
                    Inventory invtry = ivd.getInventory();
                    invtry.setActquantity(invtry.getQuantity());
                    invtry.setQuantity(0);
                }
                ivd.setInvoice(invoice);
            }
            invjson.put("invoiceid", invoice.getID());
            result = accInvoiceDAOobj.updateInvoice(invjson, invcdetails);
            invoice = (Invoice) result.getEntityList().get(0);//Add invoice details 
            accJournalEntryobj.saveAccountJEs_optimized(jeid);
            id = invoice.getID();

            if (invoiceid != null) {
                auditTrailObj.insertAuditLog(AuditAction.INVOICE_CREATED, "User " + sessionHandlerImpl.getUserFullName(request) + " has added a new customer Invoice " + recId, request, tranID);

            } else if (entryNumber != null) {
                auditTrailObj.insertAuditLog(AuditAction.CASH_SALES_CREATED, "User " + sessionHandlerImpl.getUserFullName(request) + " has added a new customer Invoice " + recId, request, tranID);
            }
        } catch (JSONException ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return invoice;
    }

    private List saveInvoiceRowsFromLMS(HttpServletRequest request, String invoiceDetails, String jeid, Company company, HashSet jeDetails, String currencyid, Double externalCurrencyRate, JSONObject dataMap1) throws ServiceException, SessionExpiredException, AccountingException, UnsupportedEncodingException {
        HashSet hs = new HashSet(), rows = new HashSet();
        ArrayList<String> prodList = new ArrayList<String>();
        double totaldiscount = 0, totalamount = 0, taxamount = 0;
        List ll = new ArrayList();
        try {
            DateFormat df = authHandler.getDateOnlyFormat(request);
            String companyid = company.getCompanyID();
            boolean inCash = Boolean.parseBoolean(dataMap1.optString("incash"));
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            KwlReturnObject cap1 = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extarPreferences = (ExtraCompanyPreferences) cap1.getEntityList().get(0);

            boolean partialInv = (dataMap1.optString("partialinv") != null) ? Boolean.parseBoolean(dataMap1.optString("partialinv")) : false;

            JSONArray jArr = new JSONArray(invoiceDetails);
            for (int i = 0; i < jArr.length(); i++) {

                JSONObject jobj = jArr.getJSONObject(i);
                InvoiceDetail row = new InvoiceDetail();
                JournalEntryDetail jed;
                row.setSrno(i + 1);
                row.setWasRowTaxFieldEditable(true);// this field has been added after making row tax field editable its value will be set always true from its implementation. i.e from 28-jan-2014.REASON -  when Row Tax Amount field was not editable then tax calculation was taking place according to tax percent, as selected From Tax combo in JS Side.
                if (!StringUtil.isNullOrEmpty(jobj.optString("desc"))) {
                  //  try {
                        row.setDescription(StringUtil.DecodeText(jobj.optString("desc")));
                    /*} catch (UnsupportedEncodingException ex) {
                        row.setDescription(jobj.optString("desc"));
                    }*/
                }
                if (preferences.isInventoryAccountingIntegration() && (!preferences.isWithInvUpdate() || inCash) && preferences.isUpdateInvLevel()) {
                    if (!StringUtil.isNullOrEmpty(jobj.optString("invstore"))) {
                        row.setInvstoreid(jobj.optString("invstore"));
                    } else {
                        row.setInvstoreid("");
                    }

                    if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                        row.setInvlocid(jobj.optString("invlocation"));
                    } else {
                        row.setInvlocid("");
                    }
                }

                if (extarPreferences.isIsPOSIntegration() && inCash) {
                    if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                        row.setInvlocid(jobj.optString("invlocation"));
                    } else {
                        row.setInvlocid("");
                    }
                }
                String linkMode = dataMap1.optString("fromLinkCombo");
                boolean updateInventoryFlag = (preferences.isWithInvUpdate()) ? false : true;

                double partamount = (jobj.has("partamount") && (!StringUtil.isNullOrEmpty(jobj.get("partamount").toString()))) ? jobj.getDouble("partamount") : 0.0;
                row.setPartamount(partamount);

                if (!StringUtil.isNullOrEmpty(linkMode)) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : ((jobj.getString("savedrowid")) != null ? jobj.getString("savedrowid") : ""));
                        SalesOrderDetail rd = (SalesOrderDetail) rdresult.getEntityList().get(0);
                        row.setSalesorderdetail(rd);

                        if (updateInventoryFlag && partialInv) {
                            double sodAmount = rd.getQuantity() * 100;

                            double invDetailAmount = getInvoiceDetailAMount(rd);
                            invDetailAmount += jobj.getDouble("quantity") * partamount;
                            if (sodAmount > invDetailAmount) {
                                updateInventoryFlag = false;
                            }
                        }
                    } else if (linkMode.equalsIgnoreCase(Constants.Delivery_Order)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        DeliveryOrderDetail deliveryOrderDetail = (DeliveryOrderDetail) rdresult.getEntityList().get(0);
                        row.setDeliveryOrderDetail(deliveryOrderDetail);
                    } else if (linkMode.equalsIgnoreCase(Constants.CUSTOMER_QUOTATION)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(QuotationDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        QuotationDetail quotationDetail = (QuotationDetail) rdresult.getEntityList().get(0);
                        row.setQuotationDetail(quotationDetail);
                    }
                }
                row.setCompany(company);
                row.setRate(jobj.getDouble("rate"));
                String productid = "";
                if (StringUtil.isNullOrEmpty(jobj.getString(Constants.productid))) {
                    String productcode = jobj.getString("productcode");
                    productid = accInvoiceDAOobj.getproductId(companyid, productcode);
                } else {
                    productid = jobj.getString(Constants.productid);
                }
                KwlReturnObject prdresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
                Product product = (Product) prdresult.getEntityList().get(0);
                prodList.add(productid);
                JSONObject inventoryjson = new JSONObject();
                inventoryjson.put(Constants.productid, productid);
                double quantity = 1;
                if (jobj.has("quantity")) {
                    quantity = jobj.getDouble("quantity");
                }
                inventoryjson.put("quantity", quantity);
                if (jobj.has("uomid")) {
                    inventoryjson.put("uomid", jobj.getString("uomid"));
                }
                if (jobj.has("baseuomquantity") && jobj.get("baseuomquantity") != null) {
                    inventoryjson.put("baseuomquantity", updateInventoryFlag ? jobj.getDouble("baseuomquantity") : 0);
                    inventoryjson.put("actquantity", updateInventoryFlag ? 0 : jobj.getDouble("baseuomquantity"));
                    inventoryjson.put("baseuomrate", jobj.has("baseuomrate") ? jobj.getDouble("baseuomrate") : 0.0);
                } else {
                    inventoryjson.put("baseuomquantity", updateInventoryFlag ? quantity : 0);
                    inventoryjson.put("actquantity", updateInventoryFlag ? 0 : quantity);
                    inventoryjson.put("baseuomrate", jobj.has("baseuomrate") ? jobj.getDouble("baseuomrate") : 0.0);
                }
                inventoryjson.put("invrecord", updateInventoryFlag ? true : false);
                if (jobj.has("desc")) {
                    inventoryjson.put("description", jobj.getString("desc"));
                }
                inventoryjson.put("carryin", false);
                inventoryjson.put("defective", false);
                inventoryjson.put("newinventory", false);
                inventoryjson.put(Constants.companyKey, companyid);
                try {
                    inventoryjson.put("updatedate", authHandler.getDateOnlyFormat(request).parse(dataMap1.optString(Constants.BillDate)));
                } catch (ParseException e) {
                    Calendar cal = Calendar.getInstance();
                    long dateValue = (long) Long.parseLong(dataMap1.optString(Constants.BillDate).toString());
                    cal.setTimeInMillis(dateValue);
                    Date calDate = null;
                    try {
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    } catch (ParseException ex) {
                        calDate = cal.getTime();
                    }
                    Date date = calDate;
                    inventoryjson.put("updatedate", date);
                }

                KwlReturnObject invresult = accProductObj.addInventory(inventoryjson);
                Inventory inventory = (Inventory) invresult.getEntityList().get(0);

                row.setInventory(inventory);

                double rowAmount = authHandler.round(row.getRate() * quantity, companyid);
                double rowdiscount = 0;
                if (partamount != 0.0) {
                    rowAmount = rowAmount * (partamount / 100);
                }
                totalamount += rowAmount;
                Discount discount = null;
                double disc = 0;
                int rowdisc = 0;
                if (jobj.has("prdiscount")) {
                    disc = jobj.getDouble("prdiscount");
                }
                if (jobj.has("discountispercent")) {
                    rowdisc = jobj.getInt("discountispercent");
                }
                if (jobj.has("rateIncludingGst")) {
                    row.setRateincludegst(jobj.optDouble("rateIncludingGst", 0));
                }
                if (disc != 0.0) {
                    JSONObject discjson = new JSONObject();
                    discjson.put("discount", disc);
                    discjson.put("inpercent", (rowdisc == 1) ? true : false);
                    discjson.put("originalamount", rowAmount);
                    discjson.put(Constants.companyKey, companyid);
                    KwlReturnObject dscresult = accDiscountobj.addDiscount(discjson);
                    discount = (Discount) dscresult.getEntityList().get(0);
                    row.setDiscount(discount);
                    rowdiscount = discount.getDiscountValue();
                    totaldiscount += rowdiscount;
                }
                {
                    JSONObject jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", rowAmount);
                    jedjson.put("accountid", product.getSalesAccount().getID());
                    jedjson.put("debit", false);
                    jedjson.put("jeid", jeid);
                    KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);

                    row.setDeferredJeDetailId(jed.getID());
                    JSONArray jcustomarray = null;
                    boolean customfieldArrayflag = true;
                    String customfieldArray = jobj.optString("customfieldArray", ""); //Custom Data from other Project
                    customfieldArray = StringUtil.DecodeText(customfieldArray);
                    if (!StringUtil.isNullOrEmpty(customfieldArray)) {
                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        String mapWithFieldType = dataMap1.optString("mapWithFieldType");
                        customrequestParams.put("customarray", customfieldArray);
                        customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        customrequestParams.put("mapWithFieldType", mapWithFieldType);
                        jcustomarray = fieldDataManagercntrl.createJSONArrForCustomFieldValueFromOtherSource(customrequestParams);
                        customfieldArrayflag = false;
                    }
                    // Add Custom fields details 
                    if (!StringUtil.isNullOrEmpty(jobj.optString(Constants.customfield, "")) || !StringUtil.isNullOrEmpty(customfieldArray)) {
                        if (customfieldArrayflag) {
                            jcustomarray = new JSONArray(jobj.optString(Constants.customfield, "[]"));
                        }
                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        customrequestParams.put("customarray", jcustomarray);
                        customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
                        customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);// Constants.Acc_JEDetail_recdetailId
                        customrequestParams.put("modulerecid", jed.getID());
                        customrequestParams.put("recdetailId", row.getInventory().getID());
                        customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        customrequestParams.put("customdataclasspath", Constants.Acc_BillInvDetail_custom_data_classpath);
                        KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                        if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                            jedjson.put("accjedetailcustomdata", jed.getID());
                            jedjson.put("jedid", jed.getID());
                            jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                        }
                    }
                }
                String rowtaxid = jobj.optString("prtaxid", "");
                if (!StringUtil.isNullOrEmpty(rowtaxid)) {
                    boolean taxExist = false;
                    KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), rowtaxid); // (Tax)session.get(Tax.class, taxid);
                    Tax rowtax = (Tax) txresult.getEntityList().get(0);
                    if (rowtax == null) {
                        throw new AccountingException(messageSource.getMessage("acc.so.taxcode", null, RequestContextUtils.getLocale(request)));
                    } else {
                        row.setTax(rowtax);
                        int rowTaxper = jobj.getInt("taxpercent");
                        double rowtaxamount = StringUtil.getDouble(jobj.getString("taxamount"));//rowtaxamount=(rowAmount - rowdiscount) * rowTaxper/100;
                        row.setRowTaxAmount(rowtaxamount);
                        taxamount += rowtaxamount;
                        if (taxamount > 0) {
                            Iterator itr = jeDetails.iterator();
                            while (itr.hasNext()) {
                                jed = (JournalEntryDetail) itr.next();
                                if (jed.getAccount() == rowtax.getAccount()) {
                                    JSONObject jedjson = new JSONObject();
                                    jedjson.put("jedid", jed.getID());
                                    jedjson.put("amount", jed.getAmount() + rowtaxamount);
                                    KwlReturnObject jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                    taxExist = true;
                                    break;
                                }
                            }
                            if (!taxExist) {
                                JSONObject jedjson = new JSONObject();
                                jedjson = new JSONObject();
                                jedjson.put("srno", jeDetails.size() + 1);
                                jedjson.put(Constants.companyKey, companyid);
                                jedjson.put("amount", rowtaxamount);
                                jedjson.put("accountid", rowtax.getAccount().getID());
                                jedjson.put("debit", false);
                                jedjson.put("jeid", jeid);
                                KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                jeDetails.add(jed);

                            }
                        }
                    }
                }
                rows.add(row);
            }
        } catch (JSONException ex) {
            throw ServiceException.FAILURE("saveInvoiceRows : " + ex.getMessage(), ex);
        }
        ll.add(new double[]{totaldiscount, totalamount, taxamount});
        ll.add(rows);
        ll.add(prodList);
        return ll;
    }

    @Override
    public void getInvoiceFromLMS(HashMap<String, Object> requestParams) throws ServiceException {
        JSONObject jobj = new JSONObject();
        JSONObject resObj = new JSONObject();
        String msg = "";
        boolean issuccess = false;
        boolean isused = false;
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("CF_Tx");
        TransactionStatus status = null;
        try {
            String companyid = (String) requestParams.get(Constants.companyKey);
//            String lmsURL = (String) requestParams.get("lmsURL");
            String userFullName = (String) requestParams.get("userfullName");
            JSONObject userData = new JSONObject();
            userData.put("iscommit", true);
            userData.put("remoteapikey", StorageHandler.GetRemoteAPIKey());
            userData.put(Constants.useridKey, (String) requestParams.get(Constants.useridKey));
            userData.put(Constants.companyKey, companyid);
//            String action = "36";
            String lmsURL = URLUtil.buildRestURL("lmsURL");
            lmsURL = lmsURL + "financials/invoice";                 
            resObj = apiCallHandlerService.restGetMethod(lmsURL, userData.toString());
//            try {
//                resObj = apiCallHandlerService.callApp(lmsURL, userData, companyid, action);
//            } catch (Exception ex) {
//            }
            if (!resObj.isNull(Constants.RES_success) && resObj.getBoolean(Constants.RES_success)) {
                int counter = 0;
                JSONArray jarr = new JSONArray(resObj.optString("invoicedata"));
                JSONArray array = new JSONArray();
                for (int i = 0; i < jarr.length(); i++) {
                    JSONObject dataMap = jarr.getJSONObject(i);
                    try {
                        status = txnManager.getTransaction(def);
                        Invoice invoice = saveInvoiceFromLMS(requestParams, dataMap, counter);
                        invoice.setApprovestatuslevel(11);
                        JSONObject jobj1 = new JSONObject();
                        jobj1.put("invoiceid", invoice.getID());
                        jobj1.put("jeno", invoice.getJournalEntry().getEntryNumber());
                        jobj1.put("jeid", invoice.getJournalEntry().getID());
                        jobj1.put("number", dataMap.optString("number"));
                        jobj1.put("itemid", dataMap.optString("itemid"));
                        array.put(jobj1);
                        txnManager.commit(status);
                    } catch (Exception e) {
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, e);
                    }
                }

                // Call API To update invoice table at LMS side
                if (jarr.length() > 0) {
//                        action = "37";
                        userData.put("invoicedata", array);
                        JSONObject resObj1 = apiCallHandlerService.restPostMethod(lmsURL, userData.toString());                        
//                        JSONObject resObj1 = apiCallHandlerService.callApp(lmsURL, userData, companyid, action);
                    if (!resObj.isNull(Constants.RES_success) && resObj.getBoolean(Constants.RES_success)) {
                        issuccess = true;
                        status = txnManager.getTransaction(def);
                        auditTrailObj.insertAuditLog(AuditAction.INVOICE_CREATED, "User " + userFullName + " has sync " + jarr.length() + " Invoices from LMS ", requestParams, companyid);
                        txnManager.commit(status);
                    }
                }
            }
            msg = "Invoices Sync Successfully";
            issuccess = true;
        } catch (Exception ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            txnManager.rollback(status);
            isused = true;
            issuccess = false;
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
                jobj.put("isused", isused);
            } catch (JSONException ex) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    public Invoice saveInvoiceFromLMS(HashMap<String, Object> requestParams, JSONObject dataMap1, int counter) throws ServiceException, AccountingException, SessionExpiredException, UnsupportedEncodingException {
        String jeentryNumber = null;
        Invoice invoice = null;
        String invoiceid = null;
        JSONObject invjson = null;
        Date billdateVal = null;
        String entryNumber = null;
        try {
            int istemplate = 0;
            KwlReturnObject result = null;
            String sequenceformat = "NA";
            int nocount;
            DateFormat df = (DateFormat) requestParams.get(Constants.df);
            String companyid = (String) requestParams.get(Constants.companyKey);
            invoiceid = dataMap1.optString("invoiceid", "");
            String termid = dataMap1.optString("termid");
            recId = invoiceid;
            String jeid = null;
            boolean jeautogenflag = false;
            Customer customer = null;
            String custId = dataMap1.optString("customer");
            if (StringUtil.isNullOrEmpty(custId)) {
                String acccode = dataMap1.optString("acccode");
                custId = accInvoiceDAOobj.getCustomerId(companyid, acccode);
            }
            if (StringUtil.isNullOrEmpty(custId)) {
                custId = accInvoiceDAOobj.getCustomerIdForPOS(companyid);
            }
            String accountid = custId;
            KwlReturnObject custresult = null;
            if (!StringUtil.isNullOrEmpty(custId)) {
                custresult = accountingHandlerDAOobj.getObject(Customer.class.getName(), custId);
                customer = (Customer) custresult.getEntityList().get(0);
                if (customer.getAccount() != null) {
                    accountid = customer.getAccount().getID();
                }
            }
            if (StringUtil.isNullOrEmpty(termid)) {
                termid = customer.getCreditTerm().getID();
            }
            String createdby = (String) requestParams.get("createdby");
            String modifiedby = (String) requestParams.get("modifiedby");
            String userFullName = (String) requestParams.get("userfullName");
            String currencyidkeyid = (String) requestParams.get(Constants.currencyKey);
            long createdon = System.currentTimeMillis();
            long updatedon = System.currentTimeMillis();

            String taxid = dataMap1.optString("taxid");
            String costCenterId = dataMap1.optString(Constants.costcenter);
            double taxamount = StringUtil.getDouble(dataMap1.optString("taxamount"));
            double externalCurrencyRate = StringUtil.getDouble(dataMap1.optString("externalcurrencyrate"));
            Discount discount = null;
            double discValue = 0.0;
            double shippingCharges = StringUtil.getDouble(dataMap1.optString("shipping"));
            double otherCharges = StringUtil.getDouble(dataMap1.optString("othercharges"));
            boolean inCash = Boolean.parseBoolean(dataMap1.optString("incash"));
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            KwlReturnObject cmp = accountingHandlerDAOobj.getObject(Company.class.getName(), companyid);
            Company company = (Company) cmp.getEntityList().get(0);
            String currencyid = (dataMap1.getString(Constants.currencyKey) == null ? currencyidkeyid : dataMap1.optString(Constants.currencyKey));
            entryNumber = dataMap1.optString("number", "");
            String contractId = dataMap1.optString("contractId");
            recId = entryNumber;
            String customerid = custId;
            invjson = new JSONObject();
            invjson.put("invoiceid", invoiceid);
            invjson.put("accountid", accountid);
            invjson.put(Constants.customerid, customerid);
            if (StringUtil.isNullOrEmpty(invoiceid)) {
                String msg = checkSOUsedFlag(requestParams, 2);
                if (!StringUtil.isNullOrEmpty(msg)) {//Check if SO is already used in DO or not.
                    throw new AccountingException(msg);
                }
            }
            try {
                billdateVal = df.parse(dataMap1.optString(Constants.BillDate));
            } catch (ParseException ex) {
                Calendar cal = Calendar.getInstance();
                long billdateValue = (long) Long.parseLong(dataMap1.optString(Constants.BillDate).toString());
                cal.setTimeInMillis(billdateValue);
                Date calDate = null;
                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                try {
                    calDate = authHandler.getDateOnlyFormat().parse(CalString);
                } catch (ParseException ex1) {
                    calDate = cal.getTime();
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex1);
                }
                billdateVal = calDate;
                try {
                    billdateVal = df.parse(df.format(billdateVal));
                } catch (ParseException ex1) {
                }
            }
            
            synchronized (this) {
                SequenceFormat prevSeqFormat = null;
                String nextAutoNo = "";
                String nextAutoNoInt = "";
                String datePrefix = "";
                String dateafterPrefix = "";
                String dateSuffix = "";
                boolean isduplicate = false;
                if (!StringUtil.isNullOrEmpty(invoiceid)) {//in edit case checks duplicate     
                    result = accInvoiceDAOobj.getDuplicateInvoiceNumberForEdit(entryNumber, companyid, invoiceid);
                    nocount = result.getRecordTotalCount();
                    if (nocount > 0) {
                        if (inCash) {
                            isduplicate = true;
                            throw new AccountingException("Sales receipt number '" + entryNumber + "' already exists.");
                        } else {
                            isduplicate = true;
                            throw new AccountingException("Invoice number '" + entryNumber + "' already exists.");
                        }
                    } else {
                        KwlReturnObject rst = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                        Invoice inv = (Invoice) rst.getEntityList().get(0);
                        prevSeqFormat = inv.getSeqformat();
                        if (!sequenceformat.equals("NA")) {
                            nextAutoNo = entryNumber;
                        }
                    }
                } else { // create new case checks duplicate
                    result = accInvoiceDAOobj.getInvoiceCount(entryNumber, companyid);
                    nocount = result.getRecordTotalCount();
                    if (nocount > 0) {
                        if (inCash) {
                            isduplicate = true;
                            throw new AccountingException("Sales receipt number '" + entryNumber + "' already exists.");
                        } else {
                            isduplicate = true;
                            throw new AccountingException("Invoice number '" + entryNumber + "' already exists.");
                        }
                    }
                }
                if (!sequenceformat.equals("NA") && prevSeqFormat == null) {
                    int from = StaticValues.AUTONUM_INVOICE;
                    if (inCash) {
                        from = StaticValues.AUTONUM_CASHSALE;
                    }
                    boolean seqformat_oldflag = StringUtil.getBoolean(dataMap1.optString("seqformat_oldflag"));
                    if (seqformat_oldflag) {
                        nextAutoNo = accCompanyPreferencesObj.getNextAutoNumber(companyid, from, sequenceformat);
                    } else {
                        Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                        seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, from, sequenceformat, seqformat_oldflag, billdateVal);
                        nextAutoNo = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                        nextAutoNoInt = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                        datePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                        dateafterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                        dateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                        invjson.put(Constants.SEQFORMAT, sequenceformat);
                        invjson.put(Constants.SEQNUMBER, nextAutoNoInt);
                        invjson.put(Constants.DATEPREFIX, datePrefix);
                        invjson.put(Constants.DATEAFTERPREFIX, dateafterPrefix);
                        invjson.put(Constants.DATESUFFIX, dateSuffix);
                    }
                    entryNumber = nextAutoNo;
                }
                invjson.put("entrynumber", entryNumber);
                invjson.put("autogenerated", nextAutoNo.equals(entryNumber));
            }
            if (StringUtil.isNullOrEmpty(dataMap1.optString("shipaddress"))) {
                invjson.put("shipaddress", customer.getShippingAddress());
            } else {
                invjson.put("shipaddress", dataMap1.optString("shipaddress"));
            }
            invjson.put("isfavourite", dataMap1.optString("isfavourite"));
            invjson.put(Constants.isFixedAsset, false);
            invjson.put(Constants.isLeaseFixedAsset, false);
            invjson.put(Constants.memo, dataMap1.optString(Constants.memo));
            invjson.put("billto", dataMap1.optString("billto"));
            if (dataMap1.optString(Constants.shipdate) != null && !StringUtil.isNullOrEmpty(dataMap1.optString(Constants.shipdate))) {
                try {
                    invjson.put(Constants.shipdate, df.parse(dataMap1.optString(Constants.shipdate)));
                } catch (ParseException ex) {

                    Calendar cal = Calendar.getInstance();
                    long shipDateValue = (long) Long.parseLong(dataMap1.optString(Constants.shipdate).toString());
                    cal.setTimeInMillis(shipDateValue);
                    Date calDate = null;
                    try {
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    } catch (ParseException ex1) {
                        calDate = cal.getTime();
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex1);
                    }
                    Date shipDateVal = calDate;
                    invjson.put(Constants.shipdate, shipDateVal);

                }
            }
            invjson.put("porefno", dataMap1.optString("porefno"));
            if (dataMap1.optString(Constants.duedate) != null) {
                try {
                    invjson.put(Constants.duedate, df.parse(dataMap1.optString(Constants.duedate)));
                } catch (ParseException ex) {
                    Calendar cal = Calendar.getInstance();
                    long dueDateValue = (long) Long.parseLong(dataMap1.optString(Constants.duedate).toString());
                    cal.setTimeInMillis(dueDateValue);
                    Date calDate = null;
                    try {
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    } catch (ParseException ex1) {
                        calDate = cal.getTime();
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex1);
                    }
                    Date dueDateVal = calDate;
                    invjson.put(Constants.duedate, dueDateVal);
                }
            } else {
                Calendar cal = Calendar.getInstance();
                Date calDate = null;
                try {
                    Date billDate = df.parse(dataMap1.optString(Constants.BillDate));
                    cal.setTime(billDate);
                    cal.add(Calendar.DATE, 15);
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    invjson.put(Constants.duedate, calDate);
                } catch (ParseException ex) {
                    long billDateValue = (long) Long.parseLong(dataMap1.optString(Constants.BillDate).toString());
                    cal.setTimeInMillis(billDateValue);
                    cal.add(Calendar.DATE, 15);
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    try {
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    } catch (ParseException ex1) {
                        calDate = cal.getTime();
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex1);
                    }
                    invjson.put(Constants.duedate, calDate);
                }
            }
            invjson.put("template", dataMap1.optString("template"));
            invjson.put(Constants.companyKey, companyid);
            invjson.put(Constants.currencyKey, currencyid);
            invjson.put("externalCurrencyRate", externalCurrencyRate);
            invjson.put("salesPerson", dataMap1.optString("salesPerson"));
            invjson.put(Constants.shipvia, dataMap1.optString(Constants.shipvia));
            invjson.put(Constants.fob, dataMap1.optString(Constants.fob));
            invjson.put("createdby", createdby);
            invjson.put("modifiedby", modifiedby);
            invjson.put("createdon", createdon);
            invjson.put("updatedon", updatedon);
            if (!StringUtil.isNullOrEmpty(termid)) {
                invjson.put("termid", termid);
            }
            invjson.put("partialinv", (dataMap1.optString("partialinv") != null) ? Boolean.parseBoolean(dataMap1.optString("partialinv")) : false);
            // Create Journal Entry
            Map<String, Object> jeDataMap = new HashMap<String, Object>();
            jeDataMap.put(Constants.companyKey, companyid);
            jeDataMap.put(Constants.globalCurrencyKey, requestParams.get(Constants.globalCurrencyKey));
            jeDataMap.put(Constants.df, requestParams.get(Constants.df));  //This format belongs to our global date format[i.e.new SimpleDateFormat("MMMM d, yyyy hh:mm:ss aa")]
            jeDataMap.put(Constants.userdf, requestParams.get(Constants.df));
            String jeSeqFormatId = "";
            synchronized (this) {
                try {
                    HashMap<String, Object> JEFormatParams = new HashMap<String, Object>();
                    JEFormatParams.put(Constants.moduleid, Constants.Acc_GENERAL_LEDGER_ModuleId);
                    JEFormatParams.put("modulename", "autojournalentry");
                    JEFormatParams.put(Constants.companyKey, companyid);
                    JEFormatParams.put("isdefaultFormat", true);

                    KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                    SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
                    Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                    seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, format.getID(), false, billdateVal);
                    String nextAutoNoTemp = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                    int sequence = Integer.parseInt((String) seqNumberMap.get(Constants.SEQNUMBER));
                    String jeDatePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                    String jeDateAfterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                    String jeDateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                    sequence = sequence + counter;
                    String number = "" + sequence;
                    String action = "" + (sequence - counter);
                    nextAutoNoTemp.replaceAll(action, number);
                    jeentryNumber = nextAutoNoTemp.replaceAll(action, number);  //next auto generated number
                    jeSeqFormatId = format.getID();
                    jeautogenflag = true;

                    jeDataMap.put("entrynumber", jeentryNumber);
                    jeDataMap.put("autogenerated", jeautogenflag);
                    jeDataMap.put(Constants.SEQFORMAT, jeSeqFormatId);
                    jeDataMap.put(Constants.SEQNUMBER, number);
                    jeDataMap.put(Constants.DATEPREFIX, jeDatePrefix);
                    jeDataMap.put(Constants.DATEAFTERPREFIX, jeDateAfterPrefix);
                    jeDataMap.put(Constants.DATESUFFIX, jeDateSuffix);
                } catch (ServiceException ex) {
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            jeDataMap.put("entrydate", billdateVal);
            if (!StringUtil.isNullOrEmpty(currencyid) && !currencyid.equalsIgnoreCase(currencyidkeyid)) {
                externalCurrencyRate = accCurrencyDAOobj.getCurrencyToBaseRate(requestParams, currencyid, billdateVal);
                invjson.put("externalCurrencyRate", externalCurrencyRate);
            }
            jeDataMap.put(Constants.companyKey, companyid);
            jeDataMap.put(Constants.memo, dataMap1.optString(Constants.memo));
            invjson.put(Constants.posttext, dataMap1.optString(Constants.posttext));
            jeDataMap.put(Constants.currencyKey, currencyid);
            jeDataMap.put("costcenterid", costCenterId);
            HashSet jeDetails = new HashSet();
            KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Create Journal entry without JEdetails
            JournalEntry journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
            jeid = journalEntry.getID();
            invjson.put("journalerentryid", jeid);
            jeDataMap.put("jeid", jeid);
            String invoiceDetails = dataMap1.optString(Constants.detail);
            List dll = saveInvoiceRowsFromLMS(requestParams, invoiceDetails, jeid, company, jeDetails, currencyid, externalCurrencyRate, dataMap1);
            double[] totals = (double[]) dll.get(0);
            HashSet<InvoiceDetail> invcdetails = (HashSet<InvoiceDetail>) dll.get(1);
            ArrayList<String> prodList = (ArrayList<String>) dll.get(2);
            double disc = 0;
            if (!StringUtil.isNullOrEmpty(dataMap1.optString("discount"))) {
                disc = StringUtil.getDouble(dataMap1.optString("discount"));
            }
            if (disc > 0) {
                JSONObject discjson = new JSONObject();
                discjson.put("discount", disc);
                discjson.put("inpercent", Boolean.parseBoolean(dataMap1.optString("perdiscount")));
                discjson.put("originalamount", totals[1] - totals[0] + totals[2]);
                discjson.put(Constants.companyKey, companyid);
                KwlReturnObject dscresult = accDiscountobj.addDiscount(discjson);
                discount = (Discount) dscresult.getEntityList().get(0);
                invjson.put("discountid", discount.getID());
                discValue = discount.getDiscountValue();
            }
            discValue += totals[0];

            if (inCash) {
                accountid = preferences.getCashAccount().getID();
            }
            double totalInvAmount = totals[1] + shippingCharges + otherCharges - discValue + taxamount + totals[2];
            try {
                Calendar cal = Calendar.getInstance();
                long billdateValue = (long) Long.parseLong(dataMap1.optString(Constants.BillDate).toString());
                cal.setTimeInMillis(billdateValue);
                Date calDate = null;
                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                calDate = authHandler.getDateOnlyFormat().parse(CalString);
                billdateVal = calDate;
            } catch (Exception ep) {
                ep.printStackTrace();
            }
            KwlReturnObject bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, totalInvAmount, currencyid, billdateVal, externalCurrencyRate);
            double totalInvAmountinBase = (Double) bAmt.getEntityList().get(0);
            ArrayList amountApprove = (accountingHandlerDAOobj.getApprovalFlagForAmount(totalInvAmountinBase, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_AMOUNT, companyid));
            boolean amountExceed = (Boolean) amountApprove.get(0);
            ArrayList prodApprove = (accountingHandlerDAOobj.getApprovalFlagForProducts(prodList, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_PRODUCT, companyid));
            boolean prodExists = (Boolean) prodApprove.get(0);
            boolean pendingApprovalFlagForDisc = false;
            int approvalLevelForDisc = 1;
            Iterator invitr = invcdetails.iterator();
            while (invitr.hasNext()) {
                InvoiceDetail ivd = (InvoiceDetail) invitr.next();
                Discount discount1 = ivd.getDiscount();
                String productId = ivd.getInventory().getProduct().getID();
                if (discount1 != null) {
                    double discountVal = discount1.getDiscountValue();
                    try {
                        Calendar cal = Calendar.getInstance();
                        long billdateValue = (long) Long.parseLong(dataMap1.optString(Constants.BillDate).toString());
                        cal.setTimeInMillis(billdateValue);
                        Date calDate = null;
                        String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                        billdateVal = calDate;
                    } catch (Exception et) {
                        et.printStackTrace();
                    }
                    KwlReturnObject dAmount = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, discountVal, currencyid, billdateVal, externalCurrencyRate);
                    double discAmountinBase = (Double) dAmount.getEntityList().get(0);
                    ArrayList prodApproveDisc = (accountingHandlerDAOobj.getApprovalFlagForProductsDiscount(discAmountinBase, productId, Constants.CUSTOMER_INVOICE_APPROVAL, Constants.TRANS_DISCOUNT, companyid, pendingApprovalFlagForDisc, approvalLevelForDisc));
                    pendingApprovalFlagForDisc = (Boolean) prodApproveDisc.get(0);
                    approvalLevelForDisc = (Integer) prodApproveDisc.get(1);
                }
            }
            int pendingApprovalFlag = (istemplate != 2 ? ((amountExceed || prodExists || pendingApprovalFlagForDisc) ? 1 : 0) : 0);//No need of approval if transaction is created as only template
            int approvalLevel = ((Integer) (amountApprove.get(1)) > (Integer) (prodApprove.get(1))) ? (Integer) (amountApprove.get(1)) : (Integer) (prodApprove.get(1));
            if (approvalLevelForDisc > approvalLevel) {
                approvalLevel = approvalLevelForDisc;
            }
            JSONObject jedjson = new JSONObject();
            jedjson.put("srno", jeDetails.size() + 1);
            jedjson.put(Constants.companyKey, companyid);
            jedjson.put("amount", totalInvAmount);
            jedjson.put("accountid", accountid);
            jedjson.put("debit", true);
            jedjson.put("jeid", jeid);
            KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
            JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
            jeDetails.add(jed);
            invjson.put("customerentryid", jed.getID());
            invjson.put(Constants.invoiceamountdue, totalInvAmount);
            invjson.put(Constants.invoiceamountdueinbase, totalInvAmountinBase);
            invjson.put(Constants.invoiceamount, totalInvAmount);
            invjson.put(Constants.invoiceamountinbase, totalInvAmountinBase);
            if (discValue > 0) {
                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", discValue);
                jedjson.put("accountid", preferences.getDiscountGiven().getID());
                jedjson.put("debit", true);
                jedjson.put("jeid", jeid);
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);
            }
            if (shippingCharges > 0) {
                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", shippingCharges);
                jedjson.put("accountid", preferences.getShippingCharges().getID());
                jedjson.put("debit", false);
                jedjson.put("jeid", jeid);
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);
                invjson.put("shipentryid", jed.getID());
            }

            if (!StringUtil.isNullOrEmpty(taxid)) {
                KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), taxid); // (Tax)session.get(Tax.class, taxid);
                Tax tax = (Tax) txresult.getEntityList().get(0);
                invjson.put("taxid", taxid);
                if (taxamount > 0) {
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", taxamount);
                    jedjson.put("accountid", tax.getAccount().getID());
                    jedjson.put("debit", false);
                    jedjson.put("jeid", jeid);
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    invjson.put("taxentryid", jed.getID());
                }
            }
            jeDataMap.put("jedetails", jeDetails);
            jeDataMap.put("pendingapproval", pendingApprovalFlag);
            jeDataMap.put("istemplate", istemplate);
            jeDataMap.put("externalCurrencyRate", externalCurrencyRate);
            jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Add Journal entry details
            journalEntry = (JournalEntry) jeresult.getEntityList().get(0);

            JSONArray jcustomarray = null;
            boolean customfieldArrayflag = true;
            String customfieldArray = dataMap1.optString("customfieldArray", ""); //Custom Data from other Project
            customfieldArray = StringUtil.DecodeText(customfieldArray);
            if (!StringUtil.isNullOrEmpty(customfieldArray)) {
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                String mapWithFieldType = dataMap1.optString("mapWithFieldType");
                customrequestParams.put("customarray", customfieldArray);
                customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("mapWithFieldType", mapWithFieldType);
                jcustomarray = fieldDataManagercntrl.createJSONArrForCustomFieldValueFromOtherSource(customrequestParams);
                customfieldArrayflag = false;
            }
            // Add Custom fields details 
            if (!StringUtil.isNullOrEmpty(dataMap1.optString(Constants.customfield, "")) || !StringUtil.isNullOrEmpty(customfieldArray)) {
                if (customfieldArrayflag) {
                    jcustomarray = new JSONArray(dataMap1.optString(Constants.customfield, "[]"));
                }
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                customrequestParams.put("customarray", jcustomarray);
                customrequestParams.put("modulename", Constants.Acc_JE_modulename);
                customrequestParams.put("moduleprimarykey", Constants.Acc_JEid);
                customrequestParams.put("modulerecid", journalEntry.getID());
                customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("customdataclasspath", Constants.Acc_BillInv_custom_data_classpath);
                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                    jeDataMap.put("accjecustomdataref", journalEntry.getID());
                    jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);
                }
            }

            try {
                Calendar cal = Calendar.getInstance();
                long billdateValue = (long) Long.parseLong(dataMap1.optString(Constants.BillDate).toString());
                cal.setTimeInMillis(billdateValue);
                Date calDate = null;
                String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                calDate = authHandler.getDateOnlyFormat().parse(CalString);
                billdateVal = calDate;
            } catch (Exception ep) {
                ep.printStackTrace();
            }
            KwlReturnObject ERresult = accCurrencyDAOobj.getExcDetailID(requestParams, currencyid, billdateVal, null);
            ExchangeRateDetails erd = (ExchangeRateDetails) ERresult.getEntityList().get(0);
            String erdid = (erd == null) ? null : erd.getID();
            invjson.put("erdid", erdid);
            invjson.put("pendingapproval", pendingApprovalFlag);
            invjson.put("istemplate", istemplate);
            invjson.put("approvallevel", approvalLevel);
            invjson.put("incash", dataMap1.optString("incash"));
            if (StringUtil.isNullOrEmpty(invoiceid)) {// Used to save billing and shipping addresses 
                boolean isDefaultAddress = true;
                Map<String, Object> addressParams = new HashMap<String, Object>();
                if (isDefaultAddress) {
                    addressParams = AccountingAddressManager.getDefaultCustomerAddressParams(customer.getID(), companyid, accountingHandlerDAOobj);// addressParams = getCustomerDefaultAddressParams(customer,companyid);
                } else {
                    addressParams = (HashMap<String, Object>) requestParams.get("addressParamsMap");
                }
                KwlReturnObject addressresult = accountingHandlerDAOobj.saveAddressDetail(addressParams, companyid);
                BillingShippingAddresses bsa = (BillingShippingAddresses) addressresult.getEntityList().get(0);
                invjson.put("billshipAddressid", bsa.getID());
            }
            invjson.put(Constants.Checklocktransactiondate, dataMap1.optString(Constants.BillDate));
            result = accInvoiceDAOobj.addInvoice(invjson, new HashSet());
            invoice = (Invoice) result.getEntityList().get(0);//Create Invoice without invoice-details.
            Iterator itr = invcdetails.iterator();
            while (itr.hasNext()) {
                InvoiceDetail ivd = (InvoiceDetail) itr.next();
                if ((pendingApprovalFlag == 1 || istemplate == 2) && ivd.getInventory().isInvrecord()) {
                    Inventory invtry = ivd.getInventory();
                    invtry.setActquantity(invtry.getQuantity());
                    invtry.setQuantity(0);
                }
                ivd.setInvoice(invoice);
            }
            invjson.put("invoiceid", invoice.getID());
            result = accInvoiceDAOobj.updateInvoice(invjson, invcdetails);
            invoice = (Invoice) result.getEntityList().get(0);//Add invoice details 
            accJournalEntryobj.saveAccountJEs_optimized(jeid);
            if (invoiceid != null) {
                auditTrailObj.insertAuditLog(AuditAction.INVOICE_CREATED, "User " + userFullName + " has added a new customer Invoice " + recId, requestParams, tranID);

            } else if (entryNumber != null) {
                auditTrailObj.insertAuditLog(AuditAction.CASH_SALES_CREATED, "User " + userFullName + " has added a new customer Invoice " + recId, requestParams, tranID);
            }
        } catch (JSONException ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return invoice;
    }

    public String checkSOUsedFlag(HashMap<String, Object> requestParams, int linkflag) throws ServiceException {
        String msg = "";
        try {
            String linkMode = requestParams.get("fromLinkCombo") != null ? (String) requestParams.get("fromLinkCombo") : ""; //When adding Sales order link for Delivery Order update link flag(2) in sale order.
            String linkNumber = requestParams.get("linkNumber") != null ? (String) requestParams.get("fromLinkCombo") : ""; //When adding Sales order link for Delivery Order update link flag(2) in sale order.
            if (!StringUtil.isNullOrEmpty(linkMode) && !StringUtil.isNullOrEmpty(linkNumber)) {
                String[] linkNumbers = linkNumber.split(",");
                if (linkNumbers.length > 0) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                        for (int i = 0; i < linkNumbers.length; i++) {
                            if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkNumbers[i]);
                                SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                                if (salesOrder.getLinkflag() == linkflag) {
                                    msg += salesOrder.getSalesOrderNumber() + ", ";
                                }
                            }
                        }
                        if (!StringUtil.isNullOrEmpty(msg)) {
                            String usedIn = "Customer Invoice";
                            if (linkflag == 2) {
                                usedIn = Constants.Delivery_Order;
                            }
                            msg = "Selected Sales Order(s) are already used in " + usedIn + ".<BR />" + msg.substring(0, msg.length() - 2);
                        }
                    }
                }
            }//outer If
        }//try
        catch (Exception ex) {
            throw ServiceException.FAILURE("checkSOUsedFlag : " + ex.getMessage(), ex);
        }
        return msg;
    }

    private List saveInvoiceRowsFromLMS(HashMap<String, Object> requestParams, String invoiceDetails, String jeid, Company company, HashSet jeDetails, String currencyid, Double externalCurrencyRate, JSONObject dataMap1) throws ServiceException, SessionExpiredException, AccountingException, UnsupportedEncodingException {
        HashSet hs = new HashSet(), rows = new HashSet();
        ArrayList<String> prodList = new ArrayList<String>();
        double totaldiscount = 0, totalamount = 0, taxamount = 0;
        List ll = new ArrayList();
        try {
            DateFormat df = (DateFormat) requestParams.get(Constants.df);
            HashMap<String, Object> GlobalParams = new HashMap<String, Object>();
            GlobalParams.put(Constants.companyKey, (String) requestParams.get(Constants.companyKey));
            GlobalParams.put(Constants.globalCurrencyKey, requestParams.get(Constants.globalCurrencyKey));
            GlobalParams.put(Constants.df, requestParams.get(Constants.df));  //This format belongs to our global date format[i.e.new SimpleDateFormat("MMMM d, yyyy hh:mm:ss aa")]
            GlobalParams.put(Constants.userdf, requestParams.get(Constants.df));
            String companyid = company.getCompanyID();
            boolean inCash = Boolean.parseBoolean(dataMap1.optString("incash"));
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            KwlReturnObject cap1 = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extarPreferences = (ExtraCompanyPreferences) cap1.getEntityList().get(0);

            boolean partialInv = (dataMap1.optString("partialinv") != null) ? Boolean.parseBoolean(dataMap1.optString("partialinv")) : false;

            JSONArray jArr = new JSONArray(invoiceDetails);
            for (int i = 0; i < jArr.length(); i++) {

                JSONObject jobj = jArr.getJSONObject(i);
                InvoiceDetail row = new InvoiceDetail();
                JournalEntryDetail jed;
                row.setSrno(i + 1);
                row.setWasRowTaxFieldEditable(true);// this field has been added after making row tax field editable its value will be set always true from its implementation. i.e from 28-jan-2014.REASON -  when Row Tax Amount field was not editable then tax calculation was taking place according to tax percent, as selected From Tax combo in JS Side.
                if (!StringUtil.isNullOrEmpty(jobj.optString("desc"))) {
                    //try {
                        row.setDescription(StringUtil.DecodeText(jobj.optString("desc")));
                   /* } catch (UnsupportedEncodingException ex) {
                        row.setDescription(jobj.optString("desc"));
                    }*/
                }
                if (preferences.isInventoryAccountingIntegration() && (!preferences.isWithInvUpdate() || inCash) && preferences.isUpdateInvLevel()) {
                    if (!StringUtil.isNullOrEmpty(jobj.optString("invstore"))) {
                        row.setInvstoreid(jobj.optString("invstore"));
                    } else {
                        row.setInvstoreid("");
                    }

                    if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                        row.setInvlocid(jobj.optString("invlocation"));
                    } else {
                        row.setInvlocid("");
                    }
                }

                if (extarPreferences.isIsPOSIntegration() && inCash) {
                    if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                        row.setInvlocid(jobj.optString("invlocation"));
                    } else {
                        row.setInvlocid("");
                    }
                }
                //                SalesOrderDetail rd = (SalesOrderDetail) session.get(SalesOrderDetail.class, jobj.getString("rowid"));\
                String linkMode = dataMap1.optString("fromLinkCombo");
                boolean updateInventoryFlag = (preferences.isWithInvUpdate()) ? false : true;

                double partamount = (jobj.has("partamount") && (!StringUtil.isNullOrEmpty(jobj.get("partamount").toString()))) ? jobj.getDouble("partamount") : 0.0;
                row.setPartamount(partamount);

                if (!StringUtil.isNullOrEmpty(linkMode)) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : ((jobj.getString("savedrowid")) != null ? jobj.getString("savedrowid") : ""));
                        SalesOrderDetail rd = (SalesOrderDetail) rdresult.getEntityList().get(0);
                        row.setSalesorderdetail(rd);

                        if (updateInventoryFlag && partialInv) {
                            double sodAmount = rd.getQuantity() * 100;

                            double invDetailAmount = getInvoiceDetailAMount(rd);
                            invDetailAmount += jobj.getDouble("quantity") * partamount;
                            if (sodAmount > invDetailAmount) {
                                updateInventoryFlag = false;
                            }
                        }
                    } else if (linkMode.equalsIgnoreCase(Constants.Delivery_Order)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        DeliveryOrderDetail deliveryOrderDetail = (DeliveryOrderDetail) rdresult.getEntityList().get(0);
                        row.setDeliveryOrderDetail(deliveryOrderDetail);
                    } else if (linkMode.equalsIgnoreCase(Constants.CUSTOMER_QUOTATION)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(QuotationDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        QuotationDetail quotationDetail = (QuotationDetail) rdresult.getEntityList().get(0);
                        row.setQuotationDetail(quotationDetail);
                    }
                }
                row.setCompany(company);
                row.setRate(jobj.getDouble("rate"));
                String productid = "";
                if (StringUtil.isNullOrEmpty(jobj.getString(Constants.productid))) {
                    String productcode = jobj.getString("productcode");
                    productid = accInvoiceDAOobj.getproductId(companyid, productcode);
                } else {
                    productid = jobj.getString(Constants.productid);
                }
                KwlReturnObject prdresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
                Product product = (Product) prdresult.getEntityList().get(0);
                prodList.add(productid);
                JSONObject inventoryjson = new JSONObject();
                inventoryjson.put(Constants.productid, productid);
                double quantity = 1;
                if (jobj.has("quantity")) {
                    quantity = jobj.getDouble("quantity");
                }
                inventoryjson.put("quantity", quantity);
                if (jobj.has("uomid")) {
                    inventoryjson.put("uomid", jobj.getString("uomid"));
                }
                if (jobj.has("baseuomquantity") && jobj.get("baseuomquantity") != null) {
                    inventoryjson.put("baseuomquantity", updateInventoryFlag ? jobj.getDouble("baseuomquantity") : 0);
                    inventoryjson.put("actquantity", updateInventoryFlag ? 0 : jobj.getDouble("baseuomquantity"));
                    inventoryjson.put("baseuomrate", jobj.has("baseuomrate") ? jobj.getDouble("baseuomrate") : 0.0);
                } else {
                    inventoryjson.put("baseuomquantity", updateInventoryFlag ? quantity : 0);
                    inventoryjson.put("actquantity", updateInventoryFlag ? 0 : quantity);
                    inventoryjson.put("baseuomrate", jobj.has("baseuomrate") ? jobj.getDouble("baseuomrate") : 0.0);
                }
                inventoryjson.put("invrecord", updateInventoryFlag ? true : false);
                if (jobj.has("desc")) {
                    inventoryjson.put("description", jobj.getString("desc"));
                }
                inventoryjson.put("carryin", false);
                inventoryjson.put("defective", false);
                inventoryjson.put("newinventory", false);
                inventoryjson.put(Constants.companyKey, companyid);
                try {
                    DateFormat df1 = (DateFormat) requestParams.get(Constants.df);
                    inventoryjson.put("updatedate", df1.parse(dataMap1.optString(Constants.BillDate)));
                } catch (ParseException e) {
                    Calendar cal = Calendar.getInstance();
                    long dateValue = (long) Long.parseLong(dataMap1.optString(Constants.BillDate).toString());
                    cal.setTimeInMillis(dateValue);
                    Date calDate = null;
                    String CalString = authHandler.getDateOnlyFormat().format(cal.getTime());
                    try {
                        calDate = authHandler.getDateOnlyFormat().parse(CalString);
                    } catch (ParseException ex) {
                        calDate = cal.getTime();
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    Date date = calDate;
                    inventoryjson.put("updatedate", date);
                }

                KwlReturnObject invresult = accProductObj.addInventory(inventoryjson);
                Inventory inventory = (Inventory) invresult.getEntityList().get(0);

                row.setInventory(inventory);

                double rowAmount = authHandler.round(row.getRate() * quantity, companyid);
                double rowdiscount = 0;
                if (partamount != 0.0) {
                    rowAmount = rowAmount * (partamount / 100);
                }
                totalamount += rowAmount;
                Discount discount = null;
                double disc = 0;
                int rowdisc = 0;
                if (jobj.has("prdiscount")) {
                    disc = jobj.getDouble("prdiscount");
                }
                if (jobj.has("discountispercent")) {
                    rowdisc = jobj.getInt("discountispercent");
                }
                if (jobj.has("rateIncludingGst")) {
                    row.setRateincludegst(jobj.optDouble("rateIncludingGst", 0));
                }
                if (disc != 0.0) {
                    JSONObject discjson = new JSONObject();
                    discjson.put("discount", disc);
                    discjson.put("inpercent", (rowdisc == 1) ? true : false);
                    discjson.put("originalamount", rowAmount);
                    discjson.put(Constants.companyKey, companyid);
                    KwlReturnObject dscresult = accDiscountobj.addDiscount(discjson);
                    discount = (Discount) dscresult.getEntityList().get(0);
                    row.setDiscount(discount);
                    rowdiscount = discount.getDiscountValue();
                    totaldiscount += rowdiscount;
                }
                {
                    JSONObject jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", rowAmount);
                    jedjson.put("accountid", product.getSalesAccount().getID());
                    jedjson.put("debit", false);
                    jedjson.put("jeid", jeid);
                    KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);

                    row.setDeferredJeDetailId(jed.getID());
                    JSONArray jcustomarray = null;
                    boolean customfieldArrayflag = true;
                    String customfieldArray = jobj.optString("customfieldArray", ""); //Custom Data from other Project
                    customfieldArray = StringUtil.DecodeText(customfieldArray);
                    if (!StringUtil.isNullOrEmpty(customfieldArray)) {
                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        String mapWithFieldType = dataMap1.optString("mapWithFieldType");
                        customrequestParams.put("customarray", customfieldArray);
                        customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        customrequestParams.put("mapWithFieldType", mapWithFieldType);
                        jcustomarray = fieldDataManagercntrl.createJSONArrForCustomFieldValueFromOtherSource(customrequestParams);
                        customfieldArrayflag = false;
                    }
                    // Add Custom fields details 
                    if (!StringUtil.isNullOrEmpty(jobj.optString(Constants.customfield, "")) || !StringUtil.isNullOrEmpty(customfieldArray)) {
                        if (customfieldArrayflag) {
                            jcustomarray = new JSONArray(jobj.optString(Constants.customfield, "[]"));
                        }
                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        customrequestParams.put("customarray", jcustomarray);
                        customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
                        customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);// Constants.Acc_JEDetail_recdetailId
                        customrequestParams.put("modulerecid", jed.getID());
                        customrequestParams.put("recdetailId", row.getInventory().getID());
                        customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        customrequestParams.put("customdataclasspath", Constants.Acc_BillInvDetail_custom_data_classpath);
                        KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                        if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                            jedjson.put("accjedetailcustomdata", jed.getID());
                            jedjson.put("jedid", jed.getID());
                            jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                        }
                    }
                }
                String rowtaxid = jobj.optString("prtaxid", "");
                if (!StringUtil.isNullOrEmpty(rowtaxid)) {
                    boolean taxExist = false;
                    KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), rowtaxid); // (Tax)session.get(Tax.class, taxid);
                    Tax rowtax = (Tax) txresult.getEntityList().get(0);
                    if (rowtax == null) {
                        //throw new AccountingException(messageSource.getMessage("acc.so.taxcode", null, RequestContextUtils.getLocale(request)));
                    } else {
                        row.setTax(rowtax);
                        double rowtaxamount = StringUtil.getDouble(jobj.getString("taxamount"));//rowtaxamount=(rowAmount - rowdiscount) * rowTaxper/100;
                        row.setRowTaxAmount(rowtaxamount);
                        taxamount += rowtaxamount;
                        if (taxamount > 0) {
                            Iterator itr = jeDetails.iterator();
                            while (itr.hasNext()) {
                                jed = (JournalEntryDetail) itr.next();
                                if (jed.getAccount() == rowtax.getAccount()) {
                                    JSONObject jedjson = new JSONObject();
                                    jedjson.put("jedid", jed.getID());
                                    jedjson.put("amount", jed.getAmount() + rowtaxamount);
                                    KwlReturnObject jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                    taxExist = true;
                                    break;
                                }
                            }
                            if (!taxExist) {
                                JSONObject jedjson = new JSONObject();
                                jedjson = new JSONObject();
                                jedjson.put("srno", jeDetails.size() + 1);
                                jedjson.put(Constants.companyKey, companyid);
                                jedjson.put("amount", rowtaxamount);
                                jedjson.put("accountid", rowtax.getAccount().getID());
                                jedjson.put("debit", false);
                                jedjson.put("jeid", jeid);
                                KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                jeDetails.add(jed);

                            }
                        }
                    }
                }
                rows.add(row);
            }
        } catch (JSONException ex) {
            throw ServiceException.FAILURE("saveInvoiceRows : " + ex.getMessage(), ex);
        }
        ll.add(new double[]{totaldiscount, totalamount, taxamount});
        ll.add(rows);
        ll.add(prodList);
        return ll;
    }


    @Override
    public void saveDONewBatch(String batchJSON, Inventory inventory, HttpServletRequest request, DeliveryOrderDetail deliveryOrderDetail, List<StockMovement> stockMovementsList, boolean isLockedinSo, boolean isbatchlockedinSO, boolean isSeriallockedinSO, String replacebatchdetails,List<InterStoreTransferRequest> interStoreTransferList) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {

        JSONObject paramJObj = new JSONObject();
        try {
            Enumeration<String> attributes = request.getAttributeNames();
            while (attributes.hasMoreElements()) {
                String attribute = attributes.nextElement();
                paramJObj.put(attribute, request.getAttribute(attribute));
            }
            Enumeration<String> parameters = request.getParameterNames();
            while (parameters.hasMoreElements()) {
                String parameter = parameters.nextElement();
                paramJObj.put(parameter, request.getParameter(parameter));
            }
            paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
            paramJObj.put(Constants.companyKey, sessionHandlerImpl.getCompanyid(request));
        } catch (JSONException e) {
            e.printStackTrace();
        }
        ExtraCompanyPreferences extraCompanyPreferences = null;
        KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), sessionHandlerImpl.getCompanyid(request));
        extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
        
        if(extraCompanyPreferences.isAutoFillBatchDetails()){
            saveDONewBatchForAutoFilledDetailsJson(batchJSON, inventory, paramJObj, deliveryOrderDetail, stockMovementsList, isLockedinSo, isbatchlockedinSO, isSeriallockedinSO, replacebatchdetails);
        }else{
            saveDONewBatchJson(batchJSON, inventory, paramJObj, deliveryOrderDetail, stockMovementsList, isLockedinSo, isbatchlockedinSO, isSeriallockedinSO, replacebatchdetails);
        }
        
    }

    @Override
    public void saveDONewBatchJson(String batchJSON, Inventory inventory, JSONObject paramJobj, DeliveryOrderDetail deliveryOrderDetail, List<StockMovement> stockMovementsList, boolean isLockedinSo, boolean isbatchlockedinSO, boolean isSeriallockedinSO, String replacebatchdetails) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        double ActbatchQty = 1;
        double batchQty = 0;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isConsignment = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        boolean isnegativestockforlocwar = false;
        boolean isnegativestockfordo = false;
        int serialsequence = 1 , batchsequence = 1; // for user selected sequence of batch and serial while creating DO.
        boolean isQAEnable = false;
        String productId = "";
        KwlReturnObject kmsg = null, kmsgOldBatch = null;
        DateFormat df = authHandler.getDateOnlyFormat();
        DateFormat df2 = new SimpleDateFormat(Constants.yyyyMMdd);
        String companyid = paramJobj.getString(Constants.companyKey);
        ExtraCompanyPreferences extraCompanyPreferences = null;
        KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), paramJobj.getString(Constants.companyKey));
        extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
        isnegativestockforlocwar = extraCompanyPreferences.isIsnegativestockforlocwar();
        CompanyAccountPreferences companyPreferences = null;
        KwlReturnObject prefresult = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), paramJobj.getString(Constants.companyKey));
        companyPreferences = prefresult != null ? (CompanyAccountPreferences) prefresult.getEntityList().get(0) : null;
        isnegativestockfordo = companyPreferences.getNegativestock()!=1;
        //accessed the product which option is activated i.e True or false
        if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), inventory.getProduct().getID());
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
            isQAEnable = product.isQaenable();
            productId = product.getProductid();
        }

        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        StockMovementDetail smd = null;
        StockMovement stockMovement = null;
        InterStoreTransferRequest interStoreTransfer = null;
        ISTDetail srd = null;
        boolean isPickPackFlow=extraCompanyPreferences.isPickpackship();
        if(deliveryOrderDetail.getDeliveryOrder().isFixedAssetDO() || deliveryOrderDetail.getDeliveryOrder().isLeaseDO() || deliveryOrderDetail.getDeliveryOrder().isIsconsignment()){
            isPickPackFlow=false;
        }
        /**
         * During Invoice with Auto DO generation with pick pack ship enabled status field is not set hence setting it here to Picked by default
         */
         if (deliveryOrderDetail.getDeliveryOrder().isIsAutoGeneratedDO() && isPickPackFlow) {
            MasterItem minstatus = deliveryOrderDetail.getDeliveryOrder().getStatus();
            if (minstatus == null) { //if current status of DO is null then proceed to set the status as Picked
                KwlReturnObject kwlmasterobj = accMasterItemsDAOobj.getMasterItemByNameorID(companyid, "Picked", "10", "mst.id", "mst.value");
                String statusmasterid = kwlmasterobj.getEntityList().isEmpty() ? "" : kwlmasterobj.getEntityList().get(0).toString();
                if (StringUtil.isNullOrEmpty(statusmasterid)) {
                    throw new AccountingException(messageSource.getMessage("acc.companypreferences.statusforpickpackshipnotavailable", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                } else {
                    KwlReturnObject kwlmasteritem = accMasterItemsDAOobj.getMasterItem(statusmasterid);
                    MasterItem miobj = (MasterItem) (kwlmasteritem.getEntityList().isEmpty() ? null : kwlmasteritem.getEntityList().get(0));
                    deliveryOrderDetail.getDeliveryOrder().setStatus(miobj);
                }
            }
        }
        NewProductBatch productBatch = null;
        String productBatchId = "";
        String serialNames="";
        String entryNumber = paramJobj.optString("numberDo", null) != null ? paramJobj.getString("numberDo") : paramJobj.optString("number", "");
        Map<Store, StockMovement> storeWiseStockMovement = new HashMap<Store, StockMovement>();
        Map<Store, InterStoreTransferRequest> storeWiseInterStoreTransferRequest = new HashMap<Store, InterStoreTransferRequest>();

        /**
         * Get Inter Store / Location Sequence format
         */
        String interstore_loc_No = "";
        SeqFormat seqFormat = null;
        try {
            if (isPickPackFlow && !extraCompanyPreferences.isInterloconpick()) {

                seqFormat = seqService.getDefaultSeqFormat(deliveryOrderDetail.getCompany(), ModuleConst.INTER_STORE_TRANSFER);
                if(seqFormat!=null){
                    interstore_loc_No = seqService.getNextFormatedSeqNumber(seqFormat);
                }else{
                    interstore_loc_No=deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber();
                }

            } else if (isPickPackFlow) {
                seqFormat = seqService.getDefaultSeqFormat(deliveryOrderDetail.getCompany(), ModuleConst.INTER_LOCATION_TRANSFER);
                if(seqFormat!=null){
                    interstore_loc_No = seqService.getNextFormatedSeqNumber(seqFormat);
                }else{
                    interstore_loc_No=deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber();
                }
            }
        } catch (SeqFormatException ex) {
            throw new AccountingException(messageSource.getMessage("acc.companypreferences.defaultsequenceformatforistnotset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
        }

        boolean sendForQAApproval = paramJobj.optBoolean("sendForQAApproval", false);
        String interStoreTransactionNo = "";
        SeqFormat interStoreTransferSeqFormat = null;
        Store qaStore = null;
        InterStoreTransferRequest interStoreTransferQC = null;
        ISTDetail istDetailQC = null;
        Map<Store, InterStoreTransferRequest> storeWiseInterStoreTransferRequestForQC = new HashMap<Store, InterStoreTransferRequest>();
        try {
            if (sendForQAApproval) {
                if (!StringUtil.isNullOrEmpty(paramJobj.optString("interstoreSeqNo")) && !StringUtil.isNullOrEmpty(paramJobj.optString("interstoreseqFormat"))) {
                    interStoreTransactionNo = paramJobj.optString("interstoreSeqNo");
                    interStoreTransferSeqFormat = (SeqFormat) paramJobj.opt("interstoreseqFormat");
                } else {
                    throw new AccountingException(messageSource.getMessage("acc.companypreferences.defaultsequenceformatforistnotset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
                KwlReturnObject tostoreres = accountingHandlerDAOobj.getObject(Store.class.getName(), extraCompanyPreferences.getInspectionStore());
                qaStore = (Store) tostoreres.getEntityList().get(0);
                if (qaStore == null) {
                    throw new InventoryException(messageSource.getMessage("acc.companypreferences.qastore.notset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
            }
        } catch (AccountingException ex) {
            throw new AccountingException(ex.getMessage());
        }
        Map oldBatchMap = new HashMap();
        Map newBatchMap = new HashMap();
        if(deliveryOrderDetail.getSodetails() != null && !StringUtil.isNullOrEmpty(deliveryOrderDetail.getSodetails().getID())){
           kmsgOldBatch = accCommonTablesDAO.getBatchMapIdQtyByDocumentId(companyid, deliveryOrderDetail.getSodetails().getID());
        }
        
        if (kmsgOldBatch == null || kmsgOldBatch.getEntityList().isEmpty() || kmsgOldBatch.getRecordTotalCount() > 0) {
            if (deliveryOrderDetail.getCidetails() != null && deliveryOrderDetail.getCidetails().getSalesorderdetail() != null) {
                String sodId = deliveryOrderDetail.getCidetails().getSalesorderdetail().getID();
                kmsgOldBatch = accCommonTablesDAO.getBatchMapIdQtyByDocumentId(companyid, sodId);
            }
        }
        if (kmsgOldBatch != null && !kmsgOldBatch.getEntityList().isEmpty() && kmsgOldBatch.getRecordTotalCount() > 0) {
            Iterator itr = kmsgOldBatch.getEntityList().iterator();
            while (itr.hasNext()) {
                Object[] obj = (Object[]) itr.next();
                String batchMapId = obj[0] != null ? (String) obj[0] : "";
                double batchMapQty = obj[1] != null ? (double) obj[1] : 0;
                if (!StringUtil.isNullOrEmpty(batchMapId)) {
                    oldBatchMap.put(batchMapId, authHandler.roundQuantity(batchMapQty, companyid));
                }
            }
        }
        
        for (int i = 0; i < jArr.length(); i++) {
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            if (jSONObject.has("quantity") && !jSONObject.optString("quantity").equals("undefined") && !jSONObject.optString("quantity").isEmpty()) {
                ActbatchQty = authHandler.roundQuantity(jSONObject.getDouble("quantity"), companyid);
            }
            String stockType = jSONObject.has("stocktype") ? jSONObject.getString("stocktype") : "";
            if (batchQty == 0) {
                batchQty = authHandler.roundQuantity(jSONObject.getDouble("quantity"), companyid);

                //as we are require store object in stock movment so taken warehouse id from that we have find out Store
                Store store = null;
                Store tostoreObj = null;
                if (isWarehouseForProduct && isLocationForProduct) {
                    KwlReturnObject warehouseObj = accountingHandlerDAOobj.getObject(Store.class.getName(), jSONObject.optString("warehouse"));
                    store = (Store) warehouseObj.getEntityList().get(0);
                }
                //Made entry in stock movment so to out the data from company warehouse
                if (isWarehouseForProduct && isLocationForProduct) {
                    if (sendForQAApproval && isQAEnable) {
                        /**
                         * If DO is send for QA approval then need to create
                         * store wise separate inter store transfer request.
                         * Create IST request and set values for required
                         * fields.
                         */
                        if (storeWiseInterStoreTransferRequestForQC.containsKey(store)) {
                            interStoreTransferQC = storeWiseInterStoreTransferRequestForQC.get(store);
                            interStoreTransferQC.setAcceptedQty(authHandler.roundQuantity(interStoreTransferQC.getAcceptedQty() + jSONObject.optDouble("quantity", 0.0), companyid));
                            interStoreTransferQC.setOrderedQty(authHandler.roundQuantity(interStoreTransferQC.getOrderedQty() + jSONObject.optDouble("quantity", 0.0), companyid));
                        } else {
                            if (store != null) {
                                interStoreTransferQC = new InterStoreTransferRequest(deliveryOrderDetail.getProduct(), store, qaStore, inventory.getProduct().getUnitOfMeasure() != null ? inventory.getProduct().getUnitOfMeasure() : deliveryOrderDetail.getUom());
                                interStoreTransferQC.setAcceptedQty(authHandler.roundQuantity(jSONObject.optDouble("quantity", 0.0), companyid));
                                interStoreTransferQC.setOrderedQty(authHandler.roundQuantity(jSONObject.optDouble("quantity", 0.0), companyid));
                                interStoreTransferQC.setRemark(deliveryOrderDetail.getRemark());
                                interStoreTransferQC.setCostCenter(deliveryOrderDetail.getDeliveryOrder().getCostcenter());
                                interStoreTransferQC.setTransactionNo(interStoreTransactionNo);
                                interStoreTransferQC.setBusinessDate(deliveryOrderDetail.getDeliveryOrder().getOrderDate());
                                interStoreTransferQC.setUom(deliveryOrderDetail.getUom());
                                String doNumber = deliveryOrderDetail.getDeliveryOrder() != null && !StringUtil.isNullOrEmpty(deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber()) ? deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber() : "";
                                interStoreTransferQC.setMemo((StringUtil.isNullOrEmpty(doNumber) ? ("IST created for QC against DO.") : ("IST created for QC against DO:" + doNumber)));
                                interStoreTransferQC.setProduct(deliveryOrderDetail.getProduct());
                                interStoreTransferQC.setPackaging(deliveryOrderDetail.getProduct().getPackaging());
                                storeWiseInterStoreTransferRequestForQC.put(store, interStoreTransferQC);

                            }
                        }
                    } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                        /**
                         * If Pick Pack Flow is Enable then add entry in Inter
                         * Store/Location Transfer
                         */
                        if (!StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackinglocation()) || !StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackingstore())) {
                            if (storeWiseInterStoreTransferRequest.containsKey(store)) {
                                interStoreTransfer = storeWiseInterStoreTransferRequest.get(store);
                                interStoreTransfer.setAcceptedQty(authHandler.roundQuantity(interStoreTransfer.getAcceptedQty() + jSONObject.optDouble("quantity", 0.0), companyid));
                                interStoreTransfer.setOrderedQty(authHandler.roundQuantity(interStoreTransfer.getOrderedQty() + jSONObject.optDouble("quantity", 0.0), companyid));
                             } else {
                                if (store != null) {
                                    if (extraCompanyPreferences.isInterloconpick()) {
                                        interStoreTransfer = new InterStoreTransferRequest(deliveryOrderDetail.getProduct(), store, store, deliveryOrderDetail.getUom());
                                    } else {
                                        KwlReturnObject tostoreres = accountingHandlerDAOobj.getObject(Store.class.getName(), extraCompanyPreferences.getPackingstore());
                                        tostoreObj = (Store) tostoreres.getEntityList().get(0);
                                        interStoreTransfer = new InterStoreTransferRequest(deliveryOrderDetail.getProduct(), store, tostoreObj, deliveryOrderDetail.getUom());
                                    }
                                    String doNumber = deliveryOrderDetail.getDeliveryOrder() != null && !StringUtil.isNullOrEmpty(deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber()) ? deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber() : "";
                                    interStoreTransfer.setAcceptedQty(authHandler.roundQuantity(jSONObject.optDouble("quantity", 0.0), companyid));
                                    interStoreTransfer.setOrderedQty(authHandler.roundQuantity(jSONObject.optDouble("quantity", 0.0), companyid));
                                    interStoreTransfer.setRemark(deliveryOrderDetail.getRemark());
                                    interStoreTransfer.setTransactionNo(interstore_loc_No);
                                    interStoreTransfer.setBusinessDate(deliveryOrderDetail.getDeliveryOrder().getOrderDate());
                                    interStoreTransfer.setUom(deliveryOrderDetail.getUom());//ERM-999 Custom Memo to identify Pick Pack generated IST entries 
                                    interStoreTransfer.setMemo((StringUtil.isNullOrEmpty(doNumber) ? (Constants.pickPack_DO_IST_Memo) : (Constants.pickPack_DO_IST_Memo + doNumber)));
                                    interStoreTransfer.setProduct(deliveryOrderDetail.getProduct());
                                    interStoreTransfer.setPackaging(deliveryOrderDetail.getProduct().getPackaging());
                                    storeWiseInterStoreTransferRequest.put(store, interStoreTransfer);


                                }
                            }
                        }
                    } else {
                        /**
                         * Add entry in Stock Movement in Normal DO
                         */
                        if (storeWiseStockMovement.containsKey(store)) {
                        stockMovement = storeWiseStockMovement.get(store);
                        stockMovement.setQuantity(authHandler.roundQuantity(stockMovement.getQuantity() + jSONObject.optDouble("quantity", 0.0), companyid));
                    } else {
                        stockMovement = new StockMovement();
                        if (store != null) {
                            stockMovement.setStore(store);
                        }
                        stockMovement.setCompany(inventory.getCompany());
                        stockMovement.setProduct(inventory.getProduct());
                        stockMovement.setStockUoM(inventory.getProduct().getUnitOfMeasure());
                        stockMovement.setPricePerUnit(deliveryOrderDetail.getBaseuomrate() < 1 ? (deliveryOrderDetail.getRate() * (1/deliveryOrderDetail.getBaseuomrate())) : deliveryOrderDetail.getRate() / deliveryOrderDetail.getBaseuomrate());
                        stockMovement.setQuantity(authHandler.roundQuantity(jSONObject.optDouble("quantity", 0.0), companyid));
                        stockMovement.setTransactionDate(deliveryOrderDetail.getDeliveryOrder().getOrderDate());
                        stockMovement.setModuleRefId(deliveryOrderDetail.getDeliveryOrder().getID());
                        stockMovement.setModuleRefDetailId(deliveryOrderDetail.getID());
                        stockMovement.setCustomer(deliveryOrderDetail.getDeliveryOrder().getCustomer());
                        stockMovement.setCostCenter(deliveryOrderDetail.getDeliveryOrder().getCostcenter());
                        stockMovement.setTransactionNo(StringUtil.isNullOrEmpty(deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber()) ? entryNumber : deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber());
                        stockMovement.setRemark((deliveryOrderDetail.getDeliveryOrder().isIsconsignment()? "Consignment ": "")+"Delivery Order Created");
                        stockMovement.setTransactionModule(deliveryOrderDetail.getDeliveryOrder().isIsconsignment() ? TransactionModule.ERP_Consignment_DO : TransactionModule.ERP_DO);
                        stockMovement.setTransactionType(TransactionType.OUT);
                        stockMovement.setMemo(deliveryOrderDetail.getDeliveryOrder().getMemo());
                        storeWiseStockMovement.put(store, stockMovement);
                    }                  
                }
                }
            }
            /**
             * If a Pick Pack DO is linked to an SO with lock quantity then
             * reduce the lock qty from the default warehouse.
             */
            if (isLockedinSo && (((!sendForQAApproval || !isQAEnable) && isPickPackFlow) || (sendForQAApproval && !isPickPackFlow))) {
                String doid = deliveryOrderDetail.getDeliveryOrder() != null ? deliveryOrderDetail.getDeliveryOrder().getID() : "";
                String productid = deliveryOrderDetail.getProduct() != null ? deliveryOrderDetail.getProduct().getID() : "";
                String sodetailid = "";
                KwlReturnObject kwlso = accInvoiceDAOobj.getSalesOrdersFromDO(doid, companyid);
                ArrayList filter_names = null;
                ArrayList filter_params = null;
                HashMap requestparams = null;
                SalesOrder salesorder =null;
                if(!kwlso.getEntityList().isEmpty()){
                Object[] objarr = (Object[]) kwlso.getEntityList().get(0);
                    salesorder = (SalesOrder) objarr[0];
                } else {
                    if(deliveryOrderDetail.getCidetails() != null && deliveryOrderDetail.getCidetails().getSalesorderdetail() != null && deliveryOrderDetail.getCidetails().getSalesorderdetail().getSalesOrder() != null){
                        salesorder = deliveryOrderDetail.getCidetails().getSalesorderdetail().getSalesOrder();
                    }
                }
                if (salesorder != null && salesorder.isLockquantityflag()) { //getting sodetails from salesorder and its lockqty
                    Set<SalesOrderDetail> sodetails = salesorder.getRows();
                    if (!(sodetails == null || sodetails.isEmpty())) {
                        for (SalesOrderDetail sod : sodetails) {
                            sodetailid = sod.getID();
                            if (sod.getProduct().getID().equalsIgnoreCase(productid)) {
                                filter_names = new ArrayList();
                                filter_params = new ArrayList();
                                requestparams = new HashMap();

                                filter_names.add("documentid");
                                filter_params.add(sodetailid);

                                requestparams.put("filter_names", filter_names);
                                requestparams.put("filter_params", filter_params);

                                KwlReturnObject batchresult = accMasterItemsDAOobj.getBatchesForDocuments(requestparams);
                                List batchlist = batchresult.getEntityList();
                                Iterator LocitrResult = batchlist.iterator();
                                Product product = sod.getProduct();
                                String batchname= "";
                                
                                while (LocitrResult.hasNext()) {
                                    LocationBatchDocumentMapping lbdm = (LocationBatchDocumentMapping) LocitrResult.next();
                                    NewProductBatch npb = lbdm.getBatchmapid();
                                    if (product.isIsBatchForProduct()) {
                                        batchname = npb.getBatchname() != null ? npb.getBatchname() : "";
                                    }//getting batchname to check for different batches of same product
                                    if (npb.getWarehouse().getId().equalsIgnoreCase(jSONObject.optString("warehouse", ""))) {
                                        if (npb.getLocation().getId().equalsIgnoreCase(jSONObject.optString("location", ""))) {
                                            if (batchname.equalsIgnoreCase(jSONObject.optString("batchname", ""))) {
                                                npb.setLockquantity(authHandler.roundQuantity(npb.getLockquantity() - jSONObject.optDouble("quantity", 0.0), companyid));
                                            }
                                        }
                                    }
                                }
                                //for serial or batchserial product get newbatchserial ids and reduce lock quantities 
                                if (product.isIsSerialForProduct()) {
                                    //same previous filter names and params can be used for serials hence passing hashmap directly
                                    KwlReturnObject serialkwl = accMasterItemsDAOobj.getSerialsForDocuments(requestparams);
                                    List seriallist = serialkwl.getEntityList();
                                    Iterator serialitr = seriallist.iterator();
                                    while (serialitr.hasNext()) {
                                        SerialDocumentMapping sdm = (SerialDocumentMapping) serialitr.next();
                                        NewBatchSerial nbs = sdm.getSerialid();
                                        //check if there are different serials or different batchnames 
                                        if (nbs.getId().equalsIgnoreCase(jSONObject.optString("serialnoid", ""))) {
                                            nbs.setLockquantity(0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) && (batchQty == ActbatchQty)) {
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.optString("quantity"));
                documentMap.put("documentid", deliveryOrderDetail.getID());
                documentMap.put(Constants.isConsignment, false);  ///in mapping kee thids
                documentMap.put("transactiontype", "27");//This is DO Type Tranction 
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("mfgdate",null))) {
                    documentMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("expdate",null))) {
                    documentMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expdate")));
                }
                documentMap.put("batchmapid", jSONObject.optString("purchasebatchid"));
                if (StringUtil.isNullOrEmpty((String) documentMap.get("batchmapid")) && (isBatchForProduct || isSerialForProduct)){
                    throw new AccountingException("Please select batch details for product with id " + productId);
                }
                if (!isConsignment && !StringUtil.isNullOrEmpty(stockType)) {
                    documentMap.put("stocktype", stockType);
                }
                if (isWarehouseForProduct && isLocationForProduct) {
                    smd = new StockMovementDetail();
                    srd = new ISTDetail();
                    istDetailQC = new ISTDetail();
                    //as we are require Location object in stock movment so taken inventoryLocation id from that we have find out Location
                    KwlReturnObject locationUpdate = accountingHandlerDAOobj.getObject(Location.class.getName(), jSONObject.optString("location"));
                    Location locationObj = (Location) locationUpdate.getEntityList().get(0);
                    String tolocationid = paramJobj.optString("pickpacklocation", ""); // default location in case of pick pack
                    Location tolocationidobj = null;
                    String packingstoreid = "";
                    Store packing_store = null;
                    KwlReturnObject StorelObj = null;
                    if(!StringUtil.isNullOrEmpty(tolocationid)){
                           KwlReturnObject toLocation = accountingHandlerDAOobj.getObject(Location.class.getName(), tolocationid);
                            tolocationidobj = (Location) toLocation.getEntityList().get(0);                            
                    }else if(extraCompanyPreferences!=null && !StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackingstore())){
                          packingstoreid = extraCompanyPreferences.getPackingstore();
                          StorelObj = accountingHandlerDAOobj.getObject(Store.class.getName(), packingstoreid);
                          if(StorelObj!=null && StorelObj.getEntityList().get(0)!=null){
                           packing_store = (Store) StorelObj.getEntityList().get(0);
                           tolocationidobj = packing_store.getDefaultLocation();    
                          }                         
                    }
                    if (locationObj != null) {
                        if (sendForQAApproval && isQAEnable) {
                            if (qaStore.getDefaultLocation() == null) {
                                throw new AccountingException(messageSource.getMessage("acc.companypreferences.defaultLocationNotSetforQAStore", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                            }
                            Location toLocatioObj = qaStore.getDefaultLocation();
                            istDetailQC.setDeliveredLocation(toLocatioObj);
                            istDetailQC.setIssuedLocation(locationObj);
                        } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                            if (extraCompanyPreferences.isInterloconpick() && !StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackinglocation())) {
                                KwlReturnObject toLocation = accountingHandlerDAOobj.getObject(Location.class.getName(), extraCompanyPreferences.getPackinglocation());
                                Location toLocatioObj = (Location) toLocation.getEntityList().get(0);
                                srd.setDeliveredLocation(toLocatioObj);
                                srd.setIssuedLocation(locationObj);
                            } else if (!extraCompanyPreferences.isInterloconpick() && !StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackingstore()) && tolocationidobj!=null) {
                                srd.setIssuedLocation(locationObj);
                                srd.setDeliveredLocation(tolocationidobj);
                            }else if(StringUtil.isNullObject(tolocationidobj)){
                                throw new AccountingException("Default Location is not set for Packaging Warehouse.");
                            }
                        }else{
                           smd.setLocation(locationObj); 
                        }
                    }
                    if (isRowForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("row"));
                        StoreMaster row = (StoreMaster) krObject.getEntityList().get(0);
                        if (sendForQAApproval && isQAEnable) {
                            istDetailQC.setIssuedRow(row);
                            istDetailQC.setDeliveredRow(row);
                        } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                            srd.setDeliveredRow(row);
                            srd.setIssuedRow(row);
                        } else {
                            smd.setRow(row);
                        }
                        
                    }
                    if (isRackForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("rack"));
                        StoreMaster rack = (StoreMaster) krObject.getEntityList().get(0);
                        if (sendForQAApproval && isQAEnable) {
                            istDetailQC.setIssuedRack(rack);
                            istDetailQC.setDeliveredRack(rack);
                        } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                            srd.setDeliveredRack(rack);
                            srd.setIssuedRack(rack);
                        } else {
                            smd.setRack(rack);
                        }
                    }
                    if (isBinForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("bin"));
                        StoreMaster bin = (StoreMaster) krObject.getEntityList().get(0);
                        if (sendForQAApproval && isQAEnable) {
                            istDetailQC.setDeliveredBin(bin);
                            istDetailQC.setIssuedBin(bin);
                        } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                            srd.setDeliveredBin(bin);
                            srd.setIssuedBin(bin);
                        } else {
                            smd.setBin(bin);
                        }
                    }
                    
                    if (sendForQAApproval && isQAEnable) {
                        istDetailQC.setDeliveredQuantity(Double.parseDouble(jSONObject.getString("quantity")));
                        istDetailQC.setIssuedQuantity(Double.parseDouble(jSONObject.getString("quantity")));
                        istDetailQC.setBatchName("");
                        istDetailQC.setIstRequest(interStoreTransferQC);
                        interStoreTransferQC.getIstDetails().add(istDetailQC);
                    } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                        srd.setDeliveredQuantity(Double.parseDouble(jSONObject.getString("quantity")));
                        srd.setIssuedQuantity(Double.parseDouble(jSONObject.getString("quantity")));
                        srd.setBatchName("");
                        srd.setIstRequest(interStoreTransfer);
                        interStoreTransfer.getIstDetails().add(srd);
                    } else {
                        smd.setQuantity(Double.parseDouble(jSONObject.getString("quantity")));
                        smd.setBatchName("");
                        smd.setStockMovement(stockMovement);
                        stockMovement.getStockMovementDetails().add(smd);
                    }

                }

                //if we have only location and warehouse in that case we have to find out batchid for that particular location and warehouse
                if (!isBatchForProduct && !isSerialForProduct) {
                    HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                    filter_names.add("company.companyID");
                    filter_params.add(paramJobj.getString(Constants.companyKey));

                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("warehouse",null))) {
                        String warehouse = jSONObject.optString("warehouse");
                        filter_names.add("warehouse.id");
                        filter_params.add(warehouse);
                    }
                    if (isLocationForProduct && !StringUtil.isNullOrEmpty(jSONObject.optString("location",null))) {
                        String location = jSONObject.optString("location");
                        filter_names.add("location.id");
                        filter_params.add(location);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("row", ""))) {
                        String row = jSONObject.optString("row");
                        filter_names.add("row.id");
                        filter_params.add(row);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("rack", ""))) {
                        String rack = jSONObject.optString("rack");
                        filter_names.add("rack.id");
                        filter_params.add(rack);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("bin", ""))) {
                        String bin = jSONObject.optString("bin");
                        filter_names.add("bin.id");
                        filter_params.add(bin);
                    }

                    if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
                        filter_names.add("product");
                        filter_params.add(inventory.getProduct().getID());
                    }
                    filterRequestParams.put("filter_names", filter_names);
                    filterRequestParams.put("filter_params", filter_params);
                    filterRequestParams.put("order_by", order_by);
                    filterRequestParams.put("order_type", order_type);
                    KwlReturnObject result=null;
                    if(!isPickPackFlow){
                        result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                    
                    List listResult = result.getEntityList();
                    double bcount = 0.0;
                    if (((isnegativestockforlocwar || isnegativestockfordo) && !(isBatchForProduct || isSerialForProduct)) && listResult.isEmpty() && !isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                        HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                        pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
                        pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("batch")));
                        if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("mfgdate",null))) {
                            pdfTemplateMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("mfgdate")));
                        }
                        if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("expdate",null))) {
                            pdfTemplateMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expdate")));
                        }
                        String batchQuantity = jSONObject.optString("quantity");

                        if (!StringUtil.isNullOrEmpty(batchQuantity)) {
                            bcount = Double.parseDouble(batchQuantity);
                        }
                        pdfTemplateMap.put("quantity", String.valueOf(-(bcount)));
                        if (jSONObject.has("balance") && !StringUtil.isNullOrEmpty(jSONObject.getString("balance"))) {
                            pdfTemplateMap.put("balance", jSONObject.getString("balance"));
                        }
                        pdfTemplateMap.put("location", jSONObject.optString("location", ""));
                        pdfTemplateMap.put("product", inventory.getProduct().getID());
                        pdfTemplateMap.put("warehouse", jSONObject.optString("warehouse", ""));
                        pdfTemplateMap.put("row", jSONObject.optString("row", ""));
                        pdfTemplateMap.put("rack", jSONObject.optString("rack", ""));
                        pdfTemplateMap.put("bin", jSONObject.optString("bin", ""));
                        pdfTemplateMap.put("isopening", false);
                        pdfTemplateMap.put("transactiontype", "28");//This is GRN Type Tranction  
                        pdfTemplateMap.put("ispurchase", true);
                            kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);
                            if (kmsg != null && kmsg.getEntityList().size() != 0) {
                                productBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                                productBatchId = productBatch.getId();
                            }
                        documentMap.put("batchmapid", productBatchId);
                    } else if(!isPickPackFlow && (!sendForQAApproval || !isQAEnable)){
                        Iterator itrResult = listResult.iterator();
                        Double quantityToDue = ActbatchQty;
                        while (itrResult.hasNext()) {
                            NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                            if (quantityToDue > 0) {
                                double dueQty = (!StringUtil.isNullOrEmpty(stockType) && "0".equals(stockType)) ? authHandler.roundQuantity(newProductBatch.getConsignquantity(), companyid) : authHandler.roundQuantity(newProductBatch.getQuantitydue(), companyid);
                                HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                                batchUpdateQtyMap.put(Constants.Acc_id, newProductBatch.getId());
                                if (dueQty > 0) {
                                    if (quantityToDue > dueQty) {
                                        batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));
                                        if ("0".equals(stockType) && !isConsignment) {
                                            batchUpdateQtyMap.put("consignquantity", String.valueOf(-(dueQty)));
                                            batchUpdateQtyMap.put("qty", "0");
                                        }
                                        if (isLockedinSo && isbatchlockedinSO && newProductBatch.getLockquantity() >= dueQty) {
                                            batchUpdateQtyMap.put("lockquantity", String.valueOf(-(dueQty)));
                                        }
                                        if (isConsignment) {
                                            batchUpdateQtyMap.put("isForconsignment", true);  //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                                        }
                                        quantityToDue = quantityToDue - dueQty;

                                    } else {
                                        batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));

                                        if ("0".equals(stockType) && !isConsignment) {
                                            batchUpdateQtyMap.put("consignquantity", String.valueOf(-(quantityToDue)));
                                            batchUpdateQtyMap.put("qty", "0");
                                        }

                                        if (isLockedinSo && isbatchlockedinSO) {
                                            Double lockquantityDue = quantityToDue;
                                            if (isConsignment && isLockedinSo && StringUtil.isNullOrEmpty(replacebatchdetails)) {
                                                JSONArray repaceArr = new JSONArray(replacebatchdetails);
                                                for (int repaceArrCount = 0; repaceArrCount < repaceArr.length(); repaceArrCount++) {
                                                    JSONObject Jobj = new JSONObject(jArr.get(repaceArrCount).toString());
                                                    if (jSONObject.has("purchasebatchid")) {
                                                        String batchid = Jobj.optString("purchasebatchid");
                                                        if (!StringUtil.isNullOrEmpty(batchid) && batchid.equalsIgnoreCase(newProductBatch.getId())) {
                                                            lockquantityDue--;
                                                        }
                                                    }
                                                }
                                            }
                                            batchUpdateQtyMap.put("lockquantity", String.valueOf(-(lockquantityDue)));
                                        }
                                        if (isConsignment) {
                                            batchUpdateQtyMap.put("isForconsignment", true); //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                                        }
                                        quantityToDue = quantityToDue - quantityToDue;

                                    }
                                    documentMap.put("batchmapid", newProductBatch.getId());
                                        if( (newProductBatch.getQuantitydue() >= ActbatchQty) || isnegativestockforlocwar) {
                                            accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                                        } else {
                                            throw new AccountingException("Quantity is not available in product with id " + productId);
                                        }

                                } else if ((isnegativestockforlocwar || isnegativestockfordo) && !(isBatchForProduct || isSerialForProduct)) {

                                    batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));
                                    batchUpdateQtyMap.put("quantity", String.valueOf(-(quantityToDue)));
                                    if ("0".equals(stockType) && !isConsignment) {
                                        batchUpdateQtyMap.put("consignquantity", String.valueOf(-(Double.parseDouble(jSONObject.getString("quantity")))));
                                        batchUpdateQtyMap.put("qty", "0");
                                    }
                                    if (isLockedinSo && isbatchlockedinSO && (!"0".equals(stockType))) {
                                        batchUpdateQtyMap.put("lockquantity", String.valueOf(-(quantityToDue)));
                                    }
                                    if (isConsignment) {
                                        batchUpdateQtyMap.put("isForconsignment", true);  //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                                    }
                                    documentMap.put("batchmapid", newProductBatch.getId());
                                        accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                                    }
                                /**
                                 * commented to handle Partial block SO--> DO case.
                                 */
//                                    if(StringUtil.isNullOrEmpty(jSONObject.optString("documentbatchid")) && StringUtil.isNullOrEmpty(jSONObject.optString("purchasebatchid")) && batchUpdateQtyMap.get("id")!=null){
//                                        jSONObject.put("purchasebatchid", (batchUpdateQtyMap.get("id")));
//                                        newBatchMap.put(jSONObject.optString("purchasebatchid"), (Double.parseDouble(jSONObject.optString("quantity","0"))));
//                                    }else
//                                        if (StringUtil.isNullOrEmpty(jSONObject.optString("documentbatchid"))){
//                                        newBatchMap.put(jSONObject.optString("purchasebatchid"), (Double.parseDouble(jSONObject.optString("quantity","0"))));
//                                    }else{
//                                        newBatchMap.put(jSONObject.optString("documentbatchid"), (Double.parseDouble(jSONObject.optString("quantity","0"))));
//                                }
                            }
                            }

                    }
                }
                } else {

                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                    batchUpdateQtyMap.put("qty", String.valueOf(-(Double.parseDouble(jSONObject.optString("quantity","0")))));
                    if (isLockedinSo && isbatchlockedinSO && (!"0".equals(stockType))
                            && oldBatchMap.get(jSONObject.optString("purchasebatchid")) != null && (Double.parseDouble(oldBatchMap.get(jSONObject.optString("purchasebatchid")).toString()) == (Double.parseDouble(jSONObject.optString("quantity","0"))))) {
                        batchUpdateQtyMap.put("lockquantity", String.valueOf(-(Double.parseDouble(jSONObject.optString("quantity","0")))));
                    }
                    if (isConsignment) {
                        batchUpdateQtyMap.put("isForconsignment", true); //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                    }
                    batchUpdateQtyMap.put(Constants.Acc_id, jSONObject.optString("purchasebatchid"));
                    if ("0".equals(stockType) && !isConsignment) {
                        batchUpdateQtyMap.put("consignquantity", String.valueOf(-(Double.parseDouble(jSONObject.optString("quantity","0")))));
                        batchUpdateQtyMap.put("qty", "0");
                    }
                    if(!isPickPackFlow && (!sendForQAApproval || !isQAEnable)){
                        accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                    }
                    
                    newBatchMap.put(jSONObject.optString("purchasebatchid"), (Double.parseDouble(jSONObject.optString("quantity","0"))));

                    //Code to Send Batch
                    KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), jSONObject.optString("purchasebatchid"));
                    NewProductBatch newProductBatch1 = (NewProductBatch) batchObj.getEntityList().get(0);
                    if (isWarehouseForProduct && isLocationForProduct) {
                        if (sendForQAApproval && isQAEnable && newProductBatch1 != null) {
                            istDetailQC.setBatchName(newProductBatch1.getBatchname());
                        } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                            srd.setBatchName(newProductBatch1.getBatchname());
                        } else {
                            smd.setBatchName(newProductBatch1.getBatchname());
                        }
                        if (!isSerialForProduct && !StringUtil.isNullOrEmpty(jSONObject.optString("expdate", null))) {
                            String expdate = jSONObject.optString("expdate");
                            expdate = df2.format(authHandler.getDateOnlyFormat().parse(expdate));
                            if (sendForQAApproval && isQAEnable) {
                                istDetailQC.setExpdate(expdate);
                            } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                                srd.setExpdate(expdate);
                            }
                        }
                    }

                }
                if (!isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                    /**
                     * added selected sequence for batch selected by user while
                     * creating DO.
                     */
                    documentMap.put("batchsequence", batchsequence++);
                    accCommonTablesDAO.saveBatchDocumentMapping(documentMap);
                }

                if (!isSerialForProduct && jSONObject.has("wastageQuantityType") && !StringUtil.isNullOrEmpty(jSONObject.optString("wastageQuantityType",null)) && jSONObject.has("wastageQuantity") && !StringUtil.isNullOrEmpty(jSONObject.optString("wastageQuantity",null))) {
                    Map<String, Object> requestParams = new HashMap<>();
                    requestParams.put("batchmapid", documentMap.get("batchmapid"));
                    requestParams.put("wastageQuantityType", jSONObject.optString("wastageQuantityType"));
                    requestParams.put("wastageQuantity", jSONObject.optString("wastageQuantity"));
                    accCommonTablesDAO.saveWastageDetailsForBatch(requestParams);
                }
            }
            batchQty--;

            if (isSerialForProduct) {  //if serial no option is on then only save the serial no details 

                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", 1);
                /**
                 * added selected sequence for serial selected by user while
                 * creating DO.
                 */
                documentMap.put("serialsequence", serialsequence++);
                documentMap.put("serialmapid", jSONObject.optString("purchaseserialid"));
                documentMap.put("documentid", deliveryOrderDetail.getID());
                documentMap.put("transactiontype", "27");//This is GRN Type Tranction  
                documentMap.put(Constants.isConsignment, false);
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.optString("expstart",null))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.optString("expend",null))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expend")));
                }
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("mfgdate",null))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("expdate",null))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expdate")));
                }
                if (!isConsignment && !StringUtil.isNullOrEmpty(stockType)) {
                    documentMap.put("stocktype", stockType);
                }
                if (!isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                    KwlReturnObject krObj = accCommonTablesDAO.saveSerialDocumentMapping(documentMap);
                    SerialDocumentMapping serialDocumentMapping = (SerialDocumentMapping) krObj.getEntityList().get(0);
                    if (jSONObject.has(Constants.customfield)) {
                        String customfield = jSONObject.getString(Constants.customfield);
                        if (!StringUtil.isNullOrEmpty(customfield)) {
                            HashMap<String, Object> DOMap = new HashMap<String, Object>();
                            JSONArray jcustomarray = new JSONArray(customfield);

                            HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                            customrequestParams.put("customarray", jcustomarray);
                            customrequestParams.put("modulename", "SerialDocumentMapping");
                            customrequestParams.put("moduleprimarykey", "SerialDocumentMappingId");
                            customrequestParams.put("modulerecid", serialDocumentMapping.getId());
                            customrequestParams.put(Constants.moduleid, Constants.SerialWindow_ModuleId);
                            customrequestParams.put(Constants.companyKey, companyid);
                            DOMap.put(Constants.Acc_id, serialDocumentMapping.getId());
                            customrequestParams.put("customdataclasspath", Constants.Acc_Serial_custom_data_classpath);
                            KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                            if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                                DOMap.put("serialcustomdataref", serialDocumentMapping.getId());
                                accCommonTablesDAO.updateserialcustomdata(DOMap);
                            }
                        }
                    }
                }
                


                KwlReturnObject serialObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), jSONObject.optString("purchaseserialid"));
                NewBatchSerial newBatchSerial = (NewBatchSerial) serialObj.getEntityList().get(0);
                if (newBatchSerial != null) {
                    if ((newBatchSerial.getQuantitydue() == 0 && !"0".equals(stockType)) || (newBatchSerial.getConsignquantity() == 0 && "0".equals(stockType))) {
                        throw new AccountingException(newBatchSerial.getSerialname() + " is Already being used so you can not use it Again");
                    }else if (newBatchSerial.getLockquantity() == 1) {
                        String soDtlId = deliveryOrderDetail.getSodetails() != null ? deliveryOrderDetail.getSodetails().getID() : "";
                        accCommonTablesDAO.releaseSerialFromOtherSo(newBatchSerial, soDtlId);
                    }
                }
                HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                serialUpdateQtyMap.put("qty", "-1");
                if (isLockedinSo && isSeriallockedinSO) {
                    serialUpdateQtyMap.put("lockquantity", "-1");
                }
                if (isConsignment) {
                    serialUpdateQtyMap.put("isForconsignment", true); //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                }
                if ("0".equals(stockType) && !isConsignment) {
                    serialUpdateQtyMap.put("consignquantity", "-1");
                    serialUpdateQtyMap.put("qty", "0");
                }
                serialUpdateQtyMap.put(Constants.Acc_id, jSONObject.optString("purchaseserialid"));
                if(!isPickPackFlow){
                    accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);
                }
                

                //Code to Send Serial Numbers to Inventory
                if (newBatchSerial != null) {
                    if (isWarehouseForProduct && isLocationForProduct) {
                        if (sendForQAApproval && isQAEnable) {
                            StringBuilder serialNamesQC = new StringBuilder();
                            serialNamesQC.append(StringUtil.isNullOrEmpty(istDetailQC.getIssuedSerialNames()) ? "" : istDetailQC.getIssuedSerialNames());
                            if (serialNamesQC.length() > 0) {
                                serialNamesQC.append(",").append(newBatchSerial.getSerialname());
                            } else {
                                serialNamesQC.append(newBatchSerial.getSerialname());
                            }
                            istDetailQC.setDeliveredSerialNames(serialNamesQC.toString());
                            istDetailQC.setIssuedSerialNames(serialNamesQC.toString());
                        } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                            StringBuilder pickpackserialNames = new StringBuilder();
                            pickpackserialNames.append(StringUtil.isNullOrEmpty(srd.getIssuedSerialNames()) ? "" : srd.getIssuedSerialNames());
                            if (pickpackserialNames.length() > 0) {
                                pickpackserialNames.append(",").append(newBatchSerial.getSerialname());
                            } else {
                                pickpackserialNames.append(newBatchSerial.getSerialname());
                            }
                            srd.setDeliveredSerialNames(pickpackserialNames.toString());
                            srd.setIssuedSerialNames(pickpackserialNames.toString());
                        } else {
                            smd.addSerialName(newBatchSerial.getSerialname());
                        }
                        String doexpdate=(jSONObject.has("expdate")&&!StringUtil.isNullOrEmpty(jSONObject.optString("expdate")))?jSONObject.optString("expdate"):"";
                        
                        if(StringUtil.isNullOrEmpty(doexpdate) && jSONObject.has("expend")){
                           doexpdate=jSONObject.optString("expend");
                        }
                        if (!StringUtil.isNullOrEmpty(doexpdate)) {
                          
                            if (sendForQAApproval && isQAEnable) {
                                StringBuilder expdate = new StringBuilder();
                                expdate.append(StringUtil.isNullOrEmpty(istDetailQC.getExpdate()) ? "" : istDetailQC.getExpdate());
                                if (expdate.length() > 0) {
                                    expdate.append(",").append(df2.format(authHandler.getDateOnlyFormat().parse(doexpdate)));
                                } else {
                                    expdate.append(df2.format(authHandler.getDateOnlyFormat().parse(doexpdate)));
                                }
                                istDetailQC.setExpdate(expdate.toString());
                            } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                                StringBuilder expdate = new StringBuilder();
                                expdate.append(StringUtil.isNullOrEmpty(srd.getExpdate()) ? "" : srd.getExpdate());
                                if (expdate.length() > 0) {
                                    expdate.append(",").append(df2.format(authHandler.getDateOnlyFormat().parse(doexpdate)));
                                } else {
                                    expdate.append(df2.format(authHandler.getDateOnlyFormat().parse(doexpdate)));
                                }
                                srd.setExpdate(expdate.toString());
                            }
                        }
                    }
                }

                if (jSONObject.has("wastageQuantityType") && !StringUtil.isNullOrEmpty(jSONObject.optString("wastageQuantityType",null)) && jSONObject.has("wastageQuantity") && !StringUtil.isNullOrEmpty(jSONObject.optString("wastageQuantity",null))) {
                    Map<String, Object> requestParams = new HashMap<>();
                    requestParams.put("serialmapid", documentMap.get("serialmapid"));
                    requestParams.put("wastageQuantityType", jSONObject.optString("wastageQuantityType"));
                    requestParams.put("wastageQuantity", jSONObject.optString("wastageQuantity"));
                    accCommonTablesDAO.saveWastageDetailsForSerial(requestParams);
                }

            } else {
                batchQty = 0;
            }
            


        }
        /**
         * save Mapping and Inter Store Location
         */
        if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateInventoryTab() && isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
            for (Map.Entry<Store, InterStoreTransferRequest> entrySet : storeWiseInterStoreTransferRequest.entrySet()) {
                InterStoreTransferRequest value = entrySet.getValue();
                Map<String, Object> requestParams = new HashMap<>();
                requestParams.put(Constants.companyid, companyid);
                requestParams.put("dod", deliveryOrderDetail.getID());
                if (extraCompanyPreferences.isInterloconpick()) {
                    requestParams.put(Constants.moduleid, Constants.Acc_InterLocation_ModuleId);
                    istService.addInterLocationTransfer(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value, requestParams);
                } else {
                    requestParams.put(Constants.moduleid, Constants.Acc_InterStore_ModuleId);
                    istService.addInterStoreTransferRequest(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value, false, requestParams);
                    istService.acceptInterStoreTransferRequest(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value);
                }
//              Commented for ERP-38814, sequence format will not be updated   
//                try {
//                    seqService.updateSeqNumber(seqFormat);
//                } catch (SeqFormatException ex) {
//                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
//                }
            }
        }

        //following condition is to free batch if batch is changed in DeliveryOrder than selected in Sales Order. ERP-20117
        if (newBatchMap.size() > 0 && oldBatchMap.size() > 0 && !isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
            List intersectionList = (List) CollectionUtils.intersection(newBatchMap.keySet(), oldBatchMap.keySet());
            List subtractedOldBatchList = (List) CollectionUtils.subtract(oldBatchMap.keySet(), intersectionList);
            List subtractedNewBatchList = (List) CollectionUtils.subtract(newBatchMap.keySet(), intersectionList);

            Iterator itr = intersectionList.iterator();
            // this loop is to check and manage lock qty if batch is same in SO and DO, and qty is different
            while (itr.hasNext()) {
                String newBatchKey = (String) itr.next();
                if ((oldBatchMap.get(newBatchKey) == newBatchMap.get(newBatchKey))) {
                    continue;
                } else if ((oldBatchMap.get(newBatchKey) != newBatchMap.get(newBatchKey))) {
                    double oldQty = (double) oldBatchMap.get(newBatchKey);
                    double newQty = (double) newBatchMap.get(newBatchKey);
                    double adjustedQty = -(oldQty - newQty);
                    if(newQty<=oldQty){
                        adjustedQty=-1*newQty;
                    }
                    HashMap<String, Object> batchLockQtyUpdateMap = new HashMap<String, Object>();
                    batchLockQtyUpdateMap.put("lockquantity", String.valueOf(adjustedQty));
                    batchLockQtyUpdateMap.put(Constants.Acc_id, newBatchKey);
                    accCommonTablesDAO.saveBatchAmountDue(batchLockQtyUpdateMap);
                }
            }
            itr = subtractedOldBatchList.iterator();
            // this loop is to check and manage/free lock qty of old batch in SO
            while (itr.hasNext()) {
                String batchKey = (String) itr.next();
                HashMap<String, Object> batchLockQtyUpdateMap = new HashMap<String, Object>();
                double qty = -(double) oldBatchMap.get(batchKey);
                batchLockQtyUpdateMap.put("lockquantity", String.valueOf(qty));
                batchLockQtyUpdateMap.put(Constants.Acc_id, batchKey);
                accCommonTablesDAO.saveBatchAmountDue(batchLockQtyUpdateMap);
            }
            itr = subtractedNewBatchList.iterator();
            // this loop is to check and manage/free lock qty of new batch in DO
            /**
             * No need to execute below block because only ID is passed
             * and nothing is passed in hashmap to update.
             */
//            while (itr.hasNext()) {
//                String batchKey = (String) itr.next();
//                HashMap<String, Object> batchLockQtyUpdateMap = new HashMap<String, Object>();
//                double qty = (double) newBatchMap.get(batchKey);
//                batchLockQtyUpdateMap.put(Constants.Acc_id, batchKey);
//                accCommonTablesDAO.saveBatchAmountDue(batchLockQtyUpdateMap);
//            }
        }

        if (isWarehouseForProduct && isLocationForProduct && (!sendForQAApproval || !isQAEnable)) {
            if (isPickPackFlow) {
                for (Map.Entry<Store, InterStoreTransferRequest> entry : storeWiseInterStoreTransferRequest.entrySet()) {
//                    interStoreTransferList.add(entry.getValue());
                }
            } else {
                for (Map.Entry<Store, StockMovement> entry : storeWiseStockMovement.entrySet()) {
                    stockMovementsList.add(entry.getValue());
                }
            }
        }
        // this function is used to make in the entry to customer warehouse means stock is added to the customer warehouse
        if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment))) {
            isConsignment = Boolean.parseBoolean(paramJobj.get(Constants.isConsignment).toString());
            if (isConsignment) { //for making consignment do make it Available for Invoice by making Stock Movmeny
                saveConsignmentNewBatchJson(batchJSON, inventory, paramJobj, deliveryOrderDetail.getID());
            }

        }
        if (sendForQAApproval && isQAEnable) {
            /**
             * We have created map for storing store wise separate IST request.
             * All IST request will have same transaction number.
             */
            for (Map.Entry<Store, InterStoreTransferRequest> entrySet : storeWiseInterStoreTransferRequestForQC.entrySet()) {
                InterStoreTransferRequest value = entrySet.getValue();
                Map<String, Object> requestParams = new HashMap<>();
                requestParams.put(Constants.companyid, companyid);
                requestParams.put(Constants.CREATE_IST_FOR_QC_DELIVERYORDER, true);
                requestParams.put("dodetailid", deliveryOrderDetail.getID());
                requestParams.put("quantity", value.getAcceptedQty());
                requestParams.put("quantityDue", value.getAcceptedQty());
                requestParams.put(Constants.moduleid, Constants.Acc_InterStore_ModuleId);
                istService.addInterStoreTransferRequest(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value, false, requestParams);
                istService.acceptInterStoreTransferRequest(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value);
                try {
                    seqService.updateSeqNumber(interStoreTransferSeqFormat);
                } catch (SeqFormatException ex) {
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }
    
        
    public void saveDONewBatchForAutoFilledDetailsJson(String batchJSON, Inventory inventory, JSONObject paramJobj, DeliveryOrderDetail deliveryOrderDetail, List<StockMovement> stockMovementsList, boolean isLockedinSo, boolean isbatchlockedinSO, boolean isSeriallockedinSO, String replacebatchdetails) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        double ActbatchQty = 1;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isConsignment = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        boolean isnegativestockforlocwar = false;
        boolean isQAEnable = false;
        String productId = "";
        KwlReturnObject kmsg = null, kmsgOldBatch = null;
        String companyid = paramJobj.getString(Constants.companyKey);
        ExtraCompanyPreferences extraCompanyPreferences = null;
        KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), paramJobj.getString(Constants.companyKey));
        extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
        isnegativestockforlocwar = extraCompanyPreferences.isIsnegativestockforlocwar();

        //accessed the product which option is activated i.e True or false
        if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), inventory.getProduct().getID());
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
            isQAEnable = product.isQaenable();
            productId = product.getProductid();
        }

        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        StockMovementDetail smd = null;
        StockMovement stockMovement = null;
        NewProductBatch productBatch = null;
        InterStoreTransferRequest interStoreTransfer = null;
        String productBatchId = "";
        String entryNumber = paramJobj.optString("numberDo", null) != null ? paramJobj.getString("numberDo") : paramJobj.optString("number", "");
        Map<Store, StockMovement> storeWiseStockMovement = new HashMap<Store, StockMovement>();
         boolean isPickPackFlow=extraCompanyPreferences.isPickpackship();
        if(deliveryOrderDetail.getDeliveryOrder().isFixedAssetDO() || deliveryOrderDetail.getDeliveryOrder().isLeaseDO() || deliveryOrderDetail.getDeliveryOrder().isIsconsignment()){
            isPickPackFlow=false;
        }
        ISTDetail srd = null;
        /**
         * During Invoice with Auto DO generation with pick pack ship enabled status field is not set hence setting it here to Picked by default
         */
         if (deliveryOrderDetail.getDeliveryOrder().isIsAutoGeneratedDO() && isPickPackFlow) {
            MasterItem minstatus = deliveryOrderDetail.getDeliveryOrder().getStatus();
            if (minstatus == null) { //if current status of DO is null then proceed to set the status as Picked
                KwlReturnObject kwlmasterobj = accMasterItemsDAOobj.getMasterItemByNameorID(companyid, "Picked", "10", "mst.id", "mst.value");
                String statusmasterid = kwlmasterobj.getEntityList().isEmpty() ? "" : kwlmasterobj.getEntityList().get(0).toString();
                if (StringUtil.isNullOrEmpty(statusmasterid)) {
                    throw new AccountingException(messageSource.getMessage("acc.companypreferences.statusforpickpackshipnotavailable", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                } else {
                    KwlReturnObject kwlmasteritem = accMasterItemsDAOobj.getMasterItem(statusmasterid);
                    MasterItem miobj = (MasterItem) (kwlmasteritem.getEntityList().isEmpty() ? null : kwlmasteritem.getEntityList().get(0));
                    deliveryOrderDetail.getDeliveryOrder().setStatus(miobj);
                }
            }
        }
        Map<Store, InterStoreTransferRequest> storeWiseInterStoreTransferRequest = new HashMap<Store, InterStoreTransferRequest>();
         /**
         * Get Inter Store / Location Sequence format
         */
        String interstore_loc_No = "";
        SeqFormat seqFormat = null;
        try {
            if (isPickPackFlow && !extraCompanyPreferences.isInterloconpick()) {

                seqFormat = seqService.getDefaultSeqFormat(deliveryOrderDetail.getCompany(), ModuleConst.INTER_STORE_TRANSFER);
                if(seqFormat!=null){
                    interstore_loc_No = seqService.getNextFormatedSeqNumber(seqFormat);
                }else{
                    interstore_loc_No=deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber();
                }

            } else if (isPickPackFlow) {
                seqFormat = seqService.getDefaultSeqFormat(deliveryOrderDetail.getCompany(), ModuleConst.INTER_LOCATION_TRANSFER);
                if(seqFormat!=null){
                    interstore_loc_No = seqService.getNextFormatedSeqNumber(seqFormat);
                }else{
                    interstore_loc_No=deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber();
                }
            }
        } catch (SeqFormatException ex) {
            throw new AccountingException(messageSource.getMessage("acc.companypreferences.defaultsequenceformatforistnotset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
        }

        boolean sendForQAApproval = paramJobj.optBoolean("sendForQAApproval", false);
        String interStoreTransactionNo = "";
        SeqFormat interStoreTransferSeqFormat = null;
        Store qaStore = null;
        InterStoreTransferRequest interStoreTransferQC = null;
        ISTDetail istDetailQC = null;
        Map<Store, InterStoreTransferRequest> storeWiseInterStoreTransferRequestForQC = new HashMap<Store, InterStoreTransferRequest>();
        try {
            if (sendForQAApproval) {
                if (!StringUtil.isNullOrEmpty(paramJobj.optString("interstoreSeqNo")) && !StringUtil.isNullOrEmpty(paramJobj.optString("interstoreseqFormat"))) {
                    interStoreTransactionNo = paramJobj.optString("interstoreSeqNo");
                    interStoreTransferSeqFormat = (SeqFormat) paramJobj.opt("interstoreseqFormat");
                } else {
                    throw new AccountingException(messageSource.getMessage("acc.companypreferences.defaultsequenceformatforistnotset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
                KwlReturnObject tostoreres = accountingHandlerDAOobj.getObject(Store.class.getName(), extraCompanyPreferences.getInspectionStore());
                qaStore = (Store) tostoreres.getEntityList().get(0);
                if (qaStore == null) {
                    throw new InventoryException(messageSource.getMessage("acc.companypreferences.qastore.notset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
            }
        } catch (AccountingException ex) {
            throw new AccountingException(ex.getMessage());
        }
        Map oldBatchMap = new HashMap();
        Map newBatchMap = new HashMap();
        if (deliveryOrderDetail.getSodetails() != null && !StringUtil.isNullOrEmpty(deliveryOrderDetail.getSodetails().getID())) {
            kmsgOldBatch = accCommonTablesDAO.getBatchMapIdQtyByDocumentId(companyid, deliveryOrderDetail.getSodetails().getID());
        }
         if (kmsgOldBatch == null || kmsgOldBatch.getEntityList().isEmpty() || kmsgOldBatch.getRecordTotalCount() > 0) {
            if (deliveryOrderDetail.getCidetails() != null && deliveryOrderDetail.getCidetails().getSalesorderdetail() != null) {
                String sodId = deliveryOrderDetail.getCidetails().getSalesorderdetail().getID();
                kmsgOldBatch = accCommonTablesDAO.getBatchMapIdQtyByDocumentId(companyid, sodId);
            }
        }
        if (kmsgOldBatch != null && !kmsgOldBatch.getEntityList().isEmpty() && kmsgOldBatch.getRecordTotalCount() > 0) {
            Iterator itr = kmsgOldBatch.getEntityList().iterator();
            while (itr.hasNext()) {
                Object[] obj = (Object[]) itr.next();
                String batchMapId = obj[0] != null ? (String) obj[0] : "";
                double batchMapQty = obj[1] != null ? (double) obj[1] : 0;
                if (!StringUtil.isNullOrEmpty(batchMapId)) {
                    oldBatchMap.put(batchMapId, batchMapQty);
                }
            }
        }

        for (int i = 0; i < jArr.length(); i++) {
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            if (jSONObject.has("quantity") && !jSONObject.optString("quantity").equals("undefined") && !jSONObject.optString("quantity").isEmpty()) {
                ActbatchQty = jSONObject.optDouble("quantity",0.0);
            }
            String stockType = "1" ; //jSONObject.has("stocktype") ? jSONObject.getString("stocktype") : ""; Sotck type not handled yet

            //as we are require store object in stock movment so taken warehouse id from that we have find out Store
            Store store = null;
            Store tostoreObj = null;
            if (isWarehouseForProduct && isLocationForProduct) {
                KwlReturnObject warehouseObj = accountingHandlerDAOobj.getObject(Store.class.getName(), jSONObject.optString("warehouse"));
                store = (Store) warehouseObj.getEntityList().get(0);
            }
            //Made entry in stock movment so to out the data from company warehouse
            if (isWarehouseForProduct && isLocationForProduct) {
                if (sendForQAApproval && isQAEnable) {
                    /**
                     * If DO is send for QA approval then need to create store
                     * wise separate inter store transfer request. Create IST
                     * request and set values for required fields.
                     */
                    if (storeWiseInterStoreTransferRequestForQC.containsKey(store)) {
                        interStoreTransferQC = storeWiseInterStoreTransferRequestForQC.get(store);
                        interStoreTransferQC.setAcceptedQty(interStoreTransferQC.getAcceptedQty() + jSONObject.optDouble("quantity", 0.0));
                        interStoreTransferQC.setOrderedQty(interStoreTransferQC.getOrderedQty() + jSONObject.optDouble("quantity", 0.0));
                    } else {
                        if (store != null) {
                            interStoreTransferQC = new InterStoreTransferRequest(deliveryOrderDetail.getProduct(), store, qaStore, inventory.getProduct().getUnitOfMeasure() != null ? inventory.getProduct().getUnitOfMeasure() : deliveryOrderDetail.getUom());
                            interStoreTransferQC.setAcceptedQty(jSONObject.optDouble("quantity", 0.0));
                            interStoreTransferQC.setOrderedQty(jSONObject.optDouble("quantity", 0.0));
                            interStoreTransferQC.setRemark(deliveryOrderDetail.getRemark());
                            interStoreTransferQC.setTransactionNo(interStoreTransactionNo);
                            interStoreTransferQC.setCostCenter(deliveryOrderDetail.getDeliveryOrder().getCostcenter());
                            interStoreTransferQC.setBusinessDate(deliveryOrderDetail.getDeliveryOrder().getOrderDate());
                            interStoreTransferQC.setUom(deliveryOrderDetail.getUom());
                            String doNumber = deliveryOrderDetail.getDeliveryOrder() != null && !StringUtil.isNullOrEmpty(deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber()) ? deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber() : "";
                            interStoreTransferQC.setMemo((StringUtil.isNullOrEmpty(doNumber) ? ("IST created for QC against DO.") : ("IST created for QC against DO:" + doNumber)));
                            interStoreTransferQC.setProduct(deliveryOrderDetail.getProduct());
                            interStoreTransferQC.setPackaging(deliveryOrderDetail.getProduct().getPackaging());
                            storeWiseInterStoreTransferRequestForQC.put(store, interStoreTransferQC);

                        }
                    }
                } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                        /**
                         * If Pick Pack Flow is Enable then add entry in Inter
                         * Store/Location Transfer
                         */
                        if (!StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackinglocation()) || !StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackingstore())) {
                            if (storeWiseInterStoreTransferRequest.containsKey(store)) {
                                interStoreTransfer = storeWiseInterStoreTransferRequest.get(store);
                                interStoreTransfer.setAcceptedQty(interStoreTransfer.getAcceptedQty() + jSONObject.optDouble("quantity", 0.0));
                                interStoreTransfer.setOrderedQty(interStoreTransfer.getOrderedQty() + jSONObject.optDouble("quantity", 0.0));
                             } else {
                                if (store != null) {
                                    if (extraCompanyPreferences.isInterloconpick()) {
                                        interStoreTransfer = new InterStoreTransferRequest(deliveryOrderDetail.getProduct(), store, store, deliveryOrderDetail.getUom());
                                    } else {
                                        KwlReturnObject tostoreres = accountingHandlerDAOobj.getObject(Store.class.getName(), extraCompanyPreferences.getPackingstore());
                                        tostoreObj = (Store) tostoreres.getEntityList().get(0);
                                        interStoreTransfer = new InterStoreTransferRequest(deliveryOrderDetail.getProduct(), store, tostoreObj, deliveryOrderDetail.getUom());
                                    }
                                    interStoreTransfer.setAcceptedQty(jSONObject.optDouble("quantity", 0.0));
                                    interStoreTransfer.setOrderedQty(jSONObject.optDouble("quantity", 0.0));
                                    interStoreTransfer.setRemark(deliveryOrderDetail.getRemark());
                                    interStoreTransfer.setTransactionNo(interstore_loc_No);
                                    interStoreTransfer.setBusinessDate(deliveryOrderDetail.getDeliveryOrder().getOrderDate());
                                    interStoreTransfer.setUom(deliveryOrderDetail.getUom());
                                    interStoreTransfer.setMemo(deliveryOrderDetail.getDeliveryOrder().getMemo());
                                    interStoreTransfer.setProduct(deliveryOrderDetail.getProduct());
                                    interStoreTransfer.setPackaging(deliveryOrderDetail.getProduct().getPackaging());
                                    storeWiseInterStoreTransferRequest.put(store, interStoreTransfer);


                                }
                            }
                        }
                    } else {
                    if (storeWiseStockMovement.containsKey(store)) {
                        stockMovement = storeWiseStockMovement.get(store);
                        stockMovement.setQuantity(stockMovement.getQuantity() + jSONObject.optDouble("quantity", 0.0));
                    } else {
                        stockMovement = new StockMovement();
                        if (store != null) {
                            stockMovement.setStore(store);
                        }
                        stockMovement.setCompany(inventory.getCompany());
                        stockMovement.setProduct(inventory.getProduct());
                        stockMovement.setStockUoM(inventory.getProduct().getUnitOfMeasure());
                        stockMovement.setPricePerUnit(deliveryOrderDetail.getBaseuomrate() < 1 ? (deliveryOrderDetail.getRate() * (1 / deliveryOrderDetail.getBaseuomrate())) : deliveryOrderDetail.getRate() / deliveryOrderDetail.getBaseuomrate());
                        stockMovement.setQuantity(jSONObject.optDouble("quantity", 0.0));
                        stockMovement.setTransactionDate(deliveryOrderDetail.getDeliveryOrder().getOrderDate());
                        stockMovement.setModuleRefId(deliveryOrderDetail.getDeliveryOrder().getID());
                        stockMovement.setModuleRefDetailId(deliveryOrderDetail.getID());
                        stockMovement.setCustomer(deliveryOrderDetail.getDeliveryOrder().getCustomer());
                        stockMovement.setCostCenter(deliveryOrderDetail.getDeliveryOrder().getCostcenter());
                        stockMovement.setTransactionNo(StringUtil.isNullOrEmpty(deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber()) ? entryNumber : deliveryOrderDetail.getDeliveryOrder().getDeliveryOrderNumber());
                        stockMovement.setRemark((deliveryOrderDetail.getDeliveryOrder().isIsconsignment() ? "Consignment " : "") + "Delivery Order Created");
                        stockMovement.setTransactionModule(deliveryOrderDetail.getDeliveryOrder().isIsconsignment() ? TransactionModule.ERP_Consignment_DO : TransactionModule.ERP_DO);
                        stockMovement.setTransactionType(TransactionType.OUT);
                        stockMovement.setMemo(deliveryOrderDetail.getDeliveryOrder().getMemo());
                        storeWiseStockMovement.put(store, stockMovement);
                    }
                }
            }
            
            
            
             if (isLockedinSo && (((!sendForQAApproval || !isQAEnable) && isPickPackFlow) || (sendForQAApproval && !isPickPackFlow))) {
                String doid = deliveryOrderDetail.getDeliveryOrder() != null ? deliveryOrderDetail.getDeliveryOrder().getID() : "";
                String productid = deliveryOrderDetail.getProduct() != null ? deliveryOrderDetail.getProduct().getID() : "";
                String sodetailid = "";
                KwlReturnObject kwlso = accInvoiceDAOobj.getSalesOrdersFromDO(doid, companyid);
                ArrayList filter_names = null;
                ArrayList filter_params = null;
                HashMap requestparams = null;
                SalesOrder salesorder =null;
                if(!kwlso.getEntityList().isEmpty()){
                Object[] objarr = (Object[]) kwlso.getEntityList().get(0);
                    salesorder = (SalesOrder) objarr[0];
                } else {
                    if(deliveryOrderDetail.getCidetails() != null && deliveryOrderDetail.getCidetails().getSalesorderdetail() != null && deliveryOrderDetail.getCidetails().getSalesorderdetail().getSalesOrder() != null){
                        salesorder = deliveryOrderDetail.getCidetails().getSalesorderdetail().getSalesOrder();
                    }
                }
                if (salesorder != null && salesorder.isLockquantityflag()) { //getting sodetails from salesorder and its lockqty
                    Set<SalesOrderDetail> sodetails = salesorder.getRows();
                    if (!(sodetails == null || sodetails.isEmpty())) {
                        for (SalesOrderDetail sod : sodetails) {
                            sodetailid = sod.getID();
                            if (sod.getProduct().getID().equalsIgnoreCase(productid)) {
                                filter_names = new ArrayList();
                                filter_params = new ArrayList();
                                requestparams = new HashMap();

                                filter_names.add("documentid");
                                filter_params.add(sodetailid);

                                requestparams.put("filter_names", filter_names);
                                requestparams.put("filter_params", filter_params);

                                KwlReturnObject batchresult = accMasterItemsDAOobj.getBatchesForDocuments(requestparams);
                                List batchlist = batchresult.getEntityList();
                                Iterator LocitrResult = batchlist.iterator();
                                Product product = sod.getProduct();
                                String batchname= "";
                                
                                while (LocitrResult.hasNext()) {
                                    LocationBatchDocumentMapping lbdm = (LocationBatchDocumentMapping) LocitrResult.next();
                                    NewProductBatch npb = lbdm.getBatchmapid();
                                    if (product.isIsBatchForProduct()) {
                                        batchname = npb.getBatchname() != null ? npb.getBatchname() : "";
                                    }//getting batchname to check for different batches of same product
                                    if (npb.getWarehouse().getId().equalsIgnoreCase(jSONObject.optString("warehouse", ""))) {
                                        if (npb.getLocation().getId().equalsIgnoreCase(jSONObject.optString("location", ""))) {
                                            if (batchname.equalsIgnoreCase(jSONObject.optString("batchname", ""))) {
                                                npb.setLockquantity(npb.getLockquantity() - jSONObject.optDouble("quantity", 0.0));
                                            }
                                        }
                                    }
                                }
                                
                                //for serial or batchserial product get newbatchserial ids and reduce lock quantities 
                                if (product.isIsSerialForProduct()) {
                                    //same previous filter names and params can be used for serials hence passing hashmap directly
                                    KwlReturnObject serialkwl = accMasterItemsDAOobj.getSerialsForDocuments(requestparams);
                                    List seriallist = serialkwl.getEntityList();
                                    Iterator serialitr = seriallist.iterator();
                                    while (serialitr.hasNext()) {
                                        SerialDocumentMapping sdm = (SerialDocumentMapping) serialitr.next();
                                        NewBatchSerial nbs = sdm.getSerialid();
                                        //check if there are different serials or different batchnames 
                                        if (nbs.getId().equalsIgnoreCase(jSONObject.optString("serialnoid", ""))) {
                                            nbs.setLockquantity(0);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct)) {  //&& (batchQty == ActbatchQty)
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.optString("quantity","0.0"));
                documentMap.put("documentid", deliveryOrderDetail.getID());
                documentMap.put(Constants.isConsignment, false);  ///in mapping kee thids
                documentMap.put("transactiontype", "27");//This is DO Type Tranction 
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("mfgdate",null))) {
                    documentMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("expdate",null))) {
                    documentMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expdate")));
                }
                if (!StringUtil.isNullOrEmpty(jSONObject.optString("purchasebatchid"))) {
                documentMap.put("batchmapid", jSONObject.optString("purchasebatchid"));
                }
                if (StringUtil.isNullOrEmpty((String) documentMap.get("batchmapid")) && (isBatchForProduct || isSerialForProduct)){
                    throw new AccountingException("Please select batch details for product with id " + productId);
                }
                if (!isConsignment && !StringUtil.isNullOrEmpty(stockType)) {
                    documentMap.put("stocktype", stockType);
                }
                if (isWarehouseForProduct && isLocationForProduct) {
                    smd = new StockMovementDetail();
                    srd = new ISTDetail();
                    istDetailQC = new ISTDetail();
                    //as we are require Location object in stock movment so taken inventoryLocation id from that we have find out Location
                    KwlReturnObject locationUpdate = accountingHandlerDAOobj.getObject(Location.class.getName(), jSONObject.optString("location"));
                    Location locationObj = (Location) locationUpdate.getEntityList().get(0);
                    String tolocationid = paramJobj.optString("pickpacklocation", ""); // default location in case of pick pack
                    Location tolocationidobj = null;
                    String packingstoreid = "";
                    Store packing_store = null;
                    KwlReturnObject StorelObj = null;
                    if(!StringUtil.isNullOrEmpty(tolocationid)){
                           KwlReturnObject toLocation = accountingHandlerDAOobj.getObject(Location.class.getName(), tolocationid);
                            tolocationidobj = (Location) toLocation.getEntityList().get(0);                            
                    }else if(extraCompanyPreferences!=null && !StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackingstore())){
                          packingstoreid = extraCompanyPreferences.getPackingstore();
                          StorelObj = accountingHandlerDAOobj.getObject(Store.class.getName(), packingstoreid);
                          if(StorelObj!=null && StorelObj.getEntityList().get(0)!=null){
                          packing_store = (Store) StorelObj.getEntityList().get(0);
                           tolocationidobj = packing_store.getDefaultLocation();    
                          }                         
                    }
                    if (locationObj != null) {
                        if (sendForQAApproval && isQAEnable) {
                            if (qaStore.getDefaultLocation() == null) {
                                throw new AccountingException(messageSource.getMessage("acc.companypreferences.defaultLocationNotSetforQAStore", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                            }
                            Location toLocatioObj = qaStore.getDefaultLocation();
                            istDetailQC.setDeliveredLocation(toLocatioObj);
                            istDetailQC.setIssuedLocation(locationObj);
                        } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                            if (extraCompanyPreferences.isInterloconpick() && !StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackinglocation())) {
                                KwlReturnObject toLocation = accountingHandlerDAOobj.getObject(Location.class.getName(), extraCompanyPreferences.getPackinglocation());
                                Location toLocatioObj = (Location) toLocation.getEntityList().get(0);
                                srd.setDeliveredLocation(toLocatioObj);
                                srd.setIssuedLocation(locationObj);
                            } else if (!extraCompanyPreferences.isInterloconpick() && !StringUtil.isNullOrEmpty(extraCompanyPreferences.getPackingstore()) && tolocationidobj!=null) {
                                srd.setIssuedLocation(locationObj);
                                srd.setDeliveredLocation(tolocationidobj);
                            }else if(StringUtil.isNullObject(tolocationidobj)){
                                throw new AccountingException("Default Location is not set for Packaging Warehouse.");
                            }
                        }else{
                           smd.setLocation(locationObj); 
                        }
                    }
                    if (isRowForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("row"));
                        StoreMaster row = (StoreMaster) krObject.getEntityList().get(0);
                        if (sendForQAApproval && isQAEnable) {
                            istDetailQC.setIssuedRow(row);
                            istDetailQC.setDeliveredRow(row);
                        } else {
                            smd.setRow(row);
                        }
                    }
                    if (isRackForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("rack"));
                        StoreMaster rack = (StoreMaster) krObject.getEntityList().get(0);
                        if (sendForQAApproval && isQAEnable) {
                            istDetailQC.setIssuedRack(rack);
                            istDetailQC.setDeliveredRack(rack);
                        } else {
                            smd.setRack(rack);
                        }
                    }
                    if (isBinForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("bin"));
                        StoreMaster bin = (StoreMaster) krObject.getEntityList().get(0);
                        if (sendForQAApproval && isQAEnable) {
                            istDetailQC.setIssuedBin(bin);
                            istDetailQC.setDeliveredBin(bin);
                        } else {
                            smd.setBin(bin);
                        }
                    }
                    if (sendForQAApproval && isQAEnable) {
                        istDetailQC.setDeliveredQuantity(Double.parseDouble(jSONObject.optString("quantity","0.0")));
                        istDetailQC.setIssuedQuantity(Double.parseDouble(jSONObject.optString("quantity","0.0")));
                        istDetailQC.setBatchName("");
                        istDetailQC.setIstRequest(interStoreTransferQC);
                        interStoreTransferQC.getIstDetails().add(istDetailQC);
                    } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                        srd.setDeliveredQuantity(Double.parseDouble(jSONObject.optString("quantity","0.0")));
                        srd.setIssuedQuantity(Double.parseDouble(jSONObject.optString("quantity","0.0")));
                        srd.setBatchName("");
                        srd.setIstRequest(interStoreTransfer);
                        interStoreTransfer.getIstDetails().add(srd);
                    }else {
                        smd.setQuantity(Double.parseDouble(jSONObject.optString("quantity","0.0")));
                        smd.setBatchName("");
                        smd.setStockMovement(stockMovement);
                        stockMovement.getStockMovementDetails().add(smd);
                    }
                }

                //if we have only location and warehouse in that case we have to find out batchid for that particular location and warehouse
                if (!isBatchForProduct && !isSerialForProduct) {
                    HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                    filter_names.add("company.companyID");
                    filter_params.add(paramJobj.getString(Constants.companyKey));

                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("warehouse"))) {
                        String warehouse = jSONObject.getString("warehouse");
                        filter_names.add("warehouse.id");
                        filter_params.add(warehouse);
                    }
                    if (isLocationForProduct && !StringUtil.isNullOrEmpty(jSONObject.getString("location"))) {
                        String location = jSONObject.optString("location");
                        filter_names.add("location.id");
                        filter_params.add(location);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("row", ""))) {
                        String row = jSONObject.optString("row");
                        filter_names.add("row.id");
                        filter_params.add(row);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("rack", ""))) {
                        String rack = jSONObject.optString("rack");
                        filter_names.add("rack.id");
                        filter_params.add(rack);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("bin", ""))) {
                        String bin = jSONObject.optString("bin");
                        filter_names.add("bin.id");
                        filter_params.add(bin);
                    }

                    if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
                        filter_names.add("product");
                        filter_params.add(inventory.getProduct().getID());
                    }
                    filterRequestParams.put("filter_names", filter_names);
                    filterRequestParams.put("filter_params", filter_params);
                    filterRequestParams.put("order_by", order_by);
                    filterRequestParams.put("order_type", order_type);
                    KwlReturnObject result=null;
                    if (!isPickPackFlow) {
                        result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                        List listResult = result.getEntityList();
                        double bcount = 0.0;
                        if ((isnegativestockforlocwar && !(isBatchForProduct || isSerialForProduct)) && listResult.isEmpty() && (!sendForQAApproval || !isQAEnable)) {
                            HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                            pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
                            pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("batch")));
                            if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("mfgdate",null))) {
                                pdfTemplateMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("mfgdate")));
                            }
                            if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("expdate",null))) {
                                pdfTemplateMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expdate")));
                            }
                            String batchQuantity = jSONObject.optString("quantity","0.0");

                            if (!StringUtil.isNullOrEmpty(batchQuantity)) {
                                bcount = Double.parseDouble(batchQuantity);
                            }
                            pdfTemplateMap.put("quantity", String.valueOf(-(bcount)));
                            if (jSONObject.has("balance") && !StringUtil.isNullOrEmpty(jSONObject.optString("balance"))) {
                                pdfTemplateMap.put("balance", jSONObject.optString("balance"));
                            }
                            pdfTemplateMap.put("location", jSONObject.optString("location", ""));
                            pdfTemplateMap.put("product", inventory.getProduct().getID());
                            pdfTemplateMap.put("warehouse", jSONObject.optString("warehouse", ""));
                            pdfTemplateMap.put("row", jSONObject.optString("row", ""));
                            pdfTemplateMap.put("rack", jSONObject.optString("rack", ""));
                            pdfTemplateMap.put("bin", jSONObject.optString("bin", ""));
                            pdfTemplateMap.put("isopening", false);
                            pdfTemplateMap.put("transactiontype", "28");//This is GRN Type Tranction  
                            pdfTemplateMap.put("ispurchase", true);
                            kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);
                            if (kmsg != null && kmsg.getEntityList().size() != 0) {
                                productBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                                productBatchId = productBatch.getId();
                            }
                            documentMap.put("batchmapid", productBatchId);
                        } else if (!sendForQAApproval || !isQAEnable) {
                            Iterator itrResult = listResult.iterator();
                            Double quantityToDue = ActbatchQty;
                            while (itrResult.hasNext()) {
                                NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                                if (quantityToDue > 0) {
                                    double dueQty = (!StringUtil.isNullOrEmpty(stockType) && "0".equals(stockType)) ? newProductBatch.getConsignquantity() : newProductBatch.getQuantitydue();
                                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                                    batchUpdateQtyMap.put(Constants.Acc_id, newProductBatch.getId());
                                    if (dueQty > 0) {
                                        if (quantityToDue > dueQty) {
                                            batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));
                                            if ("0".equals(stockType) && !isConsignment) {
                                                batchUpdateQtyMap.put("consignquantity", String.valueOf(-(dueQty)));
                                                batchUpdateQtyMap.put("qty", "0");
                                            }
                                            if (isLockedinSo && isbatchlockedinSO && newProductBatch.getLockquantity() >= dueQty) {
                                                batchUpdateQtyMap.put("lockquantity", String.valueOf(-(dueQty)));
                                            }
                                            if (isConsignment) {
                                                batchUpdateQtyMap.put("isForconsignment", true);  //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                                            }
                                            quantityToDue = quantityToDue - dueQty;

                                        } else {
                                            batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));

                                            if ("0".equals(stockType) && !isConsignment) {
                                                batchUpdateQtyMap.put("consignquantity", String.valueOf(-(quantityToDue)));
                                                batchUpdateQtyMap.put("qty", "0");
                                            }

                                            if (isLockedinSo && isbatchlockedinSO) {
                                                Double lockquantityDue = quantityToDue;
                                                if (isConsignment && isLockedinSo && StringUtil.isNullOrEmpty(replacebatchdetails)) {
                                                    JSONArray repaceArr = new JSONArray(replacebatchdetails);
                                                    for (int repaceArrCount = 0; repaceArrCount < repaceArr.length(); repaceArrCount++) {
                                                        JSONObject Jobj = new JSONObject(jArr.get(repaceArrCount).toString());
                                                        if (jSONObject.has("purchasebatchid")) {
                                                            String batchid = Jobj.optString("purchasebatchid");
                                                            if (!StringUtil.isNullOrEmpty(batchid) && batchid.equalsIgnoreCase(newProductBatch.getId())) {
                                                                lockquantityDue--;
                                                            }
                                                        }
                                                    }
                                                }
                                                batchUpdateQtyMap.put("lockquantity", String.valueOf(-(lockquantityDue)));
                                            }
                                            if (isConsignment) {
                                                batchUpdateQtyMap.put("isForconsignment", true); //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                                            }
                                            quantityToDue = quantityToDue - quantityToDue;

                                        }
                                        documentMap.put("batchmapid", newProductBatch.getId());
                                        if( (newProductBatch.getQuantitydue() >= ActbatchQty) || isnegativestockforlocwar) {
                                         accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                                        } else {
                                            throw new AccountingException("Quantity is not available in product with id " + productId);
                                        }

                                    } else if (isnegativestockforlocwar && !(isBatchForProduct || isSerialForProduct)) {

                                        batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));
                                        batchUpdateQtyMap.put("quantity", String.valueOf(-(quantityToDue)));
                                        if ("0".equals(stockType) && !isConsignment) {
                                            batchUpdateQtyMap.put("consignquantity", String.valueOf(-(Double.parseDouble(jSONObject.getString("quantity")))));
                                            batchUpdateQtyMap.put("qty", "0");
                                        }
                                        if (isLockedinSo && isbatchlockedinSO && (!"0".equals(stockType))) {
                                            batchUpdateQtyMap.put("lockquantity", String.valueOf(-(quantityToDue)));
                                        }
                                        if (isConsignment) {
                                            batchUpdateQtyMap.put("isForconsignment", true);  //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                                        }
                                        documentMap.put("batchmapid", newProductBatch.getId());
                                        accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                                    }
                                }
                            }

                        }
                    }
                } else {

                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                    batchUpdateQtyMap.put("qty", String.valueOf(-(Double.parseDouble(jSONObject.optString("quantity")))));
                    if (isLockedinSo && isbatchlockedinSO && (!"0".equals(stockType))
                            && oldBatchMap.get(jSONObject.optString("purchasebatchid")) != null && (Double.parseDouble(oldBatchMap.get(jSONObject.optString("purchasebatchid")).toString()) == (Double.parseDouble(jSONObject.optString("quantity","0.0"))))) {
                        batchUpdateQtyMap.put("lockquantity", String.valueOf(-(Double.parseDouble(jSONObject.optString("quantity","0.0")))));
                    }
                    if (isConsignment) {
                        batchUpdateQtyMap.put("isForconsignment", true); //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                    }
                    batchUpdateQtyMap.put(Constants.Acc_id, jSONObject.optString("purchasebatchid"));
                    if ("0".equals(stockType) && !isConsignment) {
                        batchUpdateQtyMap.put("consignquantity", String.valueOf(-(Double.parseDouble(jSONObject.optString("quantity")))));
                        batchUpdateQtyMap.put("qty", "0");
                    }
                    if(!isPickPackFlow && (!sendForQAApproval || !isQAEnable)){
                        accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                    }
                    newBatchMap.put(jSONObject.optString("purchasebatchid"), (Double.parseDouble(jSONObject.optString("quantity","0.0"))));

                    //Code to Send Batch
                    KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), jSONObject.optString("purchasebatchid"));
                    NewProductBatch newProductBatch1 = (NewProductBatch) batchObj.getEntityList().get(0);
                    if (isWarehouseForProduct && isLocationForProduct) {
                        if (sendForQAApproval && isQAEnable) {
                            istDetailQC.setBatchName(newProductBatch1.getBatchname());
                        } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                            srd.setBatchName(newProductBatch1.getBatchname());
                        } else {
                            smd.setBatchName(newProductBatch1.getBatchname());
                        }
                        
                    }

                } 
                if (!isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                    accCommonTablesDAO.saveBatchDocumentMapping(documentMap); // when pick pack flow is ON record created in  dodistmapping table 
                }

                if (!isSerialForProduct && jSONObject.has("wastageQuantityType") && !StringUtil.isNullOrEmpty(jSONObject.optString("wastageQuantityType",null)) && jSONObject.has("wastageQuantity") && !StringUtil.isNullOrEmpty(jSONObject.optString("wastageQuantity",null))) {
                    Map<String, Object> requestParams = new HashMap<>();
                    requestParams.put("batchmapid", documentMap.get("batchmapid"));
                    requestParams.put("wastageQuantityType", jSONObject.optString("wastageQuantityType"));
                    requestParams.put("wastageQuantity", jSONObject.optString("wastageQuantity"));
                    accCommonTablesDAO.saveWastageDetailsForBatch(requestParams);
                }

                String serialDetails=jSONObject.optString("serialDetails", "");
                
                if (isSerialForProduct && !StringUtil.isNullOrEmpty(serialDetails)) {  //if serial no option is on then only save the serial no details 
                    
                    
                    JSONArray serialArr = new JSONArray(serialDetails);
                    for (int count = 0; count < serialArr.length(); count++) {
                        JSONObject serialObject = new JSONObject(serialArr.get(count).toString());
                        HashMap<String, Object> serialDocumentMap = new HashMap<String, Object>();
                        serialDocumentMap.put("quantity", 1);
                        serialDocumentMap.put("serialmapid", serialObject.optString("purchaseserialid"));
                        serialDocumentMap.put("documentid", deliveryOrderDetail.getID());
                        serialDocumentMap.put("transactiontype", "27");//This is GRN Type Tranction  
                        serialDocumentMap.put(Constants.isConsignment, false);
                        if (serialObject.has("expstart") && !StringUtil.isNullOrEmpty(serialObject.optString("expstart",null))) {
                            serialDocumentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(serialObject.optString("expstart")));
                        }
                        if (serialObject.has("expend") && !StringUtil.isNullOrEmpty(serialObject.optString("expend",null))) {
                            serialDocumentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(serialObject.optString("expend")));
                        }
                        if (serialObject.has("mfgdate") && !StringUtil.isNullOrEmpty(serialObject.optString("mfgdate",null))) {
                            serialDocumentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(serialObject.optString("mfgdate")));
                        }
                        if (serialObject.has("expdate") && !StringUtil.isNullOrEmpty(serialObject.optString("expdate",null))) {
                            serialDocumentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(serialObject.optString("expdate")));
                        }
                        if (!isConsignment && !StringUtil.isNullOrEmpty(stockType)) {
                            serialDocumentMap.put("stocktype", stockType);
                        }
                        if (!sendForQAApproval || !isQAEnable) {
                            KwlReturnObject krObj = accCommonTablesDAO.saveSerialDocumentMapping(serialDocumentMap);

                            SerialDocumentMapping serialDocumentMapping = (SerialDocumentMapping) krObj.getEntityList().get(0);
                            if (serialObject.has(Constants.customfield)) {
                                String customfield = serialObject.getString(Constants.customfield);
                                if (!StringUtil.isNullOrEmpty(customfield)) {
                                    HashMap<String, Object> DOMap = new HashMap<String, Object>();
                                    JSONArray jcustomarray = new JSONArray(customfield);

                                    HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                                    customrequestParams.put("customarray", jcustomarray);
                                    customrequestParams.put("modulename", "SerialDocumentMapping");
                                    customrequestParams.put("moduleprimarykey", "SerialDocumentMappingId");
                                    customrequestParams.put("modulerecid", serialDocumentMapping.getId());
                                    customrequestParams.put(Constants.moduleid, Constants.SerialWindow_ModuleId);
                                    customrequestParams.put(Constants.companyKey, companyid);
                                    DOMap.put(Constants.Acc_id, serialDocumentMapping.getId());
                                    customrequestParams.put("customdataclasspath", Constants.Acc_Serial_custom_data_classpath);
                                    KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                                    if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                                        DOMap.put("serialcustomdataref", serialDocumentMapping.getId());
                                        accCommonTablesDAO.updateserialcustomdata(DOMap);
                                    }
                                }
                            }
                        }
                        KwlReturnObject serialObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), serialObject.getString("purchaseserialid"));
                        NewBatchSerial newBatchSerial = (NewBatchSerial) serialObj.getEntityList().get(0);
                        if (newBatchSerial != null) {
                            if ((newBatchSerial.getQuantitydue() == 0 && !"0".equals(stockType)) || (newBatchSerial.getConsignquantity() == 0 && "0".equals(stockType))) {
                                throw new AccountingException(newBatchSerial.getSerialname() + " is Already being used so you can not use it Again");
                            } else if (newBatchSerial.getLockquantity() == 1) {
                                String soDtlId = deliveryOrderDetail.getSodetails() != null ? deliveryOrderDetail.getSodetails().getID() : "";
                                accCommonTablesDAO.releaseSerialFromOtherSo(newBatchSerial, soDtlId);
                            }
                        }
                        HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                        serialUpdateQtyMap.put("qty", "-1");
                        if (isLockedinSo && isSeriallockedinSO) {
                            serialUpdateQtyMap.put("lockquantity", "-1");
                        }
                        if (isConsignment) {
                            serialUpdateQtyMap.put("isForconsignment", true); //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                        }
                        if ("0".equals(stockType) && !isConsignment) {
                            serialUpdateQtyMap.put("consignquantity", "-1");
                            serialUpdateQtyMap.put("qty", "0");
                        }
                        serialUpdateQtyMap.put(Constants.Acc_id, serialObject.optString("purchaseserialid"));
                        if (!sendForQAApproval || !isQAEnable) {
                            accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);
                        }
                        //Code to Send Serial Numbers to Inventory
                        if (newBatchSerial != null) {
                            if (isWarehouseForProduct && isLocationForProduct) {
                                if (sendForQAApproval && isQAEnable) {
                                    StringBuilder serialNamesQC = new StringBuilder();
                                    serialNamesQC.append(StringUtil.isNullOrEmpty(istDetailQC.getIssuedSerialNames()) ? "" : istDetailQC.getIssuedSerialNames());
                                    if (serialNamesQC.length() > 0) {
                                        serialNamesQC.append(",").append(newBatchSerial.getSerialname());
                                    } else {
                                        serialNamesQC.append(newBatchSerial.getSerialname());
                                    }
                                    istDetailQC.setDeliveredSerialNames(serialNamesQC.toString());
                                    istDetailQC.setIssuedSerialNames(serialNamesQC.toString());
                                } else if (isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
                                    StringBuilder pickpackserialNames = new StringBuilder();
                                    pickpackserialNames.append(StringUtil.isNullOrEmpty(srd.getIssuedSerialNames()) ? "" : srd.getIssuedSerialNames());
                                    if (pickpackserialNames.length() > 0) {
                                        pickpackserialNames.append(",").append(newBatchSerial.getSerialname());
                                    } else {
                                        pickpackserialNames.append(newBatchSerial.getSerialname());
                                    }
                                    srd.setDeliveredSerialNames(pickpackserialNames.toString());
                                    srd.setIssuedSerialNames(pickpackserialNames.toString());
                                } else {
                                    smd.addSerialName(newBatchSerial.getSerialname());
                                }
                            }
                        }

                        if (serialObject.has("wastageQuantityType") && !StringUtil.isNullOrEmpty(serialObject.optString("wastageQuantityType",null)) && serialObject.has("wastageQuantity") && !StringUtil.isNullOrEmpty(serialObject.optString("wastageQuantity",null))) {
                            Map<String, Object> requestParams = new HashMap<>();
                            requestParams.put("serialmapid", documentMap.get("serialmapid"));
                            requestParams.put("wastageQuantityType", serialObject.optString("wastageQuantityType"));
                            requestParams.put("wastageQuantity", serialObject.optString("wastageQuantity"));
                            accCommonTablesDAO.saveWastageDetailsForSerial(requestParams);
                        }

                    }
                }
            }
            
        }
        if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateInventoryTab() && isPickPackFlow && (!sendForQAApproval || !isQAEnable)) {
            for (Map.Entry<Store, InterStoreTransferRequest> entrySet : storeWiseInterStoreTransferRequest.entrySet()) {
                 InterStoreTransferRequest value = entrySet.getValue();
                Map<String, Object> requestParams = new HashMap<>();
                requestParams.put(Constants.companyid, companyid);
                requestParams.put("dod", deliveryOrderDetail.getID());
                if (extraCompanyPreferences.isInterloconpick()) {
                    requestParams.put(Constants.moduleid, Constants.Acc_InterLocation_ModuleId);
                    istService.addInterLocationTransfer(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value, requestParams);
                } else {
                    requestParams.put(Constants.moduleid, Constants.Acc_InterStore_ModuleId);
                    istService.addInterStoreTransferRequest(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value, false, requestParams);
                    istService.acceptInterStoreTransferRequest(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value);
                }
//                Commented for ERP-38814, sequence format will not be updated   
//                try {
//                    seqService.updateSeqNumber(seqFormat);
//                } catch (SeqFormatException ex) {
//                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
//                }
            }
        }
            //following condition is to free batch if batch is changed in DeliveryOrder than selected in Sales Order. ERP-20117
            if (newBatchMap.size() > 0 && oldBatchMap.size() > 0 && (!sendForQAApproval || !isQAEnable)) {
                List intersectionList = (List) CollectionUtils.intersection(newBatchMap.keySet(), oldBatchMap.keySet());
                List subtractedOldBatchList = (List) CollectionUtils.subtract(oldBatchMap.keySet(), intersectionList);
                List subtractedNewBatchList = (List) CollectionUtils.subtract(newBatchMap.keySet(), intersectionList);

                Iterator itr = intersectionList.iterator();
                // this loop is to check and manage lock qty if batch is same in SO and DO, and qty is different
                while (itr.hasNext()) {
                    String newBatchKey = (String) itr.next();
                    if ((oldBatchMap.get(newBatchKey) == newBatchMap.get(newBatchKey))) {
                        continue;
                    } else if ((oldBatchMap.get(newBatchKey) != newBatchMap.get(newBatchKey))) {
                        double oldQty = (double) oldBatchMap.get(newBatchKey);
                        double newQty = (double) newBatchMap.get(newBatchKey);
                        double adjustedQty = -(oldQty - newQty);
                        if (newQty <= oldQty) {
                            adjustedQty = -1 * newQty;
                        }
                        HashMap<String, Object> batchLockQtyUpdateMap = new HashMap<String, Object>();
                        batchLockQtyUpdateMap.put("lockquantity", String.valueOf(adjustedQty));
                        batchLockQtyUpdateMap.put(Constants.Acc_id, newBatchKey);
                        accCommonTablesDAO.saveBatchAmountDue(batchLockQtyUpdateMap);
                    }
                }
                itr = subtractedOldBatchList.iterator();
                // this loop is to check and manage/free lock qty of old batch in SO
                while (itr.hasNext()) {
                    String batchKey = (String) itr.next();
                    HashMap<String, Object> batchLockQtyUpdateMap = new HashMap<String, Object>();
                    double qty = -(double) oldBatchMap.get(batchKey);
                    batchLockQtyUpdateMap.put("lockquantity", String.valueOf(qty));
                    batchLockQtyUpdateMap.put(Constants.Acc_id, batchKey);
                    accCommonTablesDAO.saveBatchAmountDue(batchLockQtyUpdateMap);
                }
                itr = subtractedNewBatchList.iterator();
                // this loop is to check and manage/free lock qty of new batch in DO
                while (itr.hasNext()) {
                    String batchKey = (String) itr.next();
                    HashMap<String, Object> batchLockQtyUpdateMap = new HashMap<String, Object>();
                    double qty = (double) newBatchMap.get(batchKey);
                    batchLockQtyUpdateMap.put(Constants.Acc_id, batchKey);
                    accCommonTablesDAO.saveBatchAmountDue(batchLockQtyUpdateMap);
                }
            }

            if (isWarehouseForProduct && isLocationForProduct && (!sendForQAApproval || !isQAEnable)) {
                for (Map.Entry<Store, StockMovement> entry : storeWiseStockMovement.entrySet()) {
                    stockMovementsList.add(entry.getValue());
                }
            }
            
        if (sendForQAApproval && isQAEnable) {
            /**
             * We have created map for storing store wise separate IST request.
             * All IST request will have same transaction number.
             */
            for (Map.Entry<Store, InterStoreTransferRequest> entrySet : storeWiseInterStoreTransferRequestForQC.entrySet()) {
                InterStoreTransferRequest value = entrySet.getValue();
                Map<String, Object> requestParams = new HashMap<>();
                requestParams.put(Constants.companyid, companyid);
                requestParams.put(Constants.CREATE_IST_FOR_QC_DELIVERYORDER, true);
                requestParams.put("dodetailid", deliveryOrderDetail.getID());
                requestParams.put("quantity", value.getAcceptedQty());
                requestParams.put("quantityDue", value.getAcceptedQty());
                requestParams.put(Constants.moduleid, Constants.Acc_InterStore_ModuleId);
                istService.addInterStoreTransferRequest(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value, false, requestParams);
                istService.acceptInterStoreTransferRequest(deliveryOrderDetail.getDeliveryOrder().getCreatedby(), value);
                try {
                    seqService.updateSeqNumber(interStoreTransferSeqFormat);
                } catch (SeqFormatException ex) {
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }

    @Override
    public void saveConsignmentNewBatch(String batchJSON, Inventory inventory, HttpServletRequest request, String documentId) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {

        JSONObject paramJObj = new JSONObject();
        try {
            Enumeration<String> attributes = request.getAttributeNames();
            while (attributes.hasMoreElements()) {
                String attribute = attributes.nextElement();
                paramJObj.put(attribute, request.getAttribute(attribute));
            }
            Enumeration<String> parameters = request.getParameterNames();
            while (parameters.hasMoreElements()) {
                String parameter = parameters.nextElement();
                paramJObj.put(parameter, request.getParameter(parameter));
            }
            paramJObj.put(Constants.language, RequestContextUtils.getLocale(request).getLanguage());
        } catch (JSONException e) {
            e.printStackTrace();
        }
        saveConsignmentNewBatchJson(batchJSON, inventory, paramJObj, documentId);
    }

    public void saveConsignmentNewBatchJson(String batchJSON, Inventory inventory, JSONObject paramJobj, String documentId) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        KwlReturnObject kmsg = null;
        double ActbatchQty = 1;
        double batchQty = 0;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        String batchId = "";
        DateFormat df = authHandler.getDateOnlyFormat();
        String companyid = paramJobj.getString(Constants.companyKey);
        boolean isConsignment = false;
          boolean isEdit = false;
        if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment))) {
            isConsignment = Boolean.parseBoolean(paramJobj.get(Constants.isConsignment).toString());
        }
         if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isEdit))) {
            isEdit = Boolean.parseBoolean(paramJobj.get(Constants.isEdit).toString());
        }
        if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), inventory.getProduct().getID());
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
        }
        NewProductBatch productBatch = null;
        String productBatchId = "";
        String custWarehouse = paramJobj.optString("custWarehouse", null);  //Taken the customer warehouse to which stock is to be added 
        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        for (int i = 0; i < jArr.length(); i++) {
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());

            String batchName = jSONObject.optString("batch", "");
            //we check in customer warehouse whether batch is present is not whit same batch name
            batchId = accCommonTablesDAO.isbatchExsistOrNot(batchName, custWarehouse, inventory.getProduct().getID(), companyid);

            if (jSONObject.has("quantity") && !jSONObject.getString("quantity").equals("undefined") && !jSONObject.getString("quantity").isEmpty()) {
                ActbatchQty = jSONObject.getDouble("quantity");
            }
            if (batchQty == 0) {
                batchQty = jSONObject.getDouble("quantity");
            }
            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) && (batchQty == ActbatchQty)) {
                if (StringUtil.isNullOrEmpty(batchId)) {
                    HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                    pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
                    pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("batch")));
                    if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                        pdfTemplateMap.put("mfgdate", df.parse(jSONObject.getString("mfgdate")));
                    }
                    if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                        pdfTemplateMap.put("expdate", df.parse(jSONObject.getString("expdate")));
                    }
                    pdfTemplateMap.put("quantity", jSONObject.optString("quantity", "0"));
                    pdfTemplateMap.put("consignquantity", jSONObject.optString("quantity", "0"));
                    pdfTemplateMap.put("balance", jSONObject.optString("balance", "0"));
                    pdfTemplateMap.put("location", "");  //as every thing is depend on warehouse we do not need to pass location here
                    pdfTemplateMap.put("product", inventory.getProduct().getID());
                    pdfTemplateMap.put("row", isRowForProduct && jSONObject.has("row") ? jSONObject.optString("row") : "");
                    pdfTemplateMap.put("rack", isRackForProduct && jSONObject.has("rack") ? jSONObject.optString("rack") : "");
                    pdfTemplateMap.put("bin", isBinForProduct && jSONObject.has("bin") ? jSONObject.optString("bin") : "");
                    pdfTemplateMap.put("warehouse", !StringUtil.isNullOrEmpty(custWarehouse) ? custWarehouse : "");
                    pdfTemplateMap.put("isopening", false);
                    pdfTemplateMap.put(Constants.isConsignment, isConsignment);//This is GRN Type Tranction
                    pdfTemplateMap.put("transactiontype", "28");//This is GRN Type Tranction  
                    pdfTemplateMap.put("ispurchase", true);
                    pdfTemplateMap.put("isForconsignment", false);
                    kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);
                    if (kmsg != null && kmsg.getEntityList().size() != 0) {
                        productBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                        productBatchId = productBatch.getId();
                    }
                } else {  //in case of partial quantity of batch then jsust add taht quantity in that batch itself
                    productBatchId = batchId;
                    if (!isBatchForProduct && !isSerialForProduct) {
                        HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                        ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                        if (!StringUtil.isNullOrEmpty(custWarehouse)) {
                            String warehouse = custWarehouse;
                            filter_names.add("warehouse.id");
                            filter_params.add(warehouse);
                        }
                        if (!StringUtil.isNullOrEmpty(jSONObject.optString("location", ""))) {
                            //String location = null;// jSONObject.getString("location");
                            filter_names.add("ISNUL location.id ");
                            //filter_params.add(location);
                        }
                        filter_names.add("product");
                        filter_params.add(inventory.getProduct().getID());
                        filterRequestParams.put("filter_names", filter_names);
                        filterRequestParams.put("filter_params", filter_params);
                        filterRequestParams.put("order_by", order_by);
                        filterRequestParams.put("order_type", order_type);
                        KwlReturnObject result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                        List listResult = result.getEntityList();
                        Iterator itrResult = listResult.iterator();
                        Double quantityToDue = ActbatchQty;
                        while (itrResult.hasNext()) {
                            NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                            if (quantityToDue > 0) {
                                double dueQty = newProductBatch.getQuantitydue();
                                HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                                batchUpdateQtyMap.put(Constants.Acc_id, newProductBatch.getId());
                                if (dueQty > 0) {
                                    if (quantityToDue > dueQty) {
                                        batchUpdateQtyMap.put("qty", String.valueOf(-(dueQty)));
                                        if (isConsignment) {
                                            batchUpdateQtyMap.put("consignquantity", String.valueOf(dueQty));
                                            batchUpdateQtyMap.put("isForconsignment", false);
                                        }
                                        quantityToDue = quantityToDue - dueQty;

                                    } else {
                                        batchUpdateQtyMap.put("qty", String.valueOf((quantityToDue)));
                                        if (isConsignment) {
                                            batchUpdateQtyMap.put("consignquantity", String.valueOf(quantityToDue));
                                            batchUpdateQtyMap.put("isForconsignment", false);
                                        }
                                        quantityToDue = quantityToDue - quantityToDue;

                                    }
                                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);

                                }else if (!StringUtil.isNullOrEmpty(custWarehouse) && isConsignment) { // consignment Delivery order edit 
                                    batchUpdateQtyMap.put("qty", String.valueOf((quantityToDue)));
                                    batchUpdateQtyMap.put("quantity", String.valueOf((quantityToDue)));
                                    if (isConsignment) {
                                        batchUpdateQtyMap.put("consignquantity", String.valueOf(quantityToDue));
                                        batchUpdateQtyMap.put("isForconsignment", false);
                                    }
                                    quantityToDue = quantityToDue - quantityToDue;
                                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                                }
                            }

                        }
                    } else {

                        HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                        batchUpdateQtyMap.put("qty", String.valueOf((Double.parseDouble(jSONObject.optString("quantity","0")))));
                        batchUpdateQtyMap.put("quantity", String.valueOf((Double.parseDouble(jSONObject.optString("quantity","0")))));
                        if (isConsignment) {
                            batchUpdateQtyMap.put("consignquantity", String.valueOf(Double.parseDouble(jSONObject.optString("quantity","0"))));
                            batchUpdateQtyMap.put("isForconsignment", false);
                        }
                        batchUpdateQtyMap.put(Constants.Acc_id, productBatchId);
                        accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                    }
                }
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.optString("quantity"));
                if (!StringUtil.isNullOrEmpty(productBatchId)) {
                    documentMap.put("batchmapid", productBatchId);
                } else {
                    throw new AccountingException("saveConsignmentNewBatch: Product Batch cannot be empty.");
                }
                documentMap.put("documentid", documentId);
                documentMap.put("transactiontype", "28");//This is GRN Type Tranction
                documentMap.put(Constants.isConsignment, isConsignment);//This is GRN Type Tranctio
                if (isConsignment) {
                    documentMap.put("consignquantity", jSONObject.optString("quantity"));
                }
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("mfgdate"))) {
                    documentMap.put("mfgdate", df.parse(jSONObject.optString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.optString("expdate"))) {
                    documentMap.put("expdate", df.parse(jSONObject.optString("expdate")));
                }
                accCommonTablesDAO.saveBatchDocumentMapping(documentMap);
            }
            batchQty--;

            if (isSerialForProduct) {  //if serial no option is on then only save the serial no details 
                String serialDetailsId = "";
                HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
                pdfTemplateMap.put("product", inventory.getProduct().getID());
                pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("serialno")));
                pdfTemplateMap.put("skufield", StringUtil.DecodeText(jSONObject.optString("skufield")));
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.optString("expstart"))) {
                    pdfTemplateMap.put("expfromdate", df.parse(jSONObject.optString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.optString("expend"))) {
                    pdfTemplateMap.put("exptodate", df.parse(jSONObject.optString("expend")));
                }
                pdfTemplateMap.put("batch", productBatchId);
                pdfTemplateMap.put("transactiontype", "28");//This is GRN Type Tranction  
                pdfTemplateMap.put("quantity", "1");
                pdfTemplateMap.put("consignquantity", "1");
                pdfTemplateMap.put("ispurchase", true);
                pdfTemplateMap.put(Constants.isConsignment, isConsignment);
                pdfTemplateMap.put("isForconsignment", false);
                kmsg = accCommonTablesDAO.saveNewSerialForBatch(pdfTemplateMap);

                if (kmsg != null && kmsg.getEntityList().size() != 0) {
                    NewBatchSerial serialDetails = (NewBatchSerial) kmsg.getEntityList().get(0);
                    serialDetailsId = serialDetails.getId();
                }
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", 1);
                documentMap.put("serialmapid", serialDetailsId);
                documentMap.put("documentid", documentId);
                documentMap.put(Constants.isConsignment, isConsignment);//This is GRN Type Tranctio
                documentMap.put("transactiontype", "28");//This is GRN Type Tranction  
                if (isConsignment) {
                    documentMap.put("consignquantity", 1);
                }
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.optString("expstart"))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.optString("expend"))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(jSONObject.optString("expend")));
                }

                accCommonTablesDAO.saveSerialDocumentMapping(documentMap);

            } else {
                batchQty = 0;
            }
        }
    }

    public String getdefaultBatchJson(Product product, HttpServletRequest request, String documentid, double quantity) throws JSONException {
        JSONArray jarr = new JSONArray();
        JSONObject jobj = new JSONObject();
        Location locationObj = null;
        try {
            locationObj = locationService.getDefaultLocation(product.getCompany());
        } catch (ServiceException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        jobj.put("location", locationObj!=null?locationObj.getId():"");

        if (product.getWarehouse() != null && !StringUtil.isNullOrEmpty(product.getWarehouse().getId())) {
            jobj.put("warehouse", product.getWarehouse().getId());
        }
        jobj.put("documentid", "");
        if(!StringUtil.isNullOrEmpty(product.getID())){
            jobj.put(Constants.productid, product.getID());
        }
        jobj.put("quantity", quantity);
        jobj.put("purchasebatchid", "");
        jarr.put(jobj);
        return jarr.toString();
    }

    @Override
    public Set<WastageDetails> saveWastageDetails(JSONObject paramJobj, String deliveryOrderDetailID, String wastageDetails) throws ServiceException,JSONException {
        Set<WastageDetails> wastageDetailsSet = new HashSet<>();
        try {
            JSONArray jArr = new JSONArray(wastageDetails);
            String companyID = paramJobj.optString(Constants.companyKey);

            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jobj = jArr.getJSONObject(i);

                HashMap<String, Object> dataMap = new HashMap<>();
                if (jobj.has(Constants.productid)) {
                    dataMap.put("productID", jobj.getString(Constants.productid));
                }
                if (jobj.has("quantity")) {
                    dataMap.put("quantity", jobj.getDouble("quantity"));
                }
                if (jobj.has("percentage")) {
                    dataMap.put("percentage", jobj.getDouble("percentage"));
                }
                if (jobj.has("actualquantity")) {
                    dataMap.put("actualQuantity", jobj.getDouble("actualquantity"));
                }
                if (jobj.has("wastageQuantityType")) {
                    dataMap.put("wastageQuantityType", jobj.getInt("wastageQuantityType"));
                }
                if (jobj.has("wastageQuantity")) {
                    dataMap.put("wastageQuantity", jobj.getDouble("wastageQuantity"));
                }
                if (!StringUtil.isNullOrEmpty(deliveryOrderDetailID)) {
                    dataMap.put("deliveryOrderDetailID", deliveryOrderDetailID);
                }
                dataMap.put("companyID", companyID);

                KwlReturnObject result = accInvoiceDAOobj.saveWastageDetails(dataMap);
                WastageDetails wastageDetail = (WastageDetails) result.getEntityList().get(0);
                wastageDetailsSet.add(wastageDetail);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("saveWastageDetails : " + ex.getMessage(), ex);
        }
        return wastageDetailsSet;
    }

    @Override
    public double getValuationForDOAndSR(HashMap<String, Object> requestMap, Map<String, List<TransactionBatch>> priceValuationMap, Map<String, Double> batchQuantityMap) {
        double valuation = 0;
        try {
            List<TransactionBatch> pvbList = new ArrayList();
            boolean isSalesReturn = false;
            if (requestMap.containsKey("isSalesReturn")) {
                isSalesReturn = Boolean.parseBoolean(requestMap.get("isSalesReturn").toString());
            }
            int originalListSize = pvbList.size();
            List<TransactionBatch> tempList = new ArrayList();
            String prodID = requestMap.get(Constants.productid).toString();
            KwlReturnObject productresult = accountingHandlerDAOobj.getObject(Product.class.getName(), prodID);
            Product rowProduct = (Product) productresult.getEntityList().get(0);
            String[] batchSerialId = null;
            if (rowProduct != null && (rowProduct.isIsSerialForProduct() || rowProduct.isIsBatchForProduct()) && requestMap.containsKey("batchSerialId")) {
                batchSerialId = (String[]) requestMap.get("batchSerialId");
            }
            ValuationMethod valuationMethod = rowProduct.getValuationMethod();
            String gcurrencyid = requestMap.get(Constants.globalCurrencyKey).toString();
            String companyid = requestMap.get(Constants.companyKey).toString();
            double dquantity = (Double) requestMap.get("dquantity");
            HashMap<String, Object> requestParams = (HashMap<String, Object>) requestMap.get("GlobalParams");
            requestParams.put(Constants.companyKey, companyid);
            requestParams.put(Constants.globalCurrencyKey, gcurrencyid);
            requestParams.put("isStockLedgerReport", true);
            if (priceValuationMap.containsKey(prodID)) {
                pvbList = priceValuationMap.get(prodID);
            }
            if (pvbList.isEmpty()) {
                KwlReturnObject stockResult = accProductObj.getStockLedger(requestMap);
                List list = stockResult.getEntityList();
                for (Object object : list) {
                    Object[] row = (Object[]) object;
                    BigInteger transType = (BigInteger) row[0];
                    String productid = (String) row[1];
                    double quantity = (Double) row[9];
                    double baseUOMRate = (Double) row[11]; // Conversion Factor
                    Double baseUOMQuantity = authHandler.calculateBaseUOMQuatity(quantity, baseUOMRate, companyid);
                    double stockRate = row[10] != null ? (Double) row[10] : 0.0;
                    String currencyid = "";
                    if (!StringUtil.isNullOrEmpty((String) row[13])) {
                        currencyid = (String) row[13];
                    }
                    double grSpotRate = 0.0;
                    try {
                        if (!StringUtil.isNullOrEmpty((String) row[16])) {
                            grSpotRate = StringUtil.getDouble((String) row[16]);
                        }
                    } catch (java.lang.ClassCastException ex) {
                        if (row[16] != null) {
                            grSpotRate = (double) row[16];
                        }
                    }
                    String detailid = "";
                    if (!StringUtil.isNullOrEmpty((String) row[17])) {
                        detailid = (String) row[17];
                    }
                    Date transactionDate = (Date) row[4];
                    String transDate = authHandler.getDateOnlyFormat().format(transactionDate);
                    transactionDate = authHandler.getDateOnlyFormat().parse(transDate);
                    boolean isOpeningtransaction = false;
                    KwlReturnObject crresult;
                    if (rowProduct.isIsSerialForProduct()) {
                        crresult = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, stockRate, currencyid, transactionDate, grSpotRate);
                        stockRate = (Double) crresult.getEntityList().get(0);
                        int transactiontype = 28;
                        String serial = "";
                        if (transType.intValue() == 0 || transType.intValue() == 1 || transType.intValue() == 2 || transType.intValue() == 3 || transType.intValue() == 5 || transType.intValue() == 4) {
                            if (transType.intValue() == 0 || transType.intValue() == 1) {
                                transactiontype = 28;
                            } else if (transType.intValue() == 2 || transType.intValue() == 3 || transType.intValue() == 5 || transType.intValue() == 4) {
                                if (transType.intValue() == 2) {
                                    transactiontype = 31;
                                } else if (transType.intValue() == 3 || transType.intValue() == 5) {
                                    transactiontype = 27;
                                } else if (transType.intValue() == 4) {
                                    transactiontype = 29;
                                }
                            }
                            KwlReturnObject srno = accProductObj.getSerialNoByDocumentid(detailid, transactiontype);
                            List list2 = srno.getEntityList();
                            for (Object obj : list2) {
                                serial += obj.toString() + ",";
                            }
                            String[] serialId = serial.split(",");
                            stockRate = accProductObj.getValuationPriceForSerialBatches(productid, transType.intValue(), valuationMethod, baseUOMQuantity, stockRate, baseUOMRate, isOpeningtransaction, pvbList, true, serialId);
                        } else if (transType.intValue() == 7 || transType.intValue() == 8) {
                            KwlReturnObject saresult = accountingHandlerDAOobj.getObject(StockAdjustment.class.getName(), detailid);
                            StockAdjustment sa = (StockAdjustment) saresult.getEntityList().get(0);
                            KwlReturnObject saDetails = accProductObj.getSADetailByStockAdjustment(detailid);
                            List saDetailsList = saDetails.getEntityList();
                            Iterator it = saDetailsList.iterator();
                            while (it.hasNext()) {
                                Object[] Objrow = (Object[]) it.next();
                                String store = sa.getStore().getId();
                                String location = (String) Objrow[2];
                                String batchnames = (String) Objrow[3];
                                String serialNames = (String) Objrow[5];
                                if (!StringUtil.isNullOrEmpty(serialNames)) {
                                    String srl[] = serialNames.split(",");
                                    for (String s : srl) {
                                        KwlReturnObject storeresult = accountingHandlerDAOobj.getObject(Store.class.getName(), store);
                                        Store str = (Store) storeresult.getEntityList().get(0);
                                        KwlReturnObject locationresult = accountingHandlerDAOobj.getObject(Location.class.getName(), location);
                                        Location loc = (Location) locationresult.getEntityList().get(0);

                                        NewProductBatch batchObj = stockDAO.getERPProductBatch(sa.getProduct(), str, loc, null, null, null, batchnames);
                                        NewBatchSerial serialObj = stockDAO.getERPBatchSerial(sa.getProduct(), batchObj, s);
                                        if (serialObj != null) {
                                            serial += serialObj.getId() + ",";
                                        }
                                    }
                                }
                            }
                            String[] serialId = serial.split(",");
                            stockRate = accProductObj.getValuationPriceForSerialBatches(productid, transType.intValue(), valuationMethod, baseUOMQuantity, stockRate, baseUOMRate, isOpeningtransaction, pvbList, true, serialId);
                        }
                    } else if (rowProduct.isIsBatchForProduct() && !rowProduct.isIsSerialForProduct()) {
                        crresult = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, stockRate, currencyid, transactionDate, grSpotRate);
                        stockRate = (Double) crresult.getEntityList().get(0);
                        int transactiontype = 28;
                        String batch = "";
                        if (transType.intValue() == 0 || transType.intValue() == 1 || transType.intValue() == 2 || transType.intValue() == 3 || transType.intValue() == 5 || transType.intValue() == 4) {
                            if (transType.intValue() == 0 || transType.intValue() == 1) {
                                transactiontype = 28;
                            } else if (transType.intValue() == 2 || transType.intValue() == 3 || transType.intValue() == 5 || transType.intValue() == 4) {
                                if (transType.intValue() == 2) {
                                    transactiontype = 31;
                                } else if (transType.intValue() == 3 || transType.intValue() == 5) {
                                    transactiontype = 27;
                                } else if (transType.intValue() == 4) {
                                    transactiontype = 29;
                                }
                            }
                            KwlReturnObject srno = accProductObj.getBatchesByDocumentid(detailid, transactiontype);
                            List list2 = srno.getEntityList();
                            Iterator itr1 = list2.iterator();
                            while (itr1.hasNext()) {
                                Object[] batchRow = (Object[]) itr1.next();
                                batch = (String) batchRow[0];
                                double batchQty = (Double) batchRow[1];
                                String[] batchId = batch.split(",");
                                stockRate = accProductObj.getValuationPriceForSerialBatches(productid, transType.intValue(), valuationMethod, batchQty, stockRate, baseUOMRate, isOpeningtransaction, pvbList, false, batchId);
                            }
                        } else if (transType.intValue() == 7 || transType.intValue() == 8) {
                            KwlReturnObject saresult = accountingHandlerDAOobj.getObject(StockAdjustment.class.getName(), detailid);
                            StockAdjustment sa = (StockAdjustment) saresult.getEntityList().get(0);
                            KwlReturnObject saDetails = accProductObj.getSADetailByStockAdjustment(detailid);
                            List saDetailsList = saDetails.getEntityList();
                            Iterator it = saDetailsList.iterator();
                            while (it.hasNext()) {
                                Object[] Objrow = (Object[]) it.next();
                                String store = sa.getStore().getId();
                                String location = (String) Objrow[2];
                                String batchnames = (String) Objrow[3];
                                double finalQuantity = (Double) Objrow[4];
                                String pro = sa.getProduct().getID();
                                requestParams.put("store", store);
                                requestParams.put("location", location);
                                requestParams.put("product", pro);
                                requestParams.put("batchnames", batchnames);
                                requestParams.put("finalQuantity", finalQuantity);
                                KwlReturnObject storeresult = accountingHandlerDAOobj.getObject(Store.class.getName(), store);
                                Store str = (Store) storeresult.getEntityList().get(0);
                                KwlReturnObject locationresult = accountingHandlerDAOobj.getObject(Location.class.getName(), location);
                                Location loc = (Location) locationresult.getEntityList().get(0);
                                NewProductBatch batchObj = stockDAO.getERPProductBatch(sa.getProduct(), str, loc, null, null, null, batchnames);
                                batch = batchObj.getId();
                                String[] batchId = batch.split(",");
                                stockRate = accProductObj.getValuationPriceForSerialBatches(productid, transType.intValue(), valuationMethod, finalQuantity, stockRate, baseUOMRate, isOpeningtransaction, pvbList, false, batchId);
                            }
                        }
                    } else if (valuationMethod == ValuationMethod.FIFO || valuationMethod == ValuationMethod.STANDARD || valuationMethod == ValuationMethod.AVERAGE) {
                        crresult = accCurrencyDAOobj.getCurrencyToBaseAmount(requestMap, stockRate, currencyid, transactionDate, grSpotRate);
                        stockRate = (Double) crresult.getEntityList().get(0);
                        stockRate = accProductObj.getValuationPrice(productid, transType.intValue(), valuationMethod, baseUOMQuantity, stockRate, baseUOMRate, isOpeningtransaction, pvbList);
                    }
                }
            }
            if (rowProduct.isIsSerialForProduct()) {
                if (!isSalesReturn && batchSerialId != null) {
                    for (TransactionBatch pvb : pvbList) {
                        if (pvb.isOutEntry() || pvb.getQuantity() == 0) { // considering batch which has IN quantity. Because for DO or out transaction remove quantity from IN quantity
                            continue;
                        }
                        for (int i = 0; i <= batchSerialId.length - 1; i++) {
                            if (dquantity > 0 && pvb.getSerialId().equals(batchSerialId[i])) {
                                double outQty = 0;
                                if (dquantity >= (pvb.getQuantity() - pvb.getRemovedQty())) {
                                    outQty = (pvb.getQuantity() - 1);
                                }
                                dquantity--;
                                outQty = 1;
                                pvb.setRemovedQty(outQty);
                                TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), outQty, false, tempList.size() + originalListSize, "", batchSerialId[i]);
                                pbvTemp.setOutEntry(true);
                                tempList.add(pbvTemp);
                                valuation += pvb.getPrice() * outQty;
                            }
                        }
                    }
                } else if (batchSerialId != null) {
                    for (int i = 0; i <= batchSerialId.length - 1; i++) {
                        for (TransactionBatch pvb : pvbList) {
                            if (!pvb.isOutEntry() || pvb.getQuantity() == 0 || !pvb.getSerialId().equals(batchSerialId[i])) {
                                continue;
                            }
                            if (dquantity > 0 && pvb.getSerialId().equals(batchSerialId[i])) {
                                double retQty = 0;
                                if (dquantity >= pvb.getQuantity()) {
                                    retQty = 1;
                                }
                                dquantity -= retQty;

                                TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), retQty, false, tempList.size() + originalListSize, "", batchSerialId[i]);
                                tempList.add(pbvTemp);

                                valuation += pvb.getPrice() * retQty;
                            } else {
                                break;
                            }
                        }
                    }
                    for (TransactionBatch pvbTemp : tempList) { // breaking quantity by batch for given base uom quantity.
                        double qty = pvbTemp.getQuantity();
                        if (pvbTemp.getQuantity() == 0) { // considering batch which removed quantity. Because adding quantity from previously removed quantity.
                            continue;
                        }
                        for (int i = 0; i <= batchSerialId.length - 1; i++) {
                            if (qty > 0 && pvbTemp.getSerialId().toString().equals(batchSerialId[i])) {
                                for (TransactionBatch pvbMain : pvbList) {
                                    double availQty = pvbMain.getQuantity() - pvbMain.getRemovedQty();
                                    if (pvbMain.isOutEntry() || availQty <= 0 || !pvbMain.getSerialId().equals(pvbTemp.getSerialId())) {
                                        continue;
                                    }
                                    double retQty = 0;
                                    if (qty >= availQty) {
                                        retQty = 1;
                                    }
                                    qty -= retQty;
                                    pvbMain.setRemovedQty(pvbMain.getRemovedQty() - retQty);

                                    if (qty <= 0) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (rowProduct.isIsBatchForProduct() && !rowProduct.isIsSerialForProduct()) {
                if (!isSalesReturn && batchSerialId != null) {
                    if (valuationMethod == ValuationMethod.STANDARD) { // for Lifo consider sales return from last batch no. 
                        Collections.sort(pvbList, new PVBSorter.sortDESC());
                    } else {
                        Collections.sort(pvbList, new PVBSorter.sortASC()); // for Fifo consider sales return from first batch no. 
                    }
                    for (TransactionBatch pvb : pvbList) {
                        if (pvb.isOutEntry() || pvb.getQuantity() == 0) { // considering batch which has IN quantity. Because for DO or out transaction remove quantity from IN quantity
                            continue;
                        }
                        for (int i = 0; i <= batchSerialId.length - 1; i++) {
                            double quantityEntered = batchQuantityMap.get(batchSerialId[i]); // QUANTITY ENTERED IN ENTRY FORM
                            if (quantityEntered > 0 && pvb.getBatchId().equals(batchSerialId[i])) {
                                double outQty = 0;
                                if (quantityEntered >= (pvb.getQuantity() - pvb.getRemovedQty())) {
                                    outQty = (pvb.getQuantity() - pvb.getRemovedQty());
                                } else {
                                    outQty = quantityEntered;
                                }
                                quantityEntered -= outQty;
                                pvb.setRemovedQty(pvb.getRemovedQty() + outQty);
                                TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), outQty, false, tempList.size() + originalListSize, batchSerialId[i], "");
                                pbvTemp.setOutEntry(true);
                                tempList.add(pbvTemp);
                                valuation += pvb.getPrice() * outQty;
                                batchQuantityMap.put(batchSerialId[i], quantityEntered);
                            }
                        }
                    }
                } else if (batchSerialId != null) {
                    if (valuationMethod == ValuationMethod.STANDARD) { // for Lifo consider sales return from last batch no. 
                        Collections.sort(pvbList, new PVBSorter.sortDESC());
                    } else {
                        Collections.sort(pvbList, new PVBSorter.sortASC()); // for Fifo consider sales return from first batch no. 
                    }
                    for (int i = 0; i <= batchSerialId.length - 1; i++) {
                        for (TransactionBatch pvb : pvbList) {
                            if (!pvb.isOutEntry() || pvb.getQuantity() == 0 || !pvb.getBatchId().equals(batchSerialId[i])) {
                                continue;
                            }
                            double quantityEntered = batchQuantityMap.get(batchSerialId[i]);
                            if (dquantity > 0 && quantityEntered > 0 && pvb.getBatchId().equals(batchSerialId[i])) {
                                double retQty = 0;
                                if (dquantity >= pvb.getQuantity()) {
                                    retQty = pvb.getQuantity();
                                } else {
                                    retQty = dquantity;
                                }
                                quantityEntered -= retQty;
                                dquantity -= quantityEntered;

                                TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), retQty, false, tempList.size() + originalListSize, batchSerialId[i], "");
                                tempList.add(pbvTemp);

                                valuation += pvb.getPrice() * retQty;
                                batchQuantityMap.put(batchSerialId[i], quantityEntered);
                            } else {
                                break;
                            }
                        }
                    }
                    for (TransactionBatch pvbTemp : tempList) { // breaking quantity by batch for given base uom quantity.
                        double qty = pvbTemp.getQuantity();
                        if (pvbTemp.getQuantity() == 0) { // considering batch which removed quantity. Because adding quantity from previously removed quantity.
                            continue;
                        }
                        for (int i = 0; i <= batchSerialId.length - 1; i++) {
                            if (qty > 0 && pvbTemp.getBatchId().toString().equals(batchSerialId[i])) {
                                for (TransactionBatch pvbMain : pvbList) {
                                    double availQty = pvbMain.getQuantity() - pvbMain.getRemovedQty();
                                    if (pvbMain.isOutEntry() || availQty <= 0) {
                                        continue;
                                    }
                                    double retQty = 0;
                                    if (qty >= availQty) {
                                        retQty = availQty;
                                    } else {
                                        retQty = dquantity;
                                    }
                                    qty -= retQty;
                                    pvbMain.setRemovedQty(pvbMain.getRemovedQty() - retQty);

                                    if (qty <= 0) {
                                        break;
                                    }
                                }
                            }
                        }
                    }

                }
            } else {
                if (!isSalesReturn) {
                    if (valuationMethod == ValuationMethod.STANDARD) { // for Lifo consider sales return from last batch no. 
                        Collections.sort(pvbList, new PVBSorter.sortDESC());
                    } else {
                        Collections.sort(pvbList, new PVBSorter.sortASC()); // for Fifo consider sales return from first batch no. 
                    }
                    for (TransactionBatch pvb : pvbList) { // breaking quantity by batch for given base uom quantity.
                        if (pvb.isOutEntry() || pvb.getQuantity() == 0) { // considering batch which has IN quantity. Because for DO or out transaction remove quantity from IN quantity
                            continue;
                        }
                        if (dquantity > 0) {
                            double outQty = 0;
                            if (dquantity >= (pvb.getQuantity() - pvb.getRemovedQty())) {
                                outQty = (pvb.getQuantity() - pvb.getRemovedQty());
                            } else {
                                outQty = dquantity;
                            }
                            dquantity -= outQty;
                            pvb.setRemovedQty(pvb.getRemovedQty() + outQty);
                            TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), outQty, false, tempList.size() + originalListSize, "", "");
                            pbvTemp.setOutEntry(true);
                            tempList.add(pbvTemp);
                            valuation += outQty * (pvb.getPrice());
                        } else {
                            break;
                        }
                    }
                    double baseUomQuantity = dquantity;
                    if ((dquantity > 0 && valuationMethod != ValuationMethod.AVERAGE) || (valuation == 0 && valuationMethod == ValuationMethod.AVERAGE)) {// if base uom quntity is more than DO quantity or for average valuation if total amount is zero then use product purchase price 
                        KwlReturnObject purchase = accProductObj.getProductPrice(prodID, true, null, "", "");
                        if (purchase.getEntityList() != null && !purchase.getEntityList().isEmpty() && purchase.getEntityList().get(0) != null) {
                            double price = purchase.getEntityList().get(0) != null ? (Double) purchase.getEntityList().get(0) : 0;
                            if (valuationMethod == ValuationMethod.AVERAGE) {
                                TransactionBatch pbvTemp = new TransactionBatch(price, baseUomQuantity, false, tempList.size() + originalListSize, "", "");
                                pbvTemp.setOutEntry(true);
                                tempList.add(pbvTemp);
                                valuation += price * baseUomQuantity;
                            } else {
                                TransactionBatch pbvTemp = new TransactionBatch(price, dquantity, false, tempList.size() + originalListSize, "", "");
                                pbvTemp.setOutEntry(true);
                                tempList.add(pbvTemp);
                                valuation += price * dquantity;
                            }

                        }
                    } else if (dquantity > 0 && valuationMethod == ValuationMethod.AVERAGE && valuation > 0) { // if base uom qty is more than batch quantity for average valuation then remaining quantity should be as same average price 
                        double price = valuation / (baseUomQuantity - dquantity);
                        TransactionBatch pbvTemp = new TransactionBatch(price, dquantity, false, tempList.size() + originalListSize, "", "");
                        pbvTemp.setOutEntry(true);
                        tempList.add(pbvTemp);
                        valuation += dquantity * price;
                    }
                } else {
                    // Sales Return
                    if (valuationMethod == ValuationMethod.STANDARD) { //LIFO
                        Collections.sort(pvbList, new PVBSorter.sortDESC()); // for Lifo consider sales return from last batch no. 
                    } else {
                        Collections.sort(pvbList, new PVBSorter.sortASC());  // for Fifo or Average consider sales return from first batch no. 
                    }

                    for (TransactionBatch pvb : pvbList) {
                        if (!pvb.isOutEntry() || pvb.getQuantity() == 0 || pvb.getRemovedQty() >= pvb.getQuantity()) {
                            continue;
                        }
                        if (dquantity > 0) {
                            double retQty = 0;
                            if (dquantity >= pvb.getQuantity() - pvb.getRemovedQty()) {
                                retQty = pvb.getQuantity() - pvb.getRemovedQty();
                            } else {
                                retQty = dquantity;
                            }
                            dquantity -= retQty;

                            TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), retQty, false, tempList.size() + originalListSize, "", "");
                            tempList.add(pbvTemp);

                            valuation += pvb.getPrice() * retQty;
                        } else {
                            break;
                        }
                    }
                    double baseUomQuantity = dquantity;
                    for (TransactionBatch pvbTemp : tempList) { // breaking quantity by batch for given base uom quantity.
                        double qty = pvbTemp.getQuantity();
                        if (pvbTemp.getQuantity() == 0) { // considering batch which removed quantity. Because adding quantity from previously removed quantity.
                            continue;
                        }
                        if (qty > 0) {
                            for (TransactionBatch pvbMain : pvbList) {
                                double availQty = pvbMain.getQuantity() - pvbMain.getRemovedQty();
                                if (!pvbMain.isOutEntry() || availQty <= 0) {
                                    continue;
                                }
                                double retQty = 0;
                                if (qty >= availQty) {
                                    retQty = availQty;
                                } else {
                                    retQty = dquantity;
                                }
                                qty -= retQty;
                                pvbMain.setRemovedQty(pvbMain.getRemovedQty() + retQty);

                                if (qty <= 0) {
                                    break;
                                }
                            }
                        }
                    }
                    if ((dquantity > 0 && valuationMethod != ValuationMethod.AVERAGE) || (valuation == 0 && valuationMethod == ValuationMethod.AVERAGE)) { // if base uom quntity is more than DO quantity or for average valuation if total amount is zero then use product purchase price 
                        KwlReturnObject purchase = accProductObj.getProductPrice(prodID, true, null, "", "");
                        if (purchase.getEntityList().get(0) != null) {
                            double price = purchase.getEntityList().get(0) != null ? (Double) purchase.getEntityList().get(0) : 0;
                            if (valuationMethod == ValuationMethod.AVERAGE) {
                                TransactionBatch pbvTemp = new TransactionBatch(price, baseUomQuantity, false, tempList.size() + originalListSize, "", "");
                                tempList.add(pbvTemp);
                                valuation += price * baseUomQuantity;
                            } else {
                                TransactionBatch pbvTemp = new TransactionBatch(price, dquantity, false, tempList.size() + originalListSize, "", "");
                                tempList.add(pbvTemp);
                                valuation += price * dquantity;
                            }
                        }
                    } else if (dquantity > 0 && valuationMethod == ValuationMethod.AVERAGE) { // if base uom qty is more than DO quantity for average valuation then remaining quantity should be as same average price 
                        double price = valuation / (baseUomQuantity - dquantity);
                        TransactionBatch pbvTemp = new TransactionBatch(price, dquantity, false, tempList.size() + originalListSize, "", "");
                        tempList.add(pbvTemp);
                        valuation += dquantity * price;
                    }
                }
            }

            if (!tempList.isEmpty()) {
                pvbList.addAll(tempList);
            }
            priceValuationMap.put(prodID, pvbList);
        } catch (Exception ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.INFO, ex.getMessage());
        }
        return valuation;
    }

    @Override
    public String getBatchSerialIDs(String batchJSON, Product product, Map<String, Double> batchQuantityMap) {
        String batchSerialIds = "";
        StringBuilder builder = new StringBuilder();
        try {
            JSONArray jArr = new JSONArray(batchJSON);
            if (jArr != null && jArr.length() > 0) {
                for (int i = 0; i < jArr.length(); i++) {
                    JSONObject jsonObject = jArr.getJSONObject(i);
                    if (product.isIsSerialForProduct() && !jsonObject.optString("purchaseserialid", "").equals("")) {
                        builder.append(jsonObject.getString("purchaseserialid")).append(",");
                        batchQuantityMap.put(jsonObject.getString("purchaseserialid"), jsonObject.optDouble("quantity", 0.0));
                    } else if (product.isIsBatchForProduct() && !jsonObject.optString("purchasebatchid", "").equals("")) {
                        builder.append(jsonObject.getString("purchasebatchid")).append(",");
                        batchQuantityMap.put(jsonObject.getString("purchasebatchid"), jsonObject.optDouble("quantity", 0.0));
                    }
                }
                if (builder.length() > 0) {
                    batchSerialIds = builder.substring(0, builder.length() - 1);
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.INFO, ex.getMessage());
        }
        return batchSerialIds.toString();
    }
    
    @Override
    public String getBatchSerialIDsForAutofillBatchSerial(String batchJSON, Product product, Map<String, Double> batchQuantityMap) {
        String batchSerialIds = "";
        StringBuilder builder = new StringBuilder();
        try {
            JSONArray jArr = new JSONArray(batchJSON);
            if (jArr != null && jArr.length() > 0) {
                for (int i = 0; i < jArr.length(); i++) {
                    JSONObject jsonObject = jArr.getJSONObject(i);
                    if (jsonObject.has("serialDetails") && !StringUtil.isNullOrEmpty(jsonObject.getString("serialDetails"))) {
                        JSONArray serialArray = new JSONArray(jsonObject.getString("serialDetails"));
                        for (int count = 0; count < serialArray.length(); count++) {
                            JSONObject serialObj = serialArray.getJSONObject(count);
                            if (product.isIsSerialForProduct() && !serialObj.optString("purchaseserialid").equals("")) {
                                builder.append(serialObj.optString("purchaseserialid")).append(",");
                                batchQuantityMap.put(serialObj.optString("purchaseserialid"), serialObj.optDouble("quantity", 0.0) );
                            } else if (product.isIsBatchForProduct() && !serialObj.optString("purchasebatchid").equals("")) {
                                builder.append(serialObj.optString("purchasebatchid")).append(",");
                                batchQuantityMap.put(serialObj.optString("purchasebatchid"), serialObj.optDouble("quantity", 0.0));
                                
                            }
                        }
                    }
                    
                }
                if (builder.length() > 0) {
                    batchSerialIds = builder.substring(0, builder.length() - 1);
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.INFO, ex.getMessage());
        }
        return batchSerialIds.toString();
    }
    
    /*
     Below method is used to save Delivery Order.
     */

  @Override  
     public JSONObject saveDeliveryOrderJSON(JSONObject paramJobj) {
        String billno = "";
        String billid = "";
        String channelName = "";
        String msg = "";
        String butPendingForApproval = "";
        String entryNumber = "";
        String companyid = "";
        boolean issuccess = false;
        boolean accexception = false;
        boolean isEdit = false;
        boolean isCopy = false;
        boolean isLeaseFixedAsset = false;
        boolean isConsignment = false;
        boolean isFixedAsset = false;
        boolean isTaxDeactivated = false;
        int approvalStatusLevel = 11;
        KwlReturnObject result = null;
        /*
         * isImportSequenceFormat is true while importing DO with entry no is belongs in sequence format. 
         */
        boolean isImportSequenceFormat = false;
        JSONObject jobj = new JSONObject();
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("SO_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = null;//txnManager.getTransaction(def);

        try {
            isEdit = StringUtil.isNullOrEmpty(paramJobj.optString("isEdit", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isEdit"));
            isCopy = StringUtil.isNullOrEmpty(paramJobj.optString("copyInv", null)) ? false : Boolean.parseBoolean(paramJobj.getString("copyInv"));
            isLeaseFixedAsset = StringUtil.isNullOrEmpty(paramJobj.optString("isLeaseFixedAsset", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isLeaseFixedAsset"));
            isFixedAsset = StringUtil.isNullOrEmpty(paramJobj.optString("isFixedAsset", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isFixedAsset"));            
            isConsignment = StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment, null)) ? false : Boolean.parseBoolean(paramJobj.getString(Constants.isConsignment));
            isConsignment = StringUtil.isNullOrEmpty(paramJobj.optString("isConsignment", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isConsignment"));
            isImportSequenceFormat = StringUtil.isNullOrEmpty(paramJobj.optString("isImportSequenceFormat", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isImportSequenceFormat"));
            boolean isEditedPendingDocument = StringUtil.isNullOrEmpty(paramJobj.optString("isEditedPendingDocument",null)) ? false : Boolean.parseBoolean(paramJobj.optString("isEditedPendingDocument"));
            
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                entryNumber = paramJobj.optString("numberDo", null) != null ? paramJobj.getString("numberDo") : paramJobj.optString("deliveryOrderNo");
            } else {
                entryNumber = paramJobj.optString("numberDo", null) != null ? paramJobj.getString("numberDo") : paramJobj.optString("number");
            }
            
            companyid = paramJobj.getString(Constants.companyKey);
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0);
            String doid = paramJobj.optString("doid");
            String fromLinkCombo = paramJobj.optString("fromLinkCombo") != null ? paramJobj.optString("fromLinkCombo") : "";
            String invoiceid = "";
            String sequenceformat = paramJobj.optString("sequenceformat");
            int DOSeqNum = paramJobj.optString("DOSeqNum", null) != null ? Integer.parseInt(paramJobj.getString("DOSeqNum")) : 0;
            if(paramJobj.has("invoice")){
                invoiceid=paramJobj.optString("invoice", null);
            }
            boolean sendForQAApproval = paramJobj.optBoolean("sendForQAApproval", false);
            
            if (!StringUtil.isNullOrEmpty(doid)) {
                result = accInvoiceDAOobj.getDODuplicateNumberWithID(entryNumber, companyid, doid);
                if (result.getRecordTotalCount() > 0 && sequenceformat.equals("NA")) {
                    accexception = true;
                    throw new AccountingException(messageSource.getMessage("acc.DO.deliveryorderno", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyexists.", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
            } else {
                result = accInvoiceDAOobj.getDeliveryOrderCount(entryNumber, companyid);
                if (result.getRecordTotalCount() > 0 && sequenceformat.equals("NA")) {
                    accexception = true;
                    throw new AccountingException(messageSource.getMessage("acc.DO.deliveryorderno", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyexists.", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
                                
                //Check Deactivate Tax in New Transaction.
                if (!fieldDataManagercntrl.isTaxActivated(paramJobj)) {
                    isTaxDeactivated = true;
                    throw ServiceException.FAILURE(messageSource.getMessage("acc.tax.deactivated.tax.saveAlert", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))), "", false);
                }
            }
            
            if(isFixedAsset){
                DateFormat df = authHandler.getDateOnlyFormat();
                Date billDate = df.parse(paramJobj.optString(Constants.BillDate));
                int depreciationCalculationType = extraCompanyPreferences.getAssetDepreciationCalculationType();
                String invoiceDetails = paramJobj.optString(Constants.detail,"[]");
                JSONArray jArr = new JSONArray(invoiceDetails);
                for (int i = 0; i < jArr.length(); i++) {
                    JSONObject jobject = jArr.getJSONObject(i);
                    JSONArray assetArr = new JSONArray(jobject.getString("assetDetails"));
                    for (int assetCount = 0; assetCount < assetArr.length(); assetCount++) {
                        JSONObject assetJson = assetArr.getJSONObject(assetCount);
                        String assetDetailId = assetJson.getString("assetId");

                        KwlReturnObject accresult = accountingHandlerDAOobj.getObject(AssetDetails.class.getName(), assetDetailId);
                        AssetDetails ad = (AssetDetails) accresult.getEntityList().get(0);
                        
                        if(billDate.before(ad.getInstallationDate())){
                            throw new AccountingException(messageSource.getMessage("acc.msg.deliverydate.installationdate.alertmsg", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                        }

                        /*Below code is used to check if asset is already expired or not*/
                        boolean isExpire=false;
                        Date assetEndLifeDate=null;
                        List expireList=accProductObj.isAssetExpire(ad,billDate);
                        if(expireList!=null&& expireList.size()>0){
                            isExpire=(Boolean)expireList.get(0);
                        }
                        String backyears = "";
                        Calendar cal1 = Calendar.getInstance();
                        if (isExpire) {
                            long assetenddateinlong = (Long) expireList.get(1);
                            assetEndLifeDate = new Date(assetenddateinlong);
                            cal1.setTime(assetEndLifeDate);
                        } else {
                            cal1.setTime(billDate);
                            cal1.add(Calendar.DATE, -1);
                        }
                        int currentyear = cal1.get(Calendar.YEAR);
                        Calendar cal2 = Calendar.getInstance();
                        cal2.setTime(ad.getInstallationDate());
                        int creationyear1 = cal2.get(Calendar.YEAR);

                        boolean isAllDepreciated = true;
                        int periodDep = -1;

                        Calendar calInstallation = Calendar.getInstance();
                        calInstallation.setTime(ad.getInstallationDate());
                        long diffinlong = cal1.getTimeInMillis() - calInstallation.getTimeInMillis();
                        long enddateinlong = calInstallation.getTimeInMillis() + diffinlong;
                        Date endDate = new Date(enddateinlong);
                        Calendar calEndMonth = Calendar.getInstance();
                        calEndMonth.setTime(endDate);

                        while (creationyear1 <= currentyear) {
                            backyears += creationyear1 + ",";
                            creationyear1++;
                        }
                        
                        List<String> yearList = null;
                        if(!StringUtil.isNullOrEmpty(backyears)){
                            yearList = Arrays.asList(backyears.split("\\s*,\\s*"));
                            Collections.sort(yearList);
                            int yeardiffDep=0,k=0;
                            for (yeardiffDep = 0, k = 0; k < yearList.size(); k++, yeardiffDep++) {
                                int startMonth1=0;
                                int endMonth1=11;
                                int year1 = Integer.parseInt(yearList.get(k)); //Back Years
                                int creationyear = cal2.get(Calendar.YEAR);           //Installation Year
                                yeardiffDep = year1 - creationyear;
                                if (creationyear == currentyear) {    // if (installation year==disposal year) then start month=installation date month && End Month=disposal year month 
                                    startMonth1 = cal2.get(Calendar.MONTH);
                                    endMonth1 = cal1.get(Calendar.MONTH);
                                } else if (creationyear == year1) {           // if (installation year==backyear) then start month=installation date month && End Month=11
                                    startMonth1 = cal2.get(Calendar.MONTH);
                                } else if (currentyear == year1) {        // if (disposal year==backyear year) then start month=0 && End Month=disposal year mont
                                    endMonth1 = cal1.get(Calendar.MONTH);
                                }

                                if (depreciationCalculationType == 0) {
                                    if(yeardiffDep!=0){
                                        yeardiffDep =- 1;
                                    }
                                    startMonth1=0;
                                    endMonth1=yearList.size()-1;
                                }

                                for (int cnt = startMonth1; cnt <=endMonth1; cnt++) {
                                    if (depreciationCalculationType == 0) {
                                        if (yeardiffDep < 0) {  //if selected year is less than the cretion year then there will be no depreciation to show
                                            continue;
                                        }
                                        periodDep = yeardiffDep + 1;
                                    } else {
                                        periodDep = (12 * yeardiffDep) + cnt + 1;
                                        periodDep = calInstallation.get(Calendar.MONTH) != 0 ? periodDep - calInstallation.get(Calendar.MONTH) : periodDep;
                                    }

                                    HashMap<String, Object> filters = new HashMap<String, Object>();
                                    filters.put("period", periodDep);
                                    filters.put("assetDetailsId", ad.getId());
                                    filters.put("companyid", companyid);
                                    filters.put("assetDetails", true);
                                    KwlReturnObject dresult = accProductObj.getAssetDepreciationDetail(filters);
                                    if (dresult.getEntityList().isEmpty()) {
                                        isAllDepreciated = false;
                                        throw new AccountingException(messageSource.getMessage("acc.msg.depreciationnotposteduptodeliveryorderdate", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                                    }
                                }
                            }
                        }
                    }
                }
            }

            synchronized (this) {
                status = txnManager.getTransaction(def);
                if (sequenceformat.equals("NA")) {
                    KwlReturnObject resultInv = accCommonTablesDAO.getTransactionInTemp(entryNumber, companyid, Constants.Acc_Delivery_Order_ModuleId);
                    if (resultInv.getRecordTotalCount() > 0) {
                        accexception = true;
                        throw new AccountingException(messageSource.getMessage("acc.DO.selecteddeliveryorderno", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyinprocess.", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    } else {
                        accCommonTablesDAO.insertTransactionInTemp(entryNumber, companyid, Constants.Acc_Delivery_Order_ModuleId);
                    }
                }
                txnManager.commit(status);
            }
            status = txnManager.getTransaction(def);
            List doList = saveDeliveryOrder(paramJobj, invoiceid);
            List mailParams = (List) doList.get(3);
            DeliveryOrder deliveryOrder = (DeliveryOrder) doList.get(0);
            String additionalsauditmessage = "";
            /**
             * Get DeliveryOrder JE Number as it is required to display in prompt while saving 
             * DeliveryOrder document.
             */
            String doNumber = "";
            if(deliveryOrder.getInventoryJE()!=null){
                doNumber = ((JournalEntry)deliveryOrder.getInventoryJE()).getEntryNumber();
            }
            billid = deliveryOrder.getID();
            billno = deliveryOrder.getDeliveryOrderNumber();
            if (doList.get(1) != null) {//fields updated
                additionalsauditmessage = doList.get(1).toString();
            }
            if (deliveryOrder.getBillingShippingAddresses() != null) {
                String fullShippingAddress = deliveryOrder.getBillingShippingAddresses().getFullShippingAddress();
                jobj.put("fullShippingAddress", fullShippingAddress);
            }
            Set<DeliveryOrderDetail> doRows = deliveryOrder.getRows();
            double totalAmount = 0;
            double quantity = 0;
            if (doRows != null && !doRows.isEmpty()) {
                for (DeliveryOrderDetail cnt : doRows) {
                    quantity = cnt.getInventory().getQuantity();
                    totalAmount += cnt.getRate() * quantity;
                }
            }
            issuccess = true;
            if (doList.get(2) != null) {//Approval Status Level
                approvalStatusLevel = Integer.parseInt(doList.get(2).toString());
            }
            if (!(deliveryOrder.isFixedAssetDO() || deliveryOrder.isLeaseDO() || deliveryOrder.isIsconsignment())) {// if this is a lease or fixed asset DO or consignment Dothen it will not go for approval
                if (approvalStatusLevel != 11 || extraCompanyPreferences.isPickpackship()) {
                    Iterator doDetailsItr = doRows.iterator();
                    if(extraCompanyPreferences != null && extraCompanyPreferences.isActivateInventoryTab()){
                            stockMovementService.removeStockMovementByReferenceId(deliveryOrder.getCompany(), deliveryOrder.getID());
                    }
                    while (doDetailsItr.hasNext()) {
                        DeliveryOrderDetail doDetail = (DeliveryOrderDetail) doDetailsItr.next();
                        Inventory inventory = doDetail.getInventory();
                        if (inventory.isInvrecord()) {
                            inventory.setActquantity(inventory.getBaseuomquantity());
                            inventory.getProduct().setAvailableQuantity(inventory.getProduct().getAvailableQuantity() + inventory.getBaseuomquantity());
                            inventory.setBaseuomquantity(0.0);

                        }
                    }
                }
            }
            /*
             * post separate JE for Frewe Gift type DOs 
             */
            if((Integer.parseInt(deliveryOrder.getCompany().getCountry().getID()) == Constants.malaysian_country_id)){
                paramJobj.put("approvalStatusLevel", approvalStatusLevel) ;
                postJEForFreeGiftDo(paramJobj,deliveryOrder);
            }
            
            //Get mapping details id of invoice documents
            String savedFilesMappingId = paramJobj.optString("savedFilesMappingId", "");
            if(!StringUtil.isNullOrEmpty(savedFilesMappingId)){
                /**
                * Save temporary saved attachment files mapping in permanent table
                */
                JSONObject jsonObj = new JSONObject();
                jsonObj.put("savedFilesMappingId", savedFilesMappingId);
                jsonObj.put("docId", billid);
                jsonObj.put("companyid", companyid);
                accSalesOrderServiceobj.saveDocuments(jsonObj);
            }
            txnManager.commit(status);
            status = null;
            TransactionStatus AutoNoStatus = null;
            try {
                synchronized (this) {
                    DefaultTransactionDefinition def1 = new DefaultTransactionDefinition();
                    def1.setName("AutoNum_Tx");
                    def1.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
                    AutoNoStatus = txnManager.getTransaction(def1);

                    if (((isCopy) ? true : !isEdit) && (!StringUtil.isNullOrEmpty(sequenceformat) && !sequenceformat.equals("NA"))&&!isImportSequenceFormat) {
                        String nextAutoNumber = "";
                        boolean seqformat_oldflag = false;//    old flag was used when sequence format not implemented.
                        Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                        if (seqformat_oldflag) {
                            nextAutoNumber = accCompanyPreferencesObj.getNextAutoNumber(companyid, StaticValues.AUTONUM_DELIVERYORDER, sequenceformat);
                            seqNumberMap.put(Constants.AUTO_ENTRYNUMBER, nextAutoNumber);
                        } else {
                            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_DELIVERYORDER, sequenceformat, seqformat_oldflag, deliveryOrder.getOrderDate());
                            if (DOSeqNum != 0) {
                                seqNumberMap.put(Constants.SEQNUMBER, DOSeqNum);
                            }
                        }
                        seqNumberMap.put(Constants.DOCUMENTID, billid);
                        seqNumberMap.put(Constants.companyKey, companyid);
                        seqNumberMap.put(Constants.SEQUENCEFORMATID, sequenceformat);
                        billno = accInvoiceDAOobj.updateDOEntryNumberForNewDO(seqNumberMap);
                        if (sendForQAApproval) {
                            String memo = "IST created for QC against DO:" + billno;
                            accInvoiceDAOobj.updateMemoForIST(memo, billid, companyid);
                        }else if(extraCompanyPreferences.isPickpackship() && !sendForQAApproval){
                            String memo = Constants.pickPack_DO_IST_Memo + billno;
                            accInvoiceDAOobj.updateMemoForPickPackDOIST(memo, billid, companyid);
                        }
                    }
                    txnManager.commit(AutoNoStatus);

                }

                if (mailParams != null && !mailParams.isEmpty()) {
                    String createdby = paramJobj.optString(Constants.useridKey);
                    Iterator itr = mailParams.iterator();
                    /**
                     * parameters required for sending mail
                     */
                    Map<String, Object> mailParameteres = new HashMap();
                    mailParameteres.put(Constants.companyid, companyid);
                    mailParameteres.put(Constants.prNumber, billno);
                    mailParameteres.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                    mailParameteres.put(Constants.isCash, false);
                    mailParameteres.put(Constants.createdBy, createdby);
                    mailParameteres.put(Constants.PAGE_URL, paramJobj.optString(Constants.PAGE_URL));
                    if(deliveryOrder.getApprovestatuslevel()< 11){
                    mailParameteres.put("level",deliveryOrder.getApprovestatuslevel());
                    }

                    while (itr.hasNext()) {
                        HashMap<String, Object> paramsMap = (HashMap<String, Object>) itr.next();

                        mailParameteres.put(Constants.ruleid, (String) paramsMap.get("ruleid"));
                        mailParameteres.put(Constants.fromName, (String) paramsMap.get("fromName"));
                        mailParameteres.put(Constants.hasApprover, (Boolean) paramsMap.get("hasApprover"));
                        sendMailToApprover(mailParameteres);
                        
                    }

                }
            } catch (Exception ex) {
                if (AutoNoStatus != null) {
                    txnManager.rollback(AutoNoStatus);
                }
                accCommonTablesDAO.deleteTransactionInTemp(entryNumber, companyid, Constants.Acc_Delivery_Order_ModuleId);
            }

            // For updating delivery planner entry
            if (!isEdit && !StringUtil.isNullOrEmpty(fromLinkCombo) && !StringUtil.isNullOrEmpty(paramJobj.optString("linkNumber"))) {
                Map<String, Object> requestParams = new HashMap<>();
                requestParams.put("fromLinkCombo", fromLinkCombo);
                requestParams.put("linkNumber", paramJobj.optString("linkNumber"));
                requestParams.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                requestParams.put("userid", paramJobj.getString(Constants.useridKey));
                requestParams.put("docid", deliveryOrder.getID());
                updateDeliveryPlannerEntry(requestParams);
            }

            String actionMsg = "added new";
            if (isEdit == true && isCopy == false) {
                actionMsg = "updated";
            }
            if (isLeaseFixedAsset) {
                actionMsg += " Lease";
            }
            String auditSMS = "";

            //message construction
            if (isConsignment) {
                msg = messageSource.getMessage("acc.consignment.DO.save", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)));
            } else {
                msg = messageSource.getMessage("acc.do.save", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)));
            }
            if (approvalStatusLevel != 11) {
                butPendingForApproval = " " + messageSource.getMessage("acc.field.butpendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)));
                msg = msg.substring(0, msg.length() - 1);
            }
            
            /* 
             If we Edit pending document &
             "Send Pending Document to Next Level" is activated
             then pending message should not be appended in main message
             So it should be blank
             */
            boolean sendPendingDocumentsToNextLevel = false;
            if (isEditedPendingDocument) {
                sendPendingDocumentsToNextLevel = doList.get(8) != null ? (Boolean) doList.get(8) : false;
                if (sendPendingDocumentsToNextLevel) {
                    butPendingForApproval = "";
                }
            }
            
            if (isConsignment) {
                msg += butPendingForApproval + "<br/>" + messageSource.getMessage("acc.field.DocumentNo", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + billno + "</b>";   //" consignment Delivery order has been saved successfully";
            } else {
                msg += butPendingForApproval + "<br/>" + messageSource.getMessage("acc.field.DocumentNo", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + billno + "</b>";   //"Delivery order has been saved successfully";
            }
            /**
             * Display Information to user in prompt about JE posted for this 
             * current transaction.
             */
            if(!StringUtil.isNullOrEmpty(doNumber)){
                msg += approvalStatusLevel != 11 ? " " :", " + messageSource.getMessage("acc.field.JENo", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + doNumber + "</b>";
            }
            String modulename = "";
            if (isConsignment) {
                modulename = " Consignment Delivery Order ";
            } else if (isFixedAsset) {
                modulename = " "+Constants.Asset_Delivery_Order+" ";
            } else {
                modulename = " Delivery Order ";
            }
            /* Preparing Audit trial message if document is linking at teh time of creating */
            String linkedDocuments = (String) doList.get(4);
            String linkingMessages = "";
            if (!StringUtil.isNullOrEmpty(linkedDocuments) && !StringUtil.isNullOrEmpty(fromLinkCombo)) {
                if (isFixedAsset) {
                    linkingMessages = " by Linking to " + fromLinkCombo + " " + linkedDocuments;
                    if (fromLinkCombo.equalsIgnoreCase("Sales Invoice")) {
                        linkingMessages = " by Linking to " + Constants.DISPOSAL_INVOICE + " " + linkedDocuments;
                    }
                } else {
                    linkingMessages = " by Linking to " + fromLinkCombo + " " + linkedDocuments;
                }
            }
            auditSMS = " has " + actionMsg + modulename + billno + linkingMessages + (approvalStatusLevel != 11 ? " " + messageSource.getMessage("acc.field.whichispendingforApproval", null, null) : "") + additionalsauditmessage;
            DocumentEmailSettings documentEmailSettings = null;
            KwlReturnObject documentEmailresult = accountingHandlerDAOobj.getObject(DocumentEmailSettings.class.getName(), companyid);
            documentEmailSettings = documentEmailresult != null ? (DocumentEmailSettings) documentEmailresult.getEntityList().get(0) : null;
            if (documentEmailSettings != null && documentEmailSettings.isQtyBelowReorderLevelMail()) {     //send mail when item qty goes below than reorder level
                sendReorderLevelEmails(paramJobj.optString(Constants.useridKey), deliveryOrder);
            }

            /* Updating entry in Audit Trial while unlinking transaction through Editing*/
            Map<String, Object> auditRequestParams = new HashMap<>();
            auditRequestParams.put(Constants.reqHeader, paramJobj.getString(Constants.reqHeader));
            auditRequestParams.put(Constants.remoteIPAddress, paramJobj.getString(Constants.remoteIPAddress));
            auditRequestParams.put(Constants.useridKey, paramJobj.getString(Constants.useridKey));
            String unlinkMessage = (String) doList.get(5);
            if (!StringUtil.isNullOrEmpty(unlinkMessage)) {
                auditTrailObj.insertAuditLog(AuditAction.DELIVERY_ORDER, "User " + paramJobj.optString(Constants.userfullname) + " has unlinked " + "Delivery Order(s) " + billno + unlinkMessage + ".", auditRequestParams, billno);
            }
            auditTrailObj.insertAuditLog(AuditAction.DELIVERY_ORDER, "User " + paramJobj.optString(Constants.userfullname) + auditSMS, auditRequestParams, deliveryOrder.getID());

            if (deliveryOrder.isFixedAssetDO() && !(deliveryOrder.isIsconsignment())) {
                channelName = "/FixedAssetDeliveryList/gridAutoRefresh";
            } else if (deliveryOrder.isLeaseDO() && !(deliveryOrder.isIsconsignment())) {
                channelName = "/LeaseDeliveryOrderReport/gridAutoRefresh";
            } else if (!(deliveryOrder.isFixedAssetDO() || deliveryOrder.isLeaseDO() || deliveryOrder.isIsconsignment())) {
                channelName = "/DeliveryOrderReport/gridAutoRefresh";
            }
                        
            
            /*------Code if we edit pending document---------  */
            if (isEditedPendingDocument) {

                String roleName = doList.get(6) != null ? (String) doList.get(6) : "";
                boolean isAuthorityToApprove = doList.get(7) != null ? (Boolean) doList.get(7) : false;
                //boolean sendPendingDocumentsToNextLevel = doList.get(8) != null ? (Boolean) doList.get(8) : false;
                int levelOnWhichDocumentIsApproved = doList.get(9) != null ? (Integer) doList.get(9) : 0;

                msg += "<br>";
                /*-------If check "Send pending documents to next level" is activated from system preferences---------  */
                if (sendPendingDocumentsToNextLevel) {

                    if (roleName != "" && isAuthorityToApprove) {

                        auditTrailObj.insertAuditLog(AuditAction.DELIVERY_ORDER, "User " + paramJobj.optString(Constants.userfullname) + " has Approved a Delivery Order " + deliveryOrder.getDeliveryOrderNumber() + " at Level-" + deliveryOrder.getApprovestatuslevel(), auditRequestParams, deliveryOrder.getID());

                        msg += messageSource.getMessage("acc.field.DeliveryOrderhasbeenapprovedsuccessfully", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " by " + roleName + " " + paramJobj.optString(Constants.userfullname) + " at Level " + levelOnWhichDocumentIsApproved + ".";

                    } else if (!isAuthorityToApprove) {//If User have no authority to approve the document
                        msg = messageSource.getMessage("acc.msgbox.YouarenotauthorizedtoapprovethisrecordatLevel", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + levelOnWhichDocumentIsApproved + ".";
                    }
                } else if (!isAuthorityToApprove) {//If user have no authority to approve document
                    msg += messageSource.getMessage("acc.msgbox.YouarenotauthorizedtoapprovethisrecordatLevel", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + levelOnWhichDocumentIsApproved + " and record will be available at this level for approval" + ".";
                }

            }
            
            
            status = txnManager.getTransaction(def);
            accCommonTablesDAO.deleteTransactionInTemp(entryNumber, companyid, Constants.Acc_Delivery_Order_ModuleId);
            String[] linkNumbers = paramJobj.optString("linkNumber").split(",");
            for (int i = 0; i < linkNumbers.length; i++) {
                if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                    accCommonTablesDAO.deleteTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                }
            }
            txnManager.commit(status);
        } catch (AccountingException ex) {
           if(isFixedAsset){
              accexception = true;
            }  
            if (status != null) {
                txnManager.rollback(status);
            }
            try {
                accCommonTablesDAO.deleteTransactionInTemp(entryNumber, companyid, Constants.Acc_Delivery_Order_ModuleId);
                String[] linkNumbers = paramJobj.optString("linkNumber").split(",");
                for (int i = 0; i < linkNumbers.length; i++) {
                    if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                        accCommonTablesDAO.deleteTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                    }
                }
            } catch (ServiceException ex1) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex1);
            }
            msg = "" + ex.getMessage();
            if (ex.getMessage() == null) {
                msg = ex.getCause().getMessage();
            }
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            if (status != null) {
                txnManager.rollback(status);
            }
            try {
                accCommonTablesDAO.deleteTransactionInTemp(entryNumber, companyid, Constants.Acc_Delivery_Order_ModuleId);
                String[] linkNumbers = paramJobj.optString("linkNumber").split(",");
                for (int i = 0; i < linkNumbers.length; i++) {
                    if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                        accCommonTablesDAO.deleteTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                    }
                }
            } catch (ServiceException ex1) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex1);
            }
            msg = "" + ex.getMessage();
            if (ex.getMessage() == null) {
                msg = ex.getCause().getMessage();
            }
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
                jobj.put(Constants.billid, billid);
                jobj.put("billno", billno);
                jobj.put("accException", accexception);
                jobj.put("pendingApproval", approvalStatusLevel != 11);
                jobj.put(Constants.channelName, channelName);
                jobj.put(Constants.isTaxDeactivated, isTaxDeactivated);

            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        return jobj;

    }

    public void postJEForFreeGiftDo(JSONObject parameters, DeliveryOrder DO) throws AccountingException {
        try {
            String companyId = DO.getCompany().getCompanyID();
            if (DO.getFreeGiftJE() != null) {
                JournalEntry freeGiftJE = DO.getFreeGiftJE();
                accInvoiceDAOobj.deleteDeliveryOrdersFreeGiftJEMapping(DO.getID(), companyId);
                deleteJEArray(freeGiftJE.getID(), companyId);
            }

            int approvalStatusLevel = parameters.optInt("approvalStatusLevel", 0);
            /*
             * If DO is at approved state, then only post JE
             */ 
            if (approvalStatusLevel == Constants.INVOICEAPPROVED && DO.isIsFreeGift()) {
                Map<String, Object> requestParams = new HashMap<String, Object>();
                requestParams.put("companyId", companyId);
                requestParams.put("customerId", DO.getCustomer().getID());
                KwlReturnObject companyPrefResult = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyId);
                /*
                 * Getting the first day of financial year in which DO date falls.
                 */
                CompanyAccountPreferences pref = (CompanyAccountPreferences) companyPrefResult.getEntityList().get(0);
                Date firstFinancialDate = pref.getFinancialYearFrom();
                
                Date DoDate = DO.getOrderDate();
                Calendar cal = Calendar.getInstance();
                Calendar cal1 = Calendar.getInstance();
                cal1.setTime(firstFinancialDate);
                cal.setTime(DoDate);
                cal.set(Calendar.DATE,cal1.get(Calendar.DATE));
                cal.set(Calendar.MONTH,cal1.get(Calendar.MONTH));
                /*
                 * Check existing free gift DO for current financial year.
                 */ 
                requestParams.put("lowerLimitDate", cal.getTime());
                
                // Getting date of the day exactly after 1 year - i.e. last day of financial year
                cal.add(Calendar.YEAR, 1);
                cal.add(Calendar.DATE, -1);
                requestParams.put("upperLimitDate", cal.getTime());
                Map<String, Object> currencyParameters = new HashMap<>();
                currencyParameters.put("companyid", companyId);
                currencyParameters.put("gcurrencyid", parameters.optString("gcurrencyid"));
                KwlReturnObject result = accInvoiceDAOobj.checkForExistingFreeGiftJEs(requestParams);
                if (result.getEntityList() != null && !result.getEntityList().isEmpty()) {
                    if (result.getEntityList().get(0) != null) {
                        double totalAmtInBase = (Double) result.getEntityList().get(0);
                        /*
                         * Here totalAmtInBase is amount of free gift DO in current financial year.
                         * DO.getTotalamountinbase() is subtracted from totalAmtInBase because DO which is being saved is also considered as saved
                         * and being considered for calculation.
                         */ 
                        totalAmtInBase -= DO.getTotalamountinbase();
                        double amtForJE = 0;
                        
                        /*
                         * If atleast one JE is already posted in system, new JE will be posted only for current DO amount
                         * Else, JE will be posted for amount -> (existing DO amount + this transaction amount)
                         * Formula will be -> (amount*6)/106
                         */ 
                                
                        if (totalAmtInBase > Constants.FreeGiftDOMaxLimit) {  
                            double totalAmtForDo = DO.getTotalamount();
                            amtForJE = (totalAmtForDo * Constants.FreeGiftPercentageFigure) / (100 + Constants.FreeGiftPercentageFigure);
                            amtForJE = authHandler.round(amtForJE, companyId);
                        } else {
                            double totalAmtInBaseForDo = DO.getTotalamountinbase();
                            if (totalAmtInBaseForDo + totalAmtInBase > Constants.FreeGiftDOMaxLimit) {
                                amtForJE = ((totalAmtInBaseForDo + totalAmtInBase) * Constants.FreeGiftPercentageFigure) / (100 + Constants.FreeGiftPercentageFigure);
                                /*
                                 * If DO currency is MYR then no need to convert the amount in MYR again
                                 */ 
                                if(!DO.getCurrency().getCurrencyID().equals(Constants.RMID)){
                                    KwlReturnObject myrResult = accCurrencyDAOobj.getBaseToCurrencyAmount(currencyParameters, amtForJE, DO.getCurrency().getCurrencyID(), DO.getOrderDate(), DO.getExternalCurrencyRate());
                                    amtForJE = (Double) myrResult.getEntityList().get(0);
                                    amtForJE = authHandler.round(amtForJE, companyId);
                                }
                            }
                        }
                        if (amtForJE != 0) {
                            String gstOutputAccountId = "";
                            KwlReturnObject accountReturnObject = accAccountDAOobj.getAccountFromName(companyId, Constants.MALAYSIAN_GST_OUTPUT_TAX);
                            List accountResultList = accountReturnObject.getEntityList();
                            if (!accountResultList.isEmpty()) {
                                gstOutputAccountId = ((Account) accountResultList.get(0)).getID();
                            }
                            if (gstOutputAccountId.equals("")) {
                                accountReturnObject = accAccountDAOobj.getAccountFromName(companyId, Constants.MALAYSIAN_GST_OUTPUT_TAX_OPTIONAL);
                                accountResultList = accountReturnObject.getEntityList();
                                if (!accountResultList.isEmpty()&&accountResultList!=null) {
                                    gstOutputAccountId = ((Account) accountResultList.get(0)).getID();
                                }
                            }
                            KwlReturnObject prefResult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyId);
                            ExtraCompanyPreferences preferences = (ExtraCompanyPreferences) prefResult.getEntityList().get(0);
                            String accountForFreeGiftJE = preferences.getFreeGiftJEAccount();
                            Map<String, Object> jeDataMap = AccountingManager.getGlobalParamsJson(parameters);
                            String jeentryNumber = "";
                            String jeIntegerPart = "";
                            String jeDatePrefix = "";
                            String jeDateAfterPrefix = "";
                            String jeDateSuffix = "";
                            String jeSeqFormatId = "";
                            boolean jeautogenflag = true;
                            synchronized (this) {
                                HashMap<String, Object> JEFormatParams = new HashMap<String, Object>();
                                JEFormatParams.put("moduleid", Constants.Acc_GENERAL_LEDGER_ModuleId);
                                JEFormatParams.put("modulename", "autojournalentry");
                                JEFormatParams.put("companyid", DO.getCompany().getCompanyID());
                                JEFormatParams.put("isdefaultFormat", true);

                                KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                                SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
                                Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                                seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyId, StaticValues.AUTONUM_JOURNALENTRY, format.getID(), false, DO.getOrderDate());
                                jeentryNumber = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                                jeIntegerPart = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                                jeDatePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                                jeDateAfterPrefix = (String) seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                                jeDateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                                jeSeqFormatId = format.getID();
                                jeDataMap.put("entrynumber", jeentryNumber);
                                jeDataMap.put("autogenerated", jeautogenflag);
                            }
                            jeDataMap.put(Constants.SEQFORMAT, jeSeqFormatId);
                            jeDataMap.put(Constants.SEQNUMBER, jeIntegerPart);
                            jeDataMap.put(Constants.DATEPREFIX, jeDatePrefix);
                            jeDataMap.put(Constants.DATEAFTERPREFIX, jeDateAfterPrefix);
                            jeDataMap.put(Constants.DATESUFFIX, jeDateSuffix);
                            jeDataMap.put("entrydate", DO.getOrderDate());
                            jeDataMap.put("companyid", companyId);
                            jeDataMap.put("memo", "");
                            jeDataMap.put("currencyid", DO.getCurrency().getCurrencyID());

                            KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Create Journal entry without JEdetails
                            JournalEntry journalEntry = (JournalEntry) jeresult.getEntityList().get(0);

                            journalEntry.setExternalCurrencyRate(DO.getExternalCurrencyRate());

                            Set<JournalEntryDetail> jeDetails = new HashSet<JournalEntryDetail>();
                            JournalEntryDetail jeDetail = null;
                            JSONObject jedjson = null;
                            KwlReturnObject jedresult = null;

                            jedjson = new JSONObject();
                            jedjson.put("srno", jeDetails.size() + 1);
                            jedjson.put("companyid", companyId);
                            jedjson.put("accountid", accountForFreeGiftJE);
                            jedjson.put("amount", amtForJE);
                            jedjson.put("debit", true);
                            jedjson.put("jeid", journalEntry.getID());
                            jedjson.put("description", "");
                            jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                            jeDetail = (JournalEntryDetail) jedresult.getEntityList().get(0);
                            jeDetails.add(jeDetail);

                            jedjson = new JSONObject();
                            jedjson.put("srno", jeDetails.size() + 1);
                            jedjson.put("companyid", companyId);
                            jedjson.put("accountid", gstOutputAccountId);
                            jedjson.put("amount", amtForJE);
                            jedjson.put("debit", false);
                            jedjson.put("jeid", journalEntry.getID());
                            jedjson.put("description", "");
                            jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                            jeDetail = (JournalEntryDetail) jedresult.getEntityList().get(0);
                            jeDetails.add(jeDetail);
                            journalEntry.setDetails(jeDetails);

                            journalEntry.setTransactionId(DO.getID());
                            journalEntry.setTransactionModuleid(Constants.Acc_Free_Gift_JE_ModuleId);
                            DO.setFreeGiftJE(journalEntry);
                            DO.setApprovestatuslevel(Constants.INVOICEAPPROVED);
                        }
                    }
                }
            }
        } catch (Exception ex) {
            throw new AccountingException(ex.getMessage());
        }
    }
    
    @Override
    public List saveDeliveryOrder(JSONObject paramJobj, String invoiceid) throws SessionExpiredException, ServiceException, AccountingException, JSONException, UnsupportedEncodingException {
        DeliveryOrder deliveryOrder = null;
        List newDOlist = new ArrayList();
        List mailParams = null;
        String unlinkMessage = "";
        String currencyid = null;
        boolean gstIncluded = false;
        String invoiceno = null;
        String entryNumber=null;
        
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("SO_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus tranStatus = null;//txnManager.getTransaction(def);
        try {
            
            /*Mobile Application*/
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                currencyid = paramJobj.optString(Constants.currencyName, null);
                invoiceno = paramJobj.optString("invoiceNumber", "");
                gstIncluded = (StringUtil.isNullOrEmpty(paramJobj.optString("gstIncluded", null))) ? false : Boolean.parseBoolean(paramJobj.getString("gstIncluded"));
                entryNumber = paramJobj.optString("deliveryOrderNo", null);
            } else {
                currencyid = (paramJobj.optString(Constants.currencyKey, null) == null ? paramJobj.getString(Constants.globalCurrencyKey) : paramJobj.getString(Constants.currencyKey));
                invoiceno = paramJobj.optString("number");
                /*Include GST DO SDP-4676*/
                gstIncluded = (!StringUtil.isNullOrEmpty(paramJobj.optString("includingGST", ""))) ? Boolean.parseBoolean(paramJobj.getString("includingGST")) : false;
                entryNumber = paramJobj.optString("numberDo", null) != null ? paramJobj.optString("numberDo") : paramJobj.optString("number");
            }
            
            String companyid = paramJobj.getString(Constants.companyKey);
            boolean sendForQAApproval = paramJobj.optBoolean("sendForQAApproval", false);
//            boolean seqformat_oldflag = StringUtil.getBoolean(paramJobj.optString("seqformat_oldflagDo", null) != null ? paramJobj.getString("seqformat_oldflagDo") : paramJobj.getString("seqformat_oldflag"));
            String costCenterId = paramJobj.optString("costcenter");
            String status = paramJobj.optString("statuscombo");
            String doid = paramJobj.optString("doid");
            int DOSeqNum = paramJobj.optString("DOSeqNum", null) != null ? Integer.parseInt(paramJobj.optString("DOSeqNum").toString()) : 0;
            int seqNumber = paramJobj.optString(Constants.SEQNUMBER, null) != null ? Integer.parseInt(paramJobj.optString(Constants.SEQNUMBER).toString()) : 0;
            String datePrefix = paramJobj.optString(Constants.DATEPREFIX, null) != null ? paramJobj.getString(Constants.DATEPREFIX).toString() : "";
            String dateSuffix = paramJobj.optString(Constants.DATESUFFIX, null) != null ? paramJobj.getString(Constants.DATESUFFIX).toString() : "";
            String sequenceformat = paramJobj.optString(Constants.sequenceformatDo, null) != null ? paramJobj.getString(Constants.sequenceformatDo) : paramJobj.getString("sequenceformat");
            boolean RCMApplicable = paramJobj.optBoolean("GTAApplicable",false);//ERP-34970(ERM-534)
            boolean EWAYApplicable = paramJobj.optBoolean("EWAYApplicable",false);
            String isfavourite = paramJobj.optString("isfavourite");
            boolean isFreeGift = StringUtil.isNullOrEmpty(paramJobj.optString("isFreeGift", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isFreeGift"));
            String customerporefno = "";
            String createdby = paramJobj.optString(Constants.useridKey);
            String modifiedby = paramJobj.optString(Constants.useridKey);
            long createdon = System.currentTimeMillis();
            long updatedon = System.currentTimeMillis();
            boolean isAutoCreateDO = false;
            boolean isnegativestockforlocwar = false;
            String nextAutoNumber = "";
            /*
             * isImportSequenceFormat is true while importing DO with entry no is belongs in sequence format. 
             */
            boolean isImportSequenceFormat = StringUtil.isNullOrEmpty(paramJobj.optString("isImportSequenceFormat", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isImportSequenceFormat"));
            boolean isFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isFixedAsset", null))) ? Boolean.parseBoolean(paramJobj.getString("isFixedAsset")) : false;
            boolean isLeaseFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isLeaseFixedAsset", null))) ? Boolean.parseBoolean(paramJobj.getString("isLeaseFixedAsset")) : false;
            boolean isConsignment = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment, null))) ? Boolean.parseBoolean(paramJobj.getString(Constants.isConsignment)) : false;
            boolean isJobWorkOutReciever = (!StringUtil.isNullOrEmpty(paramJobj.optString("isJobWorkOutReciever", null))) ? Boolean.parseBoolean(paramJobj.getString("isJobWorkOutReciever")) : false;
            boolean isEdit = StringUtil.isNullOrEmpty(paramJobj.optString("isEdit", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isEdit"));
            boolean isCopy = StringUtil.isNullOrEmpty(paramJobj.optString("copyInv", null)) ? false : Boolean.parseBoolean(paramJobj.getString("copyInv"));
            boolean isEditedPendingDocument = StringUtil.isNullOrEmpty(paramJobj.optString("isEditedPendingDocument")) ? false : Boolean.parseBoolean(paramJobj.optString("isEditedPendingDocument"));
            
            String custWarehouse = paramJobj.optString("custWarehouse");
            String movementtype = paramJobj.optString("movementtype");
            String driver = paramJobj.optString("driver", null) != null ? paramJobj.optString("driver") : "";
            List doDetailsReturnList = null;
            ExtraCompanyPreferences extraCompanyPreferences = null;
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            extraCompanyPreferences = (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0);
            isnegativestockforlocwar = extraCompanyPreferences.isIsnegativestockforlocwar();
            int countryid = 0;
            if(extraCompanyPreferences != null && extraCompanyPreferences.getCompany().getCountry() != null){
                countryid = Integer.parseInt(extraCompanyPreferences.getCompany().getCountry().getID());
            }
            
            /**
             * If Avalara Integration is enabled and tax calculation in Avalara Integration is enabled
             * then we make below method call which creates and adds tax details in requestJson
             * This is used when transaction is created by means other than UI; for example import, REST etc
             */
            if (extraCompanyPreferences != null && extraCompanyPreferences.isAvalaraIntegration()) {
                JSONObject paramsJobj = new JSONObject();
                paramsJobj.put(IntegrationConstants.integrationPartyIdKey, IntegrationConstants.integrationPartyId_AVALARA);
                paramsJobj.put(Constants.companyKey, companyid);
                if (integrationCommonService.isTaxCalculationEnabled(paramsJobj)) {
                    paramJobj = integrationCommonService.createAvalaraTaxDetails(paramJobj, Constants.Acc_Delivery_Order_ModuleId);
                }
            }
            
            HashMap<String, Object> doDataMap = new HashMap<String, Object>();
            Map<String, Object> olddo = new HashMap<String, Object>();
            Map<String, Object> auditKey = new HashMap<String, Object>();
            String auditMessage = "";
            isAutoCreateDO = paramJobj.optBoolean("isAutoCreateDO",false);//It is true when DO is genereted from invoice
            String deletedLinkedDocumentID = paramJobj.optString("deletedLinkedDocumentId");

            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            if (isAutoCreateDO) {
                if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                    customerporefno = paramJobj.optString("poRefNumber", null);
                } else {
                    customerporefno = (paramJobj.optString("porefno", null) == null ? "" : paramJobj.getString("porefno"));
                }
            } else {
                customerporefno = (paramJobj.optString("customerporefno", null) == null ? "" : paramJobj.getString("customerporefno"));
            }
            if (!isAutoCreateDO) {//No need to check SO linked with invoice or not while creating DO as auto DO from Invoice form.
                paramJobj.put("linkflag", 1);
                String msg = checkSOUsedFlag(paramJobj);
                if (!StringUtil.isNullOrEmpty(msg)) {//Check if SO is already used in Invoice or not.
                    throw new AccountingException(msg);
                }
            }

            if (sendForQAApproval) {
                if ((StringUtil.isNullOrEmpty(extraCompanyPreferences.getInspectionStore()) && StringUtil.isNullOrEmpty(extraCompanyPreferences.getRepairStore()))) {
                    throw new InventoryException(messageSource.getMessage("acc.companypreferences.qastore.repairstore.notset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                } else if ((StringUtil.isNullOrEmpty(extraCompanyPreferences.getInspectionStore()))) {
                    throw new InventoryException(messageSource.getMessage("acc.companypreferences.qastore.notset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                } else if (StringUtil.isNullOrEmpty(extraCompanyPreferences.getRepairStore())) {
                    throw new InventoryException(messageSource.getMessage("acc.companypreferences.repairstore.notset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
            }
            if (!StringUtil.isNullOrEmpty(doid) && !isAutoCreateDO) {
                KwlReturnObject doObj = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);
                DeliveryOrder deliveryOrder1 = (DeliveryOrder) doObj.getEntityList().get(0);
                // delete asset details 
                if (deliveryOrder1.isFixedAssetDO() || deliveryOrder1.isLeaseDO()) {
                    deleteAssetDetailsForDO(doid, companyid);
                }

                deleteDOContractMappings(doid, companyid);

                KwlReturnObject result = accInvoiceDAOobj.getDeliveryOrderInventory(doid);
//                KwlReturnObject resultBatch = accInvoiceDAOobj.getDeliveryOrderBatches(doid, companyid);

                HashMap<String, Object> requestParams = new HashMap<String, Object>();
                requestParams.put("doid", doid);
                requestParams.put(Constants.companyKey, companyid);
                requestParams.put(Constants.isConsignment, isConsignment);
                requestParams.put("isnegativestockforlocwar", isnegativestockforlocwar);
                // update the salesorder balance quantity if we edit and change the dos quantity
                accInvoiceDAOobj.updateSOBalanceQtyAfterDO(doid, "", companyid);

            
                accInvoiceDAOobj.deleteDeliveryOrdersBatchSerialDetails(requestParams); //dlete serial no and mapping
                stockMovementService.removeStockMovementByReferenceId(deliveryOrder1.getCompany(), doid);

                //Delete Delivery Order Details Term Map  While Update time ... 
                if (extraCompanyPreferences.getLineLevelTermFlag()==1) {
                    if (isEdit) {
                        KwlReturnObject venresult = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);
                        DeliveryOrder goodsReceiptOrder = (DeliveryOrder) venresult.getEntityList().get(0);
                        Set<DeliveryOrderDetail> groDetailsobj = goodsReceiptOrder.getRows();
                        if (extraCompanyPreferences.isAvalaraIntegration()) {//If Avalara Integration is enabled, then delete tax details from Avalara tax mapping table 'TransactionDetailAvalaraTaxMapping'
                            deleteAvalaraTaxMappingForDO(groDetailsobj);
                        } else {
                            for (DeliveryOrderDetail temObj : groDetailsobj) {
                                    accInvoiceDAOobj.deleteDODetailsTermMap(temObj.getID());
                            }
                        }
                    }
                }
                /**
                 *  During DO edit process we delete previous DO before updating the new hence similar case being done in pick pack ship DO as well
                 *  calling the pick pack ship delete function here.
                 */
                if (isEdit && extraCompanyPreferences.isPickpackship() && !isConsignment && !isFixedAsset && !isLeaseFixedAsset) {
                    requestParams.put("isEdit", isEdit);
                    boolean islinkedinso = false;
                    for (DeliveryOrderDetail dtl : deliveryOrder1.getRows()) {
                        if (dtl.getSodetails() != null) {
                            islinkedinso = true;
                            break;
                        }
                    }
                    requestParams.put("islinkedinso", islinkedinso);
                    accInvoiceDAOobj.deleteDOWithPickPackandShip(requestParams);
                }
                if (!StringUtil.isNullOrEmpty(doid)) {

                    Set<DeliveryOrderDetail> dods = deliveryOrder1.getRows();
                    for (DeliveryOrderDetail goodsReceiptOrderDetails : dods) {
                        JSONObject json = new JSONObject();
                        json.put("dodetailid", goodsReceiptOrderDetails.getID());
                        KwlReturnObject kwlReturnObject = stockService.getDODetailISTMapping(json);
                        List<DODQCISTMapping> dodISTMappings = kwlReturnObject.getEntityList();
                        for (DODQCISTMapping dodqcistm : dodISTMappings) {
                            /**
                             * Don't allow user to edit Delivery Order, if DO is
                             * approved/rejected from QC store.
                             */
                            if (dodqcistm.getApprovedStockOuts() != null && !dodqcistm.getApprovedStockOuts().isEmpty()) {
                                throw new AccountingException(messageSource.getMessage("acc.deliveryOrder.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"edit", deliveryOrder1.getDeliveryOrderNumber(), "approved"}, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                            }
                            if (dodqcistm.getRejectedDODQCISTMappings() != null && !dodqcistm.getRejectedDODQCISTMappings().isEmpty()) {
                                throw new AccountingException(messageSource.getMessage("acc.goodsreceiptnote.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"edit", deliveryOrder1.getDeliveryOrderNumber(), "rejected"}, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                            }
                            if (dodqcistm.getPickedMapping() != null && !dodqcistm.getPickedMapping().isEmpty()) {
                                throw new AccountingException(messageSource.getMessage("acc.goodsreceiptnote.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"edit", deliveryOrder1.getDeliveryOrderNumber(), "picked"}, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                            }
                            if (dodqcistm.getQcInterStoreTransferRequest() != null) {
                                if (dodqcistm.getQcInterStoreTransferRequest().getStatus() != InterStoreTransferStatus.INTRANSIT) {
                                    throw new AccountingException(messageSource.getMessage("acc.deliveryOrder.cannot.be.deleted.as.stockisaccepted.byQAstore", new Object[]{"edit", deliveryOrder1.getDeliveryOrderNumber()}, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                                } else {
                                    istService.deleteISTRequest(dodqcistm.getQcInterStoreTransferRequest());
                                }
                            }
                        }
                    }
                }
                accInvoiceDAOobj.deleteDeliveryOrderDetails(doid, companyid);
                List list = result.getEntityList();
                Iterator itr = list.iterator();
                while (itr.hasNext()) {
                    String inventoryid = (String) itr.next();
                    accProductObj.deleteInventory(inventoryid, companyid);
                }
                if (isEdit) {
                    deleteExistingAutoBuildAssemblyEntriesOfDO(paramJobj, doid);
                }
                HashMap<String, Object> linkRequestParams = new HashMap<String, Object>();
                linkRequestParams.put("doid", doid);
                /* Deleting Linking information of Delivery Order during Editing Delivery Order*/
                accInvoiceDAOobj.deleteLinkingInformationOfDO(linkRequestParams);

                /* Updating Isopen Flag=0 & linkflag=0 of SI & SO during Editing DO*/
                if (!StringUtil.isNullOrEmpty(deletedLinkedDocumentID)) {
                    String[] deletedLinkedDocumentIDArr = deletedLinkedDocumentID.split(",");
                    for (int i = 0; i < deletedLinkedDocumentIDArr.length; i++) {
                        KwlReturnObject venresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), deletedLinkedDocumentIDArr[i]);
                        SalesOrder salesorder = (SalesOrder) venresult.getEntityList().get(0);
                        if (salesorder != null) {
                            linkRequestParams.put("salesOrder", salesorder);
                            linkRequestParams.put("value", "0");
                            linkRequestParams.put("isSOOpen", true);
                            accInvoiceDAOobj.updateSOLinkflag(linkRequestParams);
                            if (i == 0) {
                                unlinkMessage += " from the Sales Order(s) ";
                            }
                            if (unlinkMessage.indexOf(salesorder.getSalesOrderNumber()) == -1) {
                                unlinkMessage += salesorder.getSalesOrderNumber() + ", ";
                            }
                        } else {
                            venresult = accountingHandlerDAOobj.getObject(Invoice.class.getName(), deletedLinkedDocumentIDArr[i]);
                            Invoice invoice = (Invoice) venresult.getEntityList().get(0);
                            if (invoice != null) {
                                linkRequestParams.put("isOpenDO", true);
                                linkRequestParams.put("invoice", invoice);
                                accInvoiceDAOobj.updateInvoiceLinkflag(linkRequestParams);
                                if (i == 0) {
                                    unlinkMessage += " from the Sales Invoice(s) ";
                                }
                                if (unlinkMessage.indexOf(invoice.getInvoiceNumber()) == -1) {
                                    unlinkMessage += invoice.getInvoiceNumber() + ", ";
                                }
                            }
                        }
                    }
                }

                if (!StringUtil.isNullOrEmpty(unlinkMessage) && unlinkMessage.endsWith(", ")) {
                    unlinkMessage = unlinkMessage.substring(0, unlinkMessage.length() - 2);
                }
            }

            synchronized (this) {
                if (!StringUtil.isNullOrEmpty(doid) && !isAutoCreateDO) { //Edit case
                    KwlReturnObject docnt = accInvoiceDAOobj.getDODuplicateNumberWithID(entryNumber, companyid, doid);
                    if (sequenceformat.equals("NA") && docnt.getRecordTotalCount() > 0) {
                        throw new AccountingException("Delivery Order Number '" + entryNumber + "' already exists.");
                    }
                    KwlReturnObject doObj = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);
                    DeliveryOrder deliveryOrderObj = (DeliveryOrder) doObj.getEntityList().get(0);
                    if (isEdit == true) {
                        setValuesForAuditTrialForDO(deliveryOrderObj, paramJobj, olddo, doDataMap, auditKey);
                    }
                    if (!sequenceformat.equals("NA")) {
                        nextAutoNumber = entryNumber;
                    }
                    doDataMap.put("id", doid);

                }

                if (sequenceformat.equals("NA")) {//In case of NA checks wheather this number can also be generated by a sequence format or not 
                    List list = accCompanyPreferencesObj.checksEntryNumberForSequenceNumber(Constants.Acc_Delivery_Order_ModuleId, entryNumber, companyid);
                    if (!list.isEmpty()) {
                        boolean isvalidEntryNumber = (Boolean) list.get(0);
                        String formatName = (String) list.get(1);
                        if (!isvalidEntryNumber) {
                            throw new AccountingException(messageSource.getMessage("acc.common.enterdocumentnumber", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + entryNumber + "</b> " + messageSource.getMessage("acc.common.belongsto", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + formatName + "</b>. " + messageSource.getMessage("acc.common.plselectseqformat", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + formatName + "</b> " + messageSource.getMessage("acc.common.insteadof", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                        }
                    }
                }
            }
            boolean autogen = sequenceformat.equals("NA") ? false : true;
            if (DOSeqNum != 0) {
                autogen = true;
            }
            DateFormat df = authHandler.getDateOnlyFormat();
            if (sequenceformat.equals("NA") || !StringUtil.isNullOrEmpty(doid)) {
                doDataMap.put("entrynumber", entryNumber);
                if (isAutoCreateDO && !sequenceformat.equals("NA")) {
                    doDataMap.put(Constants.SEQNUMBER, DOSeqNum);
                    doDataMap.put(Constants.SEQFORMAT, sequenceformat);
                    doDataMap.put(Constants.DATEPREFIX, datePrefix);
                    doDataMap.put(Constants.DATESUFFIX, dateSuffix);
                }
            } else {
                /*
                 * isImportSequenceFormat is true while importing DO with entry no is belongs in sequence format. 
                 */
                if (isImportSequenceFormat) {
                    doDataMap.put("entrynumber", entryNumber);
                    doDataMap.put(Constants.SEQNUMBER, seqNumber);
                    doDataMap.put(Constants.SEQFORMAT, sequenceformat);
                } else {
                    doDataMap.put("entrynumber", "");
                }
            }
            String custId = null, termid = null;
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {//Mobile Application
                custId = (paramJobj.has("CustomerName") && paramJobj.get("CustomerName") != null) ? paramJobj.getString("CustomerName") : null;
                termid = (paramJobj.has("terms") && paramJobj.get("terms") != null) ? paramJobj.getString("terms") : null;
            } else {
                custId = paramJobj.optString("customer");
                termid = paramJobj.optString("term");
            }
            
            doDataMap.put("autogenerated", autogen);
            doDataMap.put("externalCurrencyRate", StringUtil.getDouble(paramJobj.optString("externalcurrencyrate") != "" ? paramJobj.optString("externalcurrencyrate") : "0.0"));
            doDataMap.put(Constants.memo, paramJobj.optString(Constants.memo));
            doDataMap.put("ordernoreferedformemoaddress", paramJobj.optString("ordernoreferedformemoaddress"));
            doDataMap.put("posttext", paramJobj.optString("posttext", null) == null ? "" : paramJobj.optString("posttext"));
            doDataMap.put("customerid", custId);
            if (paramJobj.optString("shipdate") != null && !StringUtil.isNullOrEmpty(paramJobj.optString("shipdate"))) {
                doDataMap.put("shipdate", df.parse(paramJobj.optString("shipdate")));
            }
            if (countryid == Constants.indian_country_id && paramJobj.has("formtypeid") && paramJobj.optString("formtypeid", null) != null) {
                doDataMap.put("formtype", (String) paramJobj.get("formtypeid"));
                doDataMap.put("gstapplicable", paramJobj.optBoolean("GSTApplicable"));
                doDataMap.put(Constants.RCMApplicable, RCMApplicable);
            }else if (extraCompanyPreferences.isIsNewGST()){
                /**
                 * ERP-32829 
                 */
                doDataMap.put(Constants.RCMApplicable, RCMApplicable);                
                doDataMap.put("gstapplicable", paramJobj.optBoolean("GSTApplicable"));
            }
            doDataMap.put(Constants.EWAYApplicable, EWAYApplicable);
            doDataMap.put("termid", termid);
            doDataMap.put("shipvia", paramJobj.optString("shipvia"));
            doDataMap.put(Constants.fob, paramJobj.optString(Constants.fob));
            doDataMap.put("orderdate", df.parse(paramJobj.optString(Constants.BillDate)));
            doDataMap.put(Constants.Checklocktransactiondate, paramJobj.optString(Constants.BillDate));//ERP-16800-Without parsing date
            doDataMap.put("status", status);
            doDataMap.put("isfavourite", isfavourite);
            doDataMap.put("customerporefno", customerporefno);
            doDataMap.put("isFixedAsset", isFixedAsset);
            doDataMap.put("isFreeGift", isFreeGift);
            doDataMap.put("isLeaseFixedAsset", isLeaseFixedAsset);
            doDataMap.put(Constants.isConsignment, isConsignment);
            doDataMap.put("isJobWorkOutReciever", isJobWorkOutReciever);
            doDataMap.put("createdby", createdby);
            doDataMap.put("modifiedby", modifiedby);
            doDataMap.put("createdon", createdon);
            doDataMap.put("updatedon", updatedon);
            doDataMap.put("salesPerson", paramJobj.optString("salesPerson"));
            doDataMap.put("gstIncluded", gstIncluded);
            doDataMap.put(Constants.isApplyTaxToTerms,paramJobj.optBoolean(Constants.isApplyTaxToTerms,false));
            doDataMap.put(Constants.isMerchantExporter,paramJobj.optBoolean(Constants.isMerchantExporter,false));
            doDataMap.put(Constants.additionalMemo,paramJobj.optString(Constants.additionalMemo,""));
//            String taxid = paramJobj.optString("taxid");
            String taxid = "";
            if (paramJobj.optString("taxid").equalsIgnoreCase("None")) {
                taxid = null;
            } else {
                taxid = paramJobj.optString("taxid",null);
            }
            /* If Global tax changing from Yes to No then key should be put in dataMap  
             *so that it should be saved in database
             */   
            doDataMap.put("taxid", taxid);
           // }
            if (isFixedAsset || isLeaseFixedAsset || isAutoCreateDO || isConsignment) {// if there is no approval rule then default approvedlevel value is 11, so in case of fixed asset invoice or lease invoice, Approve status level value will be 11;
                doDataMap.put("approvestatuslevel", 11);
            }
            if (!StringUtil.isNullOrEmpty(costCenterId)) {
                doDataMap.put("costCenterId", costCenterId);
            }
            if (!StringUtil.isNullOrEmpty(custWarehouse)) {
                doDataMap.put("custWarehouse", custWarehouse);
            }
            if (!StringUtil.isNullOrEmpty(movementtype)) {
                doDataMap.put("movementtype", movementtype);
            }
            doDataMap.put(Constants.companyKey, companyid);
            doDataMap.put(Constants.currencyKey, currencyid);
            doDataMap.put("driver", driver);
            if (isAutoCreateDO) {
                doDataMap.put("isautogenerateddo", true); // true if do is generated from invoice side
            }

            Customer customer = null;
            KwlReturnObject custresult = null;
            if (!StringUtil.isNullOrEmpty(custId)) {
                custresult = accountingHandlerDAOobj.getObject(Customer.class.getName(), custId);
                customer = (Customer) custresult.getEntityList().get(0);
            }

            boolean isDefaultAddress = paramJobj.optString("defaultAdress") != null ? Boolean.parseBoolean(paramJobj.optString("defaultAdress")) : false;
            Map<String, Object> addressParams = Collections.EMPTY_MAP;
            if (isDefaultAddress) { //defautladdress came true only when user create a new DO without saving any address from address window.customer addresses taken default 
                addressParams = AccountingAddressManager.getDefaultCustomerAddressParams(customer.getID(), companyid, accountingHandlerDAOobj);// addressParams = getCustomerDefaultAddressParams(customer,companyid);
            } else {
                addressParams = AccountingAddressManager.getAddressParamsJson(paramJobj, false);
            }
            if (!StringUtil.isNullOrEmpty(doid)) { //If Edit case then updating existing delivery order address 
                KwlReturnObject res = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);
                DeliveryOrder order = (DeliveryOrder) res.getEntityList().get(0);
                String addressID = order.getBillingShippingAddresses() == null ? "" : order.getBillingShippingAddresses().getID();
                addressParams.put("id", addressID);
            }
            KwlReturnObject addressresult = accountingHandlerDAOobj.saveAddressDetail(addressParams, companyid);
            BillingShippingAddresses bsa = (BillingShippingAddresses) addressresult.getEntityList().get(0);
            doDataMap.put("billshipAddressid", bsa.getID());

            String deliveryOrderTerms = paramJobj.optString("invoicetermsmap",null);
            if (StringUtil.isAsciiString(deliveryOrderTerms)) {
                if (new JSONArray(deliveryOrderTerms).length() > 0) {
                    doDataMap.put(Constants.termsincludegst, Boolean.parseBoolean(paramJobj.optString(Constants.termsincludegst)));
                }
            }
            //Rounding Adjustment will always calculated after calculation of totalInvAmount
            boolean isRoundingAdjustmentApplied = !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.IsRoundingAdjustmentApplied,null))?Boolean.parseBoolean(paramJobj.optString(Constants.IsRoundingAdjustmentApplied)): false;
            doDataMap.put(Constants.IsRoundingAdjustmentApplied, isRoundingAdjustmentApplied);
            //By default web application:ERP-39696
            doDataMap.put(Constants.generatedSource, (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.generatedSource, null))) ? Integer.parseInt(paramJobj.optString(Constants.generatedSource, Constants.RECORD_WEB_Application)) : null);
            
            KwlReturnObject doresult = accInvoiceDAOobj.saveDeliveryOrder(doDataMap);
            deliveryOrder = (DeliveryOrder) doresult.getEntityList().get(0);
            /**
             * Save GST History Customer/Vendor data..
             */
            if (deliveryOrder.getCompany().getCountry().getID().equalsIgnoreCase("" + Constants.indian_country_id)) {
                paramJobj.put("docid", deliveryOrder.getID());
                paramJobj.put("moduleid", Constants.Acc_Delivery_Order_ModuleId);
                /**
                 * IF Auto Generated DO from Sales Invoice then check GST History present for DO or not.
                 * Problem only in Edit case.
                 */
                if(isAutoCreateDO && isEdit){
                    JSONObject DODocGSTHistory = new JSONObject();
                    DODocGSTHistory.put("refdocid", deliveryOrder.getID());
                    fieldDataManagercntrl.getGSTDocumentHistory(DODocGSTHistory);
                    paramJobj.put("gstdochistoryid", DODocGSTHistory.optString("gstdochistoryid", ""));
                }
                fieldDataManagercntrl.createRequestMapToSaveDocHistory(paramJobj);
            }         
            String linkMode = "";
            /**
             * 
             */
            String linkModeAutoDO = null;
            Map<String, Object> doContractMap = new HashMap<>();
            if (!isAutoCreateDO) {
                linkMode = paramJobj.optString("fromLinkCombo"); //When adding Sales order link for Delivery Order update link flag(2) in sale order.
            } else {
                /**
                 * if we creating DO through invoice automatically. 
                 */
                linkModeAutoDO = paramJobj.optString(Constants.fromLinkComboAutoDO);
            }
            /**
             * If we are creating DO automatically and
             * To execute if block only when we are linking to salesorder and
             * If we are creating DO through sales invoice or customer invoice.
             */
            if (linkMode.equalsIgnoreCase("Lease Order") || linkMode.equalsIgnoreCase(Constants.SALESORDER) || linkMode.equalsIgnoreCase("Consingnment Request") || (isAutoCreateDO && StringUtil.equal(paramJobj.optString("fromLinkCombo"), Constants.SALESORDER) && (StringUtil.equal(linkModeAutoDO, "Customer Invoice") || StringUtil.equal(linkModeAutoDO, "Sales Invoice")))) {// save contract detail mapping in case of lease fixed asset or do is linked with Contracted SO.
                doContractMap.put("linkNumber", paramJobj.optString("linkNumber"));
                Set<DOContractMapping> contractMappings = getDOContractMappings(doContractMap, deliveryOrder);
                if (!contractMappings.isEmpty()) {
                    doDataMap.put("id", deliveryOrder.getID());
                    doDataMap.put("contractMappings", contractMappings);
                    accInvoiceDAOobj.saveDeliveryOrder(doDataMap);
                }
            } else if (linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase("Sales Invoice")) {
                doContractMap.put("linkNumber", paramJobj.optString("linkNumber"));
                Set<DOContractMapping> contractMappings = getDOContractMappingsFromInvoice(doContractMap, deliveryOrder);
                if (!contractMappings.isEmpty()) {
                    doDataMap.put("id", deliveryOrder.getID());
                    doDataMap.put("contractMappings", contractMappings);
                    accInvoiceDAOobj.saveDeliveryOrder(doDataMap);
                }
            }

            if (isAutoCreateDO) {
                /**
                 * Constants.fromLinkComboAutoDO value is in linkModeAutoDO
                 */
                linkMode = linkModeAutoDO;
            }

            String oldjeid = null;
            String jeentryNumber = null;
            boolean jeautogenflag = false;
            String jeIntegerPart = "";
            String jeDatePrefix = "";
            String jeDateAfterPrefix = "";
            String jeDateSuffix = "";
            String jeSeqFormatId = "";
            String jeid = null;
            boolean postInventoryJournalEntry = false;
            /*
             * Check if there is any non-inventory present or not, as Inventory Journal Entry should not be posted for non-inventory products.
             */
            if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.detail))) {
                JSONArray jArr = new JSONArray(paramJobj.optString(Constants.detail));
                for (int i = 0; i < jArr.length(); i++) {
                    JSONObject jobj = jArr.getJSONObject(i);
                    if (!StringUtil.isNullOrEmpty(jobj.getString(Constants.productid))) {
                        KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                        Product product = (Product) proresult.getEntityList().get(0);
                        /**
                          * Added (!product.isAsset) -: Asset DO - JE should not be posted ERP-38879.
                          */
                        if (product != null && product.getProducttype() != null && !(product.getProducttype().getID().equals(Producttype.SERVICE) || product.getProducttype().getID().equals(Producttype.NON_INVENTORY_PART) || product.getProducttype().getID().equals(Producttype.Inventory_Non_Sales)) && !product.isAsset()) {
                            postInventoryJournalEntry = true;
                            break;
                        }
                    }
                }
            }
            if (linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase(Constants.CUSTOMER_INVOICE)) {
                if (deliveryOrder != null && deliveryOrder.getJournalEntry() != null) {
                    JournalEntry jetemp = deliveryOrder.getJournalEntry();
                    if (jetemp != null) {
                        jeentryNumber = jetemp.getEntryNumber(); //preserving these data to generate same JE number in edit case                    
                        jeautogenflag = jetemp.isAutoGenerated();
                        jeSeqFormatId = jetemp.getSeqformat() == null ? "" : jetemp.getSeqformat().getID();
                        jeIntegerPart = String.valueOf(jetemp.getSeqnumber());
                        oldjeid = jetemp.getID();
                    }
                    deliveryOrder.setJournalEntry(null);
                    accInvoiceDAOobj.updateDeliveryOrderSetNull(deliveryOrder);
                    accJournalEntryobj.deleteJournalEntryPermanent(oldjeid, companyid);
                }
            }

            //  Auto Build product if 'Auto Build Assembly on Sale' check is on for Assembly Product
            HashMap<String, Object> assemblyParams = new HashMap<String, Object>();
            assemblyParams.put("doid", deliveryOrder.getID());
            HashMap<String, Object> pbuildMap = createBuildAssembly(paramJobj, assemblyParams);
            Set<JournalEntryDetail> inventoryJEdetails = new HashSet<>();
            String inventoryjeid = "";
            Date entryDate = df.parse(paramJobj.optString(Constants.BillDate));
            JournalEntry inventoryJE = null;
            boolean isAllProductHavingQAApprovalFlow=paramJobj.optBoolean("isAllProductHavingQAApprovalFlow",true);
            /*  Inventory JE Code for Inventory Product */ 
            try {
                if (((!sendForQAApproval || !isAllProductHavingQAApprovalFlow)) && extraCompanyPreferences != null && !extraCompanyPreferences.isPickpackship() && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD) && postInventoryJournalEntry) {
                    String oldjeid1 = null;
                    String jeentryNumber1 = null;
                    boolean jeautogenflag1 = false;
                    String jeIntegerPart1 = "";
                    String jeDatePrefix1 = "";
                    String jeAfterDatePrefix1 = "";
                    String jeDateSuffix1 = "";
                    String jeSeqFormatId1 = "";
                    if (deliveryOrder != null && deliveryOrder.getInventoryJE() != null) {
                        jeentryNumber1 = deliveryOrder.getInventoryJE().getEntryNumber(); //preserving these data to generate same JE number in edit case                    
                        jeautogenflag1 = deliveryOrder.getInventoryJE().isAutoGenerated();
                        jeSeqFormatId1 = deliveryOrder.getInventoryJE().getSeqformat() == null ? "" : deliveryOrder.getInventoryJE().getSeqformat().getID();
                        jeIntegerPart1 = String.valueOf(deliveryOrder.getInventoryJE().getSeqnumber());
                        jeDatePrefix1 = deliveryOrder.getInventoryJE().getDatePreffixValue();
                        jeAfterDatePrefix1 = deliveryOrder.getInventoryJE().getDateAfterPreffixValue();
                        jeDateSuffix1 = deliveryOrder.getInventoryJE().getDateSuffixValue();
                        oldjeid1 = deliveryOrder.getInventoryJE().getID();
                        deliveryOrder.setInventoryJE(null);
                        accInvoiceDAOobj.updateDeliveryOrderInventoryJESetNull(deliveryOrder);
                        accJournalEntryobj.deleteJournalEntryPermanent(oldjeid1, companyid);
                    } else if (isAutoCreateDO && !isCopy) {
                        if (paramJobj.has(Constants.INVENTORYJE_ENTRYNO) && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.INVENTORYJE_ENTRYNO, null))) {
                            jeentryNumber1 = paramJobj.getString(Constants.INVENTORYJE_ENTRYNO);
                        }
                        if (paramJobj.has(Constants.INVENTORYJE_ID) && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.INVENTORYJE_ID, null))) {
                            oldjeid1 = paramJobj.getString(Constants.INVENTORYJE_ID);
                        }
                        if (paramJobj.has(Constants.INVENTORYJE_SEQ_NUMBER) && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.INVENTORYJE_SEQ_NUMBER, null))) {
                            jeIntegerPart1 = paramJobj.getString(Constants.INVENTORYJE_SEQ_NUMBER);
                        }
                        if (paramJobj.has(Constants.INVENTORYJE_SEQ_FORMAT_ID) && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.INVENTORYJE_SEQ_FORMAT_ID, null))) {
                            jeSeqFormatId1 = paramJobj.getString(Constants.INVENTORYJE_SEQ_FORMAT_ID);
                        }
                        if (paramJobj.has(Constants.INVENTORYJE_IS_AUTO_GENERATED) && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.INVENTORYJE_IS_AUTO_GENERATED, null))) {
                            jeautogenflag1 = paramJobj.getBoolean(Constants.INVENTORYJE_IS_AUTO_GENERATED);
                        }
                        if (paramJobj.has(Constants.INVENTORYJE_DATE_PREFIX_VALUE) && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.INVENTORYJE_DATE_PREFIX_VALUE, null))) {
                            jeDatePrefix1 = paramJobj.getString(Constants.INVENTORYJE_DATE_PREFIX_VALUE);
                        }
                        if (paramJobj.has(Constants.INVENTORYJE_DATE_AFTER_PREFIX_VALUE) && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.INVENTORYJE_DATE_AFTER_PREFIX_VALUE, null))) {
                            jeAfterDatePrefix1 = paramJobj.getString(Constants.INVENTORYJE_DATE_AFTER_PREFIX_VALUE);
                        }
                        if (paramJobj.has(Constants.INVENTORYJE_DATE_SUFFIX_VALUE) && !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.INVENTORYJE_DATE_SUFFIX_VALUE, null))) {
                            jeDateSuffix1 = paramJobj.getString(Constants.INVENTORYJE_DATE_SUFFIX_VALUE);
                        }
                    }
                    if (StringUtil.isNullOrEmpty(oldjeid1)) {
                        synchronized (this) {
                            HashMap<String, Object> JEFormatParams = new HashMap<String, Object>();
                            JEFormatParams.put(Constants.moduleid, Constants.Acc_GENERAL_LEDGER_ModuleId);
                            JEFormatParams.put("modulename", "autojournalentry");
                            JEFormatParams.put(Constants.companyKey, companyid);
                            JEFormatParams.put("isdefaultFormat", true);
                            KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                            SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
                            Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, format.getID(), false, entryDate);
                            jeentryNumber1 = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                            jeIntegerPart1 = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                            jeDatePrefix1 = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                            jeAfterDatePrefix1 = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                            jeDateSuffix1 = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                            jeSeqFormatId1 = format.getID();
                            jeautogenflag1 = true;
                        }
                    }
                    Map<String, Object> jeDataMap1 = AccountingManager.getGlobalParamsJson(paramJobj);
                    jeDataMap1.put("entrynumber", jeentryNumber1);
                    jeDataMap1.put("autogenerated", jeautogenflag1);
                    jeDataMap1.put(Constants.SEQFORMAT, jeSeqFormatId1);
                    jeDataMap1.put(Constants.SEQNUMBER, jeIntegerPart1);
                    jeDataMap1.put(Constants.DATEPREFIX, jeDatePrefix1);
                    jeDataMap1.put(Constants.DATEAFTERPREFIX, jeAfterDatePrefix1);
                    jeDataMap1.put(Constants.DATESUFFIX, jeDateSuffix1);
                    jeDataMap1.put("entrydate", entryDate);
                    jeDataMap1.put(Constants.companyKey, companyid);
                    jeDataMap1.put("createdby", createdby);
                    jeDataMap1.put(Constants.memo, paramJobj.optString(Constants.memo));
                    jeDataMap1.put(Constants.currencyKey, currencyid);
                    jeDataMap1.put("costcenterid", costCenterId);
                    jeDataMap1.put("transactionModuleid", Constants.Acc_Delivery_Order_ModuleId);
                    jeDataMap1.put("transactionId", deliveryOrder.getID());
                    jeDataMap1.put(JournalEntryConstants.EXTERNALCURRENCYRATE, deliveryOrder.getExternalCurrencyRate());
                    KwlReturnObject jeresult1 = accJournalEntryobj.saveJournalEntry(jeDataMap1);
                    inventoryJE = (JournalEntry) jeresult1.getEntityList().get(0);
                    inventoryjeid = inventoryJE.getID();
                    deliveryOrder.setInventoryJE(inventoryJE);
                }
            } catch (Exception ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.WARNING, ex.getMessage());
            }

            try {
                if (sendForQAApproval) { // send DO for QA approval
                    SeqFormat seqFormat = seqService.getDefaultSeqFormat(extraCompanyPreferences.getCompany(), ModuleConst.INTER_STORE_TRANSFER);
                    if (seqFormat != null) {
                        String interstore_loc_No = seqService.getNextFormatedSeqNumber(seqFormat);
                        paramJobj.put("interstoreSeqNo", interstore_loc_No);
                        paramJobj.put("interstoreseqFormat", seqFormat);
                    } else {
                        throw new AccountingException(messageSource.getMessage("acc.companypreferences.defaultsequenceformatforistnotset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    }
                }
            } catch (SeqFormatException ex) {
                throw new AccountingException(messageSource.getMessage("acc.companypreferences.defaultsequenceformatforistnotset", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
            }
//            if (countryid == Constants.indian_country_id && customer != null && customer.getGSTRegistrationType() != null) {
//                MasterItem gstRegistrationType = customer.getGSTRegistrationType();
//                if (gstRegistrationType != null && gstRegistrationType.getDefaultMasterItem() != null && !StringUtil.isNullOrEmpty(gstRegistrationType.getDefaultMasterItem().getID())) {
//                    paramJobj.put("isUnRegisteredDealer", gstRegistrationType.getDefaultMasterItem().getID().equals(Constants.GSTRegType.get(Constants.GSTRegType_Unregistered)));;
//                }
//            }
            if ((linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase("Sales Invoice")) && extraCompanyPreferences != null && extraCompanyPreferences.isDeferredRevenueRecognition()) {
                JSONArray jArr = new JSONArray(paramJobj.optString(Constants.detail));
                List listDeferred = new ArrayList();
                List tempDeferred = new ArrayList();
                boolean allowProductDeferred = false;
                for (int i = 0; i < jArr.length(); i++) {
                    JSONObject jobj = jArr.getJSONObject(i);
                    KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(InvoiceDetail.class.getName(), jobj.getString("rowid"));
                    InvoiceDetail invoiceDetail = (InvoiceDetail) rdresult.getEntityList().get(0);
                    if (invoiceDetail != null) {
                        Invoice invoice = invoiceDetail.getInvoice();
                        KwlReturnObject resultDeferred = accInvoiceDAOobj.getInvoiceDetailWithDeferredJE(invoice);
                        tempDeferred = resultDeferred.getEntityList();
                    }
                    KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                    Product product = (Product) proresult.getEntityList().get(0);
                    if (product.isRevenueRecognitionProcess()) {
                        allowProductDeferred = true;
                    }
                    if (!tempDeferred.isEmpty()) {
                        listDeferred.addAll(tempDeferred);
                    }
                }
                if (!listDeferred.isEmpty()) {
                    paramJobj.put("listDeferred", listDeferred);
                }
                if (((listDeferred != null && !listDeferred.isEmpty()) || isAutoCreateDO) && allowProductDeferred) {

                    if (StringUtil.isNullOrEmpty(oldjeid)) {
                        synchronized (this) {
                            HashMap<String, Object> JEFormatParams = new HashMap<String, Object>();
                            JEFormatParams.put(Constants.moduleid, Constants.Acc_GENERAL_LEDGER_ModuleId);
                            JEFormatParams.put("modulename", "autojournalentry");
                            JEFormatParams.put(Constants.companyKey, companyid);
                            JEFormatParams.put("isdefaultFormat", true);

                            KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                            SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
                            Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, format.getID(), false, entryDate);
                            jeentryNumber = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                            jeIntegerPart = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                            jeDatePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                            jeDateAfterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                            jeDateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                            jeSeqFormatId = format.getID();
                            jeautogenflag = true;
                        }
                    }
                    Map<String, Object> jeDataMap = AccountingManager.getGlobalParamsJson(paramJobj);
                    jeDataMap.put("entrynumber", jeentryNumber);
                    jeDataMap.put("autogenerated", jeautogenflag);
                    jeDataMap.put(Constants.SEQFORMAT, jeSeqFormatId);
                    jeDataMap.put(Constants.SEQNUMBER, jeIntegerPart);
                    jeDataMap.put(Constants.DATEPREFIX, jeDatePrefix);
                    jeDataMap.put(Constants.DATEAFTERPREFIX, jeDateAfterPrefix);
                    jeDataMap.put(Constants.DATESUFFIX, jeDateSuffix);
                    jeDataMap.put("entrydate", entryDate);
                    jeDataMap.put(Constants.companyKey, companyid);
                    jeDataMap.put(Constants.memo, paramJobj.optString(Constants.memo));
                    jeDataMap.put(Constants.currencyKey, currencyid);
                    jeDataMap.put("costcenterid", costCenterId);
                    HashSet jeDetails = new HashSet();
                    KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Create Journal entry without JEdetails
                    JournalEntry journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
                    jeid = journalEntry.getID();
                    jeDataMap.put("jeid", jeid);

                    doDataMap.put("id", deliveryOrder.getID());
                    paramJobj.put("jeDetails", jeDetails);
                    paramJobj.put("jeid", jeid);
                    doDetailsReturnList = saveDeliveryOrderRows(paramJobj, deliveryOrder, companyid, isAutoCreateDO, invoiceid, inventoryJEdetails, inventoryjeid, pbuildMap);
                    deliveryOrder.setJournalEntry(journalEntry);
                    HashSet dodetails = ((HashSet) doDetailsReturnList.get(0));
                    deliveryOrder.setRows(dodetails);
                    accInvoiceDAOobj.updateDeliveryOrder(deliveryOrder);
                    jeDataMap.put("jedetails", jeDetails);
                    jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Add Journal entry details

                    journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
                } else {
                    doDataMap.put("id", deliveryOrder.getID());
                    doDetailsReturnList = saveDeliveryOrderRows(paramJobj, deliveryOrder, companyid, isAutoCreateDO, invoiceid, inventoryJEdetails, inventoryjeid, pbuildMap);
                    HashSet dodetails = ((HashSet) doDetailsReturnList.get(0));
                    deliveryOrder.setRows(dodetails);
                }
            } else {
                doDataMap.put("id", deliveryOrder.getID());
                doDetailsReturnList = saveDeliveryOrderRows(paramJobj, deliveryOrder, companyid, isAutoCreateDO, invoiceid, inventoryJEdetails, inventoryjeid, pbuildMap);
                HashSet dodetails = ((HashSet) doDetailsReturnList.get(0));
                deliveryOrder.setRows(dodetails);
            }
            if (inventoryJE != null && !extraCompanyPreferences.isPickpackship()  && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) {
                inventoryJE.setDetails(inventoryJEdetails);
                accJournalEntryobj.saveJournalEntryDetailsSet(inventoryJEdetails);
            }
            /* ------------------------ Update isOpen State Sales Order maintain a flag For SO -------------------------- */
            HashMap<String, Object> GlobalParams = AccountingManager.getGlobalParamsJson(paramJobj);
            HashSet<DeliveryOrderDetail> dodetails = ((HashSet) doDetailsReturnList.get(0));
            double totalAmount = 0;
            double subtotal = 0;
            double quantity = 0;
            double discountAmount = 0;
            double discountAmountInBase = 0;
            double taxAmount = 0;
            JSONArray productDiscountJArr = new JSONArray();
            if (dodetails != null && !dodetails.isEmpty()) {
                for (DeliveryOrderDetail cnt : dodetails) {
                    /*
                     * Check if  "Include GST" for rate  
                     * */
                    double rate = 0;
                    if (gstIncluded) {
                        rate = cnt.getRateincludegst();
                    } else {
                        rate = cnt.getRate();
                        taxAmount += authHandler.round(cnt.getRowTaxAmount(), companyid);
                    }
                    /*
                     * Code for Add termamount into totalamount for India,US country only (i.e. countries on which GST-Terms applies) ERP-41783               
                     */
                    if (extraCompanyPreferences.getLineLevelTermFlag() == 1 && !RCMApplicable) {
                        taxAmount += authHandler.round(cnt.getRowTermAmount(), companyid);
                    }
                    String productId = cnt.getInventory().getProduct().getID();
                    quantity = cnt.getInventory().getQuantity();
                    totalAmount += authHandler.round((rate * quantity), companyid);
                    subtotal = authHandler.round((rate * quantity), companyid);
                    double rowDiscVal = 0;
                    if (cnt.getDiscountispercent() == 1) {
                        rowDiscVal = authHandler.round((subtotal * cnt.getDiscount() / 100), companyid);
                        discountAmount += rowDiscVal;
                    } else {
                        rowDiscVal = authHandler.round(cnt.getDiscount(), companyid);
                        discountAmount += rowDiscVal;
                    }
                    // Mapping Product and Discount
                    KwlReturnObject dAmount = accCurrencyDAOobj.getCurrencyToBaseAmount(GlobalParams, rowDiscVal, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), deliveryOrder.getExternalCurrencyRate());
                    double discAmountinBase = (Double) dAmount.getEntityList().get(0);
                    discAmountinBase = authHandler.round(discAmountinBase, companyid);
                    JSONObject productDiscountObj = new JSONObject();
                    productDiscountObj.put("productId", productId);
                    productDiscountObj.put("discountAmount", discAmountinBase);
                    productDiscountJArr.put(productDiscountObj);
                }
            }
            double totalAmountInDocumentCurrecy = totalAmount - discountAmount;
            double taxPercent = 0;
            if (deliveryOrder.getTax() != null) {
                KwlReturnObject taxresult = accTaxObj.getTaxPercent(paramJobj.optString(Constants.companyKey), deliveryOrder.getOrderDate(), deliveryOrder.getTax().getID());
                taxPercent = (Double) taxresult.getEntityList().get(0);
                double ordertaxamount = (taxPercent == 0 ? 0 : authHandler.round((totalAmountInDocumentCurrecy * taxPercent / 100), companyid));
                taxAmount += ordertaxamount;
            }
            totalAmountInDocumentCurrecy = totalAmountInDocumentCurrecy + taxAmount;
            
           //Rounding Adjustment will always calculated after calculation of totalInvAmount
            double roundingadjustmentAmount = 0.0, roundingadjustmentAmountinbase = 0.0;
            String roundingAdjustmentAccountID = "";
            String columnPref = extraCompanyPreferences.getColumnPref();
            if (!StringUtil.isNullOrEmpty(columnPref)) {
                JSONObject prefObj = new JSONObject(columnPref);
                roundingAdjustmentAccountID = prefObj.optString(Constants.RoundingAdjustmentAccountID, "");
            }

            if (isRoundingAdjustmentApplied && !StringUtil.isNullOrEmpty(roundingAdjustmentAccountID)) {
                double totalInvAmountAfterRound = Math.round(totalAmountInDocumentCurrecy);
                roundingadjustmentAmount = authHandler.round(totalInvAmountAfterRound - totalAmountInDocumentCurrecy, companyid);
                if (roundingadjustmentAmount != 0) {
                    totalAmountInDocumentCurrecy = totalInvAmountAfterRound;//Now rounded value becomes total quotation amount
                    doDataMap.put(Constants.roundingadjustmentamount, roundingadjustmentAmount);
                    doDataMap.put(Constants.roundingadjustmentamountinbase, roundingadjustmentAmount);
                    deliveryOrder.setRoundingadjustmentamountinbase(roundingadjustmentAmount);
                    deliveryOrder.setRoundingadjustmentamount(roundingadjustmentAmount);
                    
                    String globalcurrency = paramJobj.getString(Constants.globalCurrencyKey);
                    if (!globalcurrency.equalsIgnoreCase(currencyid)) {
                        HashMap<String, Object> roundingRequestParams = new HashMap<String, Object>();
                        double externalCurrencyRate = StringUtil.getDouble(paramJobj.optString("externalcurrencyrate","1") != "" ? paramJobj.optString("externalcurrencyrate") : "0.0");
                        roundingRequestParams.put("companyid", companyid);
                        roundingRequestParams.put("gcurrencyid", (paramJobj.optString(Constants.globalCurrencyKey, null) == null ? paramJobj.optString(Constants.globalCurrencyKey) : paramJobj.optString(Constants.globalCurrencyKey)));
                        KwlReturnObject baseAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(roundingRequestParams, roundingadjustmentAmount, currencyid, df.parse(paramJobj.optString("billdate")), externalCurrencyRate);
                        roundingadjustmentAmountinbase = authHandler.round((Double) baseAmt.getEntityList().get(0), companyid);
                        doDataMap.put(Constants.roundingadjustmentamountinbase, roundingadjustmentAmountinbase);
                        deliveryOrder.setRoundingadjustmentamountinbase(roundingadjustmentAmountinbase);
                        deliveryOrder.setRoundingadjustmentamount(roundingadjustmentAmount);
                    }
                }
            }
            
            double totalAmountInBaseCurrecy = 0;
            if (deliveryOrder.getCurrency() != null) {
                HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                filterRequestParams.put(Constants.companyKey, companyid);
                filterRequestParams.put(Constants.globalCurrencyKey, paramJobj.optString(Constants.globalCurrencyKey));
                KwlReturnObject bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(filterRequestParams, totalAmountInDocumentCurrecy, deliveryOrder.getCurrency().getCurrencyID(), deliveryOrder.getOrderDate(), deliveryOrder.getExternalCurrencyRate());
                totalAmountInBaseCurrecy = authHandler.round((Double) bAmt.getEntityList().get(0), companyid);
                KwlReturnObject bAmt1 = accCurrencyDAOobj.getCurrencyToBaseAmount(filterRequestParams, discountAmount, deliveryOrder.getCurrency().getCurrencyID(), deliveryOrder.getOrderDate(), deliveryOrder.getExternalCurrencyRate());
                discountAmountInBase = authHandler.round((Double) bAmt1.getEntityList().get(0), companyid);
            }
            totalAmountInDocumentCurrecy = authHandler.round(totalAmountInDocumentCurrecy, companyid);
            deliveryOrder.setDiscountinbase(discountAmountInBase);
            deliveryOrder.setTotalamount(totalAmountInDocumentCurrecy);
            deliveryOrder.setTotalamountinbase(totalAmountInBaseCurrecy);

            String linkedDocuments = "";
            if (!isAutoCreateDO) { //If DO is auto generated from Invoice form.               
                String[] linkNumbers = paramJobj.optString("linkNumber").split(",");
                if (!StringUtil.isNullOrEmpty(linkMode) && linkNumbers.length > 0) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER) || linkMode.equalsIgnoreCase("Lease Order") || linkMode.equalsIgnoreCase("Consignment Request") || linkMode.equalsIgnoreCase("Request")
                            || linkMode.equalsIgnoreCase("Job Work Order")) {
                        for (int i = 0; i < linkNumbers.length; i++) {
                            if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                                //If multiple users are creating DO using same Sales Order then create only one DO and for others show message
                                synchronized (this) {
                                    tranStatus = txnManager.getTransaction(def);
                                    if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                                        KwlReturnObject resultInv = accCommonTablesDAO.getTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                                        if (resultInv.getRecordTotalCount() > 0) {
                    //                        accexception = true;
                                            String linkedTransactionNumber = "";
                                            KwlReturnObject soResult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkNumbers[i]);
                                            SalesOrder so = (SalesOrder) soResult.getEntityList().get(0);
                                            linkedTransactionNumber = so.getSalesOrderNumber();
                                            accCommonTablesDAO.deleteTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                                            throw new AccountingException(messageSource.getMessage("acc.SO.selectedsalesorderno", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + linkedTransactionNumber + messageSource.getMessage("acc.field.alreadyinprocess.", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                                        } else {
                                            accCommonTablesDAO.insertTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                                        }
                                    }
                                    txnManager.commit(tranStatus);
                                }
                                
                                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkNumbers[i]);
                                SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                                HashMap hMap = new HashMap();
                                hMap.put("salesOrder", salesOrder);
                                hMap.put("value", "2");

                                String status1 = getSalesOrderStatusForDO(salesOrder, isConsignment, extraCompanyPreferences, deliveryOrder.getID());
                                boolean isSOOpen = false;
                                if (status1.equals("Open")) {
                                    isSOOpen = true;
                                }
                                hMap.put("isSOOpen", isSOOpen);
                                accInvoiceDAOobj.updateSOLinkflag(hMap);

                                /*
                                 * saving linking informaion of Sales Order
                                 * while linking with Delivery Order
                                 */
                                HashMap<String, Object> requestParamsLinking = new HashMap<String, Object>();
                                requestParamsLinking.put("linkeddocid", deliveryOrder.getID());
                                requestParamsLinking.put("docid", linkNumbers[i]);
                                requestParamsLinking.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                                requestParamsLinking.put("linkeddocno", entryNumber);
                                requestParamsLinking.put("sourceflag", 0);
                                KwlReturnObject result3 = accSalesOrderDAOObj.saveSalesOrderLinking(requestParamsLinking);


                                /*
                                 * saving linking informaion of Delivery Order
                                 * while linking with Sales Order
                                 */
                                requestParamsLinking.put("linkeddocid", linkNumbers[i]);
                                requestParamsLinking.put("docid", deliveryOrder.getID());
                                requestParamsLinking.put(Constants.moduleid, Constants.Acc_Sales_Order_ModuleId);
                                requestParamsLinking.put("linkeddocno", salesOrder.getSalesOrderNumber());
                                requestParamsLinking.put("sourceflag", 1);
                                result3 = accInvoiceDAOobj.saveDeliveryOrderLinking(requestParamsLinking);
                                linkedDocuments += salesOrder.getSalesOrderNumber() + " ,";

                            }
                        }
                        linkedDocuments = linkedDocuments.substring(0, linkedDocuments.length() - 1);
                    } else if (linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase("Sales Invoice")) { //Update isOpenDO State Invoice maintain a flag For DO 
                        if (dodetails != null && !dodetails.isEmpty()) { //update balance quantity to po when creating gr link to pi and pi link to po
                            for (DeliveryOrderDetail cnt : dodetails) {
                                if (cnt.getCidetails() != null && cnt.getCidetails().getSalesorderdetail() != null) {
                                    KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), cnt.getCidetails().getSalesorderdetail().getID());
                                    SalesOrderDetail salesorderdetails = (SalesOrderDetail) rdresult.getEntityList().get(0);
                                    HashMap soMap = new HashMap();
                                    soMap.put("sodetails", salesorderdetails.getID());
                                    soMap.put(Constants.companyKey, salesorderdetails.getCompany().getCompanyID());
                                    soMap.put("balanceqty", cnt.getDeliveredQuantity());
                                    soMap.put("add", false);
                                    accCommonTablesDAO.updateSalesorderOrderStatus(soMap);
                                }
                            }
                        }
                        for (int i = 0; i < linkNumbers.length; i++) {
                            if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                                //If multiple users are creating DO using same Sales Invoice then create only one DO and for others show message
                                synchronized (this) {
                                    tranStatus = txnManager.getTransaction(def);
                                    if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                                        KwlReturnObject resultInv = accCommonTablesDAO.getTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                                        if (resultInv.getRecordTotalCount() > 0) {
                    //                        accexception = true;
                                            String linkedTransactionNumber = "";
                                            KwlReturnObject invoiceResult = accountingHandlerDAOobj.getObject(Invoice.class.getName(), linkNumbers[i]);
                                            Invoice inv = (Invoice) invoiceResult.getEntityList().get(0);
                                            linkedTransactionNumber = inv.getInvoiceNumber();
                                            accCommonTablesDAO.deleteTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                                            throw new AccountingException(messageSource.getMessage("acc.INV.selectedinvoiceno", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + linkedTransactionNumber + messageSource.getMessage("acc.field.alreadyinprocess.", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                                        } else {
                                            accCommonTablesDAO.insertTransactionInTemp(linkNumbers[i], companyid, Constants.Acc_Delivery_Order_ModuleId);
                                        }
                                    }
                                    txnManager.commit(tranStatus);
                                }
                                
                                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(Invoice.class.getName(), linkNumbers[i]);
                                Invoice invoice = (Invoice) rdresult.getEntityList().get(0);
                                HashMap hMap = new HashMap();
                                hMap.put("invoice", invoice);
                                String status1 = getInvoiceStatusForDO(invoice);
                                boolean isSOOpen = false;
                                if (status1.equals("Open")) {
                                    isSOOpen = true;
                                }
                                hMap.put("isOpenDO", isSOOpen);
                                accInvoiceDAOobj.updateInvoiceLinkflag(hMap);

                                /*
                                 * saving linking informaion of Sales Invoice
                                 * while linking with Delivery Order
                                 */
                                HashMap<String, Object> requestParamsLinking = new HashMap<String, Object>();
                                requestParamsLinking.put("linkeddocid", deliveryOrder.getID());
                                requestParamsLinking.put("docid", linkNumbers[i]);
                                requestParamsLinking.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                                requestParamsLinking.put("linkeddocno", entryNumber);
                                requestParamsLinking.put("sourceflag", 0);
                                KwlReturnObject result3 = accInvoiceDAOobj.saveInvoiceLinking(requestParamsLinking);


                                /*
                                 * saving linking informaion of Delivery Order
                                 * while linking with Sales Invoice
                                 */
                                requestParamsLinking.put("linkeddocid", linkNumbers[i]);
                                requestParamsLinking.put("docid", deliveryOrder.getID());
                                requestParamsLinking.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                                requestParamsLinking.put("linkeddocno", invoice.getInvoiceNumber());
                                requestParamsLinking.put("sourceflag", 1);
                                result3 = accInvoiceDAOobj.saveDeliveryOrderLinking(requestParamsLinking);
                                linkedDocuments += invoice.getInvoiceNumber() + " ,";

                            }
                        }
                        linkedDocuments = linkedDocuments.substring(0, linkedDocuments.length() - 1);
                    }
                }
            } else if (isAutoCreateDO) {
                if (!StringUtil.isNullOrEmpty(invoiceid)) {
                    KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                    Invoice invoice = (Invoice) rdresult.getEntityList().get(0);
                    HashMap hMap = new HashMap();
                    hMap.put("invoice", invoice);
                    boolean isSOOpen = false;
                    hMap.put("isOpenDO", isSOOpen);
                    accInvoiceDAOobj.updateInvoiceLinkflag(hMap);
                    if (dodetails != null && !dodetails.isEmpty()) { //update balance quantity to po when creating gr link to pi and pi link to po
                        for (DeliveryOrderDetail cnt : dodetails) {
                            if (cnt.getCidetails() != null && cnt.getCidetails().getSalesorderdetail() != null) {
                                KwlReturnObject Autordresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), cnt.getCidetails().getSalesorderdetail().getID());
                                SalesOrderDetail salesorderdetails = (SalesOrderDetail) Autordresult.getEntityList().get(0);
                                HashMap soMap = new HashMap();
                                soMap.put("sodetails", salesorderdetails.getID());
                                soMap.put(Constants.companyKey, salesorderdetails.getCompany().getCompanyID());
                                soMap.put("balanceqty", cnt.getDeliveredQuantity());
                                soMap.put("add", false);
                                accCommonTablesDAO.updateSalesorderOrderStatus(soMap);
                            }
                        }
                    }

                    /*
                     * saving linking informaion of Sales Invoice while linking
                     * with Delivery Order
                     */
                    HashMap<String, Object> requestParamsLinking = new HashMap<String, Object>();
                    requestParamsLinking.put("linkeddocid", deliveryOrder.getID());
                    requestParamsLinking.put("docid", invoice.getID());
                    requestParamsLinking.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                    requestParamsLinking.put("linkeddocno", entryNumber);
                    requestParamsLinking.put("sourceflag", 0);
                    KwlReturnObject result3 = accInvoiceDAOobj.saveInvoiceLinking(requestParamsLinking);


                    /*
                     * saving linking informaion of Delivery Order while linking
                     * with Sales Invoice
                     */
                    requestParamsLinking.put("linkeddocid", invoice.getID());
                    requestParamsLinking.put("docid", deliveryOrder.getID());
                    requestParamsLinking.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                    requestParamsLinking.put("linkeddocno", invoiceno);
                    requestParamsLinking.put("sourceflag", 1);
                    result3 = accInvoiceDAOobj.saveDeliveryOrderLinking(requestParamsLinking);

                }
            }
            if (isEdit == true) { //For Audit Trial-ERP-14034
                //ERP-14034 
                DateFormat sdf = authHandler.getUserDateFormatterWithoutTimeZone(paramJobj);
                if (deliveryOrder.getShipdate() != null) {
                    doDataMap.put("AuditShipDate", sdf.format(deliveryOrder.getShipdate()));  //New Ship Date
                } else {
                    doDataMap.put("AuditShipDate", "");
                }
                if (deliveryOrder.getOrderDate() != null) {
                    doDataMap.put("AuditOrderDate", sdf.format(deliveryOrder.getOrderDate()));  //New Order Date
                } else {
                    doDataMap.put("AuditOrderDate", "");
                }
            }
//            if (!isAutoCreateDO) {
            String customfield = paramJobj.optString(Constants.customfield);
            if (!StringUtil.isNullOrEmpty(customfield)) {
                JSONArray jcustomarray = new JSONArray(customfield);
                if (isAutoCreateDO) {
                    jcustomarray = fieldDataManagercntrl.getComboValueIdsForCurrentModule(jcustomarray, Constants.Acc_Delivery_Order_ModuleId, companyid, 0);            // 1= for line item
                }
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                customrequestParams.put("customarray", jcustomarray);
                customrequestParams.put("modulename", Constants.Acc_DeliveryOrder_modulename);
                customrequestParams.put("moduleprimarykey", Constants.Acc_DeliveryOrderid);
                customrequestParams.put("modulerecid", deliveryOrder.getID());
                customrequestParams.put(Constants.moduleid, isFixedAsset ? Constants.Acc_FixedAssets_DeliveryOrder_ModuleId : isConsignment ? Constants.Acc_ConsignmentDeliveryOrder_ModuleId : isLeaseFixedAsset ? Constants.Acc_Lease_DO : Constants.Acc_Delivery_Order_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("customdataclasspath", Constants.Acc_DeliveryOrder_custom_data_classpath);
                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                    doDataMap.put("accadeliveryordercustomdataref", deliveryOrder.getID());
                    KwlReturnObject accresult = accInvoiceDAOobj.updateDeliveryOrderCustomData(doDataMap);
                }
            }
            
            /*-----Forward Custom field data of DO to IST (Case: Pick-Pack-Ship only) ---------*/
            if (extraCompanyPreferences.isPickpackship() && !(deliveryOrder.isFixedAssetDO() || deliveryOrder.isLeaseDO() || deliveryOrder.isIsconsignment())) {
                HashMap<String, Object> extraparams = new HashMap<>();
                AccCustomData accCustomData = null;
                JSONArray globalCustomfield = new JSONArray();
                JSONArray lineLevelCustomfield = new JSONArray();
                String userDateFormat = paramJobj.optString(Constants.userdateformat);
                extraparams.put(Constants.companyid, companyid);
                extraparams.put(Constants.userdateformat, userDateFormat);
                extraparams.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                extraparams.put(Constants.linkModuleId, Constants.Acc_InterStore_ModuleId);

                Set<DeliveryOrderDetail> details = deliveryOrder.getRows();
                for (DeliveryOrderDetail doDetail : details) {
                    extraparams.put("dodid", doDetail.getID());

                    KwlReturnObject kwlReturnObject = accInvoiceDAOobj.getDODInterStoreMapping(extraparams);
                    List<DeliveryDetailInterStoreLocationMapping> dodistm = kwlReturnObject.getEntityList();
                    for (DeliveryDetailInterStoreLocationMapping deliveryDetailInterStoreLocationMapping : dodistm) {
                        InterStoreTransferRequest ist = deliveryDetailInterStoreLocationMapping.getInterStoreTransferRequest();

                        if (deliveryOrder.getDeliveryOrderCustomData() != null) {
                            accCustomData = deliveryOrder.getDeliveryOrderCustomData();
                            extraparams.put(Constants.customcolumn, 0); // Global Fields
                            globalCustomfield = accAccountDAOobj.createCustomFieldValueArray(accCustomData, extraparams);
                            extraparams.put(Constants.customfield, globalCustomfield.toString());
                        }

                        if (doDetail.getDeliveryOrderDetailCustomData() != null) {
                            accCustomData = doDetail.getDeliveryOrderDetailCustomData();
                            extraparams.put(Constants.customcolumn, 1); // Line Fields
                            lineLevelCustomfield = accAccountDAOobj.createCustomFieldValueArray(accCustomData, extraparams);
                            extraparams.put(Constants.LineLevelCustomData, lineLevelCustomfield.toString());
                        }

                        istService.saveGlobalAndLineLevelTransferCustomData(ist, extraparams);   // Save custom data to IST
                    }
                }
            }

       
            if (isEdit == true) {
                int moduleid = Constants.Acc_Delivery_Order_ModuleId;
                auditMessage = AccountingManager.BuildAuditTrialMessage(doDataMap, olddo, moduleid, auditKey);
            }
            newDOlist.add(deliveryOrder);
            newDOlist.add(auditMessage);

            
            /* ----Invoice Term Related Code---- */
            if (StringUtil.isAsciiString(deliveryOrderTerms)) {
                boolean isDO = true;
                Map<String, Object> termMap = new HashMap<>();
                termMap.put("invoiceterms", deliveryOrderTerms);
                termMap.put("userid", paramJobj.optString(Constants.useridKey));
                termMap.put("isdo", true);
                termMap.put("transactionid", deliveryOrder.getID());
                mapInvoiceTerms(termMap);
            }

            if (!doDetailsReturnList.isEmpty()) {
                JSONArray crmArray = (JSONArray) doDetailsReturnList.get(1);// crm array to send CRM Side for updating status of Replacement request. i.e. it is closed or open
                sendRequestToCRMForUpdatingProductReplacementStatus(paramJobj, crmArray);
            }
//                    }
            String moduleName = Constants.Delivery_Order;
            if (isLeaseFixedAsset) {
                moduleName = Constants.Lease_Delivery_Order;
            }
            if (isConsignment) {
                moduleName = Constants.moduleID_NameMap.get(Acc_ConsignmentDeliveryOrder_ModuleId);
            }
            if (isFixedAsset) {
                moduleName = Constants.Asset_Delivery_Order;
            }
            //Send Mail when Sales Order  is generated or modified.
            DocumentEmailSettings documentEmailSettings = null;
            KwlReturnObject documentEmailresult = accountingHandlerDAOobj.getObject(DocumentEmailSettings.class.getName(), paramJobj.optString(Constants.companyKey));
            documentEmailSettings = documentEmailresult != null ? (DocumentEmailSettings) documentEmailresult.getEntityList().get(0) : null;
            if (documentEmailSettings != null) {
                boolean sendmail = false;
                boolean isEditMail = false;
                if (StringUtil.isNullOrEmpty(doid)) {
                    if (isFixedAsset && documentEmailSettings.isAssetDeliveryOrderGenerationMail()) {
                        sendmail = true;
                    } else if (isLeaseFixedAsset && documentEmailSettings.isLeaseDeliveryOrderGenerationMail()) {
                        sendmail = true;
                    } //                    else if (isConsignment && documentEmailSettings.isConsignmentDOGenerationMail()) {
                    //                        sendmail = true;
                    //                    }
                    else if (documentEmailSettings.isDeleveryOrderGenerationMail()) {
                        sendmail = true;
                    }
                } else {
                    isEditMail = true;
                    if (isFixedAsset && documentEmailSettings.isAssetDeliveryOrderUpdationMail()) {
                        sendmail = true;
                    } //                    else if (isConsignment && documentEmailSettings.isConsignmentDOUpdationMail()) {
                    //                        sendmail = true;
                    //                    }
                    else if (isLeaseFixedAsset && documentEmailSettings.isLeaseDeliveryOrderUpdationMail()) {
                        sendmail = true;
                    } else if (documentEmailSettings.isDeleveryOrderUpdationMail()) {
                        sendmail = true;
                    }
                }
                 if (sendmail) {//if allow to send alert mail when option selected in companypreferences
                    String userMailId = "", userName = "",currentUserid="";
                    String createdByEmail = "";
                    String createdById = "";
                    HashMap<String, Object> requestParams = AccountingManager.getEmailNotificationParamsJson(paramJobj);
                    if (requestParams.containsKey("userfullName") && requestParams.get("userfullName") != null) {
                        userName = (String) requestParams.get("userfullName");
                    }
                    if (requestParams.containsKey("usermailid") && requestParams.get("usermailid") != null) {
                        userMailId = (String) requestParams.get("usermailid");
                    }
                    if(requestParams.containsKey(Constants.useridKey)&& requestParams.get(Constants.useridKey)!=null){
                        currentUserid=(String)requestParams.get(Constants.useridKey);
                    }
                    List<String> mailIds = new ArrayList();
                    if (!StringUtil.isNullOrEmpty(userMailId)) {
                        mailIds.add(userMailId);
                    }
                    /*
                      if Edit mail option is true then get userid and Email id of document creator.
                     */
                     if (isEditMail) {
                         if (deliveryOrder != null && deliveryOrder.getCreatedby() != null) {
                             createdByEmail = deliveryOrder.getCreatedby().getEmailID();
                             createdById = deliveryOrder.getCreatedby().getUserID();
                         }
                         /*
                          if current user userid == document creator userid then don't add creator email ID in List.
                          */
                         if (!StringUtil.isNullOrEmpty(createdByEmail) && !(currentUserid.equalsIgnoreCase(createdById))) {
                             mailIds.add(createdByEmail);
                         }
                     }
                    String[] temp = new String[mailIds.size()];
                    String[] tomailids = mailIds.toArray(temp);
                    String doNumber = entryNumber;
                    accountingHandlerDAOobj.sendSaveTransactionEmails(doNumber, moduleName, tomailids, userName, isEditMail, companyid);
                }
                if ((documentEmailSettings.isConsignmentDOGenerationMail() && !isEditMail && isConsignment) || (documentEmailSettings.isConsignmentDOUpdationMail() && isEditMail && isConsignment)) {
                    sendMailOnConsignmentDOCreationUpdation(companyid,deliveryOrder,isEditMail,documentEmailSettings,entryNumber);
                }
            }

            // Check for Multi level Approval Rules
            List approvedlevel = null;
            int approvalStatusLevel = 11;
            int level = (isEdit && !isCopy) ? 0 : deliveryOrder.getApprovestatuslevel();
            String currentUser = paramJobj.optString(Constants.useridKey);
            HashMap<String, Object> doApproveMap = new HashMap<String, Object>();
            doApproveMap.put(Constants.companyKey, companyid);
            doApproveMap.put("level", level);
            doApproveMap.put("totalAmount", String.valueOf(totalAmountInBaseCurrecy));
            doApproveMap.put("currentUser", currentUser);
            doApproveMap.put("fromCreate", true);
            doApproveMap.put("productDiscountMapList", productDiscountJArr);
            doApproveMap.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
            
                       
         /*----Declaring variable for EditedPending document-------*/
           
            JSONObject columnprefObj = new JSONObject();
            boolean sendPendingDocumentsToNextLevel = false;
            boolean ismailApplicable = false;
          
            List approvalHistoryList = null;
            String roleName = "";
            boolean isAuthorityToApprove = true;

            if (!StringUtil.isNullOrEmpty(extraCompanyPreferences.getColumnPref())) {
                columnprefObj = new JSONObject((String) extraCompanyPreferences.getColumnPref());
            }
            if (columnprefObj.has("sendPendingDocumentsToNextLevel") && columnprefObj.get("sendPendingDocumentsToNextLevel") != null && (Boolean) columnprefObj.get("sendPendingDocumentsToNextLevel") != false) {
                sendPendingDocumentsToNextLevel = true;
            }

            /*------If pending document is Edited & Check is activated from system preferences
             *---Then Edit will work same as while approving document
             */
            if (isEditedPendingDocument) {
                level = deliveryOrder.getApprovestatuslevel();
                doApproveMap.put("fromCreate", false);
                doApproveMap.put("documentLevel", level);
                if (sendPendingDocumentsToNextLevel) {

                    ismailApplicable = true;
                    doApproveMap.put("level", level);

                } else {
                    doApproveMap.put("isEditedPendingDocumentWithCheckOff", true);
                }
            }
            
            
            if (!(deliveryOrder.isFixedAssetDO() || deliveryOrder.isLeaseDO() || deliveryOrder.isIsconsignment() || deliveryOrder.isIsAutoGeneratedDO())) {// if this is a lease or fixed asset DO or consignment Dothen it will not go for approval
                doApproveMap.put(Constants.PAGE_URL, paramJobj.optString(Constants.PAGE_URL));
                approvedlevel = approveDO(deliveryOrder, doApproveMap, ismailApplicable);
                approvalStatusLevel = (Integer) approvedlevel.get(0);
                mailParams = (List) approvedlevel.get(1);
            }
            
            /*-------Block will execute , if we edit Pendig document-------- */
             if (isEditedPendingDocument) {
                 
                            

                KwlReturnObject returnObject = accountingHandlerDAOobj.getObject(Company.class.getName(), companyid);
                Company company = (Company) returnObject.getEntityList().get(0);

                if (sendPendingDocumentsToNextLevel) {
                    
                                        
                    /*-----Updating Stock & Inventory data ---------*/
                    if (approvalStatusLevel == 11) {
                        Set<DeliveryOrderDetail> doDetails = deliveryOrder.getRows();
                        List<StockMovement> stockMovementsList = new ArrayList<>();
                        for (DeliveryOrderDetail doDetail : doDetails) {
                            Product product = doDetail.getProduct();
                            if ((product != null && !deliveryOrder.isIsconsignment()) && extraCompanyPreferences.isActivateInventoryTab() && (product.isIsBatchForProduct() || product.isIslocationforproduct() || product.isIswarehouseforproduct() || product.isIsrowforproduct() || product.isIsrackforproduct() || product.isIsbinforproduct() || product.isIsSerialForProduct())) {
                                newStockMovementDeliveryOrder(doDetail, stockMovementsList);
                            }
                            Inventory inventory = doDetail.getInventory();
                            if (inventory.isInvrecord()) {
                                inventory.setBaseuomquantity(inventory.getActquantity());
                                inventory.getProduct().setAvailableQuantity(inventory.getProduct().getAvailableQuantity() - inventory.getBaseuomquantity());
                                inventory.setActquantity(0.0);
                            }
                        }

                        if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateInventoryTab() && !stockMovementsList.isEmpty()) {
                            stockMovementService.addOrUpdateBulkStockMovement(deliveryOrder.getCompany(), deliveryOrder.getID(), stockMovementsList);
                        }
                        /*
                         * Post free gift JE for free gift type DO
                         */
                        if (Integer.parseInt(deliveryOrder.getCompany().getCountry().getID()) == (Constants.malaysian_country_id)) {
                            paramJobj.put("approvalStatusLevel", approvalStatusLevel);
                            postJEForFreeGiftDo(paramJobj, deliveryOrder);
                        }
                    }
                    

                    /*----Send mail if allowed from system preferences------- */
                    if (approvalStatusLevel != Constants.NoAuthorityToApprove && preferences.isSendapprovalmail()) { // If allow to send approval mail in company account preferences

                        HashMap emailMap = new HashMap();
                        String userName = paramJobj.optString(Constants.username, null);
                        emailMap.put("userName", userName);

                        emailMap.put("company", company);
                        emailMap.put("deliveryOrder", deliveryOrder);
                        emailMap.put("baseUrl", paramJobj.optString("baseUrl", null));
                        emailMap.put("preferences", preferences);

                        sendApprovalMailForDOIfAllowedFromSystemPreferences(emailMap);

                    }

                    /*--------Save Approval history Code--------  */
                    if (approvalStatusLevel != Constants.NoAuthorityToApprove) {

                        HashMap approvalHistoryMap = new HashMap();
                        String userid = paramJobj.optString(Constants.userid, null);
                        approvalHistoryMap.put("userid", userid);

                        approvalHistoryMap.put("company", company);
                        approvalHistoryMap.put("deliveryOrder", deliveryOrder);

                        approvalHistoryList = saveApprovalHistoryForDeliveryOrder(approvalHistoryMap);
                        roleName = approvalHistoryList != null ? approvalHistoryList.get(0).toString() : "";

                    } else if (approvalStatusLevel == Constants.NoAuthorityToApprove) {
                        /*----If User have no authority to approve------*/
                        isAuthorityToApprove = false;
                    }
                } else if (approvalStatusLevel == Constants.NoAuthorityToApprove) {//If User is not authorised to approve
                    isAuthorityToApprove = false;
                }
            }

            
            
            
            newDOlist.add(approvalStatusLevel);
            newDOlist.add(mailParams);
            newDOlist.add(linkedDocuments);
            newDOlist.add(unlinkMessage);
            newDOlist.add(roleName);
            newDOlist.add(isAuthorityToApprove);
            newDOlist.add(sendPendingDocumentsToNextLevel);
            newDOlist.add(level);
        } catch (AccountingException ex) {
            throw new AccountingException(ex.getMessage());
        } catch (ScriptException ex) {
            throw ServiceException.FAILURE("saveDeliveryOrder : " + ex.getCause().getMessage(), ex);
        } catch (MessagingException ex) {
            throw ServiceException.FAILURE("saveDeliveryOrder : " + ex.getCause().getMessage(), ex);
        } catch (ParseException ex) {
            throw ServiceException.FAILURE("saveDeliveryOrder : " + ex.getCause().getMessage(), ex);
        }
        return newDOlist;
    }
    
    private void deleteAvalaraTaxMappingForDO(Set<DeliveryOrderDetail> doDetailsobj) throws JSONException, ServiceException {
        List doDetailIDsList = new ArrayList<String>();
        for (DeliveryOrderDetail temObj : doDetailsobj) {
            doDetailIDsList.add(temObj.getID());
        }
        if (!doDetailIDsList.isEmpty()) {
            //to create a comma separated string of SalesOrderDetail IDs for 'IN' subquery
            String doDetailIDsStr = org.springframework.util.StringUtils.collectionToDelimitedString(doDetailIDsList, ",", "'", "'");
            JSONObject avalaraTaxDeleteJobj = new JSONObject();
            avalaraTaxDeleteJobj.put(IntegrationConstants.parentRecordID, doDetailIDsStr);
            integrationCommonService.deleteTransactionDetailTaxMapping(avalaraTaxDeleteJobj);
        }
    }

    public List saveDeliveryOrderRows(JSONObject paramJobj, DeliveryOrder deliveryOrder, String companyid, boolean isAutoCreateDO, String invoiceid, Set<JournalEntryDetail> inventoryJEDetails, String inventoryJEid, HashMap<String, Object> pbuildMap) throws ServiceException, AccountingException, SessionExpiredException, ParseException, UnsupportedEncodingException, ScriptException {
        List returnList = new ArrayList();
        HashSet rows = new HashSet();
        JSONArray crmJsonArray = new JSONArray();
        try {
            JSONArray jArr = new JSONArray(paramJobj.optString(Constants.detail,"[]"));
            boolean isFromContract=paramJobj.optBoolean("isFromContract",false);
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            KwlReturnObject extracap = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extracap.getEntityList().get(0);
            //ERP-34970(ERM-534)
            String countryid = extraCompanyPreferences.getCompany().getCountry().getID();
            boolean RCMApplicable = paramJobj.optBoolean("GTAApplicable",false);
            boolean isFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isFixedAsset", null))) ? Boolean.parseBoolean(paramJobj.getString("isFixedAsset")) : false;
            boolean isLeaseFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isLeaseFixedAsset", null))) ? Boolean.parseBoolean(paramJobj.getString("isLeaseFixedAsset")) : false;
            boolean isConsignment = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment, null))) ? Boolean.parseBoolean(paramJobj.getString(Constants.isConsignment)) : false;
            boolean isFromVendorConsign = false;
            boolean isLinkedWithInvoice = false;
            boolean isLock = false;
            boolean isbatchlockedinSO = false;
            boolean isSeriallockedinSO = false;
            double lock_Quantity = 0;   // SO Lock Quantity

            HashMap<String, Object> GlobalParams = AccountingManager.getGlobalParamsJson(paramJobj);
            boolean isEdit = StringUtil.isNullOrEmpty(paramJobj.optString("isEdit", null)) ? false : Boolean.parseBoolean(paramJobj.optString("isEdit"));
            Map<String, List<TransactionBatch>> priceValuationMap = new HashMap<>();
            if (isAutoCreateDO) {
                if (!StringUtil.isNullOrEmpty(invoiceid)) {
                    HashMap<String, Object> invRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList();
                    filter_names.add("invoice.ID");
                    invRequestParams.put("filter_names", filter_names);
                    invRequestParams.put("filter_params", filter_params);
                    filter_params.clear();
                    filter_params.add(invoiceid);
                    KwlReturnObject idresult = accInvoiceDAOobj.getInvoiceDetails(invRequestParams);
                    Iterator itr = idresult.getEntityList().iterator();
                    int index = 0;
                    while (itr.hasNext()) {
                        InvoiceDetail row = (InvoiceDetail) itr.next();
                        jArr.getJSONObject(index).put("rowid", row.getID());
                        index++;
                    }

                }
            }

            HashSet<String> productReplacementIds = new HashSet<String>();
            List<StockMovement> stockMovementsList = new ArrayList<StockMovement>();
            List<InterStoreTransferRequest> interStoreTransferList = new ArrayList<InterStoreTransferRequest>();
            Set<String> productNameRCMNotActivate = new HashSet<String>();
            int count=0;
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jobj = jArr.getJSONObject(i);
                HashMap<String, Object> dodDataMap = new HashMap<String, Object>();
                if(extraCompanyPreferences.isPickpackship() && jobj.optString(Constants.type,"").equalsIgnoreCase("Service")){
                 count++;
                 if(count==jArr.length()){
                     Map<String, Object> map = new HashMap<String, Object>();
                     map.put("deliveryOrder", deliveryOrder);
                     map.put("companyid", companyid);
                     accInvoiceDAOobj.updateDeliveryOrderStatus(map);
                 }
                }
                               
                if (extraCompanyPreferences.isPickpackship() && !(isConsignment || isLeaseFixedAsset || isFixedAsset) && !(jobj.getString(Constants.type).equalsIgnoreCase("Service") || StringUtil.decodeString(jobj.getString(Constants.type)).equalsIgnoreCase("Non-Inventory Part"))){
                    if(!jobj.getBoolean("isLocationForProduct") && !jobj.getBoolean("isWarehouseForProduct")) {
                        throw new AccountingException("Location and Warehouse is not active for product : "+ jobj.getString("pid") );
                    } else if (!jobj.getBoolean("isLocationForProduct")){
                        throw new AccountingException("Location is not active for product : "+ jobj.getString("pid") );
                    } else if (!jobj.getBoolean("isWarehouseForProduct")){
                        throw new AccountingException("Warehouse is not active for product : "+ jobj.getString("pid") );
                    }
                }
                
                if (jobj.has("srno")) {
                    dodDataMap.put("srno", jobj.getInt("srno"));
                }

                dodDataMap.put(Constants.companyKey, companyid);
                dodDataMap.put("doid", deliveryOrder.getID());
                dodDataMap.put(Constants.productid, jobj.getString(Constants.productid));

                if (jobj.has("priceSource") && jobj.get("priceSource") != null) {
                    dodDataMap.put("priceSource", !StringUtil.isNullOrEmpty(jobj.optString("priceSource")) ? StringUtil.DecodeText(jobj.optString("priceSource")) : "");
                }
                if (jobj.has("pricingbandmasterid") && jobj.get("pricingbandmasterid") != null) {
                    dodDataMap.put("pricingbandmasterid", !StringUtil.isNullOrEmpty(jobj.optString("pricingbandmasterid")) ? StringUtil.DecodeText(jobj.optString("pricingbandmasterid")) : "");
                }

                String linkMode = paramJobj.optString("fromLinkCombo");
                String description = "";
                double baseuomrate = 1;
                double quantity = authHandler.roundQuantity((jobj.getDouble("quantity")), companyid);
                double dquantity = 0;
                if (jobj.has("isFromVendorConsign") && jobj.get("isFromVendorConsign") != null) {
                    isFromVendorConsign = jobj.optBoolean("isFromVendorConsign", false);
                }
                if (jobj.has("baseuomrate") && jobj.get("baseuomrate") != null) {
                    baseuomrate = jobj.optDouble("baseuomrate", 1);
                }
                
                if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                    if (jobj.has("uomname")) {
                        dodDataMap.put("uomid", jobj.getString("uomname"));
                    }
                } else {
                    if (jobj.has("uomid")) {
                        dodDataMap.put("uomid", jobj.getString("uomid"));
                    }
                }
                
                if (isAutoCreateDO) {
                    dquantity = quantity;
                    description = jobj.optString("desc");
                    dodDataMap.put("description", description);
                    dodDataMap.put("deliveredquantity", dquantity);
                    dodDataMap.put("baseuomdeliveredquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                    dodDataMap.put("partno", "");
                    linkMode = paramJobj.optString(Constants.fromLinkComboAutoDO);
                } else {
                    if (isFromContract) {
                        /**
                         * In case of DO created with Contract
                         */
                        dquantity = quantity;
                    } else {
                        dquantity = authHandler.roundQuantity((jobj.optDouble("dquantity")), companyid);
                    }
                    description = jobj.optString("description");
                    dodDataMap.put("description", description);
                    dodDataMap.put("deliveredquantity", dquantity);
                    dodDataMap.put("baseuomdeliveredquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                    dodDataMap.put("partno", jobj.optString("partno"));
                }
                dodDataMap.put("baseuomrate", baseuomrate);
                dodDataMap.put("baseuomquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                dodDataMap.put("quantity", quantity);
                dodDataMap.put("remark", jobj.optString("remark"));
                dodDataMap.put("reason", jobj.optString("reason"));
                String dodbom = "";
                if (!StringUtil.isNullOrEmpty(jobj.optString("bomid"))) {
                    dodDataMap.put("bomid", jobj.optString("bomid"));
                    dodbom = jobj.optString("bomid");                //bomcode id if user select bomcode while saving DO
                }
                dodDataMap.put("reason", jobj.optString("reason"));

//                if (preferences.isInventoryAccountingIntegration() && preferences.isWithInvUpdate() && preferences.isUpdateInvLevel()) {
                if (!StringUtil.isNullOrEmpty(jobj.optString("invstore"))) {
                    dodDataMap.put("invstoreid", jobj.optString("invstore"));
                } else {
                    dodDataMap.put("invstoreid", "");
                }
                if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                    dodDataMap.put("invlocationid", jobj.optString("invlocation"));
                } else {
                    dodDataMap.put("invlocationid", "");
                }

                String rowtaxid = "";
                if (!StringUtil.isNullOrEmpty(jobj.optString("prtaxid", null)) && jobj.optString("prtaxid").equalsIgnoreCase("None")) {
                    rowtaxid = null;
                } else {
                    rowtaxid = jobj.optString("prtaxid", null);
                }
                if (!StringUtil.isNullOrEmpty(rowtaxid)) {
                    boolean taxExist = false;
                    KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), rowtaxid); // (Tax)session.get(Tax.class, taxid);
                    Tax rowtax = (Tax) txresult.getEntityList().get(0);
                    double rowtaxamountFromJS = jobj.optDouble("taxamount", 0);

                    if (rowtax == null) {
                        throw new AccountingException("The Tax code(s) used in this transaction has been deleted.");//messageSource.getMessage("acc.so.taxcode", null, RequestContextUtils.getLocale(request)));
                    } else {
                        dodDataMap.put("prtaxid", rowtaxid);
                        dodDataMap.put("taxamount", rowtaxamountFromJS);
                        dodDataMap.put(Constants.isUserModifiedTaxAmount, jobj.optBoolean(Constants.isUserModifiedTaxAmount, false));
                    }
                }
                if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {//Mobile Application
                    if (jobj.has("discount")) {
                        dodDataMap.put("discount", jobj.optDouble("discount", 0));
                    }
                    if (jobj.has("discountType")) {
                        dodDataMap.put("discountispercent", jobj.optInt("discountType", 1));
                    }
                } else {
                    if (jobj.has("prdiscount") && jobj.get("prdiscount") != null) {
                        dodDataMap.put("discount", jobj.optDouble("prdiscount", 0));
                    }
                    if (jobj.has("discountispercent") && jobj.get("discountispercent") != null) {
                        dodDataMap.put("discountispercent", jobj.optInt("discountispercent", 1));
                    }
                    if (jobj.has("discountjson")) {
                        String discountjson = jobj.optString("discountjson", "");
                        discountjson = !StringUtil.isNullOrEmpty(discountjson) ? StringUtil.decodeString(discountjson) : "";
                        dodDataMap.put("discountjson", discountjson);
                    }
                }


                if (jobj.has("isFromVendorConsign") && jobj.get("isFromVendorConsign") != null) {
                    dodDataMap.put("isFromVendorConsign", jobj.optBoolean("isFromVendorConsign", false));
                }
                String linkto = jobj.optString("linkto");
                if (isEdit) {
                    /*
                     * If we linking document (that was already linked with
                     * another document) in Edit mode i.e linking SO->DO then linkto is setting
                     * same as while creating document because it is same as
                     * while creating new document by linking
                     *
                     */
                    if ((!StringUtil.isNullOrEmpty(jobj.optString("savedrowid",null)))) {
                        if (linkMode.equalsIgnoreCase("Sales Order")||linkMode.equalsIgnoreCase("Request")) {
                            KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), jobj.getString("savedrowid"));
                            SalesOrderDetail sodetails = (SalesOrderDetail) rdresult.getEntityList().get(0);
                            if (sodetails == null || StringUtil.isNullObject(sodetails)) {
                                linkto = "";
                            }
                        }
                    }
                }
                KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                Product product = (Product) proresult.getEntityList().get(0);
                 /**
                  * //ERP-34970(ERM-534)
                 * IF Invoice is RCM Applicable and Product is not RCM
                 * Applicable
                 */
                if (Integer.parseInt(countryid) == Constants.indian_country_id && RCMApplicable) {
                    if (product != null && !product.isRcmApplicable()) {
                        productNameRCMNotActivate.add(product.getName());
                        //throw new AccountingException(messageSource.getMessage("acc.common.rcmforproductnotactivated.DO.text", new Object[]{product.getName()}, null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    }
                }
                if (!StringUtil.isNullOrEmpty(linkMode)) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER) || linkMode.equalsIgnoreCase("Lease Order") || linkMode.equalsIgnoreCase("Consignment Request") || linkMode.equalsIgnoreCase("Request")
                            || linkMode.equalsIgnoreCase("Job Work Order")) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(linkto)) ? jobj.getString("rowid") : jobj.getString("savedrowid")); //for link
                        SalesOrderDetail sod = (SalesOrderDetail) rdresult.getEntityList().get(0);
                        if (sod != null) {
                            dodDataMap.put("SalesOrderDetail", sod);
                            String sodid = sod.getID();
                            double soLockQuantity = sod.getLockquantity();
                            double soLockQuantitydue = sod.getLockquantitydue();
                            double lockQuantity = 0;
                            lock_Quantity = 0;
                            Product sodProductid = sod.getProduct();  //get the product of salesorderdetail
                            if ((authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid)) >= soLockQuantity) {  //if delivered quantity is greater than salesorder lock quantity then we have lock quantity only of SO
                                lockQuantity = soLockQuantity;
                            } else {

                                lockQuantity = soLockQuantity - dquantity;  //if delivered quantity is less than lock quantity then we have lock quantity of total lock in so- deliverd

                                lockQuantity = soLockQuantity - (authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));  //if delivered quantity is less than lock quantity then we have lock quantity of total lock in so- deliverd

                            }
                            lock_Quantity = lockQuantity;
                            isLock = accInvoiceDAOobj.getSalesorderStatus(sod.getSalesOrder().getSalesOrderNumber(), companyid);   //get sales order status whether is locked or not
                            if (!StringUtil.isNullOrEmpty(sodid)) {
                                isbatchlockedinSO = accInvoiceDAOobj.getSalesorderBatchStatus(sodid, companyid);   //get sales order status whether is locked or not
                            }
                            if (!StringUtil.isNullOrEmpty(sodid)) {
                                isSeriallockedinSO = accInvoiceDAOobj.getSalesorderSerialStatus(sodid, companyid);   //get sales order status whether is locked or not
                            }
                            if (isLock) {
                                if (sodProductid.getProducttype().getID().equals(Producttype.ASSEMBLY)) {   //check type of product if assembly type of product is there then update quantity in assemby lock quantity for its sub products
                                    KwlReturnObject result2 = accInvoiceDAOobj.getAssemblySubProductList(sodProductid.getID());
                                    List list = result2.getEntityList();
                                    Iterator itr = list.iterator();
                                    while (itr.hasNext()) {
                                        Object[] oj = (Object[]) itr.next();
                                        String assmblyid = oj[0].toString();
                                        accInvoiceDAOobj.updateAssemblyLockQuantity(assmblyid, lockQuantity);  //update the quantity for assbley auantity if its delivered

                                    }
                                }
                                if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                                    if (soLockQuantity > 0 && lockQuantity <= soLockQuantity) {
                                        accInvoiceDAOobj.updateSOLockQuantity(sodid, (authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid)), companyid);  //updte salesorder lock  quntity for all type of products
                                    }
                                    if (soLockQuantitydue > 0 && lockQuantity <= soLockQuantitydue) {
                                        accCommonTablesDAO.updateSOLockQuantitydue(sodid, (authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid)), companyid);
                                    }
                                } else {
                                    if (soLockQuantity > 0 && lockQuantity <= soLockQuantity) {
                                        accInvoiceDAOobj.updateSOLockQuantity(sodid, (authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid)), companyid);  //updte salesorder lock  quntity for all type of products
                                    }
                                    if (soLockQuantitydue > 0 && lockQuantity <= soLockQuantitydue) {
                                        accCommonTablesDAO.updateSOLockQuantitydue(sodid, (authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid)), companyid);
                                    }
                                }
                            }
                            /* Function is being use to update balance quantity of SO, Commented because It was already handled */
//                                accCommonTablesDAO.updateSOBalQuantity(sodid, dquantity, companyid);
//                            }

//                            if (isLeaseFixedAsset) {
                            if (sod.getProductReplacementDetail() != null) {
                                // update status of Product Replacement request status for each quantity as well as for over all request.
                                ProductReplacementDetail productReplacementDetail = sod.getProductReplacementDetail();

                                makeProductReplacementIdsSetAndupdateProductReplacementDetails(productReplacementDetail, productReplacementIds, companyid, dquantity);

                            } else if (sod.getQuotationDetail() != null && sod.getQuotationDetail().getProductReplacementDetail() != null) {// is so is created by linking with lease quotation and lease quotation is created by linking with product replacement.
                                // update status of Product Replacement request status for each quantity as well as for over all request.
                                ProductReplacementDetail productReplacementDetail = sod.getQuotationDetail().getProductReplacementDetail();

                                makeProductReplacementIdsSetAndupdateProductReplacementDetails(productReplacementDetail, productReplacementIds, companyid, dquantity);
                            }
                        }

                    } else if (linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase(Constants.CUSTOMER_INVOICE)) {
                        isLinkedWithInvoice = true;
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(InvoiceDetail.class.getName(), jobj.getString("rowid"));
                        InvoiceDetail id = (InvoiceDetail) rdresult.getEntityList().get(0);
                        if (id != null) {
                            dodDataMap.put("InvoiceDetail", id);
                            /*
                            IF Invoice Created from Job Work Order then copy BOM code from Sales Order Details when user not select any bom while saving DO
                            */
                            if(id.getSalesorderdetail()!=null && id.getSalesorderdetail().getBomcode()!=null && StringUtil.isNullOrEmpty(dodbom)){
                                String bomid=id.getSalesorderdetail().getBomcode().getID();
                                dodDataMap.put("bomid", bomid);
                            }
                            /**
                             * ERP-31126 Need to handle block quantity case for
                             * SO -> SI -> DO. For Example, Product Initial
                             * Quantity = 10 Sales Order = 2 (Block Quantity)
                             * [Product Available Quantity = 8, Block Quantity =
                             * 2] Create Sales Invoice by linking Sales Order
                             * [Product Available Quantity = 8, Block Quantity =
                             * 2] Create Delivery Order by linking Sales Invoice
                             * [Product Available Quantity = 8, Block Quantity =
                             * 0]
                             */
                            if (id.getSalesorderdetail() != null) { //  SO->SI->DO Block Quantity
                                SalesOrderDetail sod = id.getSalesorderdetail();
                                String sodid = sod.getID();
                                double soLockQuantity = sod.getLockquantity();
                                double soLockQuantitydue = sod.getLockquantitydue();
                                double lockQuantity = 0;
                                lock_Quantity = 0;
                                Product sodProductid = sod.getProduct();  //get the product of salesorderdetail
                                if ((authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid)) >= soLockQuantity) {  //if delivered quantity is greater than salesorder lock quantity then we have lock quantity only of SO
                                    lockQuantity = soLockQuantity;
                                } else {
                                    lockQuantity = soLockQuantity - dquantity;  //if delivered quantity is less than lock quantity then we have lock quantity of total lock in so- deliverd
                                    lockQuantity = soLockQuantity - (authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));  //if delivered quantity is less than lock quantity then we have lock quantity of total lock in so- deliverd
                                }
                                lock_Quantity = lockQuantity;
                                isLock = accInvoiceDAOobj.getSalesorderStatus(sod.getSalesOrder().getSalesOrderNumber(), companyid);   //get sales order status whether is locked or not
                                if (!StringUtil.isNullOrEmpty(sodid)) {
                                    isbatchlockedinSO = accInvoiceDAOobj.getSalesorderBatchStatus(sodid, companyid);   //get sales order status whether is locked or not
                                }
                                if (!StringUtil.isNullOrEmpty(sodid)) {
                                    isSeriallockedinSO = accInvoiceDAOobj.getSalesorderSerialStatus(sodid, companyid);   //get sales order status whether is locked or not
                                }
                                if (isLock) {
                                    if (sodProductid.getProducttype().getID().equals(Producttype.ASSEMBLY)) {   //check type of product if assembly type of product is there then update quantity in assemby lock quantity for its sub products
                                        KwlReturnObject result2 = accInvoiceDAOobj.getAssemblySubProductList(sodProductid.getID());
                                        List list = result2.getEntityList();
                                        Iterator itr = list.iterator();
                                        while (itr.hasNext()) {
                                            Object[] oj = (Object[]) itr.next();
                                            String assmblyid = oj[0].toString();
                                            accInvoiceDAOobj.updateAssemblyLockQuantity(assmblyid, lockQuantity);  //update the quantity for assbley auantity if its delivered
                                        }
                                    }
                                    if (soLockQuantity > 0 && lockQuantity <= soLockQuantity) {
                                        accInvoiceDAOobj.updateSOLockQuantity(sodid, (authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid)), companyid);  //updte salesorder lock  quntity for all type of products
                                    }
                                    if (soLockQuantitydue > 0 && lockQuantity <= soLockQuantitydue) {
                                        accCommonTablesDAO.updateSOLockQuantitydue(sodid, (authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid)), companyid);
                                    }
                                }
                            }
                            JSONArray listDeferred = paramJobj.has("listDeferred") ? paramJobj.optJSONArray("listDeferred") :new JSONArray();
                          if ((!StringUtil.isNullOrEmpty(paramJobj.optString("jeid"))) && extraCompanyPreferences != null && extraCompanyPreferences.isDeferredRevenueRecognition() && (listDeferred.length()>0 || isAutoCreateDO)) {    
                                String jeid = (String) paramJobj.optString("jeid");
                                if (id.getDeferredJeDetailId() != null && product.isRevenueRecognitionProcess()) {

                                    KwlReturnObject resultJeDeffered = accountingHandlerDAOobj.getObject(JournalEntryDetail.class.getName(), id.getDeferredJeDetailId());
                                    JournalEntryDetail journalEntryDetail = (JournalEntryDetail) resultJeDeffered.getEntityList().get(0);
                                    JSONObject jedjson = new JSONObject();
                                    jedjson.put("srno",1);
                                    jedjson.put(Constants.companyKey, companyid);
                                    jedjson.put("amount", journalEntryDetail.getAmount());
                                    jedjson.put("accountid", journalEntryDetail.getAccount() != null ? journalEntryDetail.getAccount().getID() : (product.getSalesAccount() != null ? product.getSalesAccount().getID() : extraCompanyPreferences.getSalesAccount()));
                                    jedjson.put("debit", true);
                                    jedjson.put("jeid", jeid);
                                    KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                    JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);

                                    jedjson.put("srno", 2);
                                    jedjson.put(Constants.companyKey, companyid);
                                    jedjson.put("amount", journalEntryDetail.getAmount());
                                    jedjson.put("accountid", product.getSalesRevenueRecognitionAccount() != null ? product.getSalesRevenueRecognitionAccount().getID() : extraCompanyPreferences.getSalesRevenueRecognitionAccount());
                                    jedjson.put("debit", false);
                                    jedjson.put("jeid", jeid);
                                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                }
                            }

                            SalesOrderDetail sod = id.getSalesorderdetail();

                            if (sod != null && sod.getProductReplacementDetail() != null) {
                                // update status of Product Replacement request status for each quantity as well as for over all request.
                                ProductReplacementDetail productReplacementDetail = sod.getProductReplacementDetail();

                                makeProductReplacementIdsSetAndupdateProductReplacementDetails(productReplacementDetail, productReplacementIds, companyid, dquantity);

                            } else if (sod != null && sod.getQuotationDetail() != null && sod.getQuotationDetail().getProductReplacementDetail() != null) {// is so is created by linking with  replacement quotation and  quotation is created by linking with product replacement.
                                // update status of Product Replacement request status for each quantity as well as for over all request.
                                ProductReplacementDetail productReplacementDetail = sod.getQuotationDetail().getProductReplacementDetail();

                                makeProductReplacementIdsSetAndupdateProductReplacementDetails(productReplacementDetail, productReplacementIds, companyid, dquantity);
                            }

                        }
                    }
                }
                double venQty = 0;
                String batchDetails = null;
                boolean isForPOS= paramJobj.optBoolean(Constants.isForPos);
                if (jobj.has("batchdetails") && jobj.getString("batchdetails") != null && !StringUtil.isNullOrEmpty(jobj.optString("batchdetails"))) {
                    batchDetails = jobj.optString("batchdetails","[]");
                    if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true && product.isIsBatchForProduct() && product.isIsSerialForProduct()) {
                        JSONObject jsobj = accProductModuleService.manipulateBatchDetailsforMobileApps(batchDetails, jobj.getString(Constants.productid), paramJobj);
                        if (jsobj.get("batchdetails") != null && !StringUtil.isNullOrEmpty(jsobj.optString("batchdetails", null))) {
                            batchDetails = jsobj.getString("batchdetails");
                        }
                    }
                } else if(isForPOS && StringUtil.isNullOrEmpty(jobj.optString("batchdetails",null)) && paramJobj.optBoolean(Constants.isdefaultHeaderMap, false)){
                         jobj =buildBatchSerialJson(paramJobj, jobj,product);
                         batchDetails = jobj.optString("batchdetails","[]");
                }else if ((jobj.has("batchdetails") && StringUtil.isNullOrEmpty(jobj.optString("batchdetails")) && !product.isAsset()) && (product.isIslocationforproduct() || product.isIswarehouseforproduct() || product.isIsBatchForProduct() || product.isIsSerialForProduct()) && !(product.getProducttype().getID().equals(Producttype.SERVICE) || product.getProducttype().getID().equals(Producttype.NON_INVENTORY_PART))) {
                    throw new AccountingException("Batch details are not valid");
                }
                
                
                if (!isConsignment && jobj.has("batchdetails") && jobj.optString("batchdetails",null) != null && !"".equals(jobj.optString("batchdetails",null))) {
                    JSONArray batchDtJArr = new JSONArray(batchDetails);
                    for (int j = 0; j < batchDtJArr.length(); j++) {
                        JSONObject jsnObj = batchDtJArr.getJSONObject(j);
                        double qty = (jsnObj.has("quantity") && !StringUtil.isNullOrEmpty(jsnObj.getString("quantity"))) ? jsnObj.getDouble("quantity") : 0;
                        venQty += (jsnObj.has("stocktype") && "0".equals(jsnObj.getString("stocktype"))) ? qty : 0;
                    }
                }
                JSONObject inventoryjson = new JSONObject();
                inventoryjson.put(Constants.productid, jobj.getString(Constants.productid));
                inventoryjson.put("quantity", dquantity - venQty);
                inventoryjson.put("description", description);
                
                if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                    if (jobj.has("uomname")) {
                        inventoryjson.put("uomid", jobj.getString("uomname"));
                    }
                } else {
                    if (jobj.has("uomid")) {
                        inventoryjson.put("uomid", jobj.getString("uomid"));
                    }
                }
                
                if (isLeaseFixedAsset) {
                    inventoryjson.put("leaseFlag", isLeaseFixedAsset);
                }
                if (isConsignment) {
                    inventoryjson.put("consignuomquantity", dquantity * baseuomrate);
                    inventoryjson.put(Constants.isConsignment, isConsignment);
                }
                if (isFromVendorConsign) {
                    inventoryjson.put("venconsignuomquantity", -(dquantity * baseuomrate));
                } else if (venQty > 0 && !isConsignment) {
                    inventoryjson.put("venconsignuomquantity", -(venQty * baseuomrate));
                    inventoryjson.put("baseuomquantity", authHandler.calculateBaseUOMQuatity((dquantity - venQty), baseuomrate, companyid));
                } else {
                    if (extraCompanyPreferences.isPickpackship() && !(deliveryOrder.isIsconsignment() || deliveryOrder.isLeaseDO())) {
                        inventoryjson.put("baseuomquantity", 0);
                    } else {
                        inventoryjson.put("baseuomquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                    }
                }
                if (jobj.has("productweightperstockuom")) {
                    inventoryjson.put("productweightperstockuom", jobj.optDouble("productweightperstockuom", 0));
                }
                if (jobj.has("productweightincludingpakagingperstockuom")) {
                    inventoryjson.put("productweightincludingpakagingperstockuom", jobj.optDouble("productweightincludingpakagingperstockuom", 0));
                }
                if (jobj.has("productvolumeperstockuom")) {
                    inventoryjson.put("productvolumeperstockuom", jobj.optDouble("productvolumeperstockuom", 0));
                }
                if (jobj.has("productvolumeincludingpakagingperstockuom")) {
                    inventoryjson.put("productvolumeincludingpakagingperstockuom", jobj.optDouble("productvolumeincludingpakagingperstockuom", 0));
                }
                inventoryjson.put("baseuomrate", baseuomrate);
                inventoryjson.put("carryin", false);
                inventoryjson.put("defective", false);
                inventoryjson.put("newinventory", false);
                inventoryjson.put(Constants.companyKey, companyid);
                if (extraCompanyPreferences.isPickpackship() && !(deliveryOrder.isFixedAssetDO() || deliveryOrder.isLeaseDO() || deliveryOrder.isIsconsignment()) ) {
                    /**
                     * pick pack status =Pick
                     */ 
                    inventoryjson.put("pickpackstatus", 1);
                    /**
                     * For Auto assembly product with pick pack DO don't decrease qty from product master as qty is shifted to Packing Store.
                     */
                    if (product != null && product.getProducttype().getID().equalsIgnoreCase(Constants.ASSEMBLY)) {
                        inventoryjson.put("baseuomquantity", 0);  
                        inventoryjson.put("actquantity", 0);  
                        inventoryjson.put("quantity", 0);  
                    }
                } else {
                    /**
                     * pick pack status =Ship
                     */

                    inventoryjson.put("pickpackstatus", 3);
                }
                inventoryjson.put("updatedate", authHandler.getDateOnlyFormatter(paramJobj).parse(paramJobj.optString(Constants.BillDate)));
                KwlReturnObject invresult = accProductObj.addInventory(inventoryjson);
                Inventory inventory = (Inventory) invresult.getEntityList().get(0);
                boolean sendForQAApproval=paramJobj.optBoolean("sendForQAApproval",false);
                /**
                 * Adding product.isQaenable() check so that JE detail is not created for product whose QA approval flow is on in product master as that product is sent for QA approval. ERM-801
                 */
                if (!StringUtil.isNullOrEmpty(inventoryJEid) && !(product.getProducttype().getID().equals(Producttype.SERVICE) || product.getProducttype().getID().equals(Producttype.NON_INVENTORY_PART) || product.getProducttype().getID().equals(Producttype.Inventory_Non_Sales)) && !(product.isQaenable() && sendForQAApproval)) {
                    if (extraCompanyPreferences != null && !extraCompanyPreferences.isPickpackship()  && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) {
                        try {
                            if (product != null && product.getInventoryAccount() != null && product.getCostOfGoodsSoldAccount() != null) {
                                HashMap<String, Object> requestMap = new HashMap<>();
                                requestMap.put(Constants.productid, jobj.getString(Constants.productid));
                                requestMap.put("productId", jobj.getString(Constants.productid));
                                requestMap.put(Constants.companyKey, companyid);
                                requestMap.put(Constants.df, authHandler.getDateOnlyFormat());
                                requestMap.put(Constants.globalCurrencyKey, paramJobj.optString(Constants.globalCurrencyKey));
                                requestMap.put("GlobalParams", GlobalParams);
                                requestMap.put(Constants.REQ_enddate, paramJobj.optString(Constants.BillDate));
                                requestMap.put("dquantity", authHandler.calculateBaseUOMQuatity(dquantity, baseuomrate, companyid));
                                Map<String, Double> batchQuantityMap = new HashMap<>();
                                if (jobj.has("batchdetails") && jobj.get("batchdetails") != null && !StringUtil.isNullOrEmpty(jobj.get("batchdetails").toString())) {
                                    String batchSerialIds = getBatchSerialIDs(batchDetails, product, batchQuantityMap);
                                    if (!StringUtil.isNullOrEmpty(batchSerialIds)) {
                                        requestMap.put("batchSerialId", batchSerialIds.split(","));
                                    }
                                }
//                                double valuation = getValuationForDOAndSR(requestMap, priceValuationMap, batchQuantityMap); 
                                double valuation = 0; //it will be calculated via aop, so removed the valuation from here.
                                // Accrued Purchase Account
                                JSONObject jedjson = new JSONObject();
                                jedjson = new JSONObject();
                                jedjson.put("srno", inventoryJEDetails.size() + 1);
                                jedjson.put(Constants.companyKey, companyid);
                                jedjson.put("amount", valuation);
                                jedjson.put("accountid", product.getCostOfGoodsSoldAccount() != null ? product.getCostOfGoodsSoldAccount().getID() : "");
                                jedjson.put("debit", true);
                                jedjson.put("jeid", inventoryJEid);
                                KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                dodDataMap.put("cogsjedetailid", jed.getID());
                                inventoryJEDetails.add(jed);
                                // Inventory Account
                                jedjson.put("srno", inventoryJEDetails.size() + 1);
                                jedjson.put(Constants.companyKey, companyid);
                                jedjson.put("amount", valuation);
                                jedjson.put("accountid", product.getInventoryAccount() != null ? product.getInventoryAccount().getID() : "");
                                jedjson.put("debit", false);
                                jedjson.put("jeid", inventoryJEid);
                                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                dodDataMap.put("inventoryjedetailid", jed.getID());
                                inventoryJEDetails.add(jed);
                            }
                        } catch (Exception ex) {
                            Logger.getLogger(accInvoiceController.class.getName()).log(Level.WARNING, ex.getMessage());
                        }
                    }
                }
                dodDataMap.put("Inventory", inventory);
                if (jobj.has("rate")) {
                    dodDataMap.put("rate", jobj.getString("rate"));
                }
                if (jobj.has("rateIncludingGst")) {
                    dodDataMap.put("rateIncludingGst", jobj.optString("rateIncludingGst","0"));
                }
                if (!StringUtil.isNullOrEmpty(jobj.optString("recTermAmount"))) {
                    dodDataMap.put("recTermAmount", jobj.optString("recTermAmount"));
                }
                if (!StringUtil.isNullOrEmpty(jobj.optString("OtherTermNonTaxableAmount"))) {
                    dodDataMap.put("OtherTermNonTaxableAmount", jobj.optString("OtherTermNonTaxableAmount"));
                }
                
                //Get ProductBuild object for specified product.    //If same product selected twice in DO Grid then this case is not handled here.
                if(pbuildMap.containsKey(jobj.getString(Constants.productid))){
                    ProductBuild pbuild = (ProductBuild) pbuildMap.get(jobj.getString(Constants.productid));
                    dodDataMap.put("productbuild", pbuild);       //SDP-4211             
                }
                //boolean isMultiGroupCompanyflag = extraCompanyPreferences.isActivateGroupCompaniesFlag();
                //For multigroup company case only. Saving only podetailid in SO.
                if (jobj.has("sourcegrorderdetailid") && !StringUtil.isNullOrEmpty(jobj.optString("sourcegrorderdetailid", null))) {
                    dodDataMap.put("sourcegrorderdetailid", jobj.optString("sourcegrorderdetailid"));
                }
                KwlReturnObject result = accInvoiceDAOobj.saveDeliveryOrderDetails(dodDataMap);
                DeliveryOrderDetail row = (DeliveryOrderDetail) result.getEntityList().get(0);

                String replacebatchdetails = "";
                if (lock_Quantity > 0 && jobj.has("replacebatchdetails") && jobj.getString("replacebatchdetails") != null) {
                    replacebatchdetails = jobj.getString("replacebatchdetails");
                    if (!StringUtil.isNullOrEmpty(replacebatchdetails)) {
                        freeLockQuanitySOForChangeSerialDetailsInDO(paramJobj, replacebatchdetails);
                    }
                }
                if (jobj.has("batchdetails") && jobj.optString("batchdetails",null) != null && dquantity>0) {

                    boolean isCopy = StringUtil.isNullOrEmpty(paramJobj.optString("copyInv", null)) ? false : Boolean.parseBoolean(paramJobj.optString("copyInv"));
                    int level = (isEdit && !isCopy) ? 0 : deliveryOrder.getApprovestatuslevel();
                    DateFormat df = authHandler.getDateOnlyFormat();
                    String currencyid = paramJobj.optString(Constants.currencyKey);
                    JSONArray productDiscountJArr = new JSONArray();
                    double totalAmount = 0;
                    double subtotal = 0;
                    double qty = 0;
                    double discountAmount = 0;
                    double discountAmountInBase = 0;
                    double taxAmount = 0;
                    if (row != null) {
                        String productId = row.getInventory().getProduct().getID();
                        qty = row.getInventory().getQuantity();
                        totalAmount += authHandler.round(row.getRate() * qty, companyid);
                        subtotal = authHandler.round(row.getRate() * qty, companyid);
                        taxAmount += authHandler.round(row.getRowTaxAmount(), companyid);
                        double rowDiscVal = 0;
                        if (row.getDiscountispercent() == 1) {
                            rowDiscVal = authHandler.round((subtotal * row.getDiscount() / 100), companyid);
                            discountAmount += rowDiscVal;
                        } else {
                            rowDiscVal = authHandler.round(row.getDiscount(), companyid);
                            discountAmount += rowDiscVal;
                        }
                        // Mapping Product and Discount
                        KwlReturnObject dAmount = accCurrencyDAOobj.getCurrencyToBaseAmount(GlobalParams, rowDiscVal, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), deliveryOrder.getExternalCurrencyRate());
                        double discAmountinBase = (Double) dAmount.getEntityList().get(0);
                        discAmountinBase = authHandler.round(discAmountinBase, companyid);
                        JSONObject productDiscountObj = new JSONObject();
                        productDiscountObj.put("productId", productId);
                        productDiscountObj.put("discountAmount", discAmountinBase);
                        productDiscountJArr.put(productDiscountObj);
                    }
                    double totalAmountInDocumentCurrecy = totalAmount - discountAmount;
                    double taxPercent = 0;
                    if (deliveryOrder.getTax() != null) {
                        KwlReturnObject taxresult = accTaxObj.getTaxPercent(paramJobj.optString(Constants.companyKey), deliveryOrder.getOrderDate(), deliveryOrder.getTax().getID());
                        taxPercent = (Double) taxresult.getEntityList().get(0);
                        double ordertaxamount = (taxPercent == 0 ? 0 : authHandler.round((totalAmountInDocumentCurrecy * taxPercent / 100), companyid));
                        taxAmount += ordertaxamount;
                    }
                    totalAmountInDocumentCurrecy = totalAmountInDocumentCurrecy + taxAmount;
                    double totalAmountInBaseCurrecy = 0;
                    if (deliveryOrder.getCurrency() != null) {
                        HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                        filterRequestParams.put(Constants.companyKey, companyid);
                        filterRequestParams.put(Constants.globalCurrencyKey, paramJobj.optString(Constants.globalCurrencyKey));
                        KwlReturnObject bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(filterRequestParams, totalAmountInDocumentCurrecy, deliveryOrder.getCurrency().getCurrencyID(), deliveryOrder.getOrderDate(), deliveryOrder.getExternalCurrencyRate());
                        totalAmountInBaseCurrecy = authHandler.round((Double) bAmt.getEntityList().get(0), companyid);
                        KwlReturnObject bAmt1 = accCurrencyDAOobj.getCurrencyToBaseAmount(filterRequestParams, discountAmount, deliveryOrder.getCurrency().getCurrencyID(), deliveryOrder.getOrderDate(), deliveryOrder.getExternalCurrencyRate());
                        discountAmountInBase = authHandler.round((Double) bAmt1.getEntityList().get(0), companyid);
                    }
                    totalAmountInDocumentCurrecy = authHandler.round(totalAmountInDocumentCurrecy, companyid);
                    deliveryOrder.setDiscountinbase(discountAmountInBase);
                    deliveryOrder.setTotalamount(totalAmountInDocumentCurrecy);
                    deliveryOrder.setTotalamountinbase(totalAmountInBaseCurrecy);
                    
//                    String batchDetails = jobj.optString("batchdetails","[]");
                    if (!StringUtil.isNullOrEmpty(batchDetails)) { 
                        //this functtion is to reduce the stock from company level meas stock is delivered from company warehouse                          
                        boolean isOnlySerialForProduct= !(product.isIswarehouseforproduct() || product.isIslocationforproduct() || product.isIsrowforproduct() || product.isIsrackforproduct() || product.isIsbinforproduct() ||product.isIsBatchForProduct()) && product.isIsSerialForProduct();
                        if (extraCompanyPreferences.isAutoFillBatchDetails() && !isOnlySerialForProduct && !isConsignment && !isFixedAsset && !isLeaseFixedAsset) {
                            saveDONewBatchForAutoFilledDetailsJson(batchDetails, inventory, paramJobj, row, stockMovementsList, isLock, isbatchlockedinSO, isSeriallockedinSO, replacebatchdetails);
                        } else {
                            saveDONewBatchJson(batchDetails, inventory, paramJobj, row, stockMovementsList, isLock, isbatchlockedinSO, isSeriallockedinSO, replacebatchdetails);
                        }
                    }
                }

                String customfield = jobj.optString(Constants.customfield,null);
                if (!StringUtil.isNullOrEmpty(customfield)) {
                    HashMap<String, Object> DOMap = new HashMap<String, Object>();
                    JSONArray jcustomarray = new JSONArray(customfield);
                    if (isAutoCreateDO) {
                        jcustomarray = fieldDataManagercntrl.getComboValueIdsForCurrentModule(jcustomarray, Constants.Acc_Delivery_Order_ModuleId, companyid, 1);            // 1= for line item
                    }

                    HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                    customrequestParams.put("customarray", jcustomarray);
                    customrequestParams.put("modulename", "DeliveryOrderDetail");
                    customrequestParams.put("moduleprimarykey", "DeliveryOrderDetailId");
                    customrequestParams.put("modulerecid", row.getID());
                    customrequestParams.put(Constants.moduleid, isFixedAsset ? Constants.Acc_FixedAssets_DeliveryOrder_ModuleId : isConsignment ? Constants.Acc_ConsignmentDeliveryOrder_ModuleId : isLeaseFixedAsset ? Constants.Acc_Lease_DO : Constants.Acc_Delivery_Order_ModuleId);
                    customrequestParams.put(Constants.companyKey, companyid);
                    DOMap.put("id", row.getID());
                    customrequestParams.put("customdataclasspath", Constants.Acc_DeliveryOrderDetail_custom_data_classpath);
                    KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                    if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                        DOMap.put("dodetailscustomdataref", row.getID());
                        accInvoiceDAOobj.updateDODetailsCustomData(DOMap);
                    }
                }
                // Add Custom fields details for Product
                if (!StringUtil.isNullOrEmpty(jobj.optString("productcustomfield", ""))) {
                    JSONArray jcustomarray = new JSONArray(jobj.optString("productcustomfield", "[]"));
                    HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                    customrequestParams.put("customarray", jcustomarray);
                    customrequestParams.put("modulename", "DeliveryorderDetail");
                    customrequestParams.put("moduleprimarykey", "DoDetailID");
                    customrequestParams.put("modulerecid", row.getID());
                    customrequestParams.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                    customrequestParams.put("recdetailId", row.getID());
                    customrequestParams.put("productId", row.getProduct().getID());
                    customrequestParams.put(Constants.companyKey, companyid);
                    customrequestParams.put("customdataclasspath", Constants.Acc_DODETAIL_Productcustom_data_classpath);
                    /*
                     * Rich Text Area is put in json if User have not selected any data for this field. ERP-ERP-37624
                     */
                    customrequestParams.put("productIdForRichRext", row.getProduct().getID());                    
                    fieldDataManagercntrl.setRichTextAreaForProduct(customrequestParams);
                    KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                }
                if (extraCompanyPreferences.getLineLevelTermFlag()==1) {
                    /**
                     * Save GST History Customer/Vendor data.
                     */
                    jobj.put("detaildocid", row.getID());
                    jobj.put("moduleid", Constants.Acc_Delivery_Order_ModuleId);
                    fieldDataManagercntrl.createRequestMapToSaveTaxClassHistory(jobj);
                }
                // Add Custom fields details for Product
                if (!StringUtil.isNullOrEmpty(jobj.optString("LineTermdetails", ""))) {
                    if (extraCompanyPreferences.isAvalaraIntegration()) {//If Avalara Integration is enabled, then save tax details in Avalara tax mapping table 'TransactionDetailAvalaraTaxMapping' 
                        JSONObject paramsJobj = new JSONObject();
                        paramsJobj.put(IntegrationConstants.integrationPartyIdKey, IntegrationConstants.integrationPartyId_AVALARA);
                        paramsJobj.put(Constants.companyKey, companyid);
                        if (integrationCommonService.isTaxCalculationEnabled(paramsJobj)) {
                            JSONObject saveTaxParamsJobj = new JSONObject();
                            saveTaxParamsJobj.put(IntegrationConstants.parentRecordID, row.getID());
                            saveTaxParamsJobj.put(IntegrationConstants.avalaraTaxDetails, StringUtil.DecodeText(jobj.optString("LineTermdetails")));
                            integrationCommonService.saveTransactionDetailTaxMapping(saveTaxParamsJobj);
                        }
                    } else {
                        JSONArray termdetails = new JSONArray(StringUtil.DecodeText((String) jobj.optString("LineTermdetails", "[]")));
                        HashMap<String, Object> grMap = new HashMap<String, Object>();
                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        String userid = paramJobj.optString(Constants.useridKey);
                        for (int cnt = 0; cnt < termdetails.length(); cnt++) {
                            JSONObject temp = termdetails.getJSONObject(cnt);
                            HashMap<String, Object> termMap = new HashMap<String, Object>();
                            termMap.put("term", temp.getString("termid"));
                            termMap.put("termamount", StringUtil.isNullOrEmpty(temp.getString("termamount")) ? "0.0" : Double.parseDouble(temp.getString("termamount")));
                            double percentage = 0;
                            if (!StringUtil.isNullOrEmpty(temp.getString("termpercentage"))) {
                                percentage = Double.parseDouble(temp.getString("termpercentage"));
                            }
                            double purchaseValueOrSaleValue = 0;
                            double deductionOrAbatementPercent = 0;
                            if (!StringUtil.isNullOrEmpty(temp.getString("purchasevalueorsalevalue"))) {
                                purchaseValueOrSaleValue = Double.parseDouble(temp.getString("purchasevalueorsalevalue"));
                            }
                            if (!StringUtil.isNullOrEmpty(temp.getString("deductionorabatementpercent"))) {
                                deductionOrAbatementPercent = Double.parseDouble(temp.getString("deductionorabatementpercent"));
                            }
                            termMap.put("termpercentage", percentage);
                            termMap.put("assessablevalue", temp.has("assessablevalue") && !StringUtil.isNullOrEmpty(temp.getString("assessablevalue")) ? Double.parseDouble(temp.getString("assessablevalue")) : 0.0);
                            termMap.put("purchasevalueorsalevalue", purchaseValueOrSaleValue);
                            termMap.put("deductionorabatementpercent", deductionOrAbatementPercent);

                            if (temp.has("taxtype") && !StringUtil.isNullOrEmpty(temp.getString("taxtype"))) {
                                termMap.put("taxtype", temp.getInt("taxtype"));
                                if (temp.has("taxvalue") && !StringUtil.isNullOrEmpty(temp.getString("taxvalue"))) {
                                    if (temp.getInt("taxtype") == 0) { // If Flat
                                        termMap.put("termamount", temp.getDouble("taxvalue"));
                                    } else { // Else Percentage
                                        termMap.put("termpercentage", temp.getDouble("taxvalue"));
                                    }
                                }
                            }
                            /**
                             * ERP-32829 
                             */
                            termMap.put("isDefault", temp.optString("isDefault", "false"));
                            termMap.put("productentitytermid", temp.optString("productentitytermid"));
                            termMap.put("creationdate", new Date());
                            termMap.put("userid", userid);
                            termMap.put("dodetails", row.getID());
                            accInvoiceDAOobj.saveOrUpdateDODetailsTermsMap(termMap);
                        }
                    }
                }

                //       }
                rows.add(row);
                // add asset Details 
                int assetSoldFlag = 2;

                if (isLinkedWithInvoice) {
                    assetSoldFlag = 1;
                }

                if (isLeaseFixedAsset) {// in case of leasing its value will be 0
                    assetSoldFlag = 0;
                }

                boolean isFromSalesReturn = false;

                if (isFixedAsset || (isLeaseFixedAsset && product.isAsset())) {
                    Set<AssetDetails> assetDetailsSet = saveAssetDetails(paramJobj, jobj.getString(Constants.productid), jobj.getString("assetDetails"), assetSoldFlag, isLinkedWithInvoice, false, isLeaseFixedAsset, isFromSalesReturn, false, false,0);

                    Set<AssetInvoiceDetailMapping> assetInvoiceDetailMappings = saveAssetInvoiceDetailMapping(row.getID(), assetDetailsSet, companyid, Constants.Acc_Delivery_Order_ModuleId);
                }

                // For Saving Wastage Details
                if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateWastageCalculation() && jobj.has("wastageDetails") && !StringUtil.isNullOrEmpty(jobj.getString("wastageDetails"))) {
                    Set<WastageDetails> wastageDetailsSet = saveWastageDetails(paramJobj, row.getID(), jobj.getString("wastageDetails"));
                }
            }
            /*Following try block is for ERP-38814*/
            try {
                SeqFormat seqFormat = null;
                if (extraCompanyPreferences.isPickpackship() && !extraCompanyPreferences.isInterloconpick()) {
                    seqFormat = seqService.getDefaultSeqFormat(extraCompanyPreferences.getCompany(), ModuleConst.INTER_STORE_TRANSFER);
                } else if (extraCompanyPreferences.isPickpackship()) {
                    seqFormat = seqService.getDefaultSeqFormat(extraCompanyPreferences.getCompany(), ModuleConst.INTER_LOCATION_TRANSFER);
                }
                if (seqFormat!= null) {
                    seqService.updateSeqNumber(seqFormat);
                }
            } catch (SeqFormatException ex) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
            if (Integer.parseInt(countryid) == Constants.indian_country_id && RCMApplicable && !productNameRCMNotActivate.isEmpty()) {
                throw new AccountingException(messageSource.getMessage("acc.common.rcmforproductnotactivated.DO.text", new Object[]{StringUtils.join(productNameRCMNotActivate, ", ")}, null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
            }
            // Checking status of Product Replacement request i.e. it has been closed or open and update its status accordingly
            if (!productReplacementIds.isEmpty()) {
                createCRMJsonArrayForUpdatingCloseStatus(productReplacementIds, crmJsonArray, companyid);
            }
            //ERP-32101 added final condition for a case when pick pack is active and Consignment / Lease DO is created
            if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateInventoryTab() && !stockMovementsList.isEmpty() && !extraCompanyPreferences.isPickpackship() || (!stockMovementsList.isEmpty() && extraCompanyPreferences.isPickpackship() && (isConsignment || isLeaseFixedAsset))) {
                stockMovementService.addOrUpdateBulkStockMovement(deliveryOrder.getCompany(), deliveryOrder.getID(), stockMovementsList);
            }
//            JSONObject invjson = new JSONObject();
//            invjson.put("invoiceid", invoiceid);
//            accInvoiceDAOobj.updateInvoice(invjson, invcdetails);
        } catch (InventoryException ex) {
            throw new InventoryException(ex.getMessage());
        } catch (JSONException ex) {
            throw ServiceException.FAILURE("saveDeliveryOrderRows : " + ex.getMessage(), ex);
        }

        returnList.add(rows);
        returnList.add(crmJsonArray);
        return returnList;
    }
    
                    
                    
    @Override
    public String checkSOUsedFlag(JSONObject paramJobj) throws ServiceException {
        String msg = "";
        int linkflag;
        try {
            String linkMode = paramJobj.optString("fromLinkCombo"); //When adding Sales order link for Delivery Order update link flag(2) in sale order.
            linkflag = paramJobj.getInt("linkflag");
            String[] linkNumbers = paramJobj.optString("linkNumber").split(",");
            if (!StringUtil.isNullOrEmpty(linkMode) && linkNumbers.length > 0) {
                if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {
                    for (int i = 0; i < linkNumbers.length; i++) {
                        if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                            KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkNumbers[i]);
                            SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                            if (salesOrder.getLinkflag() == linkflag) {
                                msg += salesOrder.getSalesOrderNumber() + ", ";
                            }
                        }
                    }
                    if (!StringUtil.isNullOrEmpty(msg)) {
                        String usedIn = "Customer Invoice";
                        if (linkflag == 2) {
                            usedIn = "Delivery Order";
                        }
                        msg = messageSource.getMessage("acc.field.SelectedSalesOrdersarealreadyusedin", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + usedIn + ".<BR />" + msg.substring(0, msg.length() - 2);
                    }
                }
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("checkSOUsedFlag : " + ex.getMessage(), ex);
        }
        return msg;
    }
    
    @Override
    public boolean deleteExistingAutoBuildAssemblyEntriesOfDO(JSONObject paramJobj, String doid) throws ServiceException, SessionExpiredException {
        try {
            String companyid = paramJobj.getString(Constants.companyKey);

            HashMap<String, Object> requestParams = new HashMap<String, Object>();
            requestParams.put("doid", doid);
            requestParams.put(Constants.companyKey, companyid);
            KwlReturnObject autoBuildAssemblyResult = accProductObj.getAutoBuildAssemblyEntriesForDeliveryOrder(requestParams);
            List<ProductBuild> productBuildList = autoBuildAssemblyResult.getEntityList();

            for (ProductBuild build : productBuildList) {
                String productids = build.getID();
                String productrefno = build.getRefno();
                String mainproductids = build.getProduct().getID();
                double assmbledProdQty = build.getQuantity();

                boolean isEdit = StringUtil.isNullOrEmpty(paramJobj.optString("isEdit", null)) ? false : Boolean.parseBoolean(paramJobj.getString("isEdit"));

                // delete ProductBuild inventory
                if (build.getInventory() != null) {
                    accProductObj.deleteInventory(build.getInventory().getID(), companyid);
                }

                // delete ProductBuildDetail inventory
                KwlReturnObject result = accProductObj.getProductBuildDetailInventory(build.getID());
                List<ProductBuildDetails> list = result.getEntityList();
                for (ProductBuildDetails buildDetails : list) {
                    if (buildDetails.getAproduct() != null) {
                        buildDetails.getAproduct().setRecycleQuantity(buildDetails.getAproduct().getRecycleQuantity() + buildDetails.getRecycleQuantity());
                    }
                    accProductObj.deleteInventory(buildDetails.getInventory().getID(), companyid);
                    //delete batch of BoM Product
                    accProductObj.deleteProductBuildBatchDetailsByID(buildDetails.getID(), false, companyid);
                }
                //delete batch of Assembly Product
                accProductObj.deleteProductBuildBatchDetailsByID(build.getID(), true, companyid);
//                for (int i = 0; i < productids.length; i++) {
//                addAsblyProdsNegativeEntry(productids, companyid);
                KwlReturnObject compRes = accountingHandlerDAOobj.getObject(Company.class.getName(), companyid);
                Company company = (Company) compRes.getEntityList().get(0);
                stockMovementService.removeStockMovementByReferenceId(company, productids);
                accProductObj.deleteProductBuildDetailsByID(productids, companyid);
                accProductObj.deleteProductbBuildByID(productids, companyid);
                if (build.getJournalentry() != null) {
                    accJournalEntryobj.deleteJournalEntryPermanent(build.getJournalentry().getID(), companyid);
                }
                Map<String, Object> auditRequestParams = new HashMap<>();
                auditRequestParams.put(Constants.reqHeader, paramJobj.getString(Constants.reqHeader));
                auditRequestParams.put(Constants.remoteIPAddress, paramJobj.getString(Constants.remoteIPAddress));
                auditRequestParams.put(Constants.useridKey, paramJobj.getString(Constants.useridKey));
                if (!isEdit) {
                    auditTrailObj.insertAuditLog(AuditAction.PRODUCT_BUILD_ASSEMBLY_DELETION, "User " + paramJobj.getString(Constants.userfullname) + " has deleted product build Assembly " + productrefno, auditRequestParams, productids);
                }
//                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return true;
    }
    
    @Override
    public List mapInvoiceTerms(Map<String, Object> requestParams) throws ServiceException {
        List ll = new ArrayList();
        boolean isDO = false;
        String userid = "", transactionID = "";
        try {
            JSONArray termsArr = new JSONArray((String)requestParams.get("invoiceterms"));
            isDO = (Boolean) requestParams.get("isdo");
            userid = (String) requestParams.get("userid");
            transactionID = (String) requestParams.get("transactionid");
            for (int cnt = 0; cnt < termsArr.length(); cnt++) {
                JSONObject temp = termsArr.getJSONObject(cnt);
                HashMap<String, Object> termMap = new HashMap<String, Object>();
                termMap.put("term", temp.getString("id"));
                termMap.put("termamount", Double.parseDouble(temp.getString("termamount")));
                termMap.put("termtaxamount", temp.optDouble("termtaxamount",0));
                termMap.put("termtaxamountinbase", temp.optDouble("termtaxamountinbase",0));
                termMap.put("termtax", temp.optString("termtax",null));
                termMap.put("termAmountExcludingTax", temp.optDouble("termAmountExcludingTax",0));
                termMap.put("termAmountExcludingTaxInBase", temp.optDouble("termAmountExcludingTaxInBase",0));
                termMap.put("termamountinbase", temp.optDouble("termamountinbase",0)); 
                double percentage = 0;
                if (!StringUtil.isNullOrEmpty(temp.getString("termpercentage"))) {
                    percentage = Double.parseDouble(temp.getString("termpercentage"));
                }
                termMap.put("termpercentage", percentage);
                termMap.put("creationdate", new Date());
                termMap.put("userid", userid);
                if (isDO) {
                    termMap.put("deliveryOrderID", transactionID);
                    accInvoiceDAOobj.saveDeliveryOrderTermMap(termMap);
                } else {
                    termMap.put("invoice", transactionID);
                    accInvoiceDAOobj.saveInvoiceTermMap(termMap);
                }
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return ll;
    }

    public void sendReorderLevelEmails(String userId, DeliveryOrder dod) throws ServiceException {
        JSONObject jobj = new JSONObject();
        KwlReturnObject jeresult = accountingHandlerDAOobj.getObject(User.class.getName(), userId);
        User sender = (User) jeresult.getEntityList().get(0);
        String sendorInfo = sender.getEmailID() != null ? sender.getEmailID() : authHandlerDAOObj.getSysEmailIdByCompanyID(dod.getCompany().getCompanyID());
        KwlReturnObject returnObject = accountingHandlerDAOobj.getObject(Company.class.getName(), sender.getCompany().getCompanyID());
        Company company = (Company) returnObject.getEntityList().get(0);
        Map<String, Object> smtpConfigMap = authHandler.getSMTPConfigMap(company);
        List ll;
        String msg = null;

        try {
            if (dod != null && dod.getRows() != null) {
                int sno = 1;

                String emailIds = "";
                String mailSeparator = ",";
                boolean isfirst = true;

                for (DeliveryOrderDetail sod : dod.getRows()) {
                    KwlReturnObject kwlobject = accountingHandlerDAOobj.getObject(Store.class.getName(), accCommonTablesDAO.getStoreIdForNonbatchSerialByDODetailId(sender.getCompany().getCompanyID(), sod.getID()));
                    Store store = (Store) kwlobject.getEntityList().get(0);
                    Set<User> mgrSet =new HashSet(); 
                    mgrSet.addAll(store.getStoreManagerSet());
                    mgrSet.addAll(store.getStoreExecutiveSet());
                    double availableQtyinStore = stockService.getProductQuantityInStore(sod.getProduct(), store);
                    if (availableQtyinStore < sod.getProduct().getReorderLevel()) {
                        for (User user : mgrSet) {
                            if (isfirst) {
                                emailIds += user.getEmailID();
                                isfirst = false;
                            } else {
                                emailIds += mailSeparator + user.getEmailID();
                            }

                        }

                        String subject = "Reorder Level Notification";
                        String htmlTextC = "";
                        htmlTextC += "<br/>Hi,<br/>";
                        htmlTextC += "<br/>Quantity for product <b>" + sod.getProduct().getName() + "</b>  has gone below reorder level.";
                        htmlTextC += "<br/><b> Quantity :</b> " + availableQtyinStore + "</b><br/><b> Store :</b> " + store.getFullName() + "</b>";
//                htmlTextC += "<br/><b>Store :</b>     "+store + "</b>";
//                        htmlTextC += "<br/><br/>This is an auto generated email. Do not reply.<br/>";
                        htmlTextC += "<br/><br/>Regards,<br/>";
                        htmlTextC += "<br/>ERP System<br/>";
                        htmlTextC += "<br/><br/>";
                        htmlTextC += "<br/>This is an auto generated email. Do not reply.<br/>";
                        String plainMsgC = "";
                        plainMsgC += "\nRegards,\n";
                        plainMsgC += "\nDeskera Financials\n";
                        plainMsgC += "\n\n";
                        plainMsgC += "\nThis is an auto generated email. Do not reply.\n";
                        SendMailHandler.postMail(emailIds.split(","), subject, htmlTextC, plainMsgC, sendorInfo, smtpConfigMap);
                    }
                }
            }
        } catch (Exception ex) {
            msg = ex.getMessage();
        } finally {
            try {
                jobj.put(Constants.RES_msg, msg);
            } catch (JSONException ex) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

    }

    public void setValuesForAuditTrialForDO(DeliveryOrder olddo, JSONObject paramJobj, Map<String, Object> oldgreceipt, Map<String, Object> doDataMap, Map<String, Object> newAuditKey) throws SessionExpiredException {
        try {
            DateFormat df = authHandler.getUserDateFormatterWithoutTimeZone(paramJobj);
            //Setting values in map for oldgreceipt
            if (olddo != null) {
                KwlReturnObject currobretrurnlist = accountingHandlerDAOobj.getObject(KWLCurrency.class.getName(), olddo.getCurrency().getCurrencyID());
                KWLCurrency oldcurrencyobj = (KWLCurrency) currobretrurnlist.getEntityList().get(0);
                KwlReturnObject customerretrurnlist = accountingHandlerDAOobj.getObject(Customer.class.getName(), olddo.getCustomer().getID());
                Customer oldcustomer = (Customer) customerretrurnlist.getEntityList().get(0);

                if (olddo.getSalesperson() != null) {
                    KwlReturnObject oldmastersalesperson = accountingHandlerDAOobj.getObject(MasterItem.class.getName(), olddo.getSalesperson().getID());
                    MasterItem oldsalesPerson = (MasterItem) oldmastersalesperson.getEntityList().get(0);
                    oldgreceipt.put("auditSalesPerson", oldsalesPerson != null ? oldsalesPerson.getValue() : "");
                } else {
                    oldgreceipt.put("auditSalesPerson", "");
                }
                newAuditKey.put("auditSalesPerson", "Sales Person");

                if (olddo.getStatus() != null) {
                    KwlReturnObject oldmasteritemstatuslist = accountingHandlerDAOobj.getObject(MasterItem.class.getName(), olddo.getStatus().getID());
                    MasterItem oldstatus = (MasterItem) oldmasteritemstatuslist.getEntityList().get(0);
                    oldgreceipt.put("auditStatus", oldstatus != null ? oldstatus.getValue() : "");
                } else {
                    oldgreceipt.put("auditStatus", "");
                }
                newAuditKey.put("auditStatus", "Status");

                oldgreceipt.put(Constants.CustomerName, oldcustomer.getName());
                newAuditKey.put(Constants.CustomerName, "Customer");
                oldgreceipt.put(InvoiceConstants.entrynumber, olddo.getDeliveryOrderNumber());
                newAuditKey.put(InvoiceConstants.entrynumber, "Entry Number");
                oldgreceipt.put(Constants.CurrencyName, oldcurrencyobj.getName());//Currency name
                newAuditKey.put(Constants.CurrencyName, "Currency");
                oldgreceipt.put(InvoiceConstants.memo, StringUtil.isNullOrEmpty(olddo.getMemo()) ? "" : olddo.getMemo());
                newAuditKey.put(InvoiceConstants.memo, "Memo");
                oldgreceipt.put("shipvia", StringUtil.isNullOrEmpty(olddo.getShipvia()) ? "" : olddo.getShipvia());
                newAuditKey.put("shipvia", "Ship Via");
                oldgreceipt.put(Constants.fob, StringUtil.isNullOrEmpty(olddo.getFob()) ? "" : olddo.getFob());
                newAuditKey.put(Constants.fob, "FOB");
                oldgreceipt.put("AuditOrderDate", olddo.getOrderDate() != null ? df.format(olddo.getOrderDate()) : "");
                newAuditKey.put("AuditOrderDate", "Delivery Order Date");
                oldgreceipt.put("AuditShipDate", olddo.getShipdate() != null ? df.format(olddo.getShipdate()) : "");
                newAuditKey.put("AuditShipDate", "Ship Date");
            }

            //Setting values in map for doDataMap
            KwlReturnObject newcurrencyreturnobj = accountingHandlerDAOobj.getObject(KWLCurrency.class.getName(), paramJobj.getString(InvoiceConstants.currencyid));
            KWLCurrency newcurrencyobj = (KWLCurrency) newcurrencyreturnobj.getEntityList().get(0);
            doDataMap.put(Constants.CurrencyName, newcurrencyobj.getName());//Currencey name
            KwlReturnObject newcustomerlist = accountingHandlerDAOobj.getObject(Customer.class.getName(), paramJobj.getString("customer"));
            Customer newcustomer = (Customer) newcustomerlist.getEntityList().get(0);
            doDataMap.put(Constants.CustomerName, newcustomer.getName());//Customer Name

            if (!StringUtil.isNullOrEmpty(paramJobj.optString("salesPerson", null))) {
                KwlReturnObject newmastersales = accountingHandlerDAOobj.getObject(MasterItem.class.getName(), paramJobj.getString("salesPerson"));
                MasterItem salesPerson = (MasterItem) newmastersales.getEntityList().get(0);
                doDataMap.put("auditSalesPerson", salesPerson.getValue());//SalesPerson Name
            } else {
                doDataMap.put("auditSalesPerson", "");//SalesPerson Name
            }

            if (!StringUtil.isNullOrEmpty(paramJobj.optString("statuscombo", null))) {
                KwlReturnObject newmasterstatus = accountingHandlerDAOobj.getObject(MasterItem.class.getName(), paramJobj.getString("statuscombo"));
                MasterItem newstatus = (MasterItem) newmasterstatus.getEntityList().get(0);
                doDataMap.put("auditStatus", newstatus.getValue());//Status
            } else {
                doDataMap.put("auditStatus", "");//Status
            }

        } catch (Exception ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public List<String> approveDO(DeliveryOrder doObj, HashMap<String, Object> doApproveMap, boolean isMailApplicable) throws SessionExpiredException, AccountingException, ServiceException, ScriptException, MessagingException, JSONException {
        boolean hasAuthority = false;
        String companyid = "";
        List returnList = new ArrayList();
        List mailParamList = new ArrayList();
        int returnStatus;
        if (doApproveMap.containsKey(Constants.companyKey) && doApproveMap.get(Constants.companyKey) != null) {
            companyid = doApproveMap.get(Constants.companyKey).toString();
        }
        String currentUser = "";
        if (doApproveMap.containsKey("currentUser") && doApproveMap.get("currentUser") != null) {
            currentUser = doApproveMap.get("currentUser").toString();
        }
        int level = 0;
        if (doApproveMap.containsKey("level") && doApproveMap.get("level") != null) {
            level = Integer.parseInt(doApproveMap.get("level").toString());
        }
        String amount = "";
        if (doApproveMap.containsKey("totalAmount") && doApproveMap.get("totalAmount") != null) {
            amount = doApproveMap.get("totalAmount").toString();
        }
        boolean fromCreate = false;
        if (doApproveMap.containsKey("fromCreate") && doApproveMap.get("fromCreate") != null) {
            fromCreate = Boolean.parseBoolean(doApproveMap.get("fromCreate").toString());
        }
        JSONArray productDiscountMapList = null;
        if (doApproveMap.containsKey("productDiscountMapList") && doApproveMap.get("productDiscountMapList") != null) {
            productDiscountMapList = new JSONArray(doApproveMap.get("productDiscountMapList").toString());
        }
        if (!fromCreate) {
            String thisUser = currentUser;
            KwlReturnObject userclass = accountingHandlerDAOobj.getObject(User.class.getName(), thisUser);
            User user = (User) userclass.getEntityList().get(0);

            if (AccountingManager.isCompanyAdmin(user)) {
                hasAuthority = true;
            } else {
                /*
                 If "Send approval documents to next level" is disabled from system preferences & pending document is edited then
                 1. When user is authorised then document is always goes at first level
                 2. When user is not authorised then document remains at same level
                 
                 */
                boolean isEditedPendingDocumentWithCheckOff = false;
                if (doApproveMap.containsKey("isEditedPendingDocumentWithCheckOff") && doApproveMap.get("isEditedPendingDocumentWithCheckOff") != null) {
                    level = Integer.parseInt(doApproveMap.get("documentLevel").toString());//Actual level of document for fetching rule at that level for the user
                    doApproveMap.put("level", level);
                    isEditedPendingDocumentWithCheckOff = true;
                }
                
                hasAuthority = accountingHandlerDAOobj.checkForMultiLevelApprovalRules(doApproveMap);
                
                /*---If User is authorised at this level then sending document to first level that's why assigning "level=0" ------ */
                if (isEditedPendingDocumentWithCheckOff && hasAuthority) {
                    level = 0;
                }
            }
        } else {
            hasAuthority = true;
        }
        if (hasAuthority) {
            ScriptEngineManager mgr = new ScriptEngineManager();
            ScriptEngine engine = mgr.getEngineByName("JavaScript");
            int approvalStatus = 11;
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            String prNumber = doObj.getDeliveryOrderNumber();
            String doID = doObj.getID();
            HashMap<String, Object> qdDataMap = new HashMap<String, Object>();
            qdDataMap.put(Constants.companyKey, companyid);
            qdDataMap.put("level", level + 1);
            qdDataMap.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
            KwlReturnObject flowresult = accMultiLevelApprovalDAOObj.getMultiApprovalRuleData(qdDataMap);
            Iterator itr = flowresult.getEntityList().iterator();
            String fromName = "User";
            fromName = doObj.getCreatedby().getFirstName().concat(" ").concat(doObj.getCreatedby().getLastName());
            /**
             * parameters required for sending mail
             */
            Map<String, Object> mailParameteres = new HashMap();
            mailParameteres.put(Constants.companyid, companyid);
            mailParameteres.put(Constants.prNumber, prNumber);
            mailParameteres.put(Constants.fromName, fromName);
            mailParameteres.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
            mailParameteres.put(Constants.isCash, false);
            mailParameteres.put(Constants.createdBy, doObj.getCreatedby().getUserID());
            if (doApproveMap.containsKey(Constants.PAGE_URL)) {
                mailParameteres.put(Constants.PAGE_URL, (String) doApproveMap.get(Constants.PAGE_URL));
            }
            while (itr.hasNext()) {
                Object[] row = (Object[]) itr.next();
                //            JSONObject obj = new JSONObject();
                mailParameteres.put(Constants.ruleid, row[0].toString());
                HashMap<String, Object> recMap = new HashMap();
                String rule = "";
                if (row[2] != null) {
                    rule = row[2].toString();
                }
                String discountRule = "";
                if (row[7] != null) {
                    discountRule = row[7].toString();
                }
                boolean sendForApproval = false;
                int appliedUpon = Integer.parseInt(row[5].toString());
                if (appliedUpon == Constants.Specific_Products || appliedUpon == Constants.Specific_Products_Discount) {
                    if (productDiscountMapList != null) {
                        sendForApproval = AccountingManager.checkForProductAndProductDiscountRule(productDiscountMapList, appliedUpon, rule, discountRule);
                    }
                }else if(appliedUpon ==Constants.Specific_Products_Category){
                    /*
                     * Check If Rule is apply on product
                     * category from multiapproverule window
                     */
                    sendForApproval = accountingHandlerDAOobj.checkForProductCategoryForProduct(productDiscountMapList, appliedUpon, rule);
                }else {
                    rule = rule.replaceAll("[$$]+", amount);
                }
                if (StringUtil.isNullOrEmpty(rule) || (!StringUtil.isNullOrEmpty(rule) && appliedUpon != Constants.Specific_Products && appliedUpon != Constants.Specific_Products_Discount && appliedUpon !=Constants.Specific_Products_Category && Boolean.parseBoolean(engine.eval(rule).toString())) || sendForApproval) {
                    // send emails
                    boolean hasApprover = Boolean.parseBoolean(row[3].toString());
                    mailParameteres.put(Constants.hasApprover, hasApprover);
                    if (isMailApplicable) {
                        approvalStatus = level + 1;
                        mailParameteres.put("level", level);
                        sendMailToApprover(mailParameteres);
                        approvalStatus = level + 1;
                        
                    } else {
                        approvalStatus = level + 1;
                        recMap.put("ruleid", row[0].toString());
                        recMap.put("fromName", fromName);
                        recMap.put("hasApprover", hasApprover);

                        mailParamList.add(recMap);
                    }

                }
            }
            accInvoiceDAOobj.approvePendingDO(doID, companyid, approvalStatus);
             if (doObj != null && doObj.getInventoryJE() != null) {
                KwlReturnObject invJEObj = accountingHandlerDAOobj.getObject(JournalEntry.class.getName(), doObj.getInventoryJE().getID());
                JournalEntry invJE = (JournalEntry) invJEObj.getEntityList().get(0);
                if (invJE != null) {
                    invJE.setApprovestatuslevel(approvalStatus);
                }
            }
            returnStatus = approvalStatus;
        } else {
            returnStatus = Constants.NoAuthorityToApprove; //if not have approval permission then return one fix value like 999
        }
        returnList.add(returnStatus);
        returnList.add(mailParamList);

        return returnList;
    }

    public void freeLockQuanitySOForChangeSerialDetailsInDO(JSONObject paramJobj, String replacebatchdetails) {
        try {
            JSONArray jArr = new JSONArray(replacebatchdetails);
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
                String purchasebatchid = "";
                if (jSONObject.has("purchasebatchid")) {
                    purchasebatchid = jSONObject.getString("purchasebatchid");
                }
                String serialnoid = "";
                if (jSONObject.has("serialnoid")) {
                    serialnoid = jSONObject.getString("serialnoid");
                }
                double quantity = 0;
                if (jSONObject.has("quantity") && !StringUtil.isNullOrEmpty(jSONObject.optString("quantity"))) {
                    quantity = Double.parseDouble(jSONObject.getString("quantity"));
                }
                if (!StringUtil.isNullOrEmpty(purchasebatchid)) {
                    KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), purchasebatchid);
                    NewProductBatch newProductBatch = (NewProductBatch) batchObj.getEntityList().get(0);
                    if(!StringUtil.isNullOrEmpty(serialnoid)){
                        newProductBatch.setLockquantity(newProductBatch.getLockquantity() - 1);
                    }
//                    else if(quantity!=0){
//                        newProductBatch.setLockquantity(newProductBatch.getLockquantity() - quantity);
//                    } 
                }
                if (!StringUtil.isNullOrEmpty(serialnoid)) {
                    KwlReturnObject serialObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), serialnoid);
                    NewBatchSerial newBatchSerial = (NewBatchSerial) serialObj.getEntityList().get(0);
                    newBatchSerial.setLockquantity(newBatchSerial.getLockquantity() - 1);
                }
            }
        } catch (JSONException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    @Override
    public void updateDeliveryPlannerEntry(Map<String, Object> requestParams1) throws ServiceException {
        String[] linkNumbers = {};
        String linkMode = "";
        String docID = "";
        String userID = "";
        int moduleid = 0;
        if (requestParams1.containsKey("linkNumber")) {
            linkNumbers = requestParams1.get("linkNumber").toString().split(",");
        }
        if (requestParams1.containsKey("fromLinkCombo")) {
            linkMode = (String) requestParams1.get("fromLinkCombo");
        }
        if (requestParams1.containsKey("docid")) {
            docID = (String) requestParams1.get("docid");
        }
        if (requestParams1.containsKey("userid")) {
            userID = (String) requestParams1.get("userid");
        }
        if (requestParams1.containsKey(Constants.moduleid)) {
            moduleid = Integer.parseInt(requestParams1.get(Constants.moduleid).toString());
        }
        if (moduleid == Constants.Acc_Delivery_Order_ModuleId && (linkMode.equalsIgnoreCase("Customer Invoice") || linkMode.equalsIgnoreCase("Sales Invoice"))) { // For SI is linked to DO
            for (int i = 0; i < linkNumbers.length; i++) {
                if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                    KwlReturnObject result = accountingHandlerDAOobj.getObject(Invoice.class.getName(), linkNumbers[i]);
                    Invoice invoice = (Invoice) result.getEntityList().get(0);
                    Map<String, Object> requestParams = new HashMap<>();
                    requestParams.put("moduleID", moduleid);
                    requestParams.put("invoiceID", invoice.getID());
                    requestParams.put("isEmptyLinkedDoc", true);
                    KwlReturnObject delPlanResult = accInvoiceDAOobj.getDeliveryPlannerForModule(requestParams); // for getting SI delivery planner record which is having empty linking DO record

                    if (delPlanResult != null && delPlanResult.getEntityList() != null && !delPlanResult.getEntityList().isEmpty()) { // if SI delivery planner record having empty linking DO record then update DO for that record
                        DeliveryPlanner deliveryPlanner = (DeliveryPlanner) delPlanResult.getEntityList().get(0);

                        Map<String, Object> params = new HashMap<>();
                        params.put("deliveryPlannerID", deliveryPlanner.getID());
                        params.put("deliveryOrderID", docID);
                        params.put("moduleID", moduleid);
                        accInvoiceDAOobj.updateDeliveryPlannerEntry(params);
                    } else { // if SI delivery planner record not having empty linked DO record then create new entry in delivery planner by copying existing data of previous record and set current DO as linked DO
                        requestParams = new HashMap<>();
                        requestParams.put("moduleID", moduleid);
                        requestParams.put("invoiceID", invoice.getID());
                        requestParams.put("isEmptyLinkedDoc", false);
                        delPlanResult = accInvoiceDAOobj.getDeliveryPlannerForModule(requestParams); // check if SI having entry in delivery planner

                        if (delPlanResult != null && delPlanResult.getEntityList() != null && !delPlanResult.getEntityList().isEmpty()) {
                            DeliveryPlanner deliveryPlanner = (DeliveryPlanner) delPlanResult.getEntityList().get(0);
                            requestParams = new HashMap<>();
                            requestParams.put("existDeliveryPlanner", deliveryPlanner);
                            requestParams.put("moduleID", moduleid);
                            requestParams.put("deliveryOrderID", docID);
                            requestParams.put("userID", userID);
                            accInvoiceDAOobj.createEntryOfDeliveryPlannerForModule(requestParams);
                        }
                    }
                }
            }
        } else if (moduleid == Constants.Acc_Invoice_ModuleId && linkMode.equalsIgnoreCase(Constants.Delivery_Order)) { // For DO is linked to SI
            for (int i = 0; i < linkNumbers.length; i++) {
                if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                    KwlReturnObject result = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), linkNumbers[i]);
                    DeliveryOrder deliveryOrder = (DeliveryOrder) result.getEntityList().get(0);
                    Map<String, Object> requestParams = new HashMap<>();
                    requestParams.put("moduleID", moduleid);
                    requestParams.put("deliveryOrderID", deliveryOrder.getID());
                    requestParams.put("isEmptyLinkedDoc", true);
                    KwlReturnObject delPlanResult = accInvoiceDAOobj.getDeliveryPlannerForModule(requestParams);  // for getting DO delivery planner record which is having empty linking SI record

                    if (delPlanResult != null && delPlanResult.getEntityList() != null && !delPlanResult.getEntityList().isEmpty()) {  // if DO delivery planner record having empty linking SI record then update SI for that record
                        DeliveryPlanner deliveryPlanner = (DeliveryPlanner) delPlanResult.getEntityList().get(0);

                        Map<String, Object> params = new HashMap<>();
                        params.put("deliveryPlannerID", deliveryPlanner.getID());
                        params.put("invoiceID", docID);
                        params.put("moduleID", moduleid);
                        accInvoiceDAOobj.updateDeliveryPlannerEntry(params);
                    } else { // if DO delivery planner record not having empty linked SI record then create new entry in delivery planner by copying existing data of previous record and set current SI as linked SI
                        requestParams = new HashMap<>();
                        requestParams.put("moduleID", moduleid);
                        requestParams.put("deliveryOrderID", deliveryOrder.getID());
                        requestParams.put("isEmptyLinkedDoc", false);
                        delPlanResult = accInvoiceDAOobj.getDeliveryPlannerForModule(requestParams);  // check if DO having entry in delivery planner

                        if (delPlanResult != null && delPlanResult.getEntityList() != null && !delPlanResult.getEntityList().isEmpty()) {
                            DeliveryPlanner deliveryPlanner = (DeliveryPlanner) delPlanResult.getEntityList().get(0);
                            requestParams = new HashMap<>();
                            requestParams.put("existDeliveryPlanner", deliveryPlanner);
                            requestParams.put("moduleID", moduleid);
                            requestParams.put("invoiceID", docID);
                            requestParams.put("userID", userID);
                            accInvoiceDAOobj.createEntryOfDeliveryPlannerForModule(requestParams);
                        }
                    }
                }
            }
        }
    }

    @Override
    public void createCRMJsonArrayForUpdatingCloseStatus(HashSet<String> productReplacementIds, JSONArray crmJsonArray, String companyid) throws JSONException, ServiceException {
        for (String productReplacementId : productReplacementIds) {

            boolean isProductReplacementRequestFullFilled = true;

            KwlReturnObject productReplacementObj = accountingHandlerDAOobj.getObject(ProductReplacement.class.getName(), productReplacementId);
            ProductReplacement productReplacement = (ProductReplacement) productReplacementObj.getEntityList().get(0);

            Set<ProductReplacementDetail> productReplacementDetails = productReplacement.getProductReplacementDetails();

            for (ProductReplacementDetail productReplacementDetail : productReplacementDetails) {
                if (productReplacementDetail.getReplacementQuantity() > productReplacementDetail.getReplacedQuantity()) {
                    isProductReplacementRequestFullFilled = false;
                }
            }
            boolean isClosed = false;
            if (isProductReplacementRequestFullFilled) {
                // Update status of Product Replacement Request 
                isClosed = true;
                HashMap<String, Object> productReplacementMap = new HashMap<String, Object>();
                productReplacementMap.put("productReplacementId", productReplacement.getId());
                productReplacementMap.put("isClosed", isClosed);// true - closed
                productReplacementMap.put("companyId", companyid);
                accSalesOrderDAOObj.updateProductReplacement(productReplacementMap);

            }
            JSONObject crmJobj = new JSONObject();
            crmJobj.put("replacementId", productReplacement.getId());
            crmJobj.put("replacementid", productReplacement.getId());
            crmJobj.put("replacementNumber", productReplacement.getReplacementRequestNumber());
            crmJobj.put("isClosed", isClosed);
            crmJobj.put("customerid", productReplacement.getCustomer().getID());
            crmJobj.put("contractId", productReplacement.getContract().getID());
            crmJobj.put("contractid", productReplacement.getContract().getID());

            crmJsonArray.put(crmJobj);
        }
    }

    public HashMap createBuildAssembly(JSONObject paramJobj, HashMap<String, Object> params) throws AccountingException, UnsupportedEncodingException {
        // Auto Build product if 'Auto Build Assembly on Sale' check is on for Assembly Product
        HashMap<String, Object> pbuildMap = new HashMap<String, Object>();
        try {
            String companyid = paramJobj.optString(Constants.companyKey);
            String entryNumber = paramJobj.optString("numberDo", null) != null ? paramJobj.optString("numberDo") : paramJobj.optString("number");
            String doid = (String) params.get("doid");
            String refNo = "";
            boolean isAutoCreateDO = Boolean.parseBoolean(paramJobj.optString("isAutoCreateDO"));
            boolean isEdit = StringUtil.isNullOrEmpty(paramJobj.optString("isEdit", null)) ? false : Boolean.parseBoolean(paramJobj.optString("isEdit"));
            boolean isFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isFixedAsset", null))) ? Boolean.parseBoolean(paramJobj.getString("isFixedAsset")) : false;
            boolean isLeaseFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isLeaseFixedAsset", null))) ? Boolean.parseBoolean(paramJobj.getString("isLeaseFixedAsset")) : false;
            boolean isConsignment = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment, null))) ? Boolean.parseBoolean(paramJobj.getString(Constants.isConsignment)) : false;
            boolean sendForQAApproval = paramJobj.optBoolean("sendForQAApproval", false);
            if (isEdit) {
                deleteExistingAutoBuildAssemblyEntriesOfDO(paramJobj, doid);
            }
            
            if (!StringUtil.isNullOrEmpty(doid)) {
                KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
                CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);

                KwlReturnObject extraCompanyPreferencesObj = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
                ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extraCompanyPreferencesObj.getEntityList().get(0);    
            
                JSONObject columnpref = null;
                if (!StringUtil.isNullOrEmpty(extraCompanyPreferences.getColumnPref())) {
                    columnpref = new JSONObject(extraCompanyPreferences.getColumnPref());
                }

                boolean PeriodicJE = columnpref.optBoolean(Constants.PeriodicJE, false);
                boolean postJe = false;
                
                KwlReturnObject dorderObj = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);
                DeliveryOrder dorder = (DeliveryOrder) dorderObj.getEntityList().get(0);              
                HashMap<String, Double> duplicateProducts = new HashMap<String, Double>();

                JSONArray jArr1 = new JSONArray(paramJobj.optString(Constants.detail));
                for (int i = 0; i < jArr1.length(); i++) {
                    JSONObject jobj = jArr1.getJSONObject(i);
                    
                
                    double quantitytoBuild = Double.parseDouble(isAutoCreateDO ? (jobj.getString("quantity") == null ? "0" : jobj.getString("quantity")) : (jobj.getString("dquantity") == null ? "0" : jobj.getString("dquantity")));
                    String bomdetailid = paramJobj.optString("bomdetailid", null) != null ? paramJobj.optString("bomdetailid") : "";    //Get BOM formula based on BOM Code Selection
                    
                    KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                    Product product = (Product) proresult.getEntityList().get(0);
                    double availableQuantity = product.getAvailableQuantity();

                    double quantity = quantitytoBuild;
                    double baseuomrate = jobj.optDouble("baseuomrate", 1);
                    quantity = quantity * baseuomrate;
                    if(duplicateProducts.isEmpty() || !(duplicateProducts.containsKey(product.getID()))){   // Checking Duplicate Products.
                        duplicateProducts.put(product.getID(), quantity);
                    }else if(duplicateProducts.containsKey(product.getID()) && availableQuantity>0){
                        double qty=duplicateProducts.get(product.getID());
                        availableQuantity-=qty;
                        duplicateProducts.put(product.getID(), qty+quantity);
                    }
                    // pick pack DO
                    if(extraCompanyPreferences.isPickpackship() && !isConsignment && !isFixedAsset && !isLeaseFixedAsset && !sendForQAApproval){
                        String store = extraCompanyPreferences.getPackingstore();
                        KwlReturnObject StoreObj = accountingHandlerDAOobj.getObject(Store.class.getName(), store);
                        if(!StringUtil.isNullObject(StoreObj) && StoreObj.getEntityList()!=null && !StoreObj.getEntityList().isEmpty()){
                        Store packingstore = (Store) StoreObj.getEntityList().get(0);
                        double pickpackstoreqty = stockDAO.getProductTotalQuantityInStore(product, packingstore);
                        availableQuantity = availableQuantity - pickpackstoreqty;    
                        }                        
                    }
                    // Auto build for Customer Assembly
                    if ((product.getProducttype().getID().equals(Producttype.ASSEMBLY) || product.getProducttype().getID().equals(Producttype.CUSTOMER_ASSEMBLY))  && product.isAutoAssembly() && availableQuantity < quantitytoBuild) {
                        SequenceFormat format = null;
                        KwlReturnObject kwlObj =null;
                        Locale locale=Locale.forLanguageTag(paramJobj.getString(Constants.language));
                        //below code is for fetching default build assemby sequence format
                        HashMap<String, Object> BAFormatParams = new HashMap<String, Object>();
                        BAFormatParams.put(Constants.moduleid, Constants.Acc_Build_Assembly_Product_ModuleId);
                        BAFormatParams.put("modulename", "autobuildassembly");
                        BAFormatParams.put(Constants.companyKey, companyid);
                        BAFormatParams.put("isdefaultFormat", true);
                        kwlObj = accCompanyPreferencesObj.getSequenceFormat(BAFormatParams);
                        if (kwlObj.getEntityList().size() != 0){
                            format = (SequenceFormat) kwlObj.getEntityList().get(0);
                        }else{
                           String msg1=messageSource.getMessage("acc.product.gridProduct", null, locale);
                           String msg2=messageSource.getMessage("acc.product.document.defaultSequenceFormatNotSet", null,locale);
                           throw new AccountingException(msg1+" <b> "+product.getProductName()+" </b> "+msg2);
                        }
                        JSONArray wastageDetailJArr = new JSONArray();
                        if (jobj.has("wastageDetails") && !StringUtil.isNullOrEmpty(jobj.getString("wastageDetails"))) {
                            wastageDetailJArr = new JSONArray(jobj.getString("wastageDetails"));
                        }

                        paramJobj.put(Constants.productid, jobj.getString(Constants.productid));
                        
                        HashMap<String, Object> assemblyItemParams = new HashMap<String, Object>();
                        assemblyItemParams.put(Constants.productid, product.getID());
                        assemblyItemParams.put(Constants.currencyKey, paramJobj.getString(Constants.currencyKey));
                        if (!StringUtil.isNullOrEmpty(jobj.optString("bomid", ""))) {
                            assemblyItemParams.put("bomdetailid", jobj.getString("bomid"));
                        } else {
                            assemblyItemParams.put("isdefaultbom", true);
                        }
                        assemblyItemParams.put(Constants.companyid, companyid);
                        assemblyItemParams.put(Constants.companyKey, companyid);
                        assemblyItemParams.put(Constants.globalCurrencyKey, paramJobj.getString(Constants.globalCurrencyKey));
                        assemblyItemParams.put(Constants.df, authHandler.getDateOnlyFormat());
                        assemblyItemParams.put("buildquantity", quantity);
                        //assemblyItemParams.put("bomdetailid", bomdetailid);         //Pass bomdetailid
                        KwlReturnObject result = accProductObj.getAssemblyItems(assemblyItemParams);
                        
                        JSONObject assemblyItemsResult = accProductModuleService.getAssemblyItemsJson(paramJobj, result.getEntityList(), 0);

                        JSONArray assemblyItemsJArr = assemblyItemsResult.getJSONArray("data");
                        String assemblyjsonstring = "";

                        JSONArray bomValuationArray = stockService.getPriceCalculationForAsseblyProduct(assemblyItemParams);

                        double totalCost = 0;
                        boolean flag = false; // 'flag' is used for check quantity is available for product or not.
                        for (int cnt = 0; cnt < assemblyItemsJArr.length(); cnt++) {
                            JSONObject assemblyItemJobj = (JSONObject) assemblyItemsJArr.get(cnt);

                            double wastageInventoryQuantity = assemblyItemJobj.optDouble("wastageInventoryQuantity", 0.0);
                            int wastageQuantityType = assemblyItemJobj.optInt("wastageQuantityType", 0);
                            double wastageQuantity = assemblyItemJobj.optDouble("wastageQuantity", 0.0);

                            if (wastageDetailJArr.length() > 0) {
                                for (int wastageCnt = 0; cnt < wastageDetailJArr.length(); wastageCnt++) {
                                    JSONObject wastageDetailJObj = (JSONObject) wastageDetailJArr.get(wastageCnt);
                                    String productid = wastageDetailJObj.optString(Constants.productid, "");
                                    if (!StringUtil.isNullOrEmpty(productid) && assemblyItemJobj.getString(Constants.productid).equalsIgnoreCase(productid)) {
                                        wastageInventoryQuantity = wastageDetailJObj.optDouble("wastageInventoryQuantity", 0.0);
                                        wastageQuantityType = wastageDetailJObj.optInt("wastageQuantityType", 0);
                                        wastageQuantity = wastageDetailJObj.optDouble("wastageQuantity", 0.0);
                                        break;
                                    }
                                }
                            }
                            double onhand = assemblyItemJobj.getDouble("onhand"); // Available quantity of individual product
                            double quantityneeded = assemblyItemJobj.getDouble("quantity"); // Individual product quantity needed to build product 
                            double lockquantity = assemblyItemJobj.getDouble("lockquantity"); // Individual product lock quantity needed to build product 
                            String productName = assemblyItemJobj.getString("productname");
                            double totalquantity = quantitytoBuild;
                            if ((totalquantity * quantityneeded) > (onhand)) { // (total quantity to build*quantity needed)=required quantity <=(available quantity of indivisual product)
                                flag = true;
                            }

                            if (preferences.getNegativestock() == 1 && flag) { // Block case
                                throw new AccountingException(messageSource.getMessage("acc.field.QuantitygiveninBAareexceedingthequantityavailable", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + "<br>" + messageSource.getMessage("acc.nee.54", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " " + productName + " " + messageSource.getMessage("acc.field.is", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " " + onhand + "<br><br><center>" + messageSource.getMessage("acc.field.Soyoucannotproceed", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + "</center>");
                            }

                            double bomRate = 0;
                            if (bomValuationArray != null && bomValuationArray.length() > 0) {
                                for (int bomCount = 0; bomCount < bomValuationArray.length(); bomCount++) {
                                    JSONObject bomValJobj = (JSONObject) bomValuationArray.get(bomCount);
                                    if (bomValJobj.getString(Constants.productid).equalsIgnoreCase(assemblyItemJobj.getString(Constants.productid))) {
                                        bomRate = bomValJobj.getDouble("buildcost");
                                    }
                                }
                            }

                            assemblyjsonstring += "{product:\"" + assemblyItemJobj.getString(Constants.productid) + "\","
                                    + "rate:" + bomRate + "," + "inventoryquantiy:" + assemblyItemJobj.getString("quantity") + "," + "remainingquantity:0,"
                                    + "actualquantity:" + assemblyItemJobj.getString("actualquantity") + "," + "percentage:100,"
                                    + "recylequantity:0," + "quantity:" + assemblyItemJobj.getString("quantity") + ","
                                    + "wastageInventoryQuantity:" + wastageInventoryQuantity + ","
                                    + "wastageQuantityType:" + wastageQuantityType + ","
                                    + "wastageQuantity:" + wastageQuantity
                                    + "},";

                            double aquantity = Double.parseDouble(assemblyItemJobj.optString("quantity", "0"));
                            double deductqty = aquantity * quantity;
//                            totalCost += authHandler.round(deductqty * bomRate, companyid);;
                            totalCost += authHandler.round(quantity * bomRate, companyid);
                        }
                        assemblyjsonstring = assemblyjsonstring.substring(0, assemblyjsonstring.length() - 1);
                        JSONArray jarr = new JSONArray("[" + assemblyjsonstring + "]");
                        if (jarr.length() > 0) {
                            JSONObject inventoryjson = new JSONObject();
                            inventoryjson.put(Constants.productid, product.getID());
                            inventoryjson.put("quantity", quantity);
                            inventoryjson.put("baseuomquantity", quantity);
                            inventoryjson.put("baseuomrate", 1);
                            if (product.getUnitOfMeasure() != null) {
                                inventoryjson.put("uomid", product.getUnitOfMeasure().getID());
                            }
                            inventoryjson.put("description", "Build Assembly");
                            inventoryjson.put("carryin", true);
                            inventoryjson.put("defective", false);
                            inventoryjson.put("newinventory", false);
                            inventoryjson.put(Constants.companyKey, companyid);
                            KwlReturnObject invresult = accProductObj.addInventory(inventoryjson);

                            Inventory inventory = (Inventory) invresult.getEntityList().get(0);
                                                        
                            HashMap<String, Object> assemblyParams = AccountingManager.getGlobalParamsJson(paramJobj);
                            
                            assemblyParams.put("inventory", inventory);
                            assemblyParams.put("assembly", assemblyjsonstring);
                            assemblyParams.put("applydate", paramJobj.optString(Constants.BillDate));
                            assemblyParams.put("quantity", quantity);
                            assemblyParams.put(Constants.memo, messageSource.getMessage("acc.field.systemGeneratedBuildAssembly", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                            assemblyParams.put("description", product.getName());
                            assemblyParams.put("buildproductid", product.getID());
                            assemblyParams.put("doid", doid);
                            assemblyParams.put("cost", totalCost);

                            DateFormat df = (DateFormat) assemblyParams.get("df");
                            String applydate = paramJobj.optString(Constants.BillDate);
                            Date appDate = null;
                            appDate = df.parse(applydate);
                            
                            Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                            synchronized (this) {
                                seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_BUILDASSEMBLY, format.getID(), false, appDate);
                                assemblyParams.put("entrynumber", (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER));
                                assemblyParams.put("autogenerated", true);
                                assemblyParams.put(Constants.SEQFORMAT, format.getID());
                                assemblyParams.put(Constants.SEQNUMBER, (String) seqNumberMap.get(Constants.SEQNUMBER));
                                assemblyParams.put(Constants.DATEPREFIX, (String) seqNumberMap.get(Constants.DATEPREFIX));
                                assemblyParams.put(Constants.DATEAFTERPREFIX, (String) seqNumberMap.get(Constants.DATEAFTERPREFIX));
                                assemblyParams.put(Constants.DATESUFFIX, (String) seqNumberMap.get(Constants.DATESUFFIX));
                            }
                            assemblyParams.put("autoBAcreatedon",dorder.getCreatedon());
                            ProductBuild productBuild = accProductObj.updateAssemblyInventory(assemblyParams);
                            
                            //To save the Build Reference No. we have used this HashMap
                            pbuildMap.put(productBuild.getProduct().getID(), productBuild);
                            
                            // Create Journal Entry Number for new case
                            
                            JSONObject jedjson = new JSONObject();
                            String jeid = null;
                            HashSet jeDetails = new HashSet();
                            KwlReturnObject jedresult = null;
                            JournalEntryDetail jed = null;
                            
//                            if(preferences.getInventoryValuationType()==Constants.PERPETUAL_VALUATION_METHOD || (preferences.getInventoryValuationType()==Constants.PERIODIC_VALUATION_METHOD && PeriodicJE)){
                                postJe=true;
                                String oldjeid = productBuild.getJournalentry() != null ? productBuild.getJournalentry().getID() : "";
                                refNo = productBuild.getRefno();
                                String jeentryNumber = "";
                                String jeIntegerPart = "";
                                String jeDatePrefix = "";
                                String jeDateAfterPrefix = "";
                            String jeDateSuffix = "";
                            String jeSeqFormatId = "";
                            boolean jeautogenflag = false;
                            if (StringUtil.isNullOrEmpty(oldjeid)) {
                                synchronized (this) {
                                    HashMap<String, Object> JEFormatParams = new HashMap<>();
                                    JEFormatParams.put(Constants.moduleid, Constants.Acc_GENERAL_LEDGER_ModuleId);
                                    JEFormatParams.put("modulename", CompanyPreferencesConstants.AUTOJOURNALENTRY);
                                    JEFormatParams.put(Constants.companyKey, companyid);
                                    JEFormatParams.put("isdefaultFormat", true);

                                    kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                                    format = (SequenceFormat) kwlObj.getEntityList().get(0);
                                    seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, format.getID(), false, appDate);
                                    jeentryNumber = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);//ERP-26367
                                    jeIntegerPart = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                                    jeDatePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                                    jeDateAfterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                                    jeDateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                                    jeSeqFormatId = format.getID();
                                    jeautogenflag = true;
                                }
                            }

                            Map<String, Object> jeDataMap = AccountingManager.getGlobalParamsJson(paramJobj);
                            jeDataMap.put("entrynumber", jeentryNumber);
                            jeDataMap.put("autogenerated", jeautogenflag);
                            jeDataMap.put(Constants.SEQFORMAT, jeSeqFormatId);
                            jeDataMap.put(Constants.SEQNUMBER, jeIntegerPart);
                            jeDataMap.put(Constants.DATEPREFIX, jeDatePrefix);
                            jeDataMap.put(Constants.DATEAFTERPREFIX, jeDateAfterPrefix);
                            jeDataMap.put(Constants.DATESUFFIX, jeDateSuffix);
                            jeDataMap.put("entrydate", appDate);
                            jeDataMap.put(Constants.companyKey, companyid);
                            jeDataMap.put(Constants.memo, "Build Assembly JE for " + product.getName());
                            jeDataMap.put("createdby", paramJobj.optString(Constants.useridKey));
                            jeDataMap.put(Constants.currencyKey,  paramJobj.optString(Constants.currencyKey));
                             jeDetails = new HashSet();
                            KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap); // Create Journal entry without JEdetails
                            JournalEntry journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
                             jeid = journalEntry.getID();
                            jeDataMap.put("jeid", jeid);

                             jedjson = new JSONObject();
                            jedjson.put("srno", jeDetails.size() + 1);
                            jedjson.put(Constants.companyKey, companyid);
                            jedjson.put("amount", productBuild.getProductcost());
                            jedjson.put("accountid", product.getPurchaseAccount().getID());
                            jedjson.put("debit", true);
                            jedjson.put("jeid", jeid);
                             jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                             jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                            jeDetails.add(jed);
                                productBuild.setJournalentry(journalEntry);
                                productBuild.setTotaljed(jed);
                            
//                        }
                            
                            productBuild.setInventory(inventory);
                           
                            accProductObj.updateProductBuild(productBuild);

                            double totalWastageAmount = 0, totalBuildCost = 0;
                            List returnArrList = new ArrayList();
                            for (int j = 0; j < jarr.length(); j++) {
                                JSONObject assemblyJobj = jarr.getJSONObject(j);
                                HashMap<String, Object> requestParams = new HashMap<>();
                                requestParams.put("quantity", quantity);
                                requestParams.put("postJe", postJe);    //SDP-14552 : JE Amount was not posting due to wrong case-sensitive key of MAP
                                requestParams.put("assemblyjson", assemblyJobj.toString());
                                requestParams.put("buildproductid", productBuild.getID());
                                requestParams.put(Constants.companyKey, companyid);
                                ProductBuildDetails productBuildDetail = accProductObj.updateAssemblyBuildDetails(requestParams, jeid, jeDetails, returnArrList);
                                totalWastageAmount += (Double) returnArrList.get(0);
                                totalBuildCost += (Double) returnArrList.get(1);
                            }

                            saveAutoBuildAssemblyBatchDetails(paramJobj, product, productBuild, jobj);
                            // Wastage total credit entry
//                            if (preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD || (preferences.getInventoryValuationType() == Constants.PERIODIC_VALUATION_METHOD && PeriodicJE)) {
                            if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateWastageCalculation() && totalWastageAmount != 0) {
                                jedjson = new JSONObject();
                                jedjson.put("srno", jeDetails.size() + 1);
                                jedjson.put(Constants.companyKey, companyid);
                                jedjson.put("amount", totalWastageAmount);
                                jedjson.put("accountid", product.getPurchaseAccount().getID());
                                jedjson.put("debit", false);
                                jedjson.put("jeid", jeid);
                                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                                jeDetails.add(jed);
                            }
                            /*
                             * Below block written to handle JE details according to LIFO/FIFO
                             */
                            jedjson = new JSONObject();
                            jedjson.put("jedid", jed.getID());
                            jedjson.put("jeid", jeid);
                            jedjson.put("amount", totalBuildCost);
                            accJournalEntryobj.addJournalEntryDetails(jedjson);
//                        }
                            productBuild.setProductcost(totalBuildCost);
                        }

                        String action = "added";
                        String auditaction = AuditAction.PRODUCT_BUILD_ASSEMBLY_ADDED;
                        if (isEdit) {
                            action = "updated";
                            auditaction = AuditAction.PRODUCT_BUILD_ASSEMBLY_UPDATED;
                        }
                         Map<String, Object> auditRequestParams = new HashMap<>();
                        auditRequestParams.put(Constants.reqHeader, paramJobj.getString(Constants.reqHeader));
                        auditRequestParams.put(Constants.remoteIPAddress, paramJobj.getString(Constants.remoteIPAddress));
                        auditRequestParams.put(Constants.useridKey, paramJobj.getString(Constants.useridKey));
                        auditTrailObj.insertAuditLog(auditaction, "User " +  paramJobj.optString(Constants.userfullname) + " has " + action + " product build Assembly " + refNo, auditRequestParams, "");
                    }
                }
            }
        } catch (ParseException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (SessionExpiredException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ServiceException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (JSONException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
        return pbuildMap;
    }

    @Override
    public Set<DOContractMapping> getDOContractMappings(Map<String, Object> requestParams, DeliveryOrder deliveryOrder) throws ServiceException, AccountingException {
        String[] salesOrderIds = {};
        if (requestParams.containsKey("linkNumber")) {
            salesOrderIds = requestParams.get("linkNumber").toString().split(",");
        }
        Set<DOContractMapping> contractMappings = new HashSet<DOContractMapping>();
        for (int i = 0; i < salesOrderIds.length; i++) {
            if (!StringUtil.isNullOrEmpty(salesOrderIds[i])) {
                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), salesOrderIds[i]);
                SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);

                // Check if sales order is created by linking with Replacement, if it is then fetch Linked replacement Object and put it in docontractmapping
                ProductReplacement productReplacement = null;
                if (salesOrder.isIsReplacementSO()) {
                    HashMap<String, Object> soMap = new HashMap<String, Object>();
                    soMap.put("salesOrderId", salesOrder.getID());
                    KwlReturnObject productReplacementObj = accSalesOrderDAOObj.getProductReplacementsLinkedWithSalesOrder(soMap);

                    List productReplacementList = productReplacementObj.getEntityList();

                    if (!productReplacementList.isEmpty()) {
                        KwlReturnObject productReplacementObj1 = accountingHandlerDAOobj.getObject(ProductReplacement.class.getName(), (String) productReplacementList.get(0));
                        productReplacement = (ProductReplacement) productReplacementObj1.getEntityList().get(0);
                        System.out.println(productReplacement.getReplacementRequestNumber());
                    }
                }
                Contract contract = salesOrder.getContract();
                Company company = salesOrder.getCompany();
                if (contract != null) {
                    DOContractMapping contractMapping = new DOContractMapping();
                    contractMapping.setCompany(company);
                    contractMapping.setContract(contract);
                    contractMapping.setDeliveryOrder(deliveryOrder);
                    contractMapping.setSalesOrder(salesOrder);

                    if (productReplacement != null) {
                        contractMapping.setProductReplacement(productReplacement);
                    }

                    contractMappings.add(contractMapping);
                }
            }
        }
        return contractMappings;
    }

    @Override
    public Set<DOContractMapping> getDOContractMappingsFromInvoice(Map<String, Object> requestParams, DeliveryOrder deliveryOrder) throws ServiceException {
        String[] invoiceIds = {};
        if (requestParams.containsKey("linkNumber")) {
            invoiceIds = requestParams.get("linkNumber").toString().split(",");
        }
        Set<DOContractMapping> contractMappings = new HashSet<DOContractMapping>();
        for (int i = 0; i < invoiceIds.length; i++) {
            if (!StringUtil.isNullOrEmpty(invoiceIds[i])) {
                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceIds[i]);
                Invoice invoice = (Invoice) rdresult.getEntityList().get(0);

                Set<InvoiceContractMapping> invoiceContractMappings = invoice.getContractMappings();
                if (!invoiceContractMappings.isEmpty()) {
                    List<String> contractMappingDuplicateCheckList = new ArrayList<String>();

                    /*
                     * Invoice can be create by linking with multiple sales
                     * order. and each sales order may point to different
                     * Contract. so for a single Invoice there may be multiple
                     * Contracts. and invoicecontractmapping table may contain
                     * duplicate values of contract.
                     */
                    for (InvoiceContractMapping contractMapping : invoiceContractMappings) {
                        if (!contractMappingDuplicateCheckList.contains(contractMapping.getContract().getID())) {
                            contractMappingDuplicateCheckList.add(contractMapping.getContract().getID());
                            DOContractMapping dOContractMapping = new DOContractMapping();
                            dOContractMapping.setCompany(invoice.getCompany());
                            dOContractMapping.setContract(contractMapping.getContract());
                            dOContractMapping.setDeliveryOrder(deliveryOrder);
                            contractMappings.add(dOContractMapping);
                        }
                    }
                }
            }
        }
        return contractMappings;
    }

    /*
     * Function to fetch sales order status for Delivery order. Checked if
     * delivery order of all sales order quantities are prepared.
     */
    @Override
    public String getSalesOrderStatusForDO(SalesOrder so, boolean isConsignment, ExtraCompanyPreferences extraCompanyPreferences, String doid) throws ServiceException {
        Set<SalesOrderDetail> orderDetail = so.getRows();
        Iterator ite = orderDetail.iterator();
        String result = "Closed";
        double soquantity = 0;
        double doquantity = 0;
        while (ite.hasNext()) {
            SalesOrderDetail soDetail = (SalesOrderDetail) ite.next();

            //this code is used to update the Sales return so as as we are making DO then that sales  return shoild not be deleteable
            KwlReturnObject sridresult = accInvoiceDAOobj.getSRFromSOD(soDetail.getID());
            List listSr = sridresult.getEntityList();
            Iterator iteSR = listSr.iterator();
            while (iteSR.hasNext()) {
                KwlReturnObject presult = accountingHandlerDAOobj.getObject(SalesReturn.class.getName(), (String) iteSR.next());
                SalesReturn salesreturn = (SalesReturn) presult.getEntityList().get(0);
                if (salesreturn != null) {
                    HashMap poMap = new HashMap();
                    poMap.put("salesreturn", salesreturn);
                    poMap.put(Constants.companyKey, salesreturn.getCompany().getCompanyID());
                    poMap.put("isdeletable", false);
                    accInvoiceDAOobj.updateSalesReturnStatus(poMap);
                }
            }

            //below code is used to get the quantity of current GR order and according to that to update linked purchase order
            KwlReturnObject idresult = accInvoiceDAOobj.getDOIDFromSOD(soDetail.getID(), doid);
            List list = idresult.getEntityList();
            Iterator ite1 = list.iterator();
            double qua = 0;
            while (ite1.hasNext()) {
                DeliveryOrderDetail ge = (DeliveryOrderDetail) ite1.next();
                qua += ge.getDeliveredQuantity();//Delivered Quantity i.e Actual Quantity delivered while linking with Sales Order 
            }
            doquantity += qua;
            if (isConsignment && extraCompanyPreferences != null && extraCompanyPreferences.isRequestApprovalFlow()) {
                soquantity += soDetail.getBalanceqty();
                if (soDetail != null) {
                    if (soDetail != null && !StringUtil.isNullOrEmpty(soDetail.getID()) && qua > 0) {
                        HashMap poMap = new HashMap();
                        poMap.put("sodetails", soDetail.getID());
                        poMap.put(Constants.companyKey, soDetail.getCompany().getCompanyID());
                        poMap.put("balanceqty", qua);
                        poMap.put("add", false);
                        accCommonTablesDAO.updateSalesorderOrderStatus(poMap);
                    }
                }
            } else {
                if (qua < soDetail.getBalanceqty() - qua) {
                    soquantity += soDetail.getBalanceqty();
                    if (soDetail != null) {
                        if (soDetail != null && !StringUtil.isNullOrEmpty(soDetail.getID()) && qua > 0) {
                            HashMap poMap = new HashMap();
                            poMap.put("sodetails", soDetail.getID());
                            poMap.put(Constants.companyKey, soDetail.getCompany().getCompanyID());
                            poMap.put("balanceqty", qua);
                            poMap.put("add", false);
                            accCommonTablesDAO.updateSalesorderOrderStatus(poMap);
                        }
                    }
                } else {
                    soquantity += soDetail.getBalanceqty();
                    if (soDetail != null) {
                        if (soDetail != null && !StringUtil.isNullOrEmpty(soDetail.getID()) && qua > 0) {
                            HashMap poMap = new HashMap();
                            poMap.put("sodetails", soDetail.getID());
                            poMap.put(Constants.companyKey, soDetail.getCompany().getCompanyID());
                            poMap.put("balanceqty", qua);
                            poMap.put("add", false);
                            accCommonTablesDAO.updateSalesorderOrderStatus(poMap);
                        }
                    }
                }
            }
        }
        /*
         * Checking whether Sales Order fully used in DO or not
         */
        if (doquantity < soquantity) {
            result = "Open";
        }
        return result;
    }
    /**
     * ERP-34156
     * @desc checks if pickpackDO created
     * @param requestParams
     * @return true (for Present) and false (for Not Present)
     * @throws ServiceException
     * @throws JSONException 
     */
    @Override
    public JSONObject isPickPackShipDOPresent(JSONObject requestParams) throws ServiceException, JSONException {
        JSONObject returnObject = new JSONObject();
        Map<String, Object> params = new HashMap();
        Locale locale = (Locale) requestParams.get(Constants.locale);
        if (!StringUtil.isNullOrEmpty(requestParams.optString(Constants.companyid))) {
            params.put(Constants.companyid, requestParams.optString(Constants.companyid));
        }
        KwlReturnObject res = accInvoiceDAOobj.isPickPackShipDOPresent(params);
        if (res != null) {
            returnObject.put(Constants.RES_success, res.isSuccessFlag());
            /**
             * Display message if DO is Present.
             */
            if (res.isSuccessFlag()) {
                returnObject.put(Constants.RES_msg, messageSource.getMessage("acc.pickpackship.systemPreference", null, locale));
            }
        }
        return returnObject;
    }
            
    @Override
    public String getInvoiceStatusForDO(Invoice iv) throws ServiceException {
        Set<InvoiceDetail> ivDetail = iv.getRows();
        Iterator ite = ivDetail.iterator();
        String result = "Closed";
        while (ite.hasNext()) {
            InvoiceDetail iDetail = (InvoiceDetail) ite.next();
            KwlReturnObject idresult = accInvoiceDAOobj.getDOIDFromInvoiceDetails(iDetail.getID());
            List list = idresult.getEntityList();
            Iterator ite1 = list.iterator();
            double qua = 0;
            while (ite1.hasNext()) {
                DeliveryOrderDetail ge = (DeliveryOrderDetail) ite1.next();
                qua += ge.getInventory().getQuantity();
            }
            if (qua < iDetail.getInventory().getQuantity()) {
                result = "Open";
                break;
            }
        }
        return result;
    }

    @Override
    public void makeProductReplacementIdsSetAndupdateProductReplacementDetails(ProductReplacementDetail productReplacementDetail, HashSet<String> productReplacementIds, String companyid, double dquantity) throws ServiceException {
        if (productReplacementDetail != null) {
            double replacedQuantity = productReplacementDetail.getReplacedQuantity();

            double totalReplacedQuantity = replacedQuantity + dquantity;

            HashMap<String, Object> productReplacementDetailsMap = new HashMap<String, Object>();

            productReplacementDetailsMap.put("totalReplacedQuantity", totalReplacedQuantity);
            productReplacementDetailsMap.put("productReplacementDetailId", productReplacementDetail.getId());
            productReplacementDetailsMap.put("companyId", companyid);

            accSalesOrderDAOObj.updateProductReplacementDetails(productReplacementDetailsMap);

            productReplacementIds.add(productReplacementDetail.getProductReplacement().getId());
        }

    }
    /**
     * @param deliveryOrder
     * @param doApproveMap (Constants.PAGE_URL)// For sending URL in mail
     * @return
     * @throws SessionExpiredException
     * @throws ServiceException
     * @throws JSONException
     * @throws AccountingException
     * @throws ScriptException 
     */
    public int getDOCurrentApprovalStatusLevel(DeliveryOrder deliveryOrder, HashMap<String, Object> doApproveMap) throws SessionExpiredException, ServiceException, JSONException, AccountingException, ScriptException {

        int currentDOApprovalLevel = 11;
        // Check for Multi level Approval Rules
        if (!(deliveryOrder.isFixedAssetDO() || deliveryOrder.isLeaseDO() || deliveryOrder.isIsconsignment() || deliveryOrder.isIsAutoGeneratedDO())) {
            // if this is a lease or fixed asset DO or consignment Dothen it will not go for approval
            boolean isMailApplicable = false;
            boolean hasAuthority = false;
            String companyid = "";
            List mailParamList = new ArrayList();
            if (doApproveMap.containsKey(Constants.companyKey) && doApproveMap.get(Constants.companyKey) != null) {
                companyid = doApproveMap.get(Constants.companyKey).toString();
            }
            String currentUser = "";
            if (doApproveMap.containsKey("currentUser") && doApproveMap.get("currentUser") != null) {
                currentUser = doApproveMap.get("currentUser").toString();
            }
            int level = 0;
            if (doApproveMap.containsKey("level") && doApproveMap.get("level") != null) {
                level = Integer.parseInt(doApproveMap.get("level").toString());
            }
            String amount = "";
            if (doApproveMap.containsKey("totalAmount") && doApproveMap.get("totalAmount") != null) {
                amount = doApproveMap.get("totalAmount").toString();
            }
            boolean fromCreate = false;
            if (doApproveMap.containsKey("fromCreate") && doApproveMap.get("fromCreate") != null) {
                fromCreate = Boolean.parseBoolean(doApproveMap.get("fromCreate").toString());
            }
            JSONArray productDiscountMapList = null;
            if (doApproveMap.containsKey("productDiscountMapList") && doApproveMap.get("productDiscountMapList") != null) {
                productDiscountMapList = new JSONArray(doApproveMap.get("productDiscountMapList").toString());
            }
            if (!fromCreate) {
                String thisUser = currentUser;
                KwlReturnObject userclass = accountingHandlerDAOobj.getObject(User.class.getName(), thisUser);
                User user = (User) userclass.getEntityList().get(0);

                if (AccountingManager.isCompanyAdmin(user)) {
                    hasAuthority = true;
                } else {
                    hasAuthority = accountingHandlerDAOobj.checkForMultiLevelApprovalRules(doApproveMap);
                }
            } else {
                hasAuthority = true;
            }
            if (hasAuthority) {
                ScriptEngineManager mgr = new ScriptEngineManager();
                ScriptEngine engine = mgr.getEngineByName("JavaScript");
                int approvalStatus = 11;
                String prNumber = deliveryOrder.getDeliveryOrderNumber();
                HashMap<String, Object> qdDataMap = new HashMap<String, Object>();
                qdDataMap.put(Constants.companyKey, companyid);
                qdDataMap.put("level", level + 1);
                qdDataMap.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                KwlReturnObject flowresult = accMultiLevelApprovalDAOObj.getMultiApprovalRuleData(qdDataMap);
                Iterator itr = flowresult.getEntityList().iterator();
                String fromName = "User";
                fromName = deliveryOrder.getCreatedby().getFirstName().concat(" ").concat(deliveryOrder.getCreatedby().getLastName());
                /**
                 * parameters required for sending mail
                 */
                Map<String, Object> mailParameteres = new HashMap();
                mailParameteres.put(Constants.companyid, companyid);
                mailParameteres.put(Constants.prNumber, prNumber);
                mailParameteres.put(Constants.fromName, fromName);
                mailParameteres.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                mailParameteres.put(Constants.isCash, false);
                mailParameteres.put(Constants.createdBy, deliveryOrder.getCreatedby().getUserID());
                if (doApproveMap.containsKey(Constants.PAGE_URL)) {
                    mailParameteres.put(Constants.PAGE_URL, (String) doApproveMap.get(Constants.PAGE_URL));
                }
                while (itr.hasNext()) {
                    Object[] row = (Object[]) itr.next();
                    mailParameteres.put(Constants.ruleid, row[0].toString());
                    HashMap<String, Object> recMap = new HashMap();
                    String rule = "";
                    if (row[2] != null) {
                        rule = row[2].toString();
                    }
                    String discountRule = "";
                    if (row[7] != null) {
                        discountRule = row[7].toString();
                    }
                    boolean sendForApproval = false;
                    int appliedUpon = Integer.parseInt(row[5].toString());
                    if (appliedUpon == Constants.Specific_Products || appliedUpon == Constants.Specific_Products_Discount) {
                        if (productDiscountMapList != null) {
                            sendForApproval = AccountingManager.checkForProductAndProductDiscountRule(productDiscountMapList, appliedUpon, rule, discountRule);
                        }
                    } else if (appliedUpon == Constants.Specific_Products_Category) {
                        /*
                         * Check If Rule is apply on product category from
                         * multiapproverule window
                         */
                        sendForApproval = accountingHandlerDAOobj.checkForProductCategoryForProduct(productDiscountMapList, appliedUpon, rule);
                    } else {
                        rule = rule.replaceAll("[$$]+", amount);
                    }
                    if (StringUtil.isNullOrEmpty(rule) || (!StringUtil.isNullOrEmpty(rule) && appliedUpon != Constants.Specific_Products && appliedUpon != Constants.Specific_Products_Discount &&appliedUpon != Constants.Specific_Products_Category && Boolean.parseBoolean(engine.eval(rule).toString())) || sendForApproval) {
                        // send emails
                        boolean hasApprover = Boolean.parseBoolean(row[3].toString());
                        mailParameteres.put(Constants.hasApprover, hasApprover);
                        if (isMailApplicable) {
                            sendMailToApprover(mailParameteres);
                            approvalStatus = level + 1;
                        } else {
                            approvalStatus = level + 1;
                            recMap.put("ruleid", row[0].toString());
                            recMap.put("fromName", fromName);
                            recMap.put("hasApprover", hasApprover);
                            mailParamList.add(recMap);
                        }

                    }
                }
                currentDOApprovalLevel = approvalStatus;
            } else {
                currentDOApprovalLevel = Constants.NoAuthorityToApprove; //if not have approval permission then return one fix value like 999
            }
        }
        return currentDOApprovalLevel;
    }
    
    private void saveAutoBuildAssemblyBatchDetails(JSONObject paramJobj, Product product, ProductBuild productBuild, JSONObject jobj) throws SessionExpiredException, UnsupportedEncodingException, ServiceException, ParseException, JSONException, AccountingException {
        double buildQty = jobj.optDouble("quantity", 0);
        double baseuomrate = jobj.optDouble("baseuomrate", 1);
        buildQty = buildQty * baseuomrate;
        String productBatchId = null;
        Company company = product.getCompany();
        DateFormat df1 = authHandler.getDateOnlyFormat();
        KwlReturnObject extraKwlReturnObject = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), company.getCompanyID());
        ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extraKwlReturnObject.getEntityList().get(0);
        if (!StringUtil.isNullOrEmpty(jobj.optString("batchdetails"))) {
            String batchJSON = jobj.optString("batchdetails");
            JSONArray jArr = new JSONArray(batchJSON);
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject rowBatchDetail = jArr.getJSONObject(i);
                NewProductBatch productBatch = null;
                if (product.isIswarehouseforproduct() || product.isIslocationforproduct()) {
                    KwlReturnObject kmsg = null;
                    String batchname = StringUtil.DecodeText(rowBatchDetail.optString("batch"));
                    productBatchId = accCommonTablesDAO.getpurchaseBatchIdForLocationWarehouseRowRackBin(product.getID(), rowBatchDetail.getString("location"), rowBatchDetail.getString("warehouse"), rowBatchDetail.optString("row", null), rowBatchDetail.optString("rack", null), rowBatchDetail.optString("bin", null), batchname);

                    //save batch detail of assembly product
                    if (StringUtil.isNullOrEmpty(productBatchId)) {

                        HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                        pdfTemplateMap.put(Constants.companyKey, product.getCompany().getCompanyID());
                        pdfTemplateMap.put("name", batchname);
                        if (rowBatchDetail.has("mfgdate") && !StringUtil.isNullOrEmpty(rowBatchDetail.getString("mfgdate"))) {
                            pdfTemplateMap.put("mfgdate", df1.parse(rowBatchDetail.getString("mfgdate")));
                        }
                        if (rowBatchDetail.has("expdate") && !StringUtil.isNullOrEmpty(rowBatchDetail.getString("expdate"))) {
                            pdfTemplateMap.put("expdate", df1.parse(rowBatchDetail.getString("expdate")));
                        }
                        pdfTemplateMap.put("quantity", rowBatchDetail.getString("quantity"));
                        if (rowBatchDetail.has("balance") && !StringUtil.isNullOrEmpty(rowBatchDetail.getString("balance"))) {
                            pdfTemplateMap.put("balance", rowBatchDetail.getString("balance"));
                        }
                        pdfTemplateMap.put("location", rowBatchDetail.optString("location", ""));
                        pdfTemplateMap.put("product", product.getID());
                        pdfTemplateMap.put("warehouse", rowBatchDetail.optString("warehouse", ""));
                        pdfTemplateMap.put("row", rowBatchDetail.optString("row", null));
                        pdfTemplateMap.put("rack", rowBatchDetail.optString("rack", null));
                        pdfTemplateMap.put("bin", rowBatchDetail.optString("bin", null));
                        pdfTemplateMap.put("isopening", false);
                        pdfTemplateMap.put("transactiontype", "28");//This is GRN Type Tranction  
                        pdfTemplateMap.put("ispurchase", true);
                        kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);

                        if (kmsg != null && kmsg.getEntityList().size() != 0) {
                            productBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                            productBatchId = productBatch.getId();
                        }
                    } else {
                        HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                        batchUpdateQtyMap.put("qty", String.valueOf(Double.parseDouble(rowBatchDetail.getString("quantity"))));
                        batchUpdateQtyMap.put("quantity", String.valueOf(Double.parseDouble(rowBatchDetail.getString("quantity"))));
                        batchUpdateQtyMap.put("id", productBatchId);
                        accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                        KwlReturnObject batchRes = accProductObj.getObject(NewProductBatch.class.getName(), productBatchId);
                        productBatch = (NewProductBatch) batchRes.getEntityList().get(0);
                    }

                    //make entry of assembly product in locationbatchdoucmentmapping table
                    HashMap<String, Object> documentMap = new HashMap<String, Object>();
                    documentMap.put("quantity", rowBatchDetail.getString("quantity"));
                    documentMap.put("batchmapid", productBatchId);
                    documentMap.put("documentid", productBuild.getID());
                    documentMap.put("transactiontype", "28");//This is GRN Type Tranction
                    if (rowBatchDetail.has("mfgdate") && !StringUtil.isNullOrEmpty(rowBatchDetail.getString("mfgdate"))) {
                        documentMap.put("mfgdate", df1.parse(rowBatchDetail.getString("mfgdate")));
                    }
                    if (rowBatchDetail.has("expdate") && !StringUtil.isNullOrEmpty(rowBatchDetail.getString("expdate"))) {
                        documentMap.put("expdate", df1.parse(rowBatchDetail.getString("expdate")));
                    }
                    accCommonTablesDAO.saveBatchDocumentMapping(documentMap);

                    //add stock movement entry for Assembly Product
                    StockMovement stockmnt = new StockMovement();
                    Set<StockMovementDetail> stockMovementDetails = new HashSet<StockMovementDetail>();
                    StockMovementDetail stockmovementDTL = new StockMovementDetail();
                    Store Invwarehouse = null;
                    Location locationObj = null;

                    double quantity = rowBatchDetail.optDouble("quantity", 0);
                    String location = rowBatchDetail.optString("location", "");
                    String warehouse = rowBatchDetail.optString("warehouse", "");

                    if (!StringUtil.isNullOrEmpty(location)) {
                        KwlReturnObject rs = accProductObj.getObject(Location.class.getName(), location);
                        locationObj = (Location) rs.getEntityList().get(0);
                    }
                    if (!StringUtil.isNullOrEmpty(warehouse)) {
                        KwlReturnObject rs = accProductObj.getObject(Store.class.getName(), warehouse);
                        Invwarehouse = (Store) rs.getEntityList().get(0);
                    }

                    if (locationObj != null && Invwarehouse != null) {
                        stockmnt.setProduct(product);
                        stockmnt.setPricePerUnit(productBuild.getProductcost() / quantity);
                        stockmnt.setModuleRefId(productBuild != null ? productBuild.getID() : product.getID());
                        stockmnt.setModuleRefDetailId(productBuild != null ? productBuild.getID() : product.getID());
                        stockmnt.setAssembledProduct(product);
                        stockmnt.setCompany(company);
                        stockmnt.setQuantity(quantity);
                        stockmnt.setTransactionNo(productBuild.getRefno());
                        stockmnt.setRemark("New Stock Added from Auto Build Assembly.");
                        stockmnt.setStore(Invwarehouse);
                        stockmnt.setStockUoM(product.getUnitOfMeasure());
                        stockmnt.setTransactionModule(TransactionModule.PRODUCT_BUILD_ASSEMBLY);
                        stockmnt.setTransactionType(TransactionType.IN);
                        stockmnt.setTransactionDate(productBuild.getEntryDate());
                        stockmovementDTL.setBatchName("");
                        stockmovementDTL.setLocation(locationObj);
                        if (product.isIsrowforproduct()) {
                            KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), rowBatchDetail.optString("row"));
                            StoreMaster row = (StoreMaster) krObject.getEntityList().get(0);
                            stockmovementDTL.setRow(row);
                        }
                        if (product.isIsrackforproduct()) {
                            KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), rowBatchDetail.optString("rack"));
                            StoreMaster rack = (StoreMaster) krObject.getEntityList().get(0);
                            stockmovementDTL.setRack(rack);
                        }
                        if (product.isIsbinforproduct()) {
                            KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), rowBatchDetail.optString("bin"));
                            StoreMaster bin = (StoreMaster) krObject.getEntityList().get(0);
                            stockmovementDTL.setBin(bin);
                        }
                        stockmovementDTL.setQuantity(quantity);
                        stockmovementDTL.setSerialNames(null);
                        stockmovementDTL.setStockMovement(stockmnt);
                        stockMovementDetails.add(stockmovementDTL);
                        stockmnt.setStockMovementDetails(stockMovementDetails);
                        stockMovementService.addStockMovement(stockmnt);

                        //save batchDetail of BOM products
                        HashMap<String, Object> requestParams = new HashMap<String, Object>();
                        requestParams.put(Constants.productid, product.getID());
                        requestParams.put(Constants.currencyKey, paramJobj.optString(Constants.currencyKey));
                        KwlReturnObject bdresult = accProductObj.getAssemblyBuidDetails(productBuild.getID());
                        Iterator bditr = bdresult.getEntityList().iterator();
                        while (bditr.hasNext()) {
                            ProductBuildDetails pbdetail = (ProductBuildDetails) bditr.next();

                            if (pbdetail.getAproduct().getID() != null && (pbdetail.getAproduct().isIswarehouseforproduct() || pbdetail.getAproduct().isIslocationforproduct())) {
                                String BOMProductBatchId = null;
                                String bomProductId = pbdetail.getAproduct().getID();
                                NewProductBatch BOMProductBatch = null;
                                double actQty = pbdetail.getActualQuantity();
                                BOMProductBatchId = accCommonTablesDAO.getpurchaseBatchIdForLocationWarehouseRowRackBin(bomProductId, rowBatchDetail.getString("location"), rowBatchDetail.getString("warehouse"), rowBatchDetail.optString("row", null), rowBatchDetail.optString("rack", null), rowBatchDetail.optString("bin", null), StringUtil.DecodeText(rowBatchDetail.optString("batch")));

                                KwlReturnObject prodRes = accountingHandlerDAOobj.getObject(Product.class.getName(), bomProductId);
                                Product BOMProductObj = (Product) prodRes.getEntityList().get(0);

                                KwlReturnObject batchRes = accProductObj.getObject(NewProductBatch.class.getName(), BOMProductBatchId);
                                BOMProductBatch = (NewProductBatch) batchRes.getEntityList().get(0);
                                if (BOMProductBatch == null) { // Create batch if not available for ingredients
                                    HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                                    pdfTemplateMap.put(Constants.companyKey, product.getCompany().getCompanyID());
                                    pdfTemplateMap.put("name", batchname);
                                    if (rowBatchDetail.has("mfgdate") && !StringUtil.isNullOrEmpty(rowBatchDetail.getString("mfgdate"))) {
                                        pdfTemplateMap.put("mfgdate", df1.parse(rowBatchDetail.getString("mfgdate")));
                                    }
                                    if (rowBatchDetail.has("expdate") && !StringUtil.isNullOrEmpty(rowBatchDetail.getString("expdate"))) {
                                        pdfTemplateMap.put("expdate", df1.parse(rowBatchDetail.getString("expdate")));
                                    }
                                    pdfTemplateMap.put("location", rowBatchDetail.optString("location", ""));
                                    pdfTemplateMap.put("product", BOMProductObj.getID());
                                    pdfTemplateMap.put("warehouse", rowBatchDetail.optString("warehouse", ""));
                                    pdfTemplateMap.put("row", rowBatchDetail.optString("row", null));
                                    pdfTemplateMap.put("rack", rowBatchDetail.optString("rack", null));
                                    pdfTemplateMap.put("bin", rowBatchDetail.optString("bin", null));
                                    pdfTemplateMap.put("isopening", false);
                                    pdfTemplateMap.put("transactiontype", "27");//This is DO type transaction
                                    kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);
                                    if (kmsg != null && kmsg.getEntityList().size() != 0) {
                                        BOMProductBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                                        BOMProductBatchId = BOMProductBatch.getId();
                                    }
                                }
                                if (BOMProductBatch != null) {
                                    double dueQty = BOMProductBatch.getQuantitydue();
                                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                                    batchUpdateQtyMap.put("id", BOMProductBatchId);
                                    if (dueQty > 0 || extraCompanyPreferences.isIsnegativestockforlocwar()) {
                                        if ((BOMProductBatch.getQuantitydue() < actQty * buildQty) && !extraCompanyPreferences.isIsnegativestockforlocwar()) {
                                            throw new AccountingException("BoM quantity to create Assembly is not sufficient");
                                        } else {
                                            batchUpdateQtyMap.put("qty", String.valueOf(-(actQty * buildQty)));
                                        }
                                        accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);  //updating batch qtydue

                                        HashMap<String, Object> documentMap1 = new HashMap<String, Object>();
                                        documentMap1.put("quantity", String.valueOf(actQty * buildQty));
                                        documentMap1.put("documentid", pbdetail.getID());
                                        documentMap1.put("transactiontype", "27");
                                        documentMap1.put("mfgdate", BOMProductBatch.getMfgdate());
                                        documentMap1.put("expdate", BOMProductBatch.getExpdate());
                                        documentMap1.put("batchmapid", BOMProductBatchId);
                                        accCommonTablesDAO.saveBatchDocumentMapping(documentMap1); //adding entry in locationbatchdocumentmapping for BoM products

                                        //add stock movement entry for BoM Product
                                        StockMovement BoMStockMnt = new StockMovement();

                                        BoMStockMnt.setPricePerUnit(pbdetail.getRate());
                                        BoMStockMnt.setModuleRefId(productBuild.getID());
                                        BoMStockMnt.setModuleRefDetailId(productBuild.getID());
                                        BoMStockMnt.setProduct(BOMProductObj);
                                        BoMStockMnt.setRemark("Used in Auto Assembly");
                                        BoMStockMnt.setTransactionNo(productBuild.getRefno());
                                        BoMStockMnt.setStockUoM(BOMProductObj.getUnitOfMeasure());
                                        BoMStockMnt.setTransactionModule(TransactionModule.PRODUCT_BUILD_ASSEMBLY);
                                        BoMStockMnt.setTransactionType(TransactionType.OUT);
                                        BoMStockMnt.setCompany(company);
                                        BoMStockMnt.setAssembledProduct(productBuild.getProduct());
                                        BoMStockMnt.setTransactionDate(productBuild.getEntryDate());
                                        BoMStockMnt.setQuantity(actQty * buildQty);
                                        Set<StockMovementDetail> stockMovementDetailSet = new HashSet<StockMovementDetail>();
                                        StockMovementDetail BoMstockmovementDTL = new StockMovementDetail();

                                        if (Invwarehouse != null && locationObj != null) {
                                            BoMStockMnt.setStore(Invwarehouse);
                                            BoMstockmovementDTL.setBatchName("");
                                            BoMstockmovementDTL.setLocation(locationObj);
                                            if (BOMProductObj.isIsrowforproduct()) {
                                                KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), rowBatchDetail.optString("row"));
                                                StoreMaster row1 = (StoreMaster) krObject.getEntityList().get(0);
                                                BoMstockmovementDTL.setRow(row1);
                                            }
                                            if (BOMProductObj.isIsrackforproduct()) {
                                                KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), rowBatchDetail.optString("rack"));
                                                StoreMaster rack = (StoreMaster) krObject.getEntityList().get(0);
                                                BoMstockmovementDTL.setRack(rack);
                                            }
                                            if (BOMProductObj.isIsbinforproduct()) {
                                                KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), rowBatchDetail.optString("bin"));
                                                StoreMaster bin = (StoreMaster) krObject.getEntityList().get(0);
                                                BoMstockmovementDTL.setBin(bin);
                                            }
                                            BoMstockmovementDTL.setQuantity(actQty * buildQty);
                                            BoMstockmovementDTL.setSerialNames(null);
                                            BoMstockmovementDTL.setStockMovement(BoMStockMnt);
                                            stockMovementDetailSet.add(BoMstockmovementDTL);
                                        }

                                        if (BoMStockMnt.getStore() != null) {
                                            BoMStockMnt.setStockMovementDetails(stockMovementDetailSet);
                                            stockMovementService.addStockMovement(BoMStockMnt);
                                        }

                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    public void sendMailOnConsignmentDOCreationUpdation(String companyId, DeliveryOrder deliveryOrder, boolean isEdit, DocumentEmailSettings documentEmailSettings,String entryNumber) throws ServiceException {
        String  htmlTextC = "", subject = "";
        String [] toEmailIds = {};
        String doCreatorName = deliveryOrder.getCreatedby().getFullName();
        String doNumber = deliveryOrder.getDeliveryOrderNumber();
        if(StringUtil.isNullOrEmpty(doNumber)){
            doNumber=entryNumber;
        }
        htmlTextC += "<br/>Hi,<br/>";
        if (!isEdit) {
            htmlTextC += "<br/>User <b>" + doCreatorName + "</b> has created new Delivery Order  <b>" + doNumber + "</b>.<br/>";
        } else {
            htmlTextC += "<br/>User <b>" + doCreatorName + "</b> has edited Delivery Order <b>" + doNumber + "</b>.<br/>";
        }
        KwlReturnObject result = accountingHandlerDAOobj.getNotifications(companyId);
        List<NotificationRules> list = result.getEntityList();
        Iterator<NotificationRules> itr = list.iterator();
        while (itr.hasNext()) {
            NotificationRules nr = itr.next();
            if (nr != null && nr.getModuleId() == 201) {
                if (Integer.parseInt(nr.getFieldid()) == 28) {
                    subject = nr.getMailsubject();
                    htmlTextC = nr.getMailcontent();

                    subject = subject.replaceAll("#Customer_Alias#", (deliveryOrder.getCustomer() != null && deliveryOrder.getCustomer().getAliasname() != null) ? deliveryOrder.getCustomer().getAliasname() : "");
                    subject = subject.replaceAll("#Document_Number#", doNumber);
                    htmlTextC = htmlTextC.replaceAll("#Document_Number#", doNumber);
                    htmlTextC = htmlTextC.replaceAll("#User_Name#", doCreatorName);
                    
                    if (isEdit) {
                        subject = subject.replaceAll("Creation", "updation");
                        subject = subject.replaceAll("generation", "updation");
                        htmlTextC = htmlTextC.replaceAll("added", "updated");
                        htmlTextC = htmlTextC.replaceAll("created", "updated");
                    }
                    
                    
                    Set<DeliveryOrderDetail> dodSet = deliveryOrder.getRows();
                    Set<String> toEmailIdSet = new HashSet<String>();
                    Iterator<DeliveryOrderDetail> itr2 = dodSet.iterator();
                    if (nr.isMailToSalesPerson()) {
                        while (itr2.hasNext()) {
                            DeliveryOrderDetail dod = itr2.next();
                            if (dod.getSodetails() != null) {
                                MasterItem mi = dod.getSodetails().getSalesOrder().getSalesperson();
                                if (mi != null) {
                                    toEmailIdSet.add(mi.getEmailID());
                                }
                            }
                        }
                    }
                    KwlReturnObject userRes = null;
                    if (!StringUtil.isNullOrEmpty(nr.getUsers())) {
                        String userIds[] = nr.getUsers().split(",");
                        for (String userId : userIds) {
                            User user = null;
                            userRes = accountingHandlerDAOobj.getObject(User.class.getName(), userId);
                            user = (User) userRes.getEntityList().get(0);
                            if(user != null && !StringUtil.isNullOrEmpty(user.getEmailID())){
                                toEmailIdSet.add(user.getEmailID());
                            }
                        }
                    }
                    if (!StringUtil.isNullOrEmpty(nr.getEmailids())) { //copy to emails address
                        String copyToEmailIdArr[] = nr.getEmailids().split(",");
                        for(String usermail : copyToEmailIdArr){
                            toEmailIdSet.add(usermail);
                        }
                    }
                    toEmailIds=StringUtils.split(StringUtils.join(toEmailIdSet, ","), ",");
                    break;
                }
            }
        }
        List<String> headerSOItemsList=new ArrayList<String>();
        List<String> headerItemsList=new ArrayList<String>();
        List rowDetailMapList=new ArrayList();
        List rowSODetailMapList=new ArrayList();
        
        boolean isFirst=true;
        boolean isSOFirst=true;
        String salePersonListStr="";
        String doStatus="";
        if(deliveryOrder.getStatus() != null){
             doStatus=deliveryOrder.getStatus().getValue();
        }
        Set<String> ReqSet=new HashSet<String>();
        
        String reqNoHeader = "Req. No.";
        String warehouseHeader = "Warehouse";
        String locationHeader = "Location";
        String fromDateHeader = "From Date";
        String toDateHeader = "To Date";
        SimpleDateFormat sdf = new SimpleDateFormat(Constants.yyyyMMdd);  
        for(DeliveryOrderDetail dodetail : deliveryOrder.getRows()){
            String requestNo="";
           String warehouse="";
           String location="";
           Date fromDate=null;
           Date toDate=null;
           
           if (dodetail.getSodetails() != null && dodetail.getSodetails().getSalesOrder() != null) {
               requestNo = dodetail.getSodetails().getSalesOrder().getSalesOrderNumber();
               SalesOrder so = dodetail.getSodetails().getSalesOrder();
               
               if (isSOFirst) {
                   headerSOItemsList.add(reqNoHeader);
                   headerSOItemsList.add(warehouseHeader);
                   headerSOItemsList.add(locationHeader);
                   headerSOItemsList.add(fromDateHeader);
                   headerSOItemsList.add(toDateHeader);
                   isSOFirst = false;
               }
               if (!ReqSet.contains(requestNo)) {
                   warehouse = (so.getRequestWarehouse() != null ? so.getRequestWarehouse().getName() : "");
                   location = (so.getRequestLocation() != null ? so.getRequestLocation().getName() : "");
                   fromDate = so.getFromdate();
                   toDate = so.getTodate();
                   String salesPersonName = "";
                   MasterItem mi1 = so.getSalesperson();
                   if (mi1 != null) {
                       salesPersonName = mi1.getValue();
                       if (!StringUtil.isNullOrEmpty(salesPersonName)) {
                           if (StringUtil.isNullOrEmpty(salePersonListStr) && dodetail.getSrno()==1 ) {
                               salePersonListStr += salesPersonName;
                           } 
//                           else {
//                                salePersonListStr += ("," + salesPersonName);
//                           }
                       }
                   }

                   Map soMap = new HashMap();
                   soMap.put(reqNoHeader, requestNo);
                   soMap.put(warehouseHeader, warehouse);
                   soMap.put(locationHeader, location);
                   soMap.put(fromDateHeader, (fromDate != null ? sdf.format(fromDate) : ""));
                   soMap.put(toDateHeader,(toDate != null ? sdf.format(toDate) : ""));
                   rowSODetailMapList.add(soMap);
               }

                ReqSet.add(requestNo);
            }
            
            String productIdHeader="Product ID";
            String productDescHeader="Product Description";
            String reqQtyHeader="Requested Quantity";
            String delQtyHeader="Delivered Quantity";
            String productUoMHeader="UoM";
            if(isFirst){
                headerItemsList.add(productIdHeader);
                headerItemsList.add(productDescHeader);
                headerItemsList.add(reqQtyHeader);
                headerItemsList.add(delQtyHeader);
                headerItemsList.add(productUoMHeader);
                isFirst=false;
            }
            Map map=new HashMap();
            map.put(productIdHeader, dodetail.getProduct().getProductid());
            map.put(productDescHeader, dodetail.getProduct().getDescription());
            map.put(reqQtyHeader, dodetail.getActualQuantity());
            map.put(delQtyHeader, dodetail.getDeliveredQuantity());
            map.put(productUoMHeader, dodetail.getProduct().getUnitOfMeasure() != null ? dodetail.getProduct().getUnitOfMeasure().getNameEmptyforNA() : "");
            rowDetailMapList.add(map);
        }
        
        subject = subject.replaceAll("#Sales_Person#",salePersonListStr );
        
        htmlTextC = htmlTextC.concat("<br/>");
        htmlTextC = htmlTextC.concat("<b>Customer Name : </b>"+ (deliveryOrder.getCustomer() != null ? deliveryOrder.getCustomer().getName() : "")+"<br/>");
        htmlTextC = htmlTextC.concat("<b>Customer Warehouse : </b>"+(deliveryOrder.getCustWarehouse() != null ? deliveryOrder.getCustWarehouse().getName() : "")+"<br/>");
        htmlTextC = htmlTextC.concat("<b>Status : </b>"+ doStatus+"<br/>");
        htmlTextC = htmlTextC.concat("<br/><br/>");
        //for SO detail table 
        String soDetailTabularHTML="<table>";
        
        soDetailTabularHTML += "<tr>";
        for(String soHeader: headerSOItemsList){
            soDetailTabularHTML += "<th align='left'>"+soHeader+"</th>";
        }
        soDetailTabularHTML += "</tr>";
        
        for(Object obj: rowSODetailMapList){
            Map soDtlMap = (Map)obj;
            soDetailTabularHTML += "<tr>";
            for(String soHeader: headerSOItemsList){
                soDetailTabularHTML += "<td width='100px'>"+ soDtlMap.get(soHeader) +"</td>";
            }
           soDetailTabularHTML += "</tr>";
        }
        
        soDetailTabularHTML += "</table>";
        htmlTextC = htmlTextC.concat(soDetailTabularHTML);
        htmlTextC = htmlTextC.concat("<br/>");
         //for DO detail table 
        String doDetailTabularHTML=accountingHandlerDAOobj.getTabularFormatHTMLForNotificationMail(headerItemsList, rowDetailMapList);
        htmlTextC = htmlTextC.concat(doDetailTabularHTML);
        accountingHandlerDAOobj.sendTransactionEmails(toEmailIds, "", subject, htmlTextC, htmlTextC, companyId);
    }
  
    @Override
    public List<String> approveInvoice(Invoice invoice, HashMap<String, Object> invApproveMap, boolean isMailApplicable) throws SessionExpiredException, AccountingException, ServiceException, ScriptException, MessagingException, JSONException {
        boolean hasAuthority = false;
        String companyid = "";
        boolean iscash = false;
        String recurredinvoiceapproverid = "";
        List returnList = new ArrayList();
        List mailParamList = new ArrayList();
        int returnStatus;

        if (invApproveMap.containsKey(Constants.companyKey) && invApproveMap.get(Constants.companyKey) != null) {
            companyid = invApproveMap.get(Constants.companyKey).toString();
        }
        String currentUser = "";
        if (invApproveMap.containsKey("currentUser") && invApproveMap.get("currentUser") != null) {
            currentUser = invApproveMap.get("currentUser").toString();
        }
        int level = 0;
        if (invApproveMap.containsKey("level") && invApproveMap.get("level") != null) {
            level = Integer.parseInt(invApproveMap.get("level").toString());
        }
        String amount = "";
        if (invApproveMap.containsKey("totalAmount") && invApproveMap.get("totalAmount") != null) {
            amount = invApproveMap.get("totalAmount").toString();
        }
        boolean fromCreate = false;
        if (invApproveMap.containsKey("fromCreate") && invApproveMap.get("fromCreate") != null) {
            fromCreate = Boolean.parseBoolean(invApproveMap.get("fromCreate").toString());
        }
        int moduleid = 0;
        if (invApproveMap.containsKey(Constants.moduleid) && invApproveMap.get(Constants.moduleid) != null) {
            moduleid = Integer.parseInt(invApproveMap.get(Constants.moduleid).toString());
        }
        if (invApproveMap.containsKey("iscash") && invApproveMap.get("iscash") != null) {
            iscash = Boolean.parseBoolean(invApproveMap.get("iscash").toString());
        }
        JSONArray productDiscountMapList = null;
        if (invApproveMap.containsKey("productDiscountMapList") && invApproveMap.get("productDiscountMapList") != null) {
            productDiscountMapList = new JSONArray(invApproveMap.get("productDiscountMapList").toString());
        }

        if (!fromCreate) {
            String thisUser = currentUser;
            KwlReturnObject userclass = accountingHandlerDAOobj.getObject(User.class.getName(), thisUser);
            User user = (User) userclass.getEntityList().get(0);

            if (AccountingManager.isCompanyAdmin(user)) {
                hasAuthority = true;
            } else {
                /*
                 If "Send approval documents to next level" is disabled from system preferences & pending document is edited then
                 1. When user is authorised then document is always goes at first level
                 2. When user is not authorised then document remains at same level
                 
                 */
                boolean isEditedPendingDocumentWithCheckOff = false;
                if (invApproveMap.containsKey("isEditedPendingDocumentWithCheckOff") && invApproveMap.get("isEditedPendingDocumentWithCheckOff") != null) {
                    level = Integer.parseInt(invApproveMap.get("documentLevel").toString());//Actual level of document for fetching rule at that level for the user
                    invApproveMap.put("level", level);

                    isEditedPendingDocumentWithCheckOff = true;
                }
                hasAuthority = accountingHandlerDAOobj.checkForMultiLevelApprovalRules(invApproveMap);

                /*---If User is authorised at this level then sending document to first level that's why assigning "level=0" ------ */
                if (isEditedPendingDocumentWithCheckOff && hasAuthority) {
                    level = 0;
                }
            }
        } else {
            hasAuthority = true;
        }

        if (invApproveMap.containsKey("recurredinvoiceapproverid") && invApproveMap.get("recurredinvoiceapproverid") != null) {
            recurredinvoiceapproverid = invApproveMap.get("recurredinvoiceapproverid").toString();
        }
        if (!StringUtil.isNullOrEmpty(recurredinvoiceapproverid)) {
            // this if block is written for approving recurring invoice which are pending for approval.
            int approvalStatus = 11;
            String invID = invoice.getID();
            KwlReturnObject userclass = accountingHandlerDAOobj.getObject(User.class.getName(), currentUser);
            User user = (User) userclass.getEntityList().get(0);
            if (AccountingManager.isCompanyAdmin(user)) {
                hasAuthority = true;
            } else {
                if (invoice.getParentInvoice() != null && invoice.getParentInvoice().getRepeateInvoice() != null) {
                    RepeatedInvoices parentsRepeatedinvoice = (RepeatedInvoices) invoice.getParentInvoice().getRepeateInvoice();
                    String approver = parentsRepeatedinvoice.getApproverOfEditedrecurredInvoice() != null ? parentsRepeatedinvoice.getApproverOfEditedrecurredInvoice().getUserID() : "";
                    if (parentsRepeatedinvoice != null && approver.equals(user.getUserID())) {
                        hasAuthority = true;
                    }
                }
            }
            if (hasAuthority) {
                accInvoiceDAOobj.approvePendingInvoice(invID, companyid, approvalStatus);
                returnStatus = approvalStatus;
            } else {
                returnStatus = Constants.NoAuthorityToApprove;
            }
        } else if (hasAuthority) {
            ScriptEngineManager mgr = new ScriptEngineManager();
            ScriptEngine engine = mgr.getEngineByName("JavaScript");
            int approvalStatus = 11;
            String invNumber = invoice.getInvoiceNumber();
            String invID = invoice.getID();
            HashMap<String, Object> qdDataMap = new HashMap<String, Object>();
            qdDataMap.put(Constants.companyKey, companyid);
            qdDataMap.put("level", level + 1);
            qdDataMap.put(Constants.moduleid, moduleid);
            KwlReturnObject flowresult = accMultiLevelApprovalDAOObj.getMultiApprovalRuleData(qdDataMap);
            Iterator itr = flowresult.getEntityList().iterator();
            String fromName = "User";
            fromName = invoice.getCreatedby().getFirstName().concat(" ").concat(invoice.getCreatedby().getLastName());
            /**
             * parameters required for sending mail
             */
            Map<String, Object> mailParameteres = new HashMap();
            mailParameteres.put(Constants.companyid, companyid);
            mailParameteres.put(Constants.prNumber, invNumber);
            mailParameteres.put(Constants.fromName, fromName);
            mailParameteres.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
            mailParameteres.put(Constants.isCash, iscash);
            mailParameteres.put(Constants.createdBy, invoice.getCreatedby().getUserID());
            if (invApproveMap.containsKey(Constants.PAGE_URL)) {
                mailParameteres.put(Constants.PAGE_URL, (String) invApproveMap.get(Constants.PAGE_URL));
            }
            while (itr.hasNext()) {
                Object[] row = (Object[]) itr.next();
                mailParameteres.put(Constants.ruleid, row[0].toString());
                HashMap<String, Object> recMap = new HashMap();
                String rule = "";
                if (row[2] != null) {
                    rule = row[2].toString();
                }
                String discountRule = "";
                if (row[7] != null) {
                    discountRule = row[7].toString();
                }
                boolean sendForApproval = false;
                int appliedUpon = Integer.parseInt(row[5].toString());
                if (appliedUpon == Constants.Specific_Products || appliedUpon == Constants.Specific_Products_Discount) {
                    if (productDiscountMapList != null) {
                        sendForApproval = AccountingManager.checkForProductAndProductDiscountRule(productDiscountMapList, appliedUpon, rule, discountRule);
                    }
                }else if(appliedUpon ==Constants.Specific_Products_Category){
                    /*
                     * Check If Rule is apply on product
                     * category from multiapproverule window
                     */
                    sendForApproval = accountingHandlerDAOobj.checkForProductCategoryForProduct(productDiscountMapList, appliedUpon, rule);
                }else {
                    rule = rule.replaceAll("[$$]+", amount);
                }
                if (StringUtil.isNullOrEmpty(rule) || (!StringUtil.isNullOrEmpty(rule) && appliedUpon != Constants.Specific_Products && appliedUpon != Constants.Specific_Products_Discount && appliedUpon != Constants.Specific_Products_Category && Boolean.parseBoolean(engine.eval(rule).toString())) || sendForApproval) {
                    // send emails
                    boolean hasApprover = Boolean.parseBoolean(row[3].toString());
                    mailParameteres.put(Constants.hasApprover, hasApprover);
                    if (isMailApplicable) {
//                        approvalStatus = level + 1;
                        mailParameteres.put("level",level);
                        sendMailToApprover(mailParameteres);
                        approvalStatus = level + 1;
                        
                    } else {
                        approvalStatus = level + 1;
                        recMap.put("ruleid", row[0].toString());
                        recMap.put("fromName", fromName);
                        recMap.put("hasApprover", hasApprover);

                        mailParamList.add(recMap);
                    }

                }
            }
            accInvoiceDAOobj.approvePendingInvoice(invID, companyid, approvalStatus);
            returnStatus = approvalStatus;
        } else {
            returnStatus = Constants.NoAuthorityToApprove; // if not have approval permission then return one fix value like 999
        }
        returnList.add(returnStatus);
        returnList.add(mailParamList);

        return returnList;

    }
    
    /**
     * @param mailParameters(String companyid, String ruleId, String prNumber, String fromName, boolean hasApprover, int moduleid, boolean iscash, String createdby)
     * @throws ServiceException 
     */
    @Override
    public void sendMailToApprover(Map<String, Object> mailParameters) throws ServiceException {
         KwlReturnObject cap = null;
         int level=0;
        if (mailParameters.containsKey(Constants.companyid)) {
            cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), (String) mailParameters.get(Constants.companyid));
        }
        CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
        boolean hasApprover = false;
        boolean iscash = false;
        int moduleid = 0;
        String createdby = "";
        if(mailParameters.containsKey(Constants.createdBy)){
            createdby = (String) mailParameters.get(Constants.createdBy);
        }
        if(mailParameters.containsKey(Constants.moduleid)){
            moduleid = (int) mailParameters.get(Constants.moduleid);
        }
        if(mailParameters.containsKey(Constants.hasApprover)){
            hasApprover = (boolean) mailParameters.get(Constants.hasApprover);
        }
        if (mailParameters.containsKey(Constants.isCash)) {
            iscash = (boolean) mailParameters.get(Constants.isCash);
        }
        if(mailParameters.containsKey("level")){
            level = (int) mailParameters.get("level");
        }
        String transactionName = "";
        String transactionNo = "";
        switch (moduleid) {
            case Constants.Acc_Invoice_ModuleId:
                if (iscash) {
                    transactionName = "Cash Sales";
                    transactionNo = "Cash Sales Number";
                } else {
                    transactionName = "Sales Invoice";
                    transactionNo = "Sales Invoice Number";
                }
                break;
            case Constants.Acc_Delivery_Order_ModuleId:
                transactionName = "Delivery Order";
                transactionNo = "Delivery Order Number";
                break;
        }
        String requisitionApprovalSubject = transactionName + ": %s - Approval Notification";
        String requisitionApprovalHtmlMsg = "<html><head><title>Deskera Accounting - Your Deskera Account</title></head><style type='text/css'>"
                + "a:link, a:visited, a:active {\n"
                + " 	color: #03C;"
                + "}\n"
                + "body {\n"
                + "	font-family: Arial, Helvetica, sans-serif;"
                + "	color: #000;"
                + "	font-size: 13px;"
                + "}\n"
                + "</style><body>"
                + "<p>Hi All,</p>"
                + "<p></p>"
                    + "<p>%s has created " + transactionName + " %s and sent it to you for approval. at level "+(level+1)+"</p>"
                + "<p>Please review and approve it (" + transactionNo + ": %s).</p>"
                + "<p>Company Name:- %s</p>"
                + "<p>Please check on Url:- %s</p>"
                + "<p></p>"
                + "<p>Thanks</p>"
                + "<p>This is an auto generated email. Do not reply<br>";
        String requisitionApprovalPlainMsg = "Hi All,\n\n"
                + "%s has created " + transactionName + "%s and sent it to you for approval. at level "+(level+1)+"\n"
                + "Please review and approve it (" + transactionNo + ": %s).\n\n"
                + "Company Name:- %s \n"
                + "Please check on Url:- %s \n\n"
                + "Thanks\n\n"
                + "This is an auto generated email. Do not reply\n";
        try {
            if (hasApprover && preferences.isSendapprovalmail()) { // If allow to send approval mail in company account preferences
                KwlReturnObject returnObject = null;
                if(mailParameters.containsKey(Constants.companyid)){
                    returnObject = accountingHandlerDAOobj.getObject(Company.class.getName(), (String) mailParameters.get(Constants.companyid));
                }
                Company company = (Company) returnObject.getEntityList().get(0);
                String fromEmailId = (!company.isEmailFromCompanyCreator()) ? Constants.ADMIN_EMAILID : authHandlerDAOObj.getSysEmailIdByCompanyID(company.getCompanyID());
                String companyName = company.getCompanyName();
                String subject = "";
                String htmlMsg = "";
                String plainMsg = "";
                if (mailParameters.containsKey(Constants.prNumber) ) {
                     subject = String.format(requisitionApprovalSubject, (String) mailParameters.get(Constants.prNumber));
                }
                if (mailParameters.containsKey(Constants.prNumber) && mailParameters.containsKey(Constants.fromName) && mailParameters.containsKey(Constants.PAGE_URL)) {
                     htmlMsg = String.format(requisitionApprovalHtmlMsg, (String) mailParameters.get(Constants.fromName), (String) mailParameters.get(Constants.prNumber),  (String) mailParameters.get(Constants.prNumber), companyName, (String) mailParameters.get(Constants.PAGE_URL));
                     plainMsg = String.format(requisitionApprovalPlainMsg, (String) mailParameters.get(Constants.fromName), (String) mailParameters.get(Constants.prNumber), (String) mailParameters.get(Constants.prNumber), companyName, (String) mailParameters.get(Constants.PAGE_URL));
                }
                ArrayList<String> emailArray = new ArrayList<>();
                String[] emails = {};
                String userDepartment = null;
                KwlReturnObject returnObjectRes = null;

                HashMap<String, Object> dataMap = new HashMap<>();
                if (mailParameters.containsKey(Constants.ruleid)) {
                    dataMap.put(Constants.ruleid, (String) mailParameters.get(Constants.ruleid));
                }
                if(mailParameters.containsKey(Constants.companyid)){
                    dataMap.put(Constants.companyKey, (String) mailParameters.get(Constants.companyid));
                }
                dataMap.put("checkdeptwiseapprover", true);

                KwlReturnObject userResult1 = accMultiLevelApprovalDAOObj.checkDepartmentWiseApprover(dataMap);
                if (userResult1 != null && userResult1.getEntityList() != null && userResult1.getEntityList().size() > 0) {
                    User user = null;
                    if (!StringUtil.isNullObject(createdby)) {
                        returnObjectRes = accountingHandlerDAOobj.getObject(User.class.getName(), createdby);
                        user = (User) returnObjectRes.getEntityList().get(0);
                    }
                    if (user != null && !StringUtil.isNullObject(user.getDepartment())) {
                        userDepartment = user.getDepartment();
                        dataMap.put("userdepartment", userDepartment);
                    }
                }

                KwlReturnObject userResult = accMultiLevelApprovalDAOObj.getApprovalRuleTargetUsers(dataMap);

                if (userResult.getEntityList() != null && userResult.getEntityList().size() <= 0 && !StringUtil.isNullOrEmpty(userDepartment)) {
                    dataMap.remove("userdepartment");
                    userResult = accMultiLevelApprovalDAOObj.getApprovalRuleTargetUsers(dataMap);
                }

                Iterator useritr = userResult.getEntityList().iterator();
                while (useritr.hasNext()) {
                    Object[] userrow = (Object[]) useritr.next();
                    emailArray.add(userrow[3].toString());
                }
                emails = emailArray.toArray(emails);
                if (!StringUtil.isNullOrEmpty(preferences.getApprovalEmails())) {
                    String[] compPrefMailIds = preferences.getApprovalEmails().split(",");
                    emails = AccountingManager.getMergedMailIds(emails, compPrefMailIds);
                }
                if (emails.length > 0) {
                    Map<String, Object> smtpConfigMap = authHandler.getSMTPConfigMap(company);
                    SendMailHandler.postMail(emails, subject, htmlMsg, plainMsg, fromEmailId, smtpConfigMap);
                }
            }
        } catch (MessagingException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    @Override
    /*Request Dependency Removed*/
    public void saveConsignSRBatch(String batchJSON, Inventory inventory, JSONObject paramJobj, SalesReturnDetail salesReturnDetail) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        double ActbatchQty = 1;
        double batchQty = 0;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        boolean isConsignment = false;
        if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment))) {
            isConsignment = Boolean.parseBoolean(paramJobj.getString(Constants.isConsignment));
        }
        boolean isQAinspection = false;
        if (!StringUtil.isNullOrEmpty(paramJobj.optString("isQAinspection"))) {//this flag is for saving consignment return and it will true if return quantity will go through QA Inspection process otherwise it will be false
            isQAinspection = Boolean.parseBoolean(paramJobj.getString("isQAinspection"));
        }
        if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), inventory.getProduct().getID());
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
        }

        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        for (int i = 0; i < jArr.length(); i++) {
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            if (jSONObject.has("quantity") && !jSONObject.getString("quantity").equals("undefined") && !jSONObject.getString("quantity").isEmpty()) {
                ActbatchQty = jSONObject.getDouble("quantity");
            }
            if (batchQty == 0) {
                batchQty = jSONObject.getDouble("quantity");
            }
            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) && (batchQty == ActbatchQty)) {
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.getString("quantity"));
                documentMap.put("batchmapid", jSONObject.getString("purchasebatchid"));
                documentMap.put("documentid", salesReturnDetail.getID());
                documentMap.put("transactiontype", isConsignment ? "53" : "29");//This is GRN Type Tranction  
                documentMap.put(Constants.isConsignment, isConsignment);  // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                    documentMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                    documentMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expdate")));
                }

                if (!isBatchForProduct && !isSerialForProduct) {
                    HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                    filter_names.add("company.companyID");
                    filter_params.add(paramJobj.getString(Constants.companyKey));

                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("warehouse"))) {
                        String warehouse = jSONObject.getString("warehouse");
                        filter_names.add("warehouse.id");
                        filter_params.add(warehouse);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("location"))) {
                        String location = jSONObject.getString("location");
                        filter_names.add("location.id");
                        filter_params.add(location);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("row"))) {
                        String row = jSONObject.getString("row");
                        filter_names.add("row.id");
                        filter_params.add(row);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("rack"))) {
                        String rack = jSONObject.getString("rack");
                        filter_names.add("rack.id");
                        filter_params.add(rack);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("bin"))) {
                        String bin = jSONObject.getString("bin");
                        filter_names.add("bin.id");
                        filter_params.add(bin);
                    }

                    filter_names.add("product");
                    filter_params.add(inventory.getProduct().getID());
                    filterRequestParams.put("filter_names", filter_names);
                    filterRequestParams.put("filter_params", filter_params);
                    filterRequestParams.put("order_by", order_by);
                    filterRequestParams.put("order_type", order_type);
                    KwlReturnObject result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                    List listResult = result.getEntityList();
                    Iterator itrResult = listResult.iterator();
                    Double quantityToDue = ActbatchQty;
                    while (itrResult.hasNext()) {
                        NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                        if (quantityToDue > 0) {
                            double dueQty = newProductBatch.getQuantitydue();
                            HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                            batchUpdateQtyMap.put(Constants.Acc_id, newProductBatch.getId());
                            if (dueQty > 0) {
                                if (quantityToDue > dueQty) {
                                    batchUpdateQtyMap.put("qty", String.valueOf(-(dueQty)));
                                    if (isConsignment) {
                                        batchUpdateQtyMap.put("isForconsignment", true);  //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                                    }
                                    quantityToDue = quantityToDue - dueQty;

                                } else {
                                    batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));
                                    if (isConsignment) {
                                        batchUpdateQtyMap.put("isForconsignment", true); //as it is consignment do so it should not be available for normal salesreturn so we are making this flag true
                                    }
                                    quantityToDue = quantityToDue - quantityToDue;
                                }
                                documentMap.put("batchmapid", newProductBatch.getId());
                                accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                            }
                        }
                    }

                } else {
                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                    batchUpdateQtyMap.put("qty", String.valueOf(-(Double.parseDouble(jSONObject.getString("quantity")))));
                    batchUpdateQtyMap.put(Constants.Acc_id, jSONObject.getString("purchasebatchid"));
                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                }
                accCommonTablesDAO.saveBatchDocumentMapping(documentMap);

            }
            batchQty--;

            if (isSerialForProduct) {  //if serial no option is on then only save the serial no details 
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", 1);
                documentMap.put("serialmapid", jSONObject.getString("purchaseserialid"));
                documentMap.put("documentid", salesReturnDetail.getID());
                documentMap.put("transactiontype", isConsignment ? "53" : "29");
                documentMap.put(Constants.isConsignment, isConsignment); // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expend")));
                }
                if (jSONObject.has("reusablecount") && !StringUtil.isNullOrEmpty(jSONObject.getString("reusablecount"))) {
                    documentMap.put("reusablecount", jSONObject.getString("reusablecount"));
                }
                accCommonTablesDAO.saveSerialDocumentMapping(documentMap);

                HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                serialUpdateQtyMap.put("qty", "-1");
                serialUpdateQtyMap.put(Constants.Acc_id, jSONObject.getString("purchaseserialid"));
                serialUpdateQtyMap.put("isQAinspection", isQAinspection);
                serialUpdateQtyMap.put("consignquantity", "-1");
                accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);
                KwlReturnObject serialObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), jSONObject.getString("purchaseserialid"));
                NewBatchSerial newBatchSerial = (NewBatchSerial) serialObj.getEntityList().get(0);
            } else {
                batchQty = 0;
            }
        }
    }  
    
  
    // this function is used for adding data to company warehoue so here purchasebatchid should be companys Do batch id 
  @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public void saveSRBatch(String batchJSON, Inventory inventory, JSONObject paramJobj, SalesReturnDetail salesReturnDetail, List<StockMovement> stockMovementsList, List<Consignment> ConsignmentList, String rowId) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        double ActbatchQty = 1;
        double batchQty = 0;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        boolean isConsignment = false;
        int serialsequence = 1 , batchsequence = 1; // for user selected sequence of batch and serial while creating SR.
        int moduleid = 53;
        boolean isnegativestockforlocwar = false;
        String purchaseSerialId = "";
        String batchWarehouse = "";
        String batchLocation = "";
        KwlReturnObject kmsg = null;
        String entryNumber = paramJobj.optString("number",null);
        DateFormat df = authHandler.getDateOnlyFormat();
        String companyid = paramJobj.getString(Constants.companyKey);
        if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment,null))) {
            isConsignment = Boolean.parseBoolean(paramJobj.getString(Constants.isConsignment));
        }
        if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.moduleid,null))) {
            moduleid = Integer.parseInt(paramJobj.getString(Constants.moduleid));
        }

        boolean isQAinspection = false;
        if (!StringUtil.isNullOrEmpty(paramJobj.optString("isQAinspection",null))) {//this flag is for saving consignment return and it will true if return quantity will go through QA Inspection process otherwise it will be false
            isQAinspection = Boolean.parseBoolean(paramJobj.getString("isQAinspection"));
        }
        ConsignmentApprovalDetails cad = null;
        Consignment consignmentobj = new Consignment();
        Set<ConsignmentApprovalDetails> consignDetailsSet = new HashSet<ConsignmentApprovalDetails>();

        ExtraCompanyPreferences extraCompanyPreferences = null;
        KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), paramJobj.getString(Constants.companyKey));
        extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
        isnegativestockforlocwar = extraCompanyPreferences.isIsnegativestockforlocwar();

        if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), inventory.getProduct().getID());
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
        }

        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        StockMovementDetail smd = null;
        StockMovement stockMovement = null;
        NewProductBatch productBatch = null;
        String productBatchId = "";
        Map<Store, StockMovement> storeWiseStockMovement = new HashMap<Store, StockMovement>();

        if (isWarehouseForProduct && isLocationForProduct && isQAinspection) {
            consignmentobj.setCompany(inventory.getCompany());
            consignmentobj.setProduct(inventory.getProduct());
            consignmentobj.setUom(inventory.getProduct().getUnitOfMeasure());
            consignmentobj.setReturnQuantity(authHandler.calculateBaseUOMQuatity(salesReturnDetail.getReturnQuantity(), salesReturnDetail.getBaseuomrate(), companyid));
            consignmentobj.setTransactionNo(salesReturnDetail.getSalesReturn().getSalesReturnNumber());
            consignmentobj.setCustomer(salesReturnDetail.getSalesReturn().getCustomer());
            consignmentobj.setDocumentid(salesReturnDetail.getID());
            consignmentobj.setModuleRefId(salesReturnDetail.getSalesReturn().getID());
            consignmentobj.setUnitPrice(salesReturnDetail.getBaseuomrate() < 1 ? (salesReturnDetail.getRate() * (1/salesReturnDetail.getBaseuomrate())) : salesReturnDetail.getRate() / salesReturnDetail.getBaseuomrate());
            consignmentobj.setCostcenter(salesReturnDetail.getSalesReturn().getCostcenter());
        }
        for (int i = 0; i < jArr.length(); i++) {
            String purchaseBatchMapId = "";
            String batchname = "";
            Location locationObj = null;
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            if (jSONObject.has("quantity") && !jSONObject.getString("quantity").equals("undefined") && !jSONObject.getString("quantity").isEmpty()) {
                ActbatchQty = jSONObject.getDouble("quantity");
            }
            String stockType = jSONObject.has("stocktype") ? jSONObject.getString("stocktype") : "";
            NewProductBatch neproductbatch = null;
            if (isConsignment) {    // here we are taking company level batchmapid  so as to add data again to company level
                if (!StringUtil.isNullOrEmpty(jSONObject.getString("purchasebatchid")) && !StringUtil.isNullOrEmpty(jSONObject.getString("batch"))) {
                    if (!StringUtil.isNullOrEmpty(rowId)) {
                        purchaseBatchMapId = accCommonTablesDAO.getpurchaseBatchIdForSRByRowId(rowId, StringUtil.DecodeText(jSONObject.optString("batch")), jSONObject.getString("purchasebatchid"));
                    } else {
                        purchaseBatchMapId = accCommonTablesDAO.getpurchaseBatchIdForSR(jSONObject.getString("purchasebatchid"), StringUtil.DecodeText(jSONObject.optString("batch")));
                    }

                    KwlReturnObject capresult = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), purchaseBatchMapId);
                    neproductbatch = (NewProductBatch) capresult.getEntityList().get(0);
                    if (neproductbatch != null) {
                        batchLocation = neproductbatch.getLocation() != null ? neproductbatch.getLocation().getId() : "";
                        batchWarehouse = neproductbatch.getWarehouse() != null ? neproductbatch.getWarehouse().getId() : "";
                        if (!StringUtil.isNullOrEmpty(batchLocation)) {
                            jSONObject.putOpt("location", batchLocation);
                        }
                        if (!StringUtil.isNullOrEmpty(batchWarehouse)) {
                            jSONObject.putOpt("warehouse", batchWarehouse);
                        }
                    }

                } else if (!StringUtil.isNullOrEmpty(jSONObject.getString("purchasebatchid")) && StringUtil.isNullOrEmpty(jSONObject.getString("batch"))) {
                    purchaseBatchMapId = jSONObject.getString("purchasebatchid");
                    if (!StringUtil.isNullOrEmpty(rowId)) {
                        purchaseBatchMapId = accCommonTablesDAO.getpurchaseBatchIdForNonbatchByRowId(rowId, StringUtil.DecodeText(jSONObject.optString("batch")));
                    } else {
                        purchaseBatchMapId = accCommonTablesDAO.getpurchaseBatchIdForNonbatch(jSONObject.getString("purchasebatchid"), StringUtil.DecodeText(jSONObject.optString("batch")), jSONObject.getString(Constants.productid));
                    }
                    if (!StringUtil.isNullOrEmpty(purchaseBatchMapId)) {
                        KwlReturnObject capresult = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), purchaseBatchMapId);
                        neproductbatch = (NewProductBatch) capresult.getEntityList().get(0);
                        if (neproductbatch != null) {
                            batchLocation = neproductbatch.getLocation() != null ? neproductbatch.getLocation().getId() : "";
                            batchWarehouse = neproductbatch.getWarehouse() != null ? neproductbatch.getWarehouse().getId() : "";
                            if (!StringUtil.isNullOrEmpty(batchLocation)) {
                                jSONObject.putOpt("location", batchLocation);
                            }
                            if (!StringUtil.isNullOrEmpty(batchWarehouse)) {
                                jSONObject.putOpt("warehouse", batchWarehouse);
                            }
                        }
                    }
                } else if (StringUtil.isNullOrEmpty(jSONObject.getString("purchasebatchid")) && salesReturnDetail.getDodetails() != null) {
                    String doDetailId = salesReturnDetail.getDodetails().getID();
                    if (!StringUtil.isNullOrEmpty(doDetailId)) {
                        purchaseBatchMapId = accCommonTablesDAO.getBatchIdForNonbatchSerialByDODetailId(companyid, doDetailId);
                        if (!StringUtil.isNullOrEmpty(purchaseBatchMapId)) {
                            KwlReturnObject capresult = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), purchaseBatchMapId);
                            neproductbatch = (NewProductBatch) capresult.getEntityList().get(0);
                            if (neproductbatch != null) {
                                batchLocation = neproductbatch.getLocation() != null ? neproductbatch.getLocation().getId() : "";
                                batchWarehouse = neproductbatch.getWarehouse() != null ? neproductbatch.getWarehouse().getId() : "";
                                if (!StringUtil.isNullOrEmpty(batchLocation)) {
                                    jSONObject.putOpt("location", batchLocation);
                                }
                                if (!StringUtil.isNullOrEmpty(batchWarehouse)) {
                                    jSONObject.putOpt("warehouse", batchWarehouse);
                                }
                            }
                        }
                    }
                }
            } else {
                purchaseBatchMapId = jSONObject.optString("purchasebatchid", "");
            }

            if (batchQty == 0) {
                batchQty = jSONObject.getDouble("quantity");
                Store store = null;
                if (!StringUtil.isNullOrEmpty(jSONObject.optString("warehouse")) || (isWarehouseForProduct && isLocationForProduct)) {
                    KwlReturnObject warehouseObj = accountingHandlerDAOobj.getObject(Store.class.getName(), jSONObject.getString("warehouse"));
                    store = (Store) warehouseObj.getEntityList().get(0);
                }
                if (store != null && isQAinspection) {
                    consignmentobj.setStore(store);
                }
                if (isWarehouseForProduct && isLocationForProduct && !isQAinspection) {
                    if (storeWiseStockMovement.containsKey(store)) {
                        stockMovement = storeWiseStockMovement.get(store);
                        stockMovement.setQuantity(stockMovement.getQuantity() + jSONObject.optDouble("quantity", 0.0));
                    } else {
                        stockMovement = new StockMovement();
                        if (store != null) {
                            stockMovement.setStore(store);
                        }
                        stockMovement.setCompany(inventory.getCompany());
                        stockMovement.setProduct(inventory.getProduct());
                        stockMovement.setStockUoM(inventory.getProduct().getUnitOfMeasure());
                        stockMovement.setPricePerUnit(salesReturnDetail.getBaseuomrate() < 1 ? (salesReturnDetail.getRate() * (1/salesReturnDetail.getBaseuomrate())) : salesReturnDetail.getRate() / salesReturnDetail.getBaseuomrate());
                        stockMovement.setQuantity(jSONObject.optDouble("quantity", 0.0));
                        stockMovement.setTransactionDate(salesReturnDetail.getSalesReturn().getOrderDate());
                        stockMovement.setModuleRefId(salesReturnDetail.getSalesReturn().getID());
                        stockMovement.setModuleRefDetailId(salesReturnDetail.getID());
                        stockMovement.setCustomer(salesReturnDetail.getSalesReturn().getCustomer());
//                        stockMovement.setRemark("Return stock added To company warehouse");
                        stockMovement.setCostCenter(salesReturnDetail.getSalesReturn().getCostcenter());
                        stockMovement.setTransactionNo(StringUtil.isNullOrEmpty(salesReturnDetail.getSalesReturn().getSalesReturnNumber()) ? entryNumber : salesReturnDetail.getSalesReturn().getSalesReturnNumber());
                        stockMovement.setTransactionModule(TransactionModule.ERP_SALES_RETURN);
                        stockMovement.setTransactionType(TransactionType.IN);
                        stockMovement.setMemo(salesReturnDetail.getSalesReturn().getMemo());
                        storeWiseStockMovement.put(store, stockMovement);
                    }
                }
            }
            if (!StringUtil.isNullOrEmpty(jSONObject.optString("location")) || (isWarehouseForProduct && isLocationForProduct)) {
                KwlReturnObject locationUpdate = accountingHandlerDAOobj.getObject(Location.class.getName(), jSONObject.getString("location"));
                locationObj = (Location) locationUpdate.getEntityList().get(0);
            }

            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) && (batchQty == ActbatchQty)) {

                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.getString("quantity"));
                documentMap.put("batchmapid", purchaseBatchMapId);
                documentMap.put("documentid", salesReturnDetail.getID());
                documentMap.put(Constants.isConsignment, false);  // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                documentMap.put("transactiontype", "29");
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                    documentMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                    documentMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expdate")));
                }
                documentMap.put("stocktype", stockType);
                if (isWarehouseForProduct && isLocationForProduct && !isQAinspection) {
                    smd = new StockMovementDetail();
                    if (locationObj != null) {
                        smd.setLocation(locationObj);
                    }
                    if (isRowForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("row"));
                        StoreMaster row = (StoreMaster) krObject.getEntityList().get(0);
                        if (row == null && neproductbatch != null) {
                            smd.setRow(neproductbatch.getRow());
                        } else {
                            smd.setRow(row);
                        }
                    }
                    if (isRackForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("rack"));
                        StoreMaster rack = (StoreMaster) krObject.getEntityList().get(0);
                        if (rack == null && neproductbatch != null) {
                            smd.setRack(neproductbatch.getRack());
                        } else {
                            smd.setRack(rack);
                        }

                    }
                    if (isBinForProduct) {
                        KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), jSONObject.optString("bin"));
                        StoreMaster bin = (StoreMaster) krObject.getEntityList().get(0);
                        if (bin == null && neproductbatch != null) {
                            smd.setBin(neproductbatch.getBin());
                        } else {
                            smd.setBin(bin);
                        }
                    }
                    smd.setQuantity(Double.parseDouble(jSONObject.getString("quantity")));
                    smd.setBatchName("");
                    smd.setStockMovement(stockMovement);
                    stockMovement.getStockMovementDetails().add(smd);
                }
                if (!isBatchForProduct && !isSerialForProduct) {
                    HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                    filter_names.add("company.companyID");
                    filter_params.add(paramJobj.getString(Constants.companyKey));

                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("warehouse"))) {
                        String warehouse = jSONObject.getString("warehouse");
                        filter_names.add("warehouse.id");
                        filter_params.add(warehouse);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("location"))) {
                        String location = jSONObject.getString("location");
                        filter_names.add("location.id");
                        filter_params.add(location);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("row", ""))) {
                        String row = jSONObject.getString("row");
                        filter_names.add("row.id");
                        filter_params.add(row);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("rack", ""))) {
                        String rack = jSONObject.getString("rack");
                        filter_names.add("rack.id");
                        filter_params.add(rack);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.optString("bin", ""))) {
                        String bin = jSONObject.getString("bin");
                        filter_names.add("bin.id");
                        filter_params.add(bin);
                    }

                    filter_names.add("product");
                    filter_params.add(inventory.getProduct().getID());
                    filterRequestParams.put("filter_names", filter_names);
                    filterRequestParams.put("filter_params", filter_params);
                    filterRequestParams.put("order_by", order_by);
                    filterRequestParams.put("order_type", order_type);
                    KwlReturnObject result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                    List listResult = result.getEntityList();
                    if ((isnegativestockforlocwar && !(isBatchForProduct || isSerialForProduct)) && listResult.isEmpty()) {
                        HashMap<String, Object> pdfTemplateMap = new HashMap<String, Object>();
                        pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
                        pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("batch")));
                        if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                            pdfTemplateMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("mfgdate")));
                        }
                        if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                            pdfTemplateMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expdate")));
                        }
                        if (jSONObject.has("quantity") && !StringUtil.isNullOrEmpty(jSONObject.getString("quantity"))) {
                            pdfTemplateMap.put("quantity", jSONObject.optString("quantity"));
                        }
                        if (jSONObject.has("balance") && !StringUtil.isNullOrEmpty(jSONObject.getString("balance"))) {
                            pdfTemplateMap.put("balance", jSONObject.getString("balance"));
                        }
                        if (jSONObject.has("location") && !StringUtil.isNullOrEmpty(jSONObject.getString("location"))) {
                            pdfTemplateMap.put("location", jSONObject.getString("location"));
                        }

                        pdfTemplateMap.put("product", inventory.getProduct().getID());

                        if (jSONObject.has("warehouse") && !StringUtil.isNullOrEmpty(jSONObject.getString("warehouse"))) {
                            pdfTemplateMap.put("warehouse", jSONObject.getString("warehouse"));
                        }

                        pdfTemplateMap.put("row", jSONObject.optString("row", ""));
                        pdfTemplateMap.put("rack", jSONObject.optString("rack", ""));
                        pdfTemplateMap.put("bin", jSONObject.optString("bin", ""));

                        pdfTemplateMap.put("isopening", false);
                        pdfTemplateMap.put("transactiontype", "28");//This is GRN Type Tranction  
                        pdfTemplateMap.put("ispurchase", true);
                        kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);

                        if (kmsg != null && kmsg.getEntityList().size() != 0) {
                            productBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                            productBatchId = productBatch.getId();
                        }
                        documentMap.put("batchmapid", productBatchId);

                    } else if (listResult.isEmpty() && moduleid == Constants.Acc_Sales_Return_ModuleId) {
                        HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                        productBatchId = accCommonTablesDAO.getpurchaseBatchIdForLocationWarehouseRowRackBin(inventory.getProduct().getID(), jSONObject.getString("location"), jSONObject.getString("warehouse"), jSONObject.optString("row", null), jSONObject.optString("rack", null), jSONObject.optString("bin", null), StringUtil.DecodeText(jSONObject.optString("batch")));
                        if (StringUtil.isNullOrEmpty(productBatchId)) {
                            HashMap<String, Object> pdfTemplateMap = new HashMap<>();
                            pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
                            pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("batch")));
                            if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                                pdfTemplateMap.put("mfgdate", df.parse(jSONObject.getString("mfgdate")));
                            }
                            if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                                pdfTemplateMap.put("expdate", df.parse(jSONObject.getString("expdate")));
                            }
                            pdfTemplateMap.put("quantity", jSONObject.getString("quantity"));
                            if (jSONObject.has("balance") && !StringUtil.isNullOrEmpty(jSONObject.getString("balance"))) {
                                pdfTemplateMap.put("balance", jSONObject.getString("balance"));
                            }
                            pdfTemplateMap.put("location", jSONObject.optString("location", ""));
                            pdfTemplateMap.put("product", inventory.getProduct().getID());
                            pdfTemplateMap.put("warehouse", jSONObject.optString("warehouse", ""));

                            pdfTemplateMap.put("row", jSONObject.optString("row", null));
                            pdfTemplateMap.put("rack", jSONObject.optString("rack", null));
                            pdfTemplateMap.put("bin", jSONObject.optString("bin", null));

                            pdfTemplateMap.put("isopening", false);
                            pdfTemplateMap.put("transactiontype", "29");//This is GRN Type Tranction
                            pdfTemplateMap.put("ispurchase", true);
                            kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);

                            if (kmsg != null && kmsg.getEntityList().size() != 0) {
                                productBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                                productBatchId = productBatch.getId();
                            }
                            batchUpdateQtyMap.put("id", productBatchId);
                            purchaseBatchMapId = productBatchId;
                        } else {
                            batchUpdateQtyMap.put("quantity", String.valueOf(Double.parseDouble(jSONObject.getString("quantity"))));
                            batchUpdateQtyMap.put("qty", isQAinspection ? "0" : String.valueOf((Double.parseDouble(jSONObject.getString("quantity")))));
                            batchUpdateQtyMap.put("id", purchaseBatchMapId);
                        }
                        documentMap.put("quantity", jSONObject.getString("quantity"));
                        documentMap.put("batchmapid", productBatchId);
                        documentMap.put("documentid", salesReturnDetail.getID());
                        documentMap.put("transactiontype", "29"); // This is GRN Type Tranction
                        if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                            documentMap.put("mfgdate", df.parse(jSONObject.getString("mfgdate")));
                        }
                        if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                            documentMap.put("expdate", df.parse(jSONObject.getString("expdate")));
                        }
                        accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                    } else {
                        Iterator itrResult = listResult.iterator();
                        Double quantityToDue = ActbatchQty;
                        while (itrResult.hasNext()) {
                            NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                            if (quantityToDue > 0) {
                                double Qty = newProductBatch.getQuantity();
                                double dueQty = (!StringUtil.isNullOrEmpty(stockType) && "0".equals(stockType)) ? newProductBatch.getConsignquantity() : newProductBatch.getQuantitydue();
                                HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                                batchUpdateQtyMap.put(Constants.Acc_id, newProductBatch.getId());
                                if ((Qty - dueQty) > 0) {
                                    if (moduleid == Constants.Acc_Sales_Return_ModuleId && quantityToDue > 0) {
                                        batchUpdateQtyMap.put("quantity", String.valueOf(quantityToDue));
                                        batchUpdateQtyMap.put("qty", String.valueOf(quantityToDue));
                                    } else {
                                        if (quantityToDue > (Qty - dueQty)) {
                                            batchUpdateQtyMap.put("qty", String.valueOf(((Qty - dueQty))));
                                            quantityToDue = quantityToDue - (Qty - dueQty);
                                            if ("0".equals(stockType) && !isConsignment) {
                                                batchUpdateQtyMap.put("consignquantity", String.valueOf((Qty - dueQty)));
                                                batchUpdateQtyMap.put("qty", "0");
                                            }

                                        } else {
                                            batchUpdateQtyMap.put("qty", isQAinspection ? "0" : String.valueOf((quantityToDue)));
                                            if ("0".equals(stockType) && !isConsignment) {
                                                batchUpdateQtyMap.put("consignquantity", String.valueOf((quantityToDue)));
                                                batchUpdateQtyMap.put("qty", "0");
                                            }
                                            quantityToDue = quantityToDue - quantityToDue;
                                        }
                                    }
                                    documentMap.put("batchmapid", newProductBatch.getId());
                                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);

                                } else if (moduleid == Constants.Acc_Sales_Return_ModuleId && quantityToDue > 0) {
                                    batchUpdateQtyMap.put("quantity", String.valueOf(quantityToDue));
                                    batchUpdateQtyMap.put("qty", String.valueOf(quantityToDue));
                                    documentMap.put("batchmapid", newProductBatch.getId());
                                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                                } else if (isnegativestockforlocwar && !(isBatchForProduct || isSerialForProduct)) {
                                    batchUpdateQtyMap.put("qty", String.valueOf((quantityToDue)));
                                    batchUpdateQtyMap.put("quantity", String.valueOf((quantityToDue)));
                                    if ("0".equals(stockType) && !isConsignment) {
                                        batchUpdateQtyMap.put("consignquantity", String.valueOf((quantityToDue)));
                                        batchUpdateQtyMap.put("qty", "0");
                                    }

                                    documentMap.put("batchmapid", newProductBatch.getId());
                                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                                }
                            }
                        }
                    }
                } else {

                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                    if (moduleid == Constants.Acc_Sales_Return_ModuleId && !inventory.getProduct().isIsSerialForProduct()) {
                        productBatchId = accCommonTablesDAO.getpurchaseBatchIdForLocationWarehouseRowRackBin(inventory.getProduct().getID(), jSONObject.getString("location"), jSONObject.getString("warehouse"), jSONObject.optString("row", null), jSONObject.optString("rack", null), jSONObject.optString("bin", null), StringUtil.DecodeText(jSONObject.optString("batch")));
                        if (StringUtil.isNullOrEmpty(productBatchId)) {
                            HashMap<String, Object> pdfTemplateMap = new HashMap<>();
                            pdfTemplateMap.put(Constants.companyKey, inventory.getCompany().getCompanyID());
                            pdfTemplateMap.put("name", StringUtil.DecodeText(jSONObject.optString("batch")));
                            if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                                pdfTemplateMap.put("mfgdate", df.parse(jSONObject.getString("mfgdate")));
                            }
                            if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                                pdfTemplateMap.put("expdate", df.parse(jSONObject.getString("expdate")));
                            }
                            pdfTemplateMap.put("quantity", jSONObject.getString("quantity"));
                            if (jSONObject.has("balance") && !StringUtil.isNullOrEmpty(jSONObject.getString("balance"))) {
                                pdfTemplateMap.put("balance", jSONObject.getString("balance"));
                            }
                            pdfTemplateMap.put("location", jSONObject.optString("location", ""));
                            pdfTemplateMap.put("product", inventory.getProduct().getID());
                            pdfTemplateMap.put("warehouse", jSONObject.optString("warehouse", ""));

                            pdfTemplateMap.put("row", jSONObject.optString("row", null));
                            pdfTemplateMap.put("rack", jSONObject.optString("rack", null));
                            pdfTemplateMap.put("bin", jSONObject.optString("bin", null));

                            pdfTemplateMap.put("isopening", false);
                            pdfTemplateMap.put("transactiontype", "29");//This is GRN Type Tranction
                            pdfTemplateMap.put("ispurchase", true);
                            kmsg = accCommonTablesDAO.saveNewBatchForProduct(pdfTemplateMap);

                            if (kmsg != null && kmsg.getEntityList().size() != 0) {
                                productBatch = (NewProductBatch) kmsg.getEntityList().get(0);
                                productBatchId = productBatch.getId();
                            }
                            batchUpdateQtyMap.put("id", productBatchId);
                            purchaseBatchMapId = productBatchId;
                        } else {
                            batchUpdateQtyMap.put("quantity", String.valueOf(Double.parseDouble(jSONObject.getString("quantity"))));
                            batchUpdateQtyMap.put("qty", isQAinspection ? "0" : String.valueOf((Double.parseDouble(jSONObject.getString("quantity")))));
                            batchUpdateQtyMap.put("id", purchaseBatchMapId);
                            if ("0".equals(stockType) && !isConsignment) {
                                batchUpdateQtyMap.put("consignquantity", isQAinspection ? "0" : String.valueOf((Double.parseDouble(jSONObject.getString("quantity")))));
                                batchUpdateQtyMap.put("qty", "0");
                            }

                        }
                        documentMap.put("quantity", jSONObject.getString("quantity"));
                        documentMap.put("batchmapid", productBatchId);
                        documentMap.put("documentid", salesReturnDetail.getID());
                        documentMap.put("transactiontype", "29"); // This is GRN Type Tranction
                        if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                            documentMap.put("mfgdate", df.parse(jSONObject.getString("mfgdate")));
                        }
                        if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                            documentMap.put("expdate", df.parse(jSONObject.getString("expdate")));
                        }
                    } else {
                        batchUpdateQtyMap.put("qty", isQAinspection ? "0" : String.valueOf((Double.parseDouble(jSONObject.getString("quantity")))));
                        batchUpdateQtyMap.put("id", purchaseBatchMapId);
                        if ("0".equals(stockType) && !isConsignment) {
                                batchUpdateQtyMap.put("consignquantity",isQAinspection ? "0" : String.valueOf((Double.parseDouble(jSONObject.getString("quantity")))));
                            batchUpdateQtyMap.put("qty", "0");
                        }

                        batchUpdateQtyMap.put("id", purchaseBatchMapId);
                    }
                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);
                    //Code to Send Batch
                    KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), purchaseBatchMapId);
                    NewProductBatch newProductBatch1 = (NewProductBatch) batchObj.getEntityList().get(0);
                    if (isWarehouseForProduct && isLocationForProduct && !isQAinspection) {
                        smd.setBatchName(newProductBatch1.getBatchname());
                    }
                }

                /**
                 * added selected sequence for batch selected by user while
                 * creating SR.
                 */
                documentMap.put("batchsequence", batchsequence++);
                accCommonTablesDAO.saveBatchDocumentMapping(documentMap);
            }
            batchQty--;

            if (isSerialForProduct && !extraCompanyPreferences.isAutoFillBatchDetails()) {  //if serial no option is on then only save the serial no details 
                if (isConsignment && !StringUtil.isNullOrEmpty(jSONObject.getString("purchaseserialid")) && !StringUtil.isNullOrEmpty(jSONObject.getString("serialno"))) {
                    purchaseSerialId = accCommonTablesDAO.getpurchaseSerialIdForSR(jSONObject.getString("purchaseserialid"), jSONObject.getString("serialno"));
                    if (!StringUtil.isNullOrEmpty(purchaseSerialId)) {
                        jSONObject.putOpt("purchaseserialid", purchaseSerialId);
                    }
                }
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", 1);
                documentMap.put("serialmapid", jSONObject.getString("purchaseserialid"));
                documentMap.put("documentid", salesReturnDetail.getID());
                documentMap.put("transactiontype", "29");
                documentMap.put("stocktype", 1);
                if ("0".equals(stockType) && !isConsignment) {
                    documentMap.put("consignquantity", "1");
                    documentMap.put("qty", "0");
                    documentMap.put("stocktype", 0);
                }

                documentMap.put(Constants.isConsignment, false);  // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expend")));
                }
                if (jSONObject.has("reusablecount") && !StringUtil.isNullOrEmpty(jSONObject.getString("reusablecount"))) {
                    documentMap.put("reusablecount", jSONObject.getString("reusablecount"));
                }
                KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), jSONObject.getString("purchaseserialid"));
                NewBatchSerial nbs = (NewBatchSerial) batchObj.getEntityList().get(0);
                if (isSerialForProduct && isQAinspection) {
                    cad = new ConsignmentApprovalDetails();
                    cad.setLocation(locationObj);
                    cad.setQuantity(1);
                    cad.setBatch(neproductbatch);
                    cad.setSerialName(nbs != null ? nbs.getSerialname() : "");
                    if (neproductbatch != null) {
                        batchname = neproductbatch.getBatchname();
                        cad.setBatchName(batchname);
                    } else {
                        cad.setBatchName(batchname);
                    }
                    cad.setConsignment(consignmentobj);
                    cad.setApprovalStatus(ApprovalStatus.PENDING);
                    cad.setPurchaseSerialId(nbs);
                    consignDetailsSet.add(cad);
                }
                /**
                 * added selected sequence for serial selected by user while
                 * creating SR.
                 */
                documentMap.put("serialsequence", serialsequence++);
                KwlReturnObject krObj = accCommonTablesDAO.saveSerialDocumentMapping(documentMap);
                SerialDocumentMapping serialDocumentMapping = (SerialDocumentMapping) krObj.getEntityList().get(0);

                if (jSONObject.has(Constants.customfield)) {
                    String customfield = jSONObject.getString(Constants.customfield);
                    if (!StringUtil.isNullOrEmpty(customfield)) {
                        HashMap<String, Object> DOMap = new HashMap<String, Object>();
                        JSONArray jcustomarray = new JSONArray(customfield);

                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        customrequestParams.put("customarray", jcustomarray);
                        customrequestParams.put("modulename", "SerialDocumentMapping");
                        customrequestParams.put("moduleprimarykey", "SerialDocumentMappingId");
                        customrequestParams.put("modulerecid", serialDocumentMapping.getId());
                        customrequestParams.put(Constants.moduleid, Constants.SerialWindow_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        DOMap.put(Constants.Acc_id, serialDocumentMapping.getId());
                        customrequestParams.put("customdataclasspath", Constants.Acc_Serial_custom_data_classpath);
                        KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                        if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                            DOMap.put("serialcustomdataref", serialDocumentMapping.getId());
                            accCommonTablesDAO.updateserialcustomdata(DOMap);
                        }
                    }
                }
                HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                serialUpdateQtyMap.put("qty", "1");
                if ("0".equals(stockType) && !isConsignment) {
                    serialUpdateQtyMap.put("consignquantity", "1");
                    serialUpdateQtyMap.put("qty", "0");
                }
                serialUpdateQtyMap.put(Constants.Acc_id, jSONObject.getString("purchaseserialid"));
                serialUpdateQtyMap.put("isQAinspection", isQAinspection);
                accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);
                if (nbs != null) {
                    if (isWarehouseForProduct && isLocationForProduct && !isQAinspection) {
                        smd.addSerialName(nbs.getSerialname());
                    }
                }

            } else if (isSerialForProduct && extraCompanyPreferences.isAutoFillBatchDetails()) {  //if serial no option is on then only save the serial no details 

                if (isConsignment && !StringUtil.isNullOrEmpty(jSONObject.getString("purchaseserialid")) && !StringUtil.isNullOrEmpty(jSONObject.getString("serialno"))) {
                    purchaseSerialId = accCommonTablesDAO.getpurchaseSerialIdForSR(jSONObject.getString("purchaseserialid"), jSONObject.getString("serialno"));
                    if (!StringUtil.isNullOrEmpty(purchaseSerialId)) {
                        jSONObject.putOpt("purchaseserialid", purchaseSerialId);
                    }
                }
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                if (jSONObject.has("serialDetails") && !StringUtil.isNullOrEmpty(jSONObject.getString("serialDetails"))) {
                    JSONArray serialArray = new JSONArray(jSONObject.getString("serialDetails"));
                    for (int count = 0; count < serialArray.length(); count++) {
                        String purchaseserialid = new JSONObject(serialArray.get(count).toString()).optString("purchaseserialid");
                        documentMap.put("quantity", 1);
                        documentMap.put("serialmapid", purchaseserialid);
                        documentMap.put("documentid", salesReturnDetail.getID());
                        documentMap.put("transactiontype", "29");
                        documentMap.put("stocktype", 1);
                        if ("0".equals(stockType) && !isConsignment) {
                            documentMap.put("consignquantity", "1");
                            documentMap.put("qty", "0");
                            documentMap.put("stocktype", 0);
                        }

                        documentMap.put(Constants.isConsignment, false);  // for moving stock from customers warehouse to company warehouse we have same document id for mapping so here isconsignment is true
                        if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                            documentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expstart")));
                        }
                        if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                            documentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expend")));
                        }
                        if (jSONObject.has("reusablecount") && !StringUtil.isNullOrEmpty(jSONObject.getString("reusablecount"))) {
                            documentMap.put("reusablecount", jSONObject.getString("reusablecount"));
                        }
                        KwlReturnObject batchObj = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), purchaseserialid);
                        NewBatchSerial nbs = (NewBatchSerial) batchObj.getEntityList().get(0);
                        if (isSerialForProduct && isQAinspection) {
                            cad = new ConsignmentApprovalDetails();
                            cad.setLocation(locationObj);
                            cad.setQuantity(1);
                            cad.setBatch(neproductbatch);
                            cad.setSerialName(nbs != null ? nbs.getSerialname() : "");
                            if (neproductbatch != null) {
                                batchname = neproductbatch.getBatchname();
                                cad.setBatchName(batchname);
                            } 
                            else{
                                cad.setBatchName(batchname);
                            }
                            cad.setConsignment(consignmentobj);
                            cad.setApprovalStatus(ApprovalStatus.PENDING);
                            cad.setPurchaseSerialId(nbs);
                            consignDetailsSet.add(cad);
                        }

                        /**
                         * added selected sequence for serial selected by user
                         * while creating SR.
                         */
                        documentMap.put("serialsequence", serialsequence++);
                        KwlReturnObject krObj = accCommonTablesDAO.saveSerialDocumentMapping(documentMap);
                        SerialDocumentMapping serialDocumentMapping = (SerialDocumentMapping) krObj.getEntityList().get(0);

                        if (jSONObject.has(Constants.customfield)) {
                            String customfield = jSONObject.getString(Constants.customfield);
                            if (!StringUtil.isNullOrEmpty(customfield)) {
                                HashMap<String, Object> DOMap = new HashMap<String, Object>();
                                JSONArray jcustomarray = new JSONArray(customfield);

                                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                                customrequestParams.put("customarray", jcustomarray);
                                customrequestParams.put("modulename", "SerialDocumentMapping");
                                customrequestParams.put("moduleprimarykey", "SerialDocumentMappingId");
                                customrequestParams.put("modulerecid", serialDocumentMapping.getId());
                                customrequestParams.put(Constants.moduleid, Constants.SerialWindow_ModuleId);
                                customrequestParams.put(Constants.companyKey, companyid);
                                DOMap.put(Constants.Acc_id, serialDocumentMapping.getId());
                                customrequestParams.put("customdataclasspath", Constants.Acc_Serial_custom_data_classpath);
                                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                                    DOMap.put("serialcustomdataref", serialDocumentMapping.getId());
                                    accCommonTablesDAO.updateserialcustomdata(DOMap);
                                }
                            }
                        }
                        serialUpdateQtyMap.put("qty", "1");
                        if ("0".equals(stockType) && !isConsignment) {
                            serialUpdateQtyMap.put("consignquantity", "1");
                            serialUpdateQtyMap.put("qty", "0");
                        }
                        serialUpdateQtyMap.put(Constants.Acc_id, purchaseserialid);
                        serialUpdateQtyMap.put("isQAinspection", isQAinspection);
                        accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);
                        if (nbs != null) {
                            if (isWarehouseForProduct && isLocationForProduct && !isQAinspection) {
                                smd.addSerialName(nbs.getSerialname());
                            }
                        }
                    }
                }

            } else {
                if (isQAinspection) {  //as we will make entry into this table if consignment QA inspection flow is on for this
                    cad = new ConsignmentApprovalDetails();
                    cad.setLocation(locationObj);
                    cad.setQuantity(ActbatchQty);
                    cad.setConsignment(consignmentobj);
                    cad.setApprovalStatus(ApprovalStatus.PENDING);
                    cad.setBatch(neproductbatch);
                    if (isBatchForProduct) {
                        if (neproductbatch != null) {
                            batchname = neproductbatch.getBatchname();
                            cad.setBatchName(batchname);
                        } else {
                            cad.setBatchName(batchname);
                        }
                    }
                    consignDetailsSet.add(cad);
                }
                batchQty = 0;
            }
        }
        if (isWarehouseForProduct && isLocationForProduct) {
            for (Map.Entry<Store, StockMovement> entry : storeWiseStockMovement.entrySet()) {
                stockMovementsList.add(entry.getValue());
            }
            if (isQAinspection) {  //as we will make entry into this table if consignment QA inspection flow is on for this
                consignmentobj.setConsignmentApprovalDetails(consignDetailsSet);
                ConsignmentList.add(consignmentobj);
            }
        }

    }

    /**
     * Description: Validate and Import Deliver Orders data
     * @param paramJobj
     * @return JSONObject
     */
    @Override
    public JSONObject importDeliveryOrdersJSON(JSONObject paramJobj) {
        JSONObject jobj = new JSONObject();
        try {
            String doAction = paramJobj.getString("do");
    
            if (doAction.compareToIgnoreCase("import") == 0) {
                jobj = importDeliveryOrderRecordsForCSV(paramJobj);
            } else if (doAction.compareToIgnoreCase("validateData") == 0) {
                String eParams = paramJobj.getString("extraParams");
                JSONObject extraParams = StringUtil.isNullOrEmpty(eParams) ? new JSONObject() : new JSONObject(eParams);

                HashMap<String, Object> requestParams = importHandler.getImportRequestParams(paramJobj);
                requestParams.put("extraParams", extraParams);
                requestParams.put("extraObj", null);
                requestParams.put("servletContext", paramJobj.get("servletContext"));

                jobj = importHandler.validateFileData(requestParams);
                jobj.put(Constants.RES_success, true);
            }
        } catch (Exception ex) {
            try {
                jobj.put(Constants.RES_success, false);
                jobj.put(Constants.RES_msg, "" + ex.getMessage());
            } catch (JSONException jex) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, jex);
            }
        }
        return jobj;
    }

    public JSONObject importDeliveryOrderRecordsForCSV(JSONObject requestJobj) throws AccountingException, IOException, SessionExpiredException, JSONException {
        JSONObject returnObj = new JSONObject();
        String msg = "";
        int total = 0, failed = 0;
        String fileName = requestJobj.getString("filename");
        String companyID = requestJobj.getString(Constants.companyKey);
        String masterPreference = requestJobj.getString("masterPreference");
        boolean issuccess = true;
        boolean isAlreadyExist = false;
        boolean isRecordFailed = false;
        FileInputStream fileInputStream = null;
        CsvReader csvReader = null;
        HashMap<String, Object> invoiceDataMap = new HashMap<>();
        Map<String, Object> lineLevelDetailMap = new HashMap<>();
        Set<String> innerLineLevelDetailSet = new HashSet<>();
        JSONObject paramJobj = new JSONObject();
        JSONObject rowDetailObj = new JSONObject();
        JSONArray rows = new JSONArray();
        String prevInvNo = "";
        String entryNumber = "";
        StringBuffer globalDatakey = new StringBuffer();
        Set<String> globalDatakeySet = new HashSet<>();
        double totaldiscount = 0, totalamount = 0;
        double dquantity = 0;
        boolean isIncludingGST = false;

        try {
            String dateFormat = null, dateFormatId = requestJobj.getString("dateFormat");
            if (!StringUtil.isNullOrEmpty(dateFormatId)) {
                KwlReturnObject kdfObj = accountingHandlerDAOobj.getObject(KWLDateFormat.class.getName(), dateFormatId);
                KWLDateFormat kdf = (KWLDateFormat) kdfObj.getEntityList().get(0);

                dateFormat = kdf != null ? kdf.getJavaForm() : null;
            }
            DateFormat df = new SimpleDateFormat(dateFormat);
            df.setLenient(false);
            requestJobj.put(Constants.importdf, df);

            SimpleDateFormat sdf = new SimpleDateFormat("MMMM d, yyyy hh:mm:ss aa");

            KwlReturnObject extraPref = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyID);
            ExtraCompanyPreferences extrareferences = (ExtraCompanyPreferences) extraPref.getEntityList().get(0);
            Boolean isCurrencyCode = extrareferences.isCurrencyCode();
            Boolean isPickPackFlowActivate = extrareferences.isPickpackship();
            String inspectionStore=extrareferences.getInspectionStore();
            String jobWorkOutStore=extrareferences.getVendorjoborderstore();
            String packingStore=extrareferences.getPackingstore();
            boolean isnegativestockforlocwar=extrareferences.isIsnegativestockforlocwar();

            String destinationDirectory = storageHandlerImpl.GetDocStorePath() + "importplans";
            File filePath = new File(destinationDirectory + File.separator + fileName);
            fileInputStream = new FileInputStream(filePath);
            String delimiterType = requestJobj.getString("delimiterType");
            csvReader = new CsvReader(new InputStreamReader(fileInputStream), delimiterType);

            JSONObject resjson = new JSONObject(requestJobj.getString("resjson"));
            JSONArray jSONArray = resjson.getJSONArray("root");
            HashMap<String, Integer> columnConfig = new HashMap<>();
            
            for (int i = 0; i < jSONArray.length(); i++) {
                JSONObject jSONObject = jSONArray.getJSONObject(i);
                columnConfig.put(jSONObject.getString("dataindex"), jSONObject.getInt("csvindex"));
            }

            int cnt = 0;
            StringBuilder failedRecords = new StringBuilder();
            StringBuilder singleDOFailedRecords = new StringBuilder();// DO with one row of failure record then all rows will be included in failure file
            int singleDOFailureRecoredCount = 0;//  count of total DO rows in import file
            Set<String> failureList = new HashSet<>(); // set of DO having failyure record's
            HashMap currencyMap = accSalesOrderServiceobj.getCurrencyMap(isCurrencyCode);

            while (csvReader.readRecord()) {
                String failureMsg = "";
                String[] recarr = csvReader.getValues();
                boolean isfailurerecord = false; // used to keep track DO Row  failure/correct

                if (cnt == 0) {
                    failedRecords.append(accSalesOrderServiceobj.createCSVrecord(recarr)).append("\" \"");
                } else if (cnt == 1) {
                    failedRecords.append("\n").append(accSalesOrderServiceobj.createCSVrecord(recarr)).append("\"Error Message\"");
                } else {
                    try {
                        String currencyID = requestJobj.getString(Constants.globalCurrencyKey);

                        entryNumber = "";
                        globalDatakey = new StringBuffer();
                        if (columnConfig.containsKey("number")) {
                            entryNumber = recarr[(Integer) columnConfig.get("number")].replaceAll("\"", "").trim();
                            if (StringUtil.isNullOrEmpty(entryNumber)) {
                                failureMsg += "Delivery Order Number is not available. ";
                            }
                            globalDatakey.append(entryNumber);
                        } else {
                            failureMsg += "Delivery Order Number column is not found. ";
                        }
                        
                        // Process and save previous DO if valid.
                        if (!prevInvNo.equalsIgnoreCase(entryNumber)) {// || entryNumber.equalsIgnoreCase("")) {
                            if (failureList.contains(prevInvNo)) {
                                failed += singleDOFailureRecoredCount;
                                failedRecords.append(singleDOFailedRecords);
                                singleDOFailedRecords = new StringBuilder();
                                singleDOFailureRecoredCount = 0;
                            }
                            if (rows.length() > 0 && !isRecordFailed) {
                                    double amountAfterRemovingDiscount = totalamount - totaldiscount;
                                    double taxamount = 0.0;
                                    if (!StringUtil.isNullOrEmpty(paramJobj.optString("taxid", null))) {
                                        taxamount = getGlobalTaxAmount(paramJobj, companyID, amountAfterRemovingDiscount);
                                    }
                                    paramJobj.put("taxamount", String.valueOf(taxamount));
                                    if (isIncludingGST) {
                                        /*
                                         * When Including GST is true then we need
                                         * to recalculate line level tax,unit price
                                         * and invoiceterm amount accordingly Below
                                         * method does the same.
                                         */
                                        Map<String, Object> invoiceMap = new HashMap();
                                        invoiceMap.put(Constants.companyid, companyID);
                                        invoiceMap.put("amountAfterRemovingDiscount", amountAfterRemovingDiscount);
                                        Date invBillDate = paramJobj.has("billdate") ? (Date) paramJobj.get("billdate") : null;
                                        invoiceMap.put("billdate", invBillDate);
                                        updateLineLevelTaxUnitPriceOnIncludeGST(rows, new JSONArray(), invoiceMap);
                                    }
                                    paramJobj.put(Constants.detail, rows.toString());
                                    // for Delivery Order
                                    paramJobj.put(Constants.PAGE_URL, requestJobj.optString(Constants.PAGE_URL));
                                    saveDeliveryOrderJSON(paramJobj);
                            }

                            // reset variables
                            paramJobj = new JSONObject();
                            rows = new JSONArray();
                            isRecordFailed = false;
                            isAlreadyExist = false;
                            totaldiscount = 0;
                            totalamount = 0;
                            singleDOFailedRecords = new StringBuilder();
                            singleDOFailureRecoredCount = 0;
                            innerLineLevelDetailSet =new HashSet<>();
                            globalDatakeySet=new  HashSet<>();
                        }
                        
                        Date billDate = null;
                        if (columnConfig.containsKey(Constants.BillDate)) {
                            String deliveryOrderDateStr = recarr[(Integer) columnConfig.get(Constants.BillDate)].replaceAll("\"", "").trim();

                            if (StringUtil.isNullOrEmpty(deliveryOrderDateStr)) {
                                failureMsg += "Delivery Order Date is not available. ";
                            } else {
                                try {
                                    billDate = df.parse(deliveryOrderDateStr);
                                    globalDatakey.append(deliveryOrderDateStr);
                                } catch (Exception ex) {
                                    failureMsg += "Incorrect date format for Delivery Order Date, Please specify values in " + dateFormat + " format. ";
                                }
                            }
                        } else {
                            failureMsg += "Delivery Order Date column is not found. ";
                        }
                      
                        String costCenterID = "";
                        if (columnConfig.containsKey("costcenter")) {
                            String costCenterName = recarr[(Integer) columnConfig.get("costcenter")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(costCenterName)) {
                                costCenterID = accSalesOrderServiceobj.getCostCenterIDByName(costCenterName, companyID);
                                globalDatakey.append(costCenterID);
                                if (StringUtil.isNullOrEmpty(costCenterID)) {
                                    failureMsg += "Cost Center is not found for name " + costCenterName + ". ";
                                }
                            }
                        }

                        Date shipDate = null;
                        if (columnConfig.containsKey("shipdate")) {
                            String shipDateStr = recarr[(Integer) columnConfig.get("shipdate")].replaceAll("\"", "").trim();

                            if (!StringUtil.isNullOrEmpty(shipDateStr)) {
                                try {
                                    shipDate = df.parse(shipDateStr);
                                    globalDatakey.append(shipDateStr);
                                } catch (Exception ex) {
                                    failureMsg += "Incorrect date format for Ship Date, Please specify values in " + dateFormat + " format. ";
                                }
                            }
                        }

                        String customerID = "";
                        String accountID = "";
                        Customer customer=null;
                        /*
                         * 1. Customer Code
                         */
                        if (columnConfig.containsKey("CustomerCode")) {
                            String customerCode = recarr[(Integer) columnConfig.get("CustomerCode")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(customerCode)) {
                                customer = getCustomerByCode(customerCode, companyID);
                                if (customer != null) {
                                    accountID = customer.getAccount().getID();
                                    customerID = customer.getID();
                                    globalDatakey.append(customerID);
                                } else {
                                    failureMsg += messageSource.getMessage("acc.field.CustomerCodeisnotavailable", null, Locale.forLanguageTag(Constants.language)) + customerCode + ". ";
                                }
                            }
                        }

                        /*
                         * 2. Customer Name if customerID is empty it means
                         * customer is not found for given code. so need to
                         * search data on name
                         */
                        if (StringUtil.isNullOrEmpty(customerID)) {
                            if (columnConfig.containsKey("CustomerName")) {
                                String customerName = recarr[(Integer) columnConfig.get("CustomerName")].replaceAll("\"", "").trim();
                                if (!StringUtil.isNullOrEmpty(customerName)) {
                                    customer = null;
                                    KwlReturnObject retObj = accCustomerDAOObj.getCustomerByName(customerName, companyID);
                                    if (retObj != null && !retObj.getEntityList().isEmpty()) {
                                        customer = (Customer) retObj.getEntityList().get(0);
                                    }
                                    if (customer != null) {
                                        accountID = customer.getAccount().getID();
                                        customerID = customer.getID();
                                        globalDatakey.append(customerID);
                                    } else {
                                        failureMsg += messageSource.getMessage("acc.field.CustomerisnotfoundforCustomerCodeName", null, Locale.forLanguageTag(requestJobj.getString(Constants.language)));
                                    }
                                } else {
                                    failureMsg += messageSource.getMessage("acc.field.CustomerisnotfoundforCustomerCodeName", null, Locale.forLanguageTag(requestJobj.getString(Constants.language)));
                                }
                            } else {
                                failureMsg += messageSource.getMessage("acc.field.CustomerisnotfoundforCustomerCodeName", null, Locale.forLanguageTag(requestJobj.getString(Constants.language)));
                            }
                        }
                        
                        /*
                         Check Customer is activate/Deactivate.
                        */
                        if(customer!=null && !customer.isActivate()){
                            failureMsg += "Customer " + customer.getAcccode() + " is deactivated.Please enter the activated Customer.";
                        }

                        String termID = "";
                        if (columnConfig.containsKey("termid")) {
                            String termName = recarr[(Integer) columnConfig.get("termid")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(termName)) {
                                termID = accSalesOrderServiceobj.getTermIDByName(termName, companyID);
                                if (StringUtil.isNullOrEmpty(termID)) {
                                    failureMsg += "Credit Term is not found for name " + termName + ". ";
                                }else{
                                    globalDatakey.append(termID);
                                }
                            } else {
                                failureMsg += "Credit Term is not available. ";
                            }
                        } else {
                            failureMsg += "Credit Term column is not found. ";
                        }

                        String memo = "";
                        if (columnConfig.containsKey(Constants.memo)) {
                            memo = recarr[(Integer) columnConfig.get(Constants.memo)].replaceAll("\"", "").trim();
                            globalDatakey.append(memo);
                        }

                        String shipVia = "";
                        if (columnConfig.containsKey("shipvia")) {
                            shipVia = recarr[(Integer) columnConfig.get("shipvia")].replaceAll("\"", "").trim();
                            globalDatakey.append(shipVia);
                        }

                        String fob = "";
                        if (columnConfig.containsKey(Constants.fob)) {
                            fob = recarr[(Integer) columnConfig.get(Constants.fob)].replaceAll("\"", "").trim();
                            globalDatakey.append(fob);
                        }

                        String customerPORefNo = "";
                        if (columnConfig.containsKey("customerporefno")) {
                            customerPORefNo = recarr[(Integer) columnConfig.get("customerporefno")].replaceAll("\"", "").trim();
                            globalDatakey.append(customerPORefNo);
                        }

                        String salesPersonID = "";
                        if (columnConfig.containsKey("salesPerson")) {
                            String salesPersonName = recarr[(Integer) columnConfig.get("salesPerson")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(salesPersonName)) {
                                salesPersonID = getSalesPersonIDByName(salesPersonName, companyID);
                                globalDatakey.append(salesPersonID);
                                if (StringUtil.isNullOrEmpty(salesPersonID)) {
                                    failureMsg += "Sales Person is not found for name " + salesPersonName + ". ";
                                }
                            }
                        }

                        String statusID = "";
                        String statusVal = "";
                        if (columnConfig.containsKey("statuscombo")) {
                            String statusName = recarr[(Integer) columnConfig.get("statuscombo")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(statusName)) {
                                List<String> valList= getDOStatusIDByName(statusName, companyID);
                                if (valList==null || valList.isEmpty()) {
                                    failureMsg += "DO status is not found for name " + statusName + ". ";
                                }else{
                                    statusID=valList.get(0);//Status ID 
                                    statusVal=valList.get(1);// Status Value
                                    globalDatakey.append(statusID);
                                }
                            }
                        }

                        /*
                        Pick and Pack flow validation
                        */
                        if (isPickPackFlowActivate) {
                            if (StringUtil.isNullOrEmpty(statusID)) {
                                failureMsg += "If Pick and Pack Flow is activated then DO status should not be empty.";
                            } else if (!statusVal.equalsIgnoreCase("Picked")) {
                                failureMsg += "If Pick and Pack Flow is activated then DO status should be Picked.";
                            }

                        }

                        if (isCurrencyCode ? columnConfig.containsKey("currencyCode") : columnConfig.containsKey(Constants.currencyKey)) {
                            String currencyStr = isCurrencyCode ? recarr[(Integer) columnConfig.get("currencyCode")].replaceAll("\"", "").trim() : recarr[(Integer) columnConfig.get(Constants.currencyKey)].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(currencyStr)) {
                                currencyID = accSalesOrderServiceobj.getCurrencyId(currencyStr, currencyMap);

                                if (StringUtil.isNullOrEmpty(currencyID)) {
                                    failureMsg += messageSource.getMessage("acc.field.ImportProductExceptionFormat", null, Locale.forLanguageTag(requestJobj.getString(Constants.language))) + ". ";
                                }
                            } else {
                                if (!masterPreference.equalsIgnoreCase("1")) {
                                    failureMsg += "Currency is not available. ";
                                }
                            }
                        }

                        /**
                         * If Avalara Integration is enabled, then includingGST flag is always false
                         */
                        if (columnConfig.containsKey("gstIncluded") && !extrareferences.isAvalaraIntegration()) {
                            String isIncludingGSTStr = recarr[(Integer) columnConfig.get("gstIncluded")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(isIncludingGSTStr)) {
                                if (isIncludingGSTStr.equalsIgnoreCase("TRUE")) {
                                    isIncludingGST = true;
                                } else if (isIncludingGSTStr.equalsIgnoreCase("FALSE")) {
                                    isIncludingGST = false;
                                } else {
                                    failureMsg += "Format you entered for Include GST is not correct. It should be like \"TRUE\" or \"FALSE\". ";
                                }
                                globalDatakey.append(isIncludingGSTStr);
                            }
                        }

                        boolean isIncludeProductTax = false;
                        if (columnConfig.containsKey("includeprotax")) {
                            String isIncludeProductTaxStr = recarr[(Integer) columnConfig.get("includeprotax")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(isIncludeProductTaxStr)) {
                                if (isIncludeProductTaxStr.equalsIgnoreCase("Yes")) {
                                    isIncludeProductTax = true;
                                } else if (isIncludeProductTaxStr.equalsIgnoreCase("No")) {
                                    isIncludeProductTax = false;
                                } else {
                                    failureMsg += "Format you entered for Include Product Tax is not correct. It should be like \"Yes\" or \"No\". ";
                                }
                              globalDatakey.append(isIncludeProductTaxStr);
                            }
                        }

                        if (isIncludingGST && !isIncludeProductTax) {
                            failureMsg += "If value Including GST is \"TRUE\" then value of Include Product Tax should be \"Yes\". ";
                        }

                        boolean isIncludeTotalTax = false;
                        if (columnConfig.containsKey("taxincluded")) {
                            String isIncludeTotalTaxStr = recarr[(Integer) columnConfig.get("taxincluded")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(isIncludeTotalTaxStr)) {
                                if (isIncludeTotalTaxStr.equalsIgnoreCase("Yes")) {
                                    isIncludeTotalTax = true;
                                } else if (isIncludeTotalTaxStr.equalsIgnoreCase("No")) {
                                    isIncludeTotalTax = false;
                                } else {
                                    failureMsg += "Format you entered for Include Total Tax is not correct. It should be like \"Yes\" or \"No\". ";
                                }
                                globalDatakey.append(isIncludeTotalTaxStr);
                            }
                        }

                        if (isIncludeProductTax && isIncludeTotalTax) {
                            failureMsg += "If value of Include Product Tax is \"Yes\" then value of Include Total Tax should be \"No\".";
                        }

                        String taxID = "";
                        if (columnConfig.containsKey("taxid")) {
                            String taxCode = recarr[(Integer) columnConfig.get("taxid")].replaceAll("\"", "").trim();
                            if (!StringUtil.isNullOrEmpty(taxCode)) {
                                Tax tax = accSalesOrderServiceobj.getGSTByCode(taxCode, companyID);
                                if (tax == null) {
                                    failureMsg += "Tax Code is not found for code " + taxCode;
                                } else {
                                    taxID = tax.getID();
                                }
                            } else {
                                if (!isIncludingGST && !isIncludeProductTax && isIncludeTotalTax) {
                                    failureMsg += "Tax Code is not available. ";
                                }
                            }
                        } else {
                            if (!isIncludingGST && !isIncludeProductTax && isIncludeTotalTax) {
                                failureMsg += "Tax Code column is not found. ";
                            }
                        }

                        globalDatakey.append(taxID);
                        String tempString=globalDatakey.toString();
                        boolean added=globalDatakeySet.add(tempString);
                        /*
                        If check all Global level Data is same for each document.
                        */
                        if(!prevInvNo.isEmpty() && prevInvNo.equalsIgnoreCase(entryNumber) && added){
                            failureMsg += "Global level data are not same for document no "+entryNumber ;
                        }
                        
                        Product product = null;
                        double quantity = 0;
                        double unitPrice = 0;
                        double unitPriceIncludingGST = 0;
                        UnitOfMeasure uom = null;
                        int rowdisc = 1;
                        String rowtaxamount = "0";
                        Tax rowtax = null;
                        double discountValue = 0;

                        /**
                         * *************************** Validating Line Level
                         * Data ****************************
                         */
                        //Product Level data can be empty when number of Terms more than Line Item. So this variable used to find Is all column of line level is empty or not
                        boolean isAllLineLevelDataIsEmpty = isAllLineLevelInformationIsEmpty(columnConfig, recarr);
                        if (isAllLineLevelDataIsEmpty) {
                            failureMsg += "Empty data found for all Line Item columns.";
                        } else if (!isAllLineLevelDataIsEmpty) {
                            if (columnConfig.containsKey(Constants.productid)) {
                                String productID = recarr[(Integer) columnConfig.get(Constants.productid)].replaceAll("\"", "").trim();
                                if (!StringUtil.isNullOrEmpty(productID)) {
                                    product = accSalesOrderServiceobj.getProductByProductID(productID, companyID);
                                    if (product == null) {
                                        failureMsg += "Product ID is not found for " + productID + ". ";
                                    }
                                } else {
                                    failureMsg += "Product ID is not available. ";
                                }
                            } else {
                                failureMsg += "Product ID column is not found. ";
                            }

                            if (columnConfig.containsKey("quantity")) {
                                String quantityStr = recarr[(Integer) columnConfig.get("quantity")].replaceAll("\"", "").trim();
                                if (StringUtil.isNullOrEmpty(quantityStr)) {
                                    failureMsg += "Actual Quantity is not available. ";
                                } else {
                                    try {
                                        quantity = authHandler.roundQuantity(Double.parseDouble(quantityStr), companyID);
                                    } catch (Exception ex) {
                                        failureMsg += "Incorrect numeric value for Actual Quantity, Please ensure that value type of Quantity matches with the Quantity. ";
                                    }
                                }
                            } else {
                                failureMsg += "Quantity column is not found. ";
                            }

                            if (columnConfig.containsKey("dquantity")) {
                                String quantityStr = recarr[(Integer) columnConfig.get("dquantity")].replaceAll("\"", "").trim();
                                if (StringUtil.isNullOrEmpty(quantityStr)) {
                                    failureMsg += " Delivered Quantity is not available. ";
                                } else {
                                    try {
                                        dquantity = authHandler.roundQuantity(Double.parseDouble(quantityStr), companyID);
                                    } catch (Exception ex) {
                                        failureMsg += "Incorrect numeric value for Delivered Quantity, Please ensure that value type of Quantity matches with the Quantity. ";
                                    }
                                }
                            } else {
                                failureMsg += "Quantity column is not found. ";
                            }

                            if (columnConfig.containsKey("rate")) {
                                String unitPriceStr = recarr[(Integer) columnConfig.get("rate")].replaceAll("\"", "").trim();
                                if (StringUtil.isNullOrEmpty(unitPriceStr)) {
                                    failureMsg += "Unit Price is not available. ";
                                } else {
                                    try {
                                        unitPrice = authHandler.roundQuantity(Double.parseDouble(unitPriceStr), companyID);
                                    } catch (Exception ex) {
                                        failureMsg += "Incorrect numeric value for Unit Price, Please ensure that value type of Unit Price matches with the Unit Price. ";
                                    }
                                }
                            } else {
                                failureMsg += "Unit Price column is not found. ";
                            }

                            if (columnConfig.containsKey("uomid")) {
                                String productUOMName = recarr[(Integer) columnConfig.get("uomid")].replaceAll("\"", "").trim();
                                if (!StringUtil.isNullOrEmpty(productUOMName)) {
                                    uom = accSalesOrderServiceobj.getUOMByName(productUOMName, companyID);
                                    if (uom != null) {
                                    } else {
                                        if (!masterPreference.equalsIgnoreCase("1")) {
                                            failureMsg += "Product Unit Of Measure is not found for " + productUOMName + ". ";
                                        }
                                    }
                                } else {
                                    if (!masterPreference.equalsIgnoreCase("1")) {
                                        failureMsg += "Product Unit Of Measure is not available. ";
                                    }
                                }
                            }

                            if (columnConfig.containsKey("discountispercent")) {
                                String discountTypeStr = recarr[(Integer) columnConfig.get("discountispercent")].replaceAll("\"", "").trim();
                                if (!StringUtil.isNullOrEmpty(discountTypeStr)) {
                                    if (discountTypeStr.equalsIgnoreCase("Percentage")) {
                                        rowdisc = 1;
                                    } else if (discountTypeStr.equalsIgnoreCase("Flat")) {
                                        rowdisc = 0;
                                    } else {
                                        failureMsg += "Format you entered is not correct. It should be like \"Percentage\" or \"Flat\". ";
                                    }
                                } else {
                                    if (!masterPreference.equalsIgnoreCase("1")) {
                                        failureMsg += "Discount Type is not available. ";
                                    }
                                }
                            }

                            if (columnConfig.containsKey("prdiscount")) {
                                String discountStr = recarr[(Integer) columnConfig.get("prdiscount")].replaceAll("\"", "").trim();
                                if (StringUtil.isNullOrEmpty(discountStr)) {
                                    failureMsg += "Dicount is not available. ";
                                } else {
                                    try {
                                        discountValue = authHandler.roundQuantity(Double.parseDouble(discountStr), companyID);
                                    } catch (Exception ex) {
                                        failureMsg += "Incorrect numeric value for Discount, Please ensure that value type of Discount matches with the Discount. ";
                                    }
                                }
                            }
                        }
                        
                        /*
                         If Delivered quantity is greater than Actual quantity then reject that record.
                         */
                        if (dquantity > quantity) {
                            failureMsg += "Delivered quantity should not be greater than actual quantity. ";
                        } else if (dquantity <= 0) {
                            failureMsg += "Delivered quantity should not be equal or less than zero. ";
                        }
                       
                        
                        /*
                        Create Global Data JSON for DO
                        */
                        if (!prevInvNo.equalsIgnoreCase(entryNumber)) {// || entryNumber.equalsIgnoreCase("")) {
                            
                            prevInvNo = entryNumber;
                            KwlReturnObject result = accInvoiceDAOobj.getDeliveryOrderCount(entryNumber, companyID);
                            int nocount = result.getRecordTotalCount();
                            if (nocount > 0) {
                                isAlreadyExist = true;
                                 failureMsg += "Delivery Order number'" + entryNumber + "' already exists.";
                            }

                            // For create custom field array
                            JSONArray customJArr = accSalesOrderServiceobj.createGlobalCustomFieldArrayForImport(requestJobj, jSONArray, recarr, df, Constants.Acc_Delivery_Order_ModuleId);

                            Date dueDate = null;
                            // For adding due date
                            if (!StringUtil.isNullOrEmpty(termID)) {
                                dueDate = getDueDateFromTermAndBillDate(termID, billDate);
                            }
                            // For getting exchange rate
                            double exchangeRateForTransaction = accSalesOrderServiceobj.getExchangeRateForTransaction(requestJobj, billDate, currencyID);

                            String sequenceFormatID = "NA";
                            /*
                             * isImportSequenceFormat is true while importing DO with entry no is belongs in sequence format. 
                             */
                            boolean isImportSequenceFormat = false;
                            boolean autogenerated = false;
                            if (!StringUtil.isNullOrEmpty(entryNumber)) {
                                Map<String, String> sequenceNumberDataMap = new HashMap<String, String>();
                                sequenceNumberDataMap.put("moduleID", String.valueOf(Constants.Acc_Delivery_Order_ModuleId));
                                sequenceNumberDataMap.put("entryNumber", entryNumber);
                                sequenceNumberDataMap.put("companyID", companyID);
                                List list = importHandler.checksEntryNumberForSequenceNumber(sequenceNumberDataMap);
                                if (!list.isEmpty()) {
                                    boolean isvalidEntryNumber = (Boolean) list.get(0);
                                    if (!isvalidEntryNumber) {
                                        String formatID = (String) list.get(2);
                                        int intSeq = (Integer) list.get(3);
                                        paramJobj.put(Constants.SEQNUMBER, intSeq);
                                        paramJobj.put(Constants.SEQFORMAT, formatID);
                                        autogenerated = true;
                                        isImportSequenceFormat = true;
                                        sequenceFormatID = formatID;
                                    }
                                }
                            }

                            paramJobj.put(Constants.companyKey, companyID);
                            paramJobj.put(Constants.globalCurrencyKey, requestJobj.optString(Constants.globalCurrencyKey));
                            paramJobj.put(Constants.useridKey, requestJobj.optString(Constants.useridKey));
                            paramJobj.put(Constants.userfullname, requestJobj.optString(Constants.userfullname));
                            paramJobj.put(Constants.reqHeader, requestJobj.optString(Constants.reqHeader));
                            paramJobj.put(Constants.remoteIPAddress, requestJobj.optString(Constants.remoteIPAddress));
                            paramJobj.put(Constants.timezonedifference, requestJobj.optString(Constants.timezonedifference));
                            paramJobj.put(Constants.language, Constants.language);
                            paramJobj.put(Constants.currencyKey, currencyID);
                            paramJobj.put("number", entryNumber);
                            paramJobj.put("sequenceformat", sequenceFormatID);
                            paramJobj.put("seqformat", sequenceFormatID);
                            paramJobj.put("autogenerated", autogenerated);
                            paramJobj.put("isImportSequenceFormat", isImportSequenceFormat);
                            paramJobj.put("customer", customerID);
                            paramJobj.put("defaultAdress", "true");
                            paramJobj.put(Constants.costcenter, costCenterID);
                            paramJobj.put("statuscombo", statusID);
                            paramJobj.put(Constants.memo, memo);
                            paramJobj.put("posttext", "");
                            paramJobj.put("term", termID);
                            paramJobj.put(Constants.BillDate, sdf.format(billDate));
                            paramJobj.put("duedate", (dueDate != null) ? sdf.format(dueDate) : dueDate);
                            paramJobj.put("perdiscount", "false");
                            paramJobj.put("discount", "0");
                            paramJobj.put("includingGST", "false");

                            if (shipDate != null) {
                                paramJobj.put("shipdate", sdf.format(shipDate));
                            }
                            paramJobj.put("shipvia", shipVia);
                            paramJobj.put(Constants.fob, fob);
                            paramJobj.put("isfavourite", "false");
                            paramJobj.put("salesPerson", salesPersonID);
                            paramJobj.put("customerporefno", customerPORefNo);
                            paramJobj.put("externalcurrencyrate", String.valueOf(exchangeRateForTransaction));
                            paramJobj.put("istemplate", "0");
                            paramJobj.put("taxamount", "0");
                            paramJobj.put("invoicetermsmap", "[]");
                            paramJobj.put("termsincludegst", "false");
                            paramJobj.put("fromLinkCombo", "");
                            paramJobj.put("linkFrom", "");
                            paramJobj.put("linkNumber", "");
                            paramJobj.put("templatename", "");
                            paramJobj.put(Constants.customfield, customJArr.toString());
                            paramJobj.put("isEdit", "false");
                            paramJobj.put("copyInv", "false");
                            paramJobj.put(Constants.isDraft, "false");
                            paramJobj.put("includeprotax", "false");
                            paramJobj.put("shipLength", "1");
                            paramJobj.put("taxid", "");
                            paramJobj.put("deletedLinkedDocumentId", "");
                            paramJobj.put("invoicetype", "");
                            paramJobj.put("seqformat_oldflag", "false");

                            Map<String, Object> requestParams = new HashMap<>();
                            requestParams.put(Constants.companyKey, companyID);
                            CompanyPreferencesCMN.checkLockPeriod(accCompanyPreferencesObj, requestParams, billDate, false);
                        } // end global details

                        rowDetailObj = new JSONObject();
                        String lineLevelDetailKey="";
                        if (product != null && !product.getProducttype().getID().equals(Producttype.Inventory_Non_Sales)) {
                            lineLevelDetailKey = entryNumber + product.getProductid() + unitPrice + discountValue;

                            // Check Batch Related if Warehouse and Location is activated for product.
                            if (product.isIswarehouseforproduct() && product.isIslocationforproduct()) {

                                /* Validate  Line level Details IF product having activated Warehouse , Location ,Batch, Serial ,Row,Rack,Bin */
                                Map<String, Object> requestMap = new HashMap<>();
                                requestMap.put("isSalesTransaction", true); // Need to send true for Sales Transactions
                                requestMap.put("product", product);
                                requestMap.put("columnConfig", columnConfig);
                                requestMap.put("recarr", recarr);
                                requestMap.put("companyID", companyID);
                                requestMap.put("failureMsg", failureMsg);
                                requestMap.put("masterPreference", masterPreference);
                                requestMap.put("df", df);
                                requestMap.put("dateFormat", dateFormat);
                                requestMap.put("dquantity", dquantity);
                                requestMap.put("linelevelkey", lineLevelDetailKey);
                                requestMap.put("inspectionStore", inspectionStore);
                                requestMap.put("jobWorkOutStore", jobWorkOutStore);
                                requestMap.put("packingStore", packingStore);
                                requestMap.put("isnegativestockforlocwar", isnegativestockforlocwar);

                                Map<String, Object> returnMap = accProductModuleService.validateAndGetBatchSerialDetail(requestMap, innerLineLevelDetailSet);

                                if (returnMap.containsKey("failureMsg") && returnMap.get("failureMsg") != null) {
                                    failureMsg = (String) returnMap.get("failureMsg");
                                }

                                if (!isRecordFailed && StringUtil.isNullOrEmpty(failureMsg) && returnMap.containsKey("batchDetailArr") && returnMap.get("batchDetailArr") != null) {
                                    JSONArray rowWiseBatchDetail = (JSONArray) returnMap.get("batchDetailArr");
                                    rowDetailObj.put("batchdetails", rowWiseBatchDetail);
                                }
                            }
                        }
                        
                        if(product!=null && product.getProducttype().getID().equals(Producttype.Inventory_Non_Sales)){
                            failureMsg += "You can't import DO with Inventory Non-Sale type product.";
                        }
                        
                        /*
                         If any failure then Skip that DO
                        */
                        if (!StringUtil.isNullOrEmpty(failureMsg)) {
//                            failureList.add(entryNumber);
                            throw new AccountingException(failureMsg);
                        }
                        
                        
                        
                        // For Line level details
                        double conversionFactor = 1;
                        // Add Custom fields details of line items
                        JSONArray lineCustomJArr = accSalesOrderServiceobj.createLineLevelCustomFieldArrayForImport(requestJobj, jSONArray, recarr, df, Constants.Acc_Delivery_Order_ModuleId);
                        if (!lineLevelDetailMap.containsKey(lineLevelDetailKey)) {
                            rowDetailObj.put(Constants.productid, (product != null) ? product.getID() : "");
                            rowDetailObj.put("rate", unitPrice);
                            rowDetailObj.put("priceSource", "");
                            rowDetailObj.put("quantity", String.valueOf(quantity));
                            rowDetailObj.put("dquantity", String.valueOf(dquantity));
                            rowDetailObj.put("uomid", (uom != null) ? uom.getID() : product.getUnitOfMeasure().getID());//Put product's UOM if UOM is not specified in import file
                            rowDetailObj.put("baseuomquantity", quantity * conversionFactor);
                            rowDetailObj.put("baseuomrate", String.valueOf(conversionFactor));
                            rowDetailObj.put("dependentType", "");
                            rowDetailObj.put("inouttime", "");
                            rowDetailObj.put("showquantity", "");
                            rowDetailObj.put("description", (product != null) ? product.getDescription() : "");
                            rowDetailObj.put("invstore", "");
                            rowDetailObj.put("invlocation", "");
                            rowDetailObj.put("rowid", "");
                            rowDetailObj.put("prtaxid", "");
                            rowDetailObj.put("taxamount", "0");
                            rowDetailObj.put("linkto", "");
                            rowDetailObj.put("savedrowid", "");
                            rowDetailObj.put("recTermAmount", "");
                            rowDetailObj.put("OtherTermNonTaxableAmount", "");
                            rowDetailObj.put("productcustomfield", "[{}]");
                            rowDetailObj.put("LineTermdetails", "");
                            rowDetailObj.put("productMRP", "");
                            rowDetailObj.put("valuationType", "");
                            rowDetailObj.put("reortingUOMExcise", "");
                            rowDetailObj.put("reortingUOMSchemaExcise", "");
                            rowDetailObj.put("valuationTypeVAT", "");
                            rowDetailObj.put("reportingUOMVAT", "");
                            rowDetailObj.put("reportingUOMSchemaVAT", "");
                            rowDetailObj.put(Constants.customfield, lineCustomJArr.toString());
                            rowDetailObj.put(lineLevelDetailKey, "success");
                            double rate = unitPrice;
                            if (paramJobj.optString("includingGST", "").equalsIgnoreCase("true")) {
                                rate = unitPriceIncludingGST;
                            }
                            double rowAmount = rate * quantity;
                            totalamount += rowAmount;

                            double rowdiscount = discountValue;
                            if (rowdisc == 1) { // for percent disc
                                rowdiscount = (rowAmount * discountValue) / 100;
                            }
                            rowDetailObj.put("prdrowiscount", String.valueOf(rowdiscount));
                            totaldiscount += rowdiscount;
                            lineLevelDetailMap.put(lineLevelDetailKey, rowDetailObj);
                            rows.put(rowDetailObj);
                        } else {

                            if (rows.length() > 0) {
                                for (int index = 0; index < rows.length(); index++) {
                                    JSONObject tempLineObj = rows.getJSONObject(index);
                                    if (tempLineObj.has(lineLevelDetailKey)) {
                                        double tempActualQty = tempLineObj.optDouble("quantity");
                                        double tempDeliverdQty = tempLineObj.optDouble("dquantity");
                                        tempLineObj.put("quantity", tempActualQty + quantity);
                                        tempLineObj.put("dquantity", tempDeliverdQty + dquantity);
                                        if (tempLineObj.has("batchdetails")) {
                                            JSONArray tempBatchArr = tempLineObj.optJSONArray("batchdetails");

                                            if (rowDetailObj.has("batchdetails")) {
                                                JSONArray tempInnerBatchArr = rowDetailObj.optJSONArray("batchdetails");
                                                if (tempInnerBatchArr.length() > 0) {
                                                    for (int innerIndex = 0; innerIndex < tempInnerBatchArr.length(); innerIndex++) {
                                                        tempBatchArr.put(tempInnerBatchArr.getJSONObject(innerIndex));
                                                    }
                                                }
                                            }
                                        }
                                    }

                                }

                            }
                        }
                    } catch (Exception ex) {
                        isRecordFailed = true;
                        isfailurerecord = true;
                        String errorMsg = ex.getMessage();
                        if (ex.getMessage() != null) {
                            errorMsg = ex.getMessage();
                        } else if (ex.getCause() != null) {
                            errorMsg = ex.getCause().getMessage();
                        }

                        // Just add into failure list - which is processed once at a time when DO number is changed or if it is last record.
                        if(!failureList.contains(entryNumber)) {
                            failureList.add(entryNumber);
                        }
                        singleDOFailureRecoredCount++;
                        singleDOFailedRecords.append("\n").append(accSalesOrderServiceobj.createCSVrecord(recarr)).append("\"").append(errorMsg.replaceAll("\"", "")).append("\"");
                    }
                    if (!isfailurerecord) {
                        singleDOFailureRecoredCount++;
                        singleDOFailedRecords.append("\n").append(accSalesOrderServiceobj.createCSVrecord(recarr)).append("\"").append(" ").append("\"");
                    }
                    total++;
                }
                cnt++;
            }

            // save DO for last record
            if (!isAlreadyExist && !isRecordFailed) {

                JSONArray invoiceTermArrayDetails = new JSONArray();
                double amountAfterRemovingDiscount = totalamount - totaldiscount;
                double taxamount = 0.0;
                if (!StringUtil.isNullOrEmpty(paramJobj.optString("taxid", null))) {
                    taxamount = getGlobalTaxAmount(paramJobj, companyID, amountAfterRemovingDiscount);
                }
                if (paramJobj.optString("includingGST", "").equalsIgnoreCase("true")) {
                    /*
                     * When Including GST is true then we need to recalculate
                     * line level tax,unit price and invoiceterm amount
                     * accordingly Below method does the same.
                     */
                    Map<String, Object> invoiceMap = new HashMap();
                    invoiceMap.put(Constants.companyid, companyID);
                    invoiceMap.put("amountAfterRemovingDiscount", amountAfterRemovingDiscount);
                    invoiceMap.put("billdate", sdf.parse(paramJobj.getString("billdate")));
                    updateLineLevelTaxUnitPriceOnIncludeGST(rows, invoiceTermArrayDetails, invoiceMap);
                }
                paramJobj.put("taxamount", String.valueOf(taxamount));
                paramJobj.put(Constants.detail, rows.toString());
                paramJobj.put(Constants.PAGE_URL, requestJobj.optString(Constants.PAGE_URL));
                saveDeliveryOrderJSON(paramJobj);
            }
            if (failureList.contains(prevInvNo)) {
                failed += singleDOFailureRecoredCount;
                failedRecords.append(singleDOFailedRecords);
            }
            if (failed > 0) {
                importHandler.createFailureFiles(fileName, failedRecords, ".csv");
            }

            int success = total - failed;
            if (total == 0) {
                msg = "Empty file.";
            } else if (success == 0) {
                msg = "Failed to import all the records.";
            } else if (success == total) {
                msg = "All records are imported successfully.";
            } else {
                msg = "Imported " + success + " record" + (success > 1 ? "s" : "") + " successfully";
                msg += (failed == 0 ? "." : " and failed to import " + failed + " record" + (failed > 1 ? "s" : "") + ".");
            }
        } catch (Exception ex) {
            issuccess = false;
            msg = "" + ex.getMessage();

            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw new AccountingException("Error While Importing Records.");
        } finally {
            fileInputStream.close();
            csvReader.close();

            // For saving import log
            saveImportLog(requestJobj, msg, total, failed, Constants.Acc_Delivery_Order_ModuleId);

            try {
                returnObj.put(Constants.RES_success, issuccess);
                returnObj.put(Constants.RES_msg, msg);
                returnObj.put("totalrecords", total);
                returnObj.put("successrecords", total - failed);
                returnObj.put("failedrecords", failed);
                returnObj.put("filename", ImportLog.getActualFileName(fileName));
                returnObj.put("Module", Constants.Acc_Delivery_Order_ModuleId);
            } catch (JSONException ex) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        return returnObj;
    }
    public void saveImportLog(JSONObject requestJobj, String msg, int total, int failed, int moduleID) {
        DefaultTransactionDefinition ldef = new DefaultTransactionDefinition();
        ldef.setName("import_Tx");
        ldef.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus lstatus = txnManager.getTransaction(ldef);

        try {
            HashMap<String, Object> logDataMap = new HashMap<>();
            logDataMap.put("FileName", ImportLog.getActualFileName(requestJobj.getString("filename")));
            logDataMap.put("StorageName", requestJobj.getString("filename"));
            logDataMap.put("Log", msg);
            logDataMap.put("Type", "csv");
            logDataMap.put("FailureFileType", failed > 0 ? "csv" : "");
            logDataMap.put("TotalRecs", total);
            logDataMap.put("Rejected", failed);
            logDataMap.put("Module", moduleID);
            logDataMap.put("ImportDate", new Date());
            logDataMap.put("User", requestJobj.getString(Constants.useridKey));
            logDataMap.put("Company", requestJobj.getString(Constants.companyKey));
            importDao.saveImportLog(logDataMap);
            txnManager.commit(lstatus);
        } catch (JSONException | ServiceException | DataInvalidateException | TransactionException ex) {
            txnManager.rollback(lstatus);
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    public String getSalesPersonIDByName(String salesPersonName, String companyID) throws AccountingException {
        String salesPersonID = "";
        try {
            if (!StringUtil.isNullOrEmpty(salesPersonName) && !StringUtil.isNullOrEmpty(companyID)) {
                HashMap<String, Object> filterRequestParams = new HashMap<>();
                ArrayList filter_names = new ArrayList(), filter_params = new ArrayList();
                filter_names.add("company.companyID");
                filter_params.add(companyID);
                filter_names.add("masterGroup.ID");
                filter_params.add("15"); // For Geting Sales Person
                filter_names.add("value");
                filter_params.add(salesPersonName);
                filterRequestParams.put("filter_names", filter_names);
                filterRequestParams.put("filter_params", filter_params);

                KwlReturnObject retObj = accMasterItemsDAOobj.getMasterItems(filterRequestParams);
                if (retObj != null && !retObj.getEntityList().isEmpty()) {
                    MasterItem salesPerson = (MasterItem) retObj.getEntityList().get(0);
                    salesPersonID = salesPerson.getID();
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw new AccountingException("System Failure while fetching Sales Person.");
        }
        return salesPersonID;
    }
    public List<String> getDOStatusIDByName(String statusName, String companyID) throws AccountingException {
        List<String> valList=new ArrayList();
        try {
            if (!StringUtil.isNullOrEmpty(statusName) && !StringUtil.isNullOrEmpty(companyID)) {
                HashMap<String, Object> filterRequestParams = new HashMap<>();
                ArrayList filter_names = new ArrayList(), filter_params = new ArrayList();
                filter_names.add("company.companyID");
                filter_params.add(companyID);
                filter_names.add("masterGroup.ID");
                filter_params.add("10"); // For Geting DO status ID
                filter_names.add("value");
                filter_params.add(statusName);
                filterRequestParams.put("filter_names", filter_names);
                filterRequestParams.put("filter_params", filter_params);

                KwlReturnObject retObj = accMasterItemsDAOobj.getMasterItems(filterRequestParams);
                if (retObj != null && !retObj.getEntityList().isEmpty()) {
                    MasterItem status = (MasterItem) retObj.getEntityList().get(0);
                    valList.add(status.getID());
                    valList.add(status.getValue());
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw new AccountingException("System Failure while fetching Sales Person.");
        }
        return valList;
    }
     public Date getDueDateFromTermAndBillDate(String termID, Date billDate) throws ServiceException {
        Date dueDate;
        KwlReturnObject termObj = accountingHandlerDAOobj.getObject(Term.class.getName(), termID);
        Term term = (Term) termObj.getEntityList().get(0);

        Calendar cal = Calendar.getInstance();
        cal.setTime(billDate);
        cal.add(Calendar.DAY_OF_MONTH, term.getTermdays());
        dueDate = cal.getTime();

        return dueDate;
    }
     
     @Override
    public void saveBankReconsilation(Map<String, Object> requestParams, Map<String, Object> globalParams) throws ServiceException, JSONException, UnsupportedEncodingException {
        HashMap<String, Object> brMap = new HashMap<String, Object>();
        KwlReturnObject crresult = accCurrencyDAOobj.getCurrencyToBaseAmount(globalParams, (Double) requestParams.get("clearingamount"), (String) requestParams.get(Constants.currencyKey), (Date) requestParams.get("clearanceDate"), 0);
        double clearingAmount = (Double) crresult.getEntityList().get(0);

        if (requestParams.containsKey("oldjeid")) {
            deleteBankReconcilation(requestParams);
        }

        brMap.put("startdate", (Date) requestParams.get("startDate"));
        brMap.put("enddate", (Date) requestParams.get("endDate"));
        brMap.put("clearanceDate", (Date) requestParams.get("clearanceDate"));
        brMap.put("clearingamount", clearingAmount);
        brMap.put("endingamount", (Double) requestParams.get("endingAmount"));
        brMap.put("accountid", (String) requestParams.get("bankAccountId"));
        brMap.put(Constants.companyKey, (String) requestParams.get("companyId"));
        brMap.put("checkCount", 0);
        brMap.put("depositeCount", 1);
        brMap.put("createdby", (String) requestParams.get("createdby"));
        Invoice invoice = (Invoice) requestParams.get("invoice");
        JournalEntry entry = invoice.getJournalEntry();

        Set details = entry.getDetails();
        Iterator iter = details.iterator();
        String accountName = "";
        while (iter.hasNext()) {
            JournalEntryDetail d = (JournalEntryDetail) iter.next();
            if (d.isDebit()) {
                continue;
            }
            accountName += d.getAccount().getName() + ", ";
        }
        accountName = accountName.substring(0, Math.max(0, accountName.length() - 2));


        KwlReturnObject brresult = accBankReconciliationObj.addBankReconciliation(brMap);
        BankReconciliation br = (BankReconciliation) brresult.getEntityList().get(0);
        String brid = br.getID();
        HashSet hs = new HashSet();
        HashMap<String, Object> brdMap = new HashMap<String, Object>();
        brdMap.put(Constants.companyKey, (String) requestParams.get("companyId"));
        brdMap.put("amount", clearingAmount);
        brdMap.put("jeid", entry.getID());
        brdMap.put("accountname", accountName);
        brdMap.put("debit", true);
        brdMap.put("brid", brid);
        KwlReturnObject brdresult1 = accBankReconciliationObj.addBankReconciliationDetail(brdMap);
        BankReconciliationDetail brd1 = (BankReconciliationDetail) brdresult1.getEntityList().get(0);
        hs.add(brd1);
    }

    /*
     * Handele the Edit And Save For Bank Reconcialtion in Cash Sales
     */
    @Override
    public void deleteBankReconcilation(Map<String, Object> requestParams) throws ServiceException {
        if (requestParams.containsKey("oldjeid")) {
            String reconsilationID = "";
            String unReconsilationID = "";
            String jeid = (String) requestParams.get("oldjeid");
            String companyid = (String) requestParams.get("companyId");

            //Deleting  BankReconciliationDetail
            KwlReturnObject reconsiledDetails = accBankReconciliationObj.getBRfromJE(jeid, companyid, true);
            if (reconsiledDetails.getRecordTotalCount() > 0) {
                List<BankReconciliationDetail> brd = reconsiledDetails.getEntityList();
                for (BankReconciliationDetail reconciliation : brd) {
                    accBankReconciliationObj.permenantDeleteBankReconciliationDetail(reconciliation.getID(), companyid);
                    reconsilationID = reconciliation.getBankReconciliation().getID();
                }
            }

            //Deleting  BankUnreconciliationDetail
            KwlReturnObject unReconsiledDetails = accBankReconciliationObj.getBankUnReconsiledfromJE(jeid, companyid, true);
            if (unReconsiledDetails.getRecordTotalCount() > 0) {
                List<BankUnreconciliationDetail> brd = unReconsiledDetails.getEntityList();
                for (BankUnreconciliationDetail reconciliation : brd) {
                    accBankReconciliationObj.permenantDeleteBankUnReconciliationDetail(reconciliation.getID(), companyid);
                    unReconsilationID = reconciliation.getBankReconciliation().getID();
                }
            }
            if (!StringUtil.isNullOrEmpty(reconsilationID)) {
                accBankReconciliationObj.deleteBankReconciliation(reconsilationID, companyid);
            }
            if (!StringUtil.isNullOrEmpty(unReconsilationID)) {
                accBankReconciliationObj.deleteBankReconciliation(unReconsilationID, companyid);
            }
        }
    }
    
 @Override   
  public JSONObject saveInvoice(JSONObject paramJobj) {
        JSONObject jobj = new JSONObject();
        boolean issuccess = false;
        boolean isAccountingExe = false;
        boolean isDuplicateNoExe = false;
        boolean isTaxDeactivated = false;
        String msg = "";
        String invoiceNumBer = "";
        String JENumBer = ""; 
        String channelName = "";
        String companyid = "";
        String entryNumber = "";
        String invid="",deliveryOid="",doEntryNumber="";
        String repeatedid = null;
        int intervalUnit = 0;
        String intervalType = null;
        Date sdate = null;
        String billNo="";
        Date nextdate = null;
        Date expdate = null;
        int noOfInvPost = 0;
        int noOfInvRemainPost = 0;
        KwlReturnObject result = null;
        int nocount;
        int doinvflag = 0;
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("IC_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        boolean isAutoCreateDO = false;
        TransactionStatus status = null;
        Map<String,String> deleteparam=null;
        boolean inCash = false;
        String unlinkMessage = "";
        String linkedDocuments = "";
        String auditMessage = "";
        int pendingApprFlag = 0;
        Map<String, Object> seqNumMap = new HashMap<String, Object>();
        try {
            companyid = paramJobj.getString(Constants.companyKey);
            inCash = Boolean.parseBoolean(paramJobj.optString("incash"));            
            String invoiceid = null;
            String doid = paramJobj.optString("doid", null);
            int istemplate = paramJobj.optInt("istemplate",0);
            boolean isDraft = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isDraft, null))) ? Boolean.parseBoolean(paramJobj.getString(Constants.isDraft)) : false; //SDP-13487
            boolean isSaveDraftRecord = (!StringUtil.isNullOrEmpty(paramJobj.optString("isSaveDraftRecord", null))) ? Boolean.parseBoolean(paramJobj.getString("isSaveDraftRecord")) : false; //SDP-13487
            boolean isAutoSeqForEmptyDraft = (!StringUtil.isNullOrEmpty(paramJobj.optString("isAutoSeqForEmptyDraft", null))) ? Boolean.parseBoolean(paramJobj.getString("isAutoSeqForEmptyDraft")) : false; //SDP-13927 : If Draft already having sequence no. then do not update it
            //boolean isSequenceFormatChangedInEdit = (!StringUtil.isNullOrEmpty(paramJobj.optString("isSequenceFormatChangedInEdit", null))) ? Boolean.parseBoolean(paramJobj.getString("isSequenceFormatChangedInEdit")) : false; //SDP-13927 : If Draft already having sequence no. then do not update it
            
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                entryNumber = paramJobj.optString("invoiceNumber", "");
                invoiceid = (paramJobj.has(Constants.billid) && paramJobj.get(Constants.billid) != null) ? paramJobj.getString(Constants.billid) : null;
                doEntryNumber = paramJobj.optString("deliveryOrderNo", null) != null ? paramJobj.optString("deliveryOrderNo") : paramJobj.optString("deliveryOrderNo");
            } else {
                entryNumber = paramJobj.optString("number", null);
                invoiceid = paramJobj.optString("invoiceid");
                doEntryNumber = paramJobj.optString("numberDo", null) != null ? paramJobj.optString("numberDo") : paramJobj.optString("number");
            }
            
            /*Mobile App case*/
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("generateDeliveryOrder",null)) && paramJobj.optBoolean(Constants.isdefaultHeaderMap)==true) {
                paramJobj.put("isAutoCreateDO", paramJobj.optString("generateDeliveryOrder"));
            }
            /**
             * createAsTransactionChkboxwithTemplate- used to create template along with transaction.
             */
            boolean createAsTransactionChkboxwithTemplate = paramJobj.optString("createAsTransactionChkbox").equalsIgnoreCase("on") ? true : false;
            isAutoCreateDO = Boolean.parseBoolean(paramJobj.optString("isAutoCreateDO"));
            deleteparam=new HashMap<String, String>();
            deleteparam.put("invoiceno", entryNumber);
            deleteparam.put("dono", doEntryNumber);
            deleteparam.put(Constants.companyKey, companyid);
            if (isAutoCreateDO) {
                deleteparam.put("isautocreatedo", paramJobj.optString("isAutoCreateDO", null));
                if (!paramJobj.has(Constants.sequenceformatDo) || StringUtil.isNullOrEmpty(Constants.sequenceformatDo)) {
                    String sequenceformatid = null;
                    Map<String, Object> sfrequestParams = new HashMap<String, Object>();
                    sfrequestParams.put(Constants.companyKey, paramJobj.get(Constants.companyKey));
                    sfrequestParams.put("modulename", "autodo");
                    sfrequestParams.put("isdefaultFormat", true);
                    KwlReturnObject seqFormatResult = accCompanyPreferencesObj.getSequenceFormat(sfrequestParams);
                    List<SequenceFormat> ll = seqFormatResult.getEntityList();
                    if (ll.size() > 0) {
                        SequenceFormat format = (SequenceFormat) ll.get(0);
                        sequenceformatid = format.getID();
                        paramJobj.put(Constants.sequenceformatDo, sequenceformatid);
                    } else if (!StringUtil.isNullOrEmpty(paramJobj.optString("doEntryNumber", null))) {
                        paramJobj.put(Constants.sequenceformatDo, "NA");
                    }
                }//end of sequenceformat
            }

            if (!paramJobj.has(Constants.sequenceformat) || StringUtil.isNullOrEmpty(paramJobj.optString(Constants.sequenceformat, null))) {
                String sequenceformatid = null;
                Map<String, Object> sfrequestParams = new HashMap<String, Object>();
                sfrequestParams.put(Constants.companyKey, paramJobj.get(Constants.companyKey));
                
                if (inCash) {
                    sfrequestParams.put("modulename", "autocashsales");
                } else {
                    sfrequestParams.put("modulename", "autoinvoice");
                }
                sfrequestParams.put("isdefaultFormat", true);
                KwlReturnObject seqFormatResult = accCompanyPreferencesObj.getSequenceFormat(sfrequestParams);
                List<SequenceFormat> ll = seqFormatResult.getEntityList();
                if (ll.size() > 0) {
                    SequenceFormat format = (SequenceFormat) ll.get(0);
                    sequenceformatid = format.getID();
                    paramJobj.put(Constants.sequenceformat, sequenceformatid);
                } else if (!StringUtil.isNullOrEmpty(entryNumber)) {
                    paramJobj.put(Constants.sequenceformat, "NA");
                }
            }//end of sequenceformat

            /**
             * creating template for sales invoice.
             * istemplate=2 //creating only template
             * istemplate=0 //creating only transaction
             */
            if ((istemplate != 2) && StringUtil.isNullOrEmpty(paramJobj.optString(Constants.sequenceformat, null))) {
                JSONObject response = StringUtil.getErrorResponse("acc.common.erp33", paramJobj, "Sequence Format Details are missing. <br>Please set the Sequence Format from system controls.", messageSource);
                throw ServiceException.FAILURE(response.optString(Constants.RES_MESSAGE), "", false);
            }
            
            String sequenceformat = paramJobj.optString("sequenceformat",null);
            String sequenceformatDo = paramJobj.optString(Constants.sequenceformatDo,null) != null ? paramJobj.optString(Constants.sequenceformatDo,"NA") : "";
            boolean isEdit = StringUtil.isNullOrEmpty(paramJobj.optString("isEdit",null)) ? false : Boolean.parseBoolean(paramJobj.optString("isEdit"));
            boolean isCopy = StringUtil.isNullOrEmpty(paramJobj.optString("copyInv",null)) ? false : Boolean.parseBoolean(paramJobj.optString("copyInv"));
            boolean isLeaseFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isLeaseFixedAsset"))) ? Boolean.parseBoolean(paramJobj.optString("isLeaseFixedAsset")) : false;
            boolean isExicseOpeningbalance = false;
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isExicseOpeningbalance"))) {
                isExicseOpeningbalance = Boolean.parseBoolean(paramJobj.optString("isExicseOpeningbalance"));
            }  
            boolean isEditedPendingDocument = false;
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isEditedPendingDocument"))) {
                isEditedPendingDocument = Boolean.parseBoolean(paramJobj.optString("isEditedPendingDocument"));
            }
            
            ExtraCompanyPreferences extraCompanyPreferences = null;
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;            
            
            if (!StringUtil.isNullOrEmpty(invoiceid) ) {//In edit case checks duplicate number
                if (!isAutoCreateDO) { // If Auto create DO enabled, then we don't allow to edit the invoice. This case handled in next code block. 
                    result = accInvoiceDAOobj.getDuplicateInvoiceNumberForEdit(entryNumber, companyid, invoiceid);
                    nocount = result.getRecordTotalCount();
                    if (nocount > 0 && sequenceformat.equals("NA")) {
                        doinvflag=0;
                        if (inCash) {//For cash sales
                            isDuplicateNoExe = true;
                            throw new AccountingException(messageSource.getMessage("acc.CS.salesreceipteno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyexists.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                        } else {
                            isDuplicateNoExe = true;
                            throw new AccountingException(messageSource.getMessage("acc.INV.invoiceno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyexists.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                        }
                        
                    }
                }
                /*
                    Checks duplicate number in Edit case and if auto create DO is enabled 
                */
                if (isAutoCreateDO && sequenceformatDo.equals("NA")) {
                    result = accInvoiceDAOobj.getDODuplicateNumberWithID(doEntryNumber, companyid,doid);
                    if (result.getRecordTotalCount() > 0) {
                        doinvflag=1;
                        isDuplicateNoExe = true;
                        throw new AccountingException(messageSource.getMessage("acc.DO.deliveryorderno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + doEntryNumber + messageSource.getMessage("acc.field.alreadyexists.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    }
                }
                /**
                 * ERP-38244 Do not allow editing a Sales Invoice if it has an Auto DO with QC flow enabled.
                 */
                if (isAutoCreateDO) {
                    KwlReturnObject dokwl = kwlCommonTablesDAOObj.getObject(DeliveryOrder.class.getName(), doid);
                    DeliveryOrder doobj = (DeliveryOrder) (dokwl.getEntityList().isEmpty() ? null : dokwl.getEntityList().get(0));
                    if (doobj != null && doobj.isIsAutoGeneratedDO() && !(doobj.isIsconsignment() || doobj.isLeaseDO())) {
                        if (accInvoiceDAOobj.isQCEnabledDO(doid, companyid)) {
                            throw new AccountingException(messageSource.getMessage("acc.field.salesinvoicedodelete", new Object[]{doobj.getDeliveryOrderNumber()}, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                        }
                    }
                }
            } else {//In add case check duplicate number
                result = accInvoiceDAOobj.getInvoiceCount(entryNumber, companyid);
                if (result.getRecordTotalCount() > 0 && sequenceformat.equals("NA")) {
                    doinvflag=0;
                    if (inCash) {
                        isDuplicateNoExe = true;
                        throw new AccountingException(messageSource.getMessage("acc.CS.salesreceipteno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyexists.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    } else {
                        isDuplicateNoExe = true;
                        throw new AccountingException(messageSource.getMessage("acc.INV.invoiceno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyexists.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    }
                }

                if (isAutoCreateDO && sequenceformatDo.equals("NA")) {
                    result = accInvoiceDAOobj.getDeliveryOrderCount(doEntryNumber, companyid);
                    if (result.getRecordTotalCount() > 0) {
                        doinvflag=1;
                        isDuplicateNoExe = true;
                        throw new AccountingException(messageSource.getMessage("acc.DO.deliveryorderno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + doEntryNumber + messageSource.getMessage("acc.field.alreadyexists.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    }
                }
                
                //Check Deactivate Tax in New Transaction.
                if (!fieldDataManagercntrl.isTaxActivated(paramJobj)) {
                    isTaxDeactivated = true;
                    throw ServiceException.FAILURE(messageSource.getMessage("acc.tax.deactivated.tax.saveAlert", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))), "", false);
                }
            }
            /* check for dublication of customer PORefNo in unlinked invoiced editcase createnes case*/
            JSONObject jObj =new JSONObject((String) extraCompanyPreferences.getColumnPref());
            if (!StringUtil.isNullOrEmpty(extraCompanyPreferences.getColumnPref()) && jObj.has(Constants.customerPoReferenceNo) && jObj.get(Constants.customerPoReferenceNo) != null && (Boolean) jObj.get(Constants.customerPoReferenceNo) != false) { 
                    String CustomerPORefNo = paramJobj.optString("porefno") != null ? paramJobj.optString("porefno") : "";
                    invid = paramJobj.optString("invoiceid") != null ? paramJobj.optString("invoiceid") : "";
                    String salesInvNo = "", salesInvNoTotal = "";
                    if (!StringUtil.isNullOrEmpty(CustomerPORefNo)) {
                        JSONObject reqParams = new JSONObject();
                        reqParams.put("CustomerPORefNo", CustomerPORefNo);
                        reqParams.put("companyid", companyid);
                        reqParams.put("invid", invid);
                        result = accInvoiceDAOobj.getInvoiceFromCustomerPORefNo(reqParams);
                        if (result != null && result.getRecordTotalCount() > 0) {
                            List<String> li = result.getEntityList();
                            if (!li.isEmpty()) {
                                for (String obj : li) {
                                    salesInvNo = !StringUtil.isNullOrEmpty(obj) ? obj : "";
                                    salesInvNoTotal += salesInvNo + " ,";
                                }
                               throw new AccountingException(messageSource.getMessage("acc.gst.CustPORefErrorSI", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + salesInvNoTotal.substring(0, salesInvNoTotal.length() - 1) + "<b>");
                            }
                        }
                    }  
            }      
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("countryid", null)) && Integer.parseInt(paramJobj.optString("countryid")) == Constants.indian_country_id) {
                int from = StaticValues.AUTONUM_INVOICE;
                if (inCash) {
                    from = StaticValues.AUTONUM_CASHSALE;
                }
                boolean seqformat_oldflag = StringUtil.getBoolean(paramJobj.optString("seqformat_oldflag"));
                DateFormat df = authHandler.getDateOnlyFormat();
                Date billDate = df.parse(paramJobj.optString(Constants.BillDate));
                if ((!StringUtil.isNullOrEmpty(sequenceformat) && !sequenceformat.equals("NA"))) {
                    seqNumMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, from, sequenceformat, seqformat_oldflag, billDate);
                    String autoNumber = (String) seqNumMap.get(Constants.AUTO_ENTRYNUMBER);
                    if (autoNumber.length() > Constants.SequenceFormatMaxLength || !StringUtil.isSequenceFormatValid(autoNumber)) {
                        throw new AccountingException(Constants.SequenceformatErrorMsg1 + autoNumber + Constants.SequenceformatErrorMsg2 + Constants.SequenceFormatMaxLength + Constants.SequenceformatErrorMsg3);
                    }
                } else if (!StringUtil.isNullOrEmpty(sequenceformat) && sequenceformat.equals("NA") || !StringUtil.isSequenceFormatValid(entryNumber)) {
                    if ((!StringUtil.isNullOrEmpty(sequenceformat) && entryNumber.length() > Constants.SequenceFormatMaxLength) || !StringUtil.isSequenceFormatValid(entryNumber)) {
                        throw new AccountingException(Constants.SequenceformatErrorMsg1 + entryNumber + Constants.SequenceformatErrorMsg2 + Constants.SequenceFormatMaxLength + Constants.SequenceformatErrorMsg3);
                    }
                }
            }
            
            boolean isFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isFixedAsset",null))) ? Boolean.parseBoolean(paramJobj.optString("isFixedAsset")) : false;
            if(isFixedAsset){
                DateFormat df = authHandler.getDateOnlyFormat();
                Date billDate = df.parse(paramJobj.optString(Constants.BillDate));
                int depreciationCalculationType = extraCompanyPreferences.getAssetDepreciationCalculationType();
                String invoiceDetails = paramJobj.optString(Constants.detail,"[]");
                JSONArray jArr = new JSONArray(invoiceDetails);
                for (int i = 0; i < jArr.length(); i++) {
                    JSONObject jobject = jArr.getJSONObject(i);
                    JSONArray assetArr = new JSONArray(jobject.getString("assetDetails"));
                    for (int assetCount = 0; assetCount < assetArr.length(); assetCount++) {
                        JSONObject assetJson = assetArr.getJSONObject(assetCount);
                        String assetDetailId = assetJson.getString("assetId");

                        KwlReturnObject accresult = accountingHandlerDAOobj.getObject(AssetDetails.class.getName(), assetDetailId);
                        AssetDetails ad = (AssetDetails) accresult.getEntityList().get(0);
                        
                        if(billDate.before(ad.getInstallationDate())){
                            throw new AccountingException(messageSource.getMessage("acc.msg.invoicedate.installationdate.alertmsg", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                        }

                        /*Below code is used to check if asset is already expired or not*/
                        boolean isExpire=false;
                        Date assetEndLifeDate=null;
                        List expireList=accProductObj.isAssetExpire(ad,billDate);
                        if(expireList!=null&& expireList.size()>0){
                            isExpire=(Boolean)expireList.get(0);
                        }
                        String backyears = "";
                        Calendar cal1 = Calendar.getInstance();
                        if (isExpire) {
                            long assetenddateinlong = (Long) expireList.get(1);
                            assetEndLifeDate = new Date(assetenddateinlong);
                            cal1.setTime(assetEndLifeDate);
                        } else {
                            cal1.setTime(billDate);
                            cal1.add(Calendar.DATE, -1);
                        }
                        int currentyear = cal1.get(Calendar.YEAR);
                        Calendar cal2 = Calendar.getInstance();
                        cal2.setTime(ad.getInstallationDate());
                        int creationyear1 = cal2.get(Calendar.YEAR);

                        boolean isAllDepreciated = true;
                        int periodDep = -1;

                        Calendar calInstallation = Calendar.getInstance();
                        calInstallation.setTime(ad.getInstallationDate());
                        long diffinlong = cal1.getTimeInMillis() - calInstallation.getTimeInMillis();
                        long enddateinlong = calInstallation.getTimeInMillis() + diffinlong;
                        Date endDate = new Date(enddateinlong);
                        Calendar calEndMonth = Calendar.getInstance();
                        calEndMonth.setTime(endDate);

                        while (creationyear1 <= currentyear) {
                            backyears += creationyear1 + ",";
                            creationyear1++;
                        }
                        
                        List<String> yearList = null;
                        if(!StringUtil.isNullOrEmpty(backyears)){
                            yearList = Arrays.asList(backyears.split("\\s*,\\s*"));
                            Collections.sort(yearList);
                            int yeardiffDep=0,k=0;
                            for (yeardiffDep = 0, k = 0; k < yearList.size(); k++, yeardiffDep++) {
                                int startMonth1=0;
                                int endMonth1=11;
                                int year1 = Integer.parseInt(yearList.get(k)); //Back Years
                                int creationyear = cal2.get(Calendar.YEAR);           //Installation Year
                                yeardiffDep = year1 - creationyear;
                                if (creationyear == currentyear) {    // if (installation year==disposal year) then start month=installation date month && End Month=disposal year month 
                                    startMonth1 = cal2.get(Calendar.MONTH);
                                    endMonth1 = cal1.get(Calendar.MONTH);
                                } else if (creationyear == year1) {           // if (installation year==backyear) then start month=installation date month && End Month=11
                                    startMonth1 = cal2.get(Calendar.MONTH);
                                } else if (currentyear == year1) {        // if (disposal year==backyear year) then start month=0 && End Month=disposal year mont
                                    endMonth1 = cal1.get(Calendar.MONTH);
                                }

                                if (depreciationCalculationType == 0) {
                                    if(yeardiffDep!=0){
                                        yeardiffDep =- 1;
                                    }
                                    startMonth1=0;
                                    endMonth1=yearList.size()-1;
                                }

                                for (int cnt = startMonth1; cnt <=endMonth1; cnt++) {
                                    if (depreciationCalculationType == 0) {
                                        if (yeardiffDep < 0) {  //if selected year is less than the cretion year then there will be no depreciation to show
                                            continue;
                                        }
                                        periodDep = yeardiffDep + 1;
                                    } else {
                                        periodDep = (12 * yeardiffDep) + cnt + 1;
                                        periodDep = calInstallation.get(Calendar.MONTH) != 0 ? periodDep - calInstallation.get(Calendar.MONTH) : periodDep;
                                    }

                                    HashMap<String, Object> filters = new HashMap<String, Object>();
                                    filters.put("period", periodDep);
                                    filters.put("assetDetailsId", ad.getId());
                                    filters.put("companyid", companyid);
                                    filters.put("assetDetails", true);
                                    KwlReturnObject dresult = accProductObj.getAssetDepreciationDetail(filters);
                                    if (dresult.getEntityList().isEmpty()) {
                                        isAllDepreciated = false;
                                        throw new AccountingException(messageSource.getMessage("acc.msg.depreciationnotposteduptoinvoicedate", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            synchronized (this) {//Checks duplicate number for simultaneous transactions
                
                status = txnManager.getTransaction(def);
                KwlReturnObject resultInv = accCommonTablesDAO.getTransactionInTemp(entryNumber, companyid, Constants.Acc_Invoice_ModuleId);
                if (resultInv.getRecordTotalCount() > 0 && sequenceformat.equals("NA")) {
                    doinvflag=0;
                    if (inCash) {
                        isDuplicateNoExe = true;
                        throw new AccountingException(messageSource.getMessage("acc.CS.selectedsalesreceipteno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyinprocess.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    } else {
                        isDuplicateNoExe = true;
                        throw new AccountingException(messageSource.getMessage("acc.INV.selectedinvoiceno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + entryNumber + messageSource.getMessage("acc.field.alreadyinprocess.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    }
                } else {
                    accCommonTablesDAO.insertTransactionInTemp(entryNumber, companyid, Constants.Acc_Invoice_ModuleId);
                }
                
                if (isAutoCreateDO && sequenceformatDo.equals("NA")) {
                    resultInv = accCommonTablesDAO.getTransactionInTemp(doEntryNumber, companyid, Constants.Acc_Delivery_Order_ModuleId);
                    if (resultInv.getRecordTotalCount() > 0) {
                        doinvflag=1;
                        isDuplicateNoExe = true;
                        throw new AccountingException(messageSource.getMessage("acc.DO.selecteddeliveryorderno", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + doEntryNumber + messageSource.getMessage("acc.field.alreadyinprocess.", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    } else {
                        accCommonTablesDAO.insertTransactionInTemp(doEntryNumber, companyid, Constants.Acc_Delivery_Order_ModuleId);
                    }
                }
                txnManager.commit(status);
            }
            
            status = txnManager.getTransaction(def);
            List mailParams=null;
            /**
             * creating template for sales invoice.
             * istemplate=2 //creating only template
             * istemplate=0 //creating only transaction
             */
        Map<Integer,List<String>> invDetailTermMap = new HashMap<>();
            if (createAsTransactionChkboxwithTemplate) {
                paramJobj.put("istemplate", 2);
                saveInvoiceJsonNew(paramJobj, invDetailTermMap);
                paramJobj.remove("istemplate");
            }
            /**
             * creating sales invoice transaction.
             */
            List li = saveInvoiceJsonNew(paramJobj, invDetailTermMap);
            Invoice invoiceObj = null;
            
            if(!isLeaseFixedAsset){  //In Lease Sales Invoice Mail parametrs are not used so added check of Lease Fixed asset.ERP-21195
               mailParams=(List)li.get(10);
            }
            
            boolean isContractMapping = paramJobj.optString("isContractMapping",null)!=null ? (Boolean)paramJobj.get("isContractMapping") : false;
            boolean hasRepeatInvoice = paramJobj.optString("hasRepeatInvoice",null)!=null ? (Boolean)paramJobj.get("hasRepeatInvoice") : false;
            boolean isRepeatInvoiceCreated = paramJobj.optString("isRepeatInvoiceCreated",null)!=null ? (Boolean)paramJobj.get("isRepeatInvoiceCreated") : false;
            
            if (li.get(5) != null) {
                invoiceNumBer = li.get(5).toString();
            }
            if (li.get(8) != null) {
                JENumBer = li.get(8).toString();
            }
            
            
            String roleName = "";
            boolean isAuthorityToApprove = false;
            boolean sendPendingDocumentsToNextLevel = false;
            String approvedJENumber = "";
            String approvedJEMessage = "";
            int levelOnWhichDocumentIsApproved = 0;
            
            if ((isRepeatInvoiceCreated) || (hasRepeatInvoice)) {
            if (li!=null && li.size() >10 && li.get(10) != null) {
                    repeatedid = li.get(10).toString();
            }
                if (li!=null && li.size() >11 && li.get(11) != null && !StringUtil.isNullOrEmpty(li.get(11).toString())) {
                    intervalUnit = (Integer) li.get(11);
                }
                if (li!=null && li.size() >12 && li.get(12) != null && !StringUtil.isNullOrEmpty(li.get(12).toString())) {
                    intervalType = li.get(12).toString();
                }
                if (li!=null && li.size() >13 && li.get(13) != null && !StringUtil.isNullOrEmpty(li.get(13).toString())) {
                    sdate = (Date) li.get(13);
                }
                if (li!=null && li.size() >14 && li.get(14) != null && !StringUtil.isNullOrEmpty(li.get(14).toString())) {
                    expdate = (Date) li.get(14);
                }
                if (li!=null && li.size() >15 && li.get(15) != null && !StringUtil.isNullOrEmpty(li.get(15).toString())) {
                    noOfInvPost = (Integer) li.get(15);
                }
                if (li!=null && li.size() >16 && li.get(16) != null && !StringUtil.isNullOrEmpty(li.get(16).toString())) {
                    nextdate = (Date) li.get(14);
                }
                if (li!=null && li.size() >17 && li.get(17) != null && !StringUtil.isNullOrEmpty(li.get(17).toString())) {
                    noOfInvRemainPost = (Integer) li.get(17);
                }
                if (li!=null && li.size() >18 && li.get(18) != null && !StringUtil.isNullOrEmpty(li.get(18).toString())) {
                    invoiceObj = (Invoice) li.get(18);
                }
            } else {
                if (li!=null && li.size() >11 && li.get(11) != null && !StringUtil.isNullOrEmpty(li.get(11).toString())) {
                    unlinkMessage = (String) li.get(11);
                }
                if (li!=null && li.size() >12 && li.get(12) != null && !StringUtil.isNullOrEmpty(li.get(12).toString())) {
                    linkedDocuments = (String) li.get(12);
                }
                if (li!=null && li.size() >13 && li.get(13) != null && !StringUtil.isNullOrEmpty(li.get(13).toString())) {
                    auditMessage = (String) li.get(13);
                }
                if (li!=null && li.size() >14 && li.get(14) != null && !StringUtil.isNullOrEmpty(li.get(14).toString())) {
                    pendingApprFlag = (Integer) li.get(14);
                }
                if (li!=null && li.size() >15 && li.get(15) != null && !StringUtil.isNullOrEmpty(li.get(15).toString())) {
                    invoiceObj = (Invoice) li.get(15);
                }
                
                if (li != null && li.size() > 16 && li.get(16) != null && !StringUtil.isNullOrEmpty(li.get(16).toString())) {
                    roleName = (String) li.get(16);
                }
                if (li != null && li.size() > 17 && li.get(17) != null && !StringUtil.isNullOrEmpty(li.get(17).toString())) {
                    isAuthorityToApprove = (Boolean) li.get(17);
                }

                if (li != null && li.size() > 18 && li.get(18) != null && !StringUtil.isNullOrEmpty(li.get(18).toString())) {
                    sendPendingDocumentsToNextLevel = (Boolean) li.get(18);
                }

                if (li != null && li.size() > 19 && li.get(19) != null && !StringUtil.isNullOrEmpty(li.get(19).toString())) {
                    approvedJENumber = (String) li.get(19);
                }

                if (li != null && li.size() > 20 && li.get(20) != null && !StringUtil.isNullOrEmpty(li.get(20).toString())) {
                    approvedJEMessage = (String) li.get(20);
                }
                
                if (li != null && li.size() > 21 && li.get(21) != null && !StringUtil.isNullOrEmpty(li.get(21).toString())) {
                    levelOnWhichDocumentIsApproved = (Integer) li.get(21);
                }
            }
          
            
            boolean isConsignment = paramJobj.optString(Constants.isConsignment,null) != null ? Boolean.parseBoolean(paramJobj.optString(Constants.isConsignment)) : false;
            boolean pendingApprovalFlag = false;
            int DOSeqNum = paramJobj.optString("DOSeqNum",null) != null ? Integer.parseInt(paramJobj.optString("DOSeqNum")) : 0;
            String pendingstatus = (String) li.get(2);
            if (StringUtil.equal("Pending Approval", pendingstatus)) {
                pendingstatus = messageSource.getMessage("acc.field.butpendingforApproval", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language)));
                pendingApprovalFlag = true;
            } else {
                pendingstatus = "";
            }
            
            
            /* 
             If we Edit pending document &
             "Send Pending Document to Next Level" is activated
             then pending message should not be appended in main message
             So it should be blank
             */
            if (isEditedPendingDocument && sendPendingDocumentsToNextLevel) {
                pendingstatus = "";
            }
            
            String[] id = (String[]) li.get(0);
            DeliveryOrder deliveryOrder=new DeliveryOrder();
            if (isAutoCreateDO) {
                /*Get request parameters */
                List doList = saveDeliveryOrder(paramJobj, id[0]); 
                deliveryOrder = (DeliveryOrder) doList.get(0);
                billNo=deliveryOrder.getDeliveryOrderNumber();
                Set<DeliveryOrderDetail> doRows = deliveryOrder.getRows();
                double totalAmount = 0;
                double quantity = 0;
                if (doRows != null && !doRows.isEmpty()) {
                    for (DeliveryOrderDetail cnt : doRows) {
                        quantity = cnt.getInventory().getQuantity();
                        totalAmount += cnt.getRate() * quantity;
                    }
                }
                if(pendingApprovalFlag){
                    accInvoiceDAOobj.approvePendingDO(deliveryOrder.getID(), companyid, 1);
                    stockMovementService.removeStockMovementByReferenceId(deliveryOrder.getCompany(), deliveryOrder.getID());
                    Iterator doDetailsItr = doRows.iterator();
                    while (doDetailsItr.hasNext()) {
                        DeliveryOrderDetail doDetail = (DeliveryOrderDetail) doDetailsItr.next();
                        Inventory inventory = doDetail.getInventory();
                        if (inventory.isInvrecord()) {
                            inventory.setActquantity(inventory.getBaseuomquantity());
                            inventory.getProduct().setAvailableQuantity(inventory.getProduct().getAvailableQuantity()+inventory.getBaseuomquantity());
                            inventory.setBaseuomquantity(0.0);
                        }
                    }
                }
                          
            }
            invid=id[0];
            deliveryOid=deliveryOrder.getID();
            if (deliveryOrder.getCustomer() != null) {
                jobj.put("personid", deliveryOrder.getCustomer().getID());
                if (!StringUtil.isNullOrEmpty(String.valueOf(deliveryOrder.isIsconsignment()))) {
                    jobj.put("isconsignment", deliveryOrder.isIsconsignment());
                } else {
                    jobj.put("isconsignment", false);
                }
            }
            //Get mapping details id of invoice documents
            String savedFilesMappingId = paramJobj.optString("savedFilesMappingId", "");
            if(!StringUtil.isNullOrEmpty(savedFilesMappingId)){
                /**
                * Save temporary saved attachment files mapping in permanent table
                */
                JSONObject jsonObj = new JSONObject();
                jsonObj.put("savedFilesMappingId", savedFilesMappingId);
                jsonObj.put("docId", invid);
                jsonObj.put("companyid", companyid);
                accSalesOrderServiceobj.saveDocuments(jsonObj);
            }
            
            String autoCreateDOMsg = "";
            txnManager.commit(status);
            status = null;
                        
            
            /*Mapping of Excise Unit Fields with the Template mapping*/

            if (!StringUtil.isNullOrEmpty(paramJobj.optString("countryid",null)) && Integer.parseInt(paramJobj.optString("countryid")) == Constants.indian_country_id) {
                //status=null;
                //status = txnManager.getTransaction(def);     

                DefaultTransactionDefinition tmpdef = new DefaultTransactionDefinition();
                tmpdef.setName("EUT_Tx");
                tmpdef.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
                TransactionStatus statusTmp = txnManager.getTransaction(tmpdef);
                try {
                    HashMap<String, Object> requestParams = new HashMap<String, Object>();
                    HashMap<String, Object> ModuleTempParams = new HashMap<String, Object>();
                    ModuleTempParams.put("modulerecordid", invid);
                    ModuleTempParams.put(Constants.companyKey, companyid);
                    KwlReturnObject capInv = accountingHandlerDAOobj.getModuleTemplates(ModuleTempParams);
  
                    requestParams = new HashMap<String, Object>();
                    if(!StringUtil.isNullOrEmpty(paramJobj.optString("indiaExcise",null))){
                        JSONObject tmpjobj = new JSONObject(paramJobj.optString("indiaExcise"));
                        if (extraCompanyPreferences.isExciseApplicable()) {
                            requestParams = mapExciseDetails(invid,tmpjobj,paramJobj);
                            if(isCopy){
                                if(requestParams.containsKey("id")){
                                    requestParams.remove("id");
                                }
                            }
                            accInvoiceDAOobj.saveExciseDetails(requestParams);
                        }
                    }
                    
                    txnManager.commit(statusTmp);
                    statusTmp = null;
                }catch(Exception ex){
                    if (statusTmp != null) {
                        txnManager.rollback(statusTmp);
                    }
                    statusTmp = null;
                }
            }
            
            Boolean cash = Boolean.parseBoolean(paramJobj.optString("incash"));
            TransactionStatus AutoNoStatus = null;
            try {
                synchronized (this) {
                    DefaultTransactionDefinition def1 = new DefaultTransactionDefinition();
                    def1.setName("AutoNum_Tx");
                    def1.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
                    AutoNoStatus = txnManager.getTransaction(def1);

                    boolean seqformat_oldflag = StringUtil.getBoolean(paramJobj.optString("seqformat_oldflag"));
                    if (((isCopy) ? true : !isEdit) && StringUtil.isNullOrEmpty(invoiceid) && (!StringUtil.isNullOrEmpty(sequenceformat) && !sequenceformat.equals("NA"))) {
                        KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), id[0]);
                        Invoice invoice = (Invoice) invObj.getEntityList().get(0);
                        int from = StaticValues.AUTONUM_INVOICE;
                        if (cash) {
                            from = StaticValues.AUTONUM_CASHSALE;
                        }
                        String nextAutoNumber = "";
                        Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                        if (seqformat_oldflag) {
                            nextAutoNumber = accCompanyPreferencesObj.getNextAutoNumber(companyid, from, sequenceformat);
                            seqNumberMap.put(Constants.AUTO_ENTRYNUMBER, nextAutoNumber);
                        } else {
//                            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, from, sequenceformat, seqformat_oldflag, invoice.getJournalEntry().getEntryDate());
                            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, from, sequenceformat, seqformat_oldflag, invoice.getCreationDate());
                        }
                        seqNumberMap.put(Constants.DOCUMENTID, id[0]);
                        seqNumberMap.put(Constants.companyKey, companyid);
                        seqNumberMap.put(Constants.SEQUENCEFORMATID, sequenceformat);
                        //SDP-13487 : When user save the transaction at very first time then transaction no. & sequence no.will be saved as empty.
                        seqNumberMap.put(Constants.isDraft, isDraft);
                          invoiceNumBer = accInvoiceDAOobj.updateInvoiceEntryNumberForNewSI(seqNumberMap);   
                    } else if(isSaveDraftRecord && !sequenceformat.equals("NA") && isAutoSeqForEmptyDraft){  //SDP-13487 : Do not update Invoice No. in case of Sequence Format as "NA",  //SDP-13927 : If Draft already having sequence no. then do not update it
                        /*
                        Below piece of code has written to handle Auto-Sequence no.in edit mode.
                        When user open the draft in edit mode, he can save it as a draft or a transaction. If it save as draft again then this code will not be execute.
                        But, if he saves it as a transaction then this code will be execute to get the Auto-Sequence No and set it to transaction no.
                        */
                        KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), id[0]);
                        Invoice invoice = (Invoice) invObj.getEntityList().get(0);
                        int from = StaticValues.AUTONUM_INVOICE;
                        if (cash) {
                            from = StaticValues.AUTONUM_CASHSALE;
                        }
                        Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                        seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, from, sequenceformat, seqformat_oldflag, invoice.getCreationDate());
                        seqNumberMap.put(Constants.DOCUMENTID, id[0]);
                        seqNumberMap.put(Constants.companyKey, companyid);
                        seqNumberMap.put(Constants.SEQUENCEFORMATID, sequenceformat);
                        seqNumberMap.put(Constants.isDraft, isDraft);
                         invoiceNumBer = accInvoiceDAOobj.updateInvoiceEntryNumberForNewSI(seqNumberMap);
                    } else if(isDraft && !sequenceformat.equals("NA") && isAutoSeqForEmptyDraft){
                        /* SDP-13923
                        This piece of code has been written to fix below case.
                        1)Draft has been made with NA. 2)Draft has opened in edit mode and saved as a draft again with Auto-Sequence Format.
                        3)Again draft opened in edit mode then sequence format should be Auto-Sequence Format.
                        */
                        KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), id[0]);
                        Invoice invoice = (Invoice) invObj.getEntityList().get(0);
                        int from = StaticValues.AUTONUM_INVOICE;
                        if (cash) {
                            from = StaticValues.AUTONUM_CASHSALE;
                        }
                        Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                        seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, from, sequenceformat, seqformat_oldflag, invoice.getCreationDate());
                        seqNumberMap.put(Constants.DOCUMENTID, id[0]);
                        seqNumberMap.put(Constants.companyKey, companyid);
                        seqNumberMap.put(Constants.SEQUENCEFORMATID, sequenceformat);
                        seqNumberMap.put(Constants.isDraft, isDraft);
                        invoiceNumBer = accInvoiceDAOobj.updateInvoiceEntryNumberForNewSI(seqNumberMap);
                    }
                            
                    if (StringUtil.isNullOrEmpty(doid) && isAutoCreateDO && !sequenceformatDo.equals("NA")) {
                        String nextAutoNumber1 = "";
                        Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                        if (seqformat_oldflag) {
                            nextAutoNumber1 = accCompanyPreferencesObj.getNextAutoNumber(companyid, StaticValues.AUTONUM_DELIVERYORDER, sequenceformatDo);
                            seqNumberMap.put(Constants.AUTO_ENTRYNUMBER, nextAutoNumber1);
                        } else {
                            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_DELIVERYORDER, sequenceformatDo, seqformat_oldflag, deliveryOrder.getOrderDate());
                            if (DOSeqNum != 0) {
                                seqNumberMap.put(Constants.SEQNUMBER, DOSeqNum);
                            }
                        }
                        seqNumberMap.put(Constants.DOCUMENTID, deliveryOrder.getID());
                        seqNumberMap.put(Constants.companyKey, companyid);
                        seqNumberMap.put(Constants.SEQUENCEFORMATID, sequenceformatDo);
                        billNo = accInvoiceDAOobj.updateDOEntryNumberForNewDO(seqNumberMap);
                        boolean sendForQAApproval = paramJobj.optBoolean("sendForQAApproval", false);
                        if (sendForQAApproval) {
                            String memo = "IST created for QC against DO:" + billNo;
                            accInvoiceDAOobj.updateMemoForIST(memo, deliveryOrder.getID(), companyid);
                        } else if (!sendForQAApproval && extraCompanyPreferences.isPickpackship()) {
                            String memo = Constants.pickPack_DO_IST_Memo + billNo;
                            accInvoiceDAOobj.updateMemoForPickPackDOIST(memo, deliveryOrder.getID(), companyid);
                        }

                    }
                    if (((isCopy) ? true : !isEdit) && StringUtil.isNullOrEmpty(invoiceid) && !pendingApprovalFlag) {
                        HashMap<String, Object> JEFormatParams = new HashMap<String, Object>();
                        JEFormatParams.put(Constants.moduleid, Constants.Acc_GENERAL_LEDGER_ModuleId);
                        JEFormatParams.put("modulename", CompanyPreferencesConstants.AUTOJOURNALENTRY);
                        JEFormatParams.put(Constants.companyKey, companyid);
                        JEFormatParams.put("isdefaultFormat", true);
                        //SDP-13487 : When user save the transaction at very first time then transaction no. & sequence no.will be saved as empty.
                        JEFormatParams.put(Constants.isDraft, isDraft);
                        KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                        SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
                        KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), id[0]);
                        Invoice invoice = (Invoice) invObj.getEntityList().get(0);
			paramJobj.put("isDraft", isDraft);  //ERP-38357 : If isDraft=TRUE then JE No.will not be create / update.
                        JENumBer = updateJEEntryNumberForNewJE(paramJobj, invoice.getJournalEntry(), companyid, format.getID(),invoice.getJournalEntry().getPendingapproval());
                        
                    } else if(isSaveDraftRecord && (isAutoSeqForEmptyDraft || sequenceformat.equals("NA")) && !pendingApprovalFlag){  //SDP-13927 : If Draft already having sequence no. then do not update it
                        // when  we are saving record from draft then  if pending approval is true Then  No JE Need to posted ERP-38805 
                        /*
                        Below piece of code has written to handle Auto-Sequence no.in edit mode for Auto JE.
                        When user open the draft in edit mode, he can save it as a draft or a transaction. If it save as draft again then this code will not be execute.
                        But, if he saves it as a transaction then this code will be execute to get the Auto-Sequence No for Auto JE and set it to JE no.
                        */
                        HashMap<String, Object> JEFormatParams = new HashMap<String, Object>();
                        JEFormatParams.put(Constants.moduleid, Constants.Acc_GENERAL_LEDGER_ModuleId);
                        JEFormatParams.put("modulename", CompanyPreferencesConstants.AUTOJOURNALENTRY);
                        JEFormatParams.put(Constants.companyKey, companyid);
                        JEFormatParams.put("isdefaultFormat", true);
                        JEFormatParams.put(Constants.isDraft, isDraft);
                        KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                        SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
                        KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), id[0]);
                        Invoice invoice = (Invoice) invObj.getEntityList().get(0);
			paramJobj.put("isDraft", isDraft);  //ERP-38357 : If isDraft=TRUE then JE No.will not be create / update.
                        JENumBer = updateJEEntryNumberForNewJE(paramJobj, invoice.getJournalEntry(), companyid, format.getID(),invoice.getJournalEntry().getPendingapproval());
                    }
                    String pendingmsg  = "";
                    if (isAutoCreateDO) {
                        pendingmsg = " " +pendingstatus;
                    }
                    autoCreateDOMsg = messageSource.getMessage("acc.field.Invoice/CashSalewithDeliveryOrder", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + "<b> (" + billNo + ")</b>" + " " + messageSource.getMessage("acc.field.hasbeensavedsuccessfully", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language)))+ pendingmsg +"<br/>" + messageSource.getMessage("acc.field.DocumentNo", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + invoiceNumBer + ",</b> " + messageSource.getMessage("acc.field.JENo", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + JENumBer + "</b>";
                    
                    Map<String, Object> auditRequestParams = new HashMap<String, Object>();
                    auditRequestParams.put(Constants.reqHeader, paramJobj.getString(Constants.reqHeader));
                    auditRequestParams.put(Constants.remoteIPAddress, paramJobj.getString(Constants.remoteIPAddress));
                    auditRequestParams.put(Constants.useridKey, paramJobj.getString(Constants.useridKey));
                    
                    if(isAutoCreateDO){
                        String action = "added new";
                        String auditMSG = " has " + action + " Auto Delivery Order " + billNo +" with Invoice "+invoiceNumBer;
//                        auditTrailObj.insertAuditLog(AuditAction.DELIVERY_ORDER, "User " + paramJobj.optString(Constants.userfullname) + auditMSG, paramJobj, deliveryOrder.getID());
                        auditTrailObj.insertAuditLog(AuditAction.DELIVERY_ORDER, "User " + paramJobj.optString(Constants.userfullname) + auditMSG, auditRequestParams, deliveryOrder.getID());
                    }
                   
                    txnManager.commit(AutoNoStatus);
                }
                if (mailParams != null && !mailParams.isEmpty()) {
                    /**
                     * parameters required for sending mail
                     */
                    String createdby = paramJobj.optString(Constants.useridKey);
                    Map<String, Object> mailParameteres = new HashMap();
                    mailParameteres.put(Constants.companyid, companyid);
                    mailParameteres.put(Constants.prNumber, invoiceNumBer);
                    mailParameteres.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                    mailParameteres.put(Constants.isCash, (Boolean) inCash);
                    mailParameteres.put(Constants.createdBy, createdby);
                    mailParameteres.put(Constants.PAGE_URL, paramJobj.optString(Constants.PAGE_URL));
                    Iterator itr = mailParams.iterator();

                    while (itr.hasNext()) {
                        HashMap<String, Object> paramsMap = (HashMap<String, Object>) itr.next();

                        mailParameteres.put(Constants.ruleid, (String) paramsMap.get("ruleid"));
                        mailParameteres.put(Constants.fromName, (String) paramsMap.get("fromName"));
                        mailParameteres.put(Constants.hasApprover, (Boolean) paramsMap.get("hasApprover"));

                        sendMailToApprover(mailParameteres);

                    }


                }
            } catch (AccountingException ex) {
                if (AutoNoStatus != null) {
                    txnManager.rollback(AutoNoStatus);
                }
                issuccess = false;
                isAccountingExe=true;
                throw new AccountingException(ex.getMessage());
            }catch (Exception ex) {
                if (AutoNoStatus != null) {
                    txnManager.rollback(AutoNoStatus);
                }
                deleteEntryInTemp(deleteparam);
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
            status = txnManager.getTransaction(def);
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isGeneratedRecurringInvoice",null))) {
                int isGeneratedRecurringInvoice = Integer.parseInt(paramJobj.optString("isGeneratedRecurringInvoice"));
                HashMap<String, Object> requestParams = new HashMap<String, Object>();
                DateFormat df = (DateFormat) authHandler.getDateOnlyFormat();
                Date generatedDate = (Date) df.parse(paramJobj.optString("generatedDate"));
                requestParams.put("invoice", paramJobj.optString("Oldinvoiceid"));
                requestParams.put("excludeOrGenerate", isGeneratedRecurringInvoice);
                requestParams.put("generatedDate", generatedDate);
                requestParams.put(Constants.companyKey, companyid);
                KwlReturnObject Excludeinv = accInvoiceDAOobj.saveExcludedRecords(requestParams);
            }
            /*
             * If invoice terms applied then add mapping in against invoice
             */
            //Putting invoicedetail id in InvoiceTerms Array
            
            String InvoiceTerms = paramJobj.optString("invoicetermsmap", "[]");
            if (invoiceObj != null) {
                Set<InvoiceDetail> details = invoiceObj.getRows();
                JSONArray termsArrRemove = new JSONArray(InvoiceTerms);
                JSONArray termsArrAdd = new JSONArray();
                for (int cnt = 0; cnt < termsArrRemove.length(); cnt++) {
                    JSONObject temp = termsArrRemove.getJSONObject(cnt);
                    boolean added = false;
                    for (InvoiceDetail invDetail : details) {
                        if (invDetailTermMap.containsKey(invDetail.getSrno()) && invDetailTermMap.get(invDetail.getSrno()) != null) {
                            List termids = invDetailTermMap.get(invDetail.getSrno());

                            for (Object termid1 : termids) {
                                if (temp.optString("id").equals(termid1)) {
                                    temp.put("invoicedetail", invDetail.getID());
                                    termsArrAdd.put(temp);
                                    added = true;
                                }
                            }
                        }
                    }
                    if (!added) {
                        termsArrAdd.put(temp);
                    }
                }
                InvoiceTerms = termsArrAdd.toString();
            }
            
            if (StringUtil.isAsciiString(InvoiceTerms)) {
                boolean isDo = false;
                mapInvoiceTerms(InvoiceTerms, id[0], paramJobj.optString(Constants.useridKey), isDo);
            }
            
            // For updating delivery planner entry
            if (!isEdit && !StringUtil.isNullOrEmpty(paramJobj.optString("fromLinkCombo",null)) && !StringUtil.isNullOrEmpty(paramJobj.optString("linkNumber",null))) {
                Map<String, Object> requestParams=new HashMap<>();
                requestParams.put("fromLinkCombo", paramJobj.optString("fromLinkCombo"));
                requestParams.put("linkNumber", paramJobj.optString("linkNumber"));
                requestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                requestParams.put("userid",paramJobj.optString(Constants.useridKey));
                requestParams.put("docid",id[0]);
                updateDeliveryPlannerEntry(requestParams);
            }

            ArrayList discountArr = (ArrayList) li.get(1);
            jobj.put("invoiceid", id[0]);


            jobj.put("accountid", li.get(3));
            jobj.put("accountName", li.get(4));
            jobj.put("invoiceNo", invoiceNumBer);
            jobj.put("address", li.get(6));
            jobj.put("amount", li.get(7));
            jobj.put("fullShippingAddress", li.get(9));
            
            jobj.put("repeatedid", repeatedid);
            jobj.put("intervalUnit", intervalUnit);
            jobj.put("intervalType", intervalType);
            jobj.put("sdate", sdate);
            jobj.put("expdate", expdate);
            jobj.put("noOfInvPost", noOfInvPost);
            jobj.put("nextdate", nextdate);
            jobj.put("noOfInvRemainPost", noOfInvRemainPost);
            
            KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), id[0]);
            Invoice invoice = (Invoice) invObj.getEntityList().get(0);
            if (invoice != null) {
                if (invoice.getCustomer() != null) {
                    jobj.put("driverID", (invoice.getCustomer().getDriver() != null) ? invoice.getCustomer().getDriver().getID() : "");
                    jobj.put("vehicleNoID", (invoice.getCustomer().getVehicleNo() != null) ? invoice.getCustomer().getVehicleNo().getID() : "");
                }
            }
            
            boolean isJeNoEmpty = false;
            if (StringUtil.isNullOrEmpty(JENumBer)) {
                isJeNoEmpty = true;
            }
            if (istemplate == 1) {
                msg = (cash ? messageSource.getMessage("acc.field.SalesReceiptandTemplatehasbeensavedsuccessfully", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.field.CustomerInvoiceandTemplatehasbeensavedsuccessfully", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language)))) + (pendingApprovalFlag ? (messageSource.getMessage("acc.field.but", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + (cash ? messageSource.getMessage("acc.field.SalesReceipt", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.field.CustomerInvoice", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language)))) + messageSource.getMessage("acc.field.ispendingforApproval", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language)))) : ".");
                msg += "<br/>" + messageSource.getMessage("acc.field.DocumentNo", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + invoiceNumBer + ",</b> " + messageSource.getMessage("acc.field.JENo", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + JENumBer + "</b>";
            } else if (istemplate == 2) {
                msg = (cash ? messageSource.getMessage("acc.templateinv.2", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.templateinv.1", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))));
              }else if (isConsignment) {
                    msg = (cash ? messageSource.getMessage("acc.Consignment.inv.cashsave", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.Consignment.inv.creditsave", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language)))) + " " + pendingstatus + "<br/>" + messageSource.getMessage("acc.field.DocumentNo", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + invoiceNumBer + ",</b> " + messageSource.getMessage("acc.field.JENo", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + JENumBer + "</b>";
              } else if(isDraft) {   //SDP-13487
                  //Below code snippet has written to show difference message when entry has been saved as a transaction or a draft.
                  String documentno = " ";
                  if(!StringUtil.isNullOrEmpty(invoiceNumBer)){
                      documentno = " <b>"+invoiceNumBer+"</b> ";
                  }
                  if(cash){
                      msg = messageSource.getMessage("acc.invcash.draft.msg", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)))+documentno+messageSource.getMessage("acc.draft.success.msg.hasbeensavedsuccessfully", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)));
                  } else {
                      msg = messageSource.getMessage("acc.inv.draft.msg", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)))+documentno+messageSource.getMessage("acc.draft.success.msg.hasbeensavedsuccessfully", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)));
                  }
              } else{
                  // Excise Opening Balance check from Vendor Master ERP-27108 : to hide JE POST
                    msg = (cash ? messageSource.getMessage("acc.inv.2", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) : messageSource.getMessage("acc.inv.1", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language)))) + " " + pendingstatus + "<br/>" + messageSource.getMessage("acc.field.DocumentNo", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + invoiceNumBer + ".</b> " + ((isJeNoEmpty || isExicseOpeningbalance)?"":messageSource.getMessage("acc.field.JENo", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ": <b>" + JENumBer + "</b>");
                    if (!StringUtil.isNullOrEmpty(paramJobj.optString("createAsTransactionChkbox", "")) && paramJobj.optString("createAsTransactionChkbox").equalsIgnoreCase("on") && !StringUtil.isNullOrEmpty(paramJobj.optString("templatename", ""))) {
                        msg += "<br>Template Name: <b>"+ paramJobj.optString("templatename", "") +"</b>";
                    }
              }
            
            if (isAutoCreateDO) {
                msg = autoCreateDOMsg;
            }
            /* Preparing Audit trial message if document is linking at the time of creating (SDP-11270)*/   
            String template = " template for record ";
            if (istemplate == 0) {
                template = "";
            }
            String action = "added new";
            if (isEdit == true && isCopy == false) {
                action = "updated";
            }
            if(isLeaseFixedAsset) {
                action += " Lease";
            }
            String linkMode = paramJobj.optString("fromLinkCombo");
            String linkingMessages = "";
            if (!StringUtil.isNullOrEmpty(linkedDocuments) && !StringUtil.isNullOrEmpty(linkMode)) {
                linkingMessages = " by Linking to " + linkMode + " " + linkedDocuments;
            }
            Map<String, Object> auditRequestParams = new HashMap<String, Object>();
            auditRequestParams.put(Constants.reqHeader, paramJobj.getString(Constants.reqHeader));
            auditRequestParams.put(Constants.remoteIPAddress, paramJobj.getString(Constants.remoteIPAddress));
            auditRequestParams.put(Constants.useridKey, paramJobj.getString(Constants.useridKey));
            String JEmsg="";
            if (!inCash) {
                if ((!isJeNoEmpty || !isExicseOpeningbalance) && pendingApprFlag != 1 ) {
                    JEmsg = "with" +messageSource.getMessage("acc.field.JENo", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + ":" + JENumBer;
                }                    
                if(!StringUtil.isNullOrEmpty(recId)){
                    auditTrailObj.insertAuditLog(AuditAction.INVOICE_CREATED, "User " + paramJobj.optString(Constants.userfullname) + " has " + action + template + (isConsignment ? " Consignment Sales Invoice " : isFixedAsset ? " Asset Disposal Invoice " : " Customer Invoice ") + (istemplate!=2? recId:"")  + JEmsg + linkingMessages + (pendingApprFlag == 1 ? " " + messageSource.getMessage("acc.field.whichispendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : "" ) + auditMessage, auditRequestParams, tranID);
                }else{
                    auditTrailObj.insertAuditLog(AuditAction.INVOICE_CREATED, "User " + paramJobj.optString(Constants.userfullname) + " has " + action + template + (isConsignment ? " Consignment Sales Invoice " : isFixedAsset ? " Asset Disposal Invoice " : " Customer Invoice ") + (istemplate!=2? invoiceNumBer:"") + JEmsg +linkingMessages + (pendingApprFlag == 1 ? " " + messageSource.getMessage("acc.field.whichispendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : "" ) + auditMessage, auditRequestParams, tranID);
                }
                if (!StringUtil.isNullOrEmpty(unlinkMessage)) {
                    auditTrailObj.insertAuditLog(action, "User " + paramJobj.optString(Constants.userfullname) + " has unlinked " + "Sales Invoice " + recId + unlinkMessage + ".", auditRequestParams, recId);
                }

            } else if (entryNumber != null) {
                auditTrailObj.insertAuditLog(AuditAction.CASH_SALES_CREATED, "User " + paramJobj.optString(Constants.userfullname) + " has " + action + template + " Cash Sales " + recId + (pendingApprFlag == 1 ? " " + messageSource.getMessage("acc.field.whichispendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : "") + auditMessage, auditRequestParams, tranID);
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("createAsTransactionChkbox", "")) && paramJobj.optString("createAsTransactionChkbox").equalsIgnoreCase("on") && !StringUtil.isNullOrEmpty(paramJobj.optString("templatename", ""))) {
                auditTrailObj.insertAuditLog(AuditAction.TEMPLATE_CREATED, "User " + paramJobj.optString(Constants.userfullname) + " has " + action + " Document Template "+paramJobj.optString("templatename", "")+ " for record "+ (cash ? "Cash Sales" :"Customer Invoice") , auditRequestParams, tranID);
            }
            issuccess = true;
            jobj.put("pendingApproval", pendingApprovalFlag);
            
            if(isFixedAsset && !isConsignment){
                channelName ="/FixedAssetDisposalInvoiceList/gridAutoRefresh";
            } else if(isLeaseFixedAsset && !isConsignment){
                channelName ="/LeaseInvoiceList/gridAutoRefresh";
            } else if(!(isFixedAsset || isLeaseFixedAsset || isConsignment)){//For normal CS and SI
                channelName ="/CustomerInvoiceAndCashSalesReport/gridAutoRefresh";
            }            
            txnManager.commit(status);
            
            /**
             * Commit tax to Avalara and save tax into database in case of Avalara Integration
             */
            if (extraCompanyPreferences.isAvalaraIntegration() && invoice != null && extraCompanyPreferences.getLineLevelTermFlag() == 1) {
                JSONObject paramsJobj = new JSONObject();
                paramsJobj.put(IntegrationConstants.integrationPartyIdKey, IntegrationConstants.integrationPartyId_AVALARA);
                paramsJobj.put(Constants.companyKey, companyid);
                /**
                 * Commit is to be done only if committing is enabled in Avalara integration settings and
                 * if invoice is neither draft, nor template, nor pending for approval
                 */
                boolean isCommit = integrationCommonService.isTaxCommittingEnabled(paramsJobj);
                isCommit = isCommit && (!invoice.isDraft() && (invoice.getIstemplate() != 2) && invoice.getApprovestatuslevel() == 11);
                if (integrationCommonService.isTaxCalculationEnabled(paramsJobj)) {
                    /**
                     * Commit taxes to Avalara and save taxes only if Tax Committing is enabled in System Controls
                     * If Tax Committing is disabled but Tax Calculation is enabled, then we only calculate the taxes again (without committing) to save
                     */
                    JSONObject tempJobj = commitTaxToAvalaraAndSave(paramJobj, invoice, id[0], invoiceNumBer, companyid, isEdit, msg, isCommit);
                    msg = tempJobj.optString(Constants.RES_msg, msg);
                } else {
                    msg += "<br><br><b>NOTE:</b> " + messageSource.getMessage("acc.integration.taxNotCommitted", null,  Locale.forLanguageTag(paramJobj.getString(Constants.language)));
            }
                }
            
            /*============Edit pending document code to prepare message and insert audit trial entry ===========  */ 
            
            if (isEditedPendingDocument) {
                                  
                String approvalMessage = "<ol style='list-style: inside none inside; padding: 5px;'>";
                String notAuthorisedMsg = "<ol style='list-style: inside none inside; padding: 5px;'>";
                String userMsg = "";
                String combineUseMsg = "";
                String notAuthorisedUserMsg = "";
                 String recurredInvoiceApproverID = "";

                /*-------If check "Send pending documents to next level" is activated from system preferences---------  */
                if (sendPendingDocumentsToNextLevel) {

                    if (roleName != "" && isAuthorityToApprove) {

                        // Audit log entry
                         action = "Cash Sales ";
                        String auditaction = AuditAction.CASH_SALES_APPROVED;
                        if (!inCash) {
                            action = "Customer Invoice ";
                            auditaction = AuditAction.CUSTOMERINVOICEAPPROVED;
                        }
                       

                        userMsg = roleName + " " + paramJobj.optString(Constants.userfullname) + " " + messageSource.getMessage("acc.field.transactionhasbeenapprovedsuccessfully", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)));
                        if (!StringUtil.isNullOrEmpty(recurredInvoiceApproverID)) {//check for recurring invoices
                            msg += "<li>" + messageSource.getMessage("acc.invapprovedsuccessfully", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " by " + roleName + " " + paramJobj.optString(Constants.userfullname) + "</li>";
                        } else {
                            /*Message binding as per approval transaction*/
                            approvalMessage += "<li>" + messageSource.getMessage("acc.field.Invoice", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + "<b> " + invoiceObj.getInvoiceNumber() + "</b> " + " at Level " + levelOnWhichDocumentIsApproved + "." + approvedJEMessage + "</li>";
                        }

                        auditTrailObj.insertAuditLog(auditaction, "User " + paramJobj.optString(Constants.userfullname) + " has Approved a " + action + invoiceObj.getInvoiceNumber() + approvedJENumber + " at Level-" + levelOnWhichDocumentIsApproved, auditRequestParams, invoiceObj.getID());

                        
                    } else if (!isAuthorityToApprove) {//If User have no authority to approve the document
                           notAuthorisedUserMsg = roleName + " " + paramJobj.optString(Constants.userfullname) + " " + messageSource.getMessage("acc.field.transactionsarenotapproved", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)));
                        if (!StringUtil.isNullOrEmpty(recurredInvoiceApproverID)) {
                            notAuthorisedMsg += "<li>" + messageSource.getMessage("acc.pendingrecurredinvoice.approver.notauthorizedmessage", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + "</li>";
                        } else {
                            /*Message binding as per user are not authorise to  approval transaction*/
                            notAuthorisedMsg += "<li>" + messageSource.getMessage("acc.field.Invoice", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + "<b> " + invoiceObj.getInvoiceNumber() + "</b> " + " at Level " + levelOnWhichDocumentIsApproved + "." + approvedJEMessage + "</li>";
                        }
                    }
                } else if (!isAuthorityToApprove) {//If user have no authority to approve document
                    approvalMessage += "<br>";
                    approvalMessage += messageSource.getMessage("acc.msgbox.YouarenotauthorizedtoapprovethisrecordatLevel", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + levelOnWhichDocumentIsApproved + " and record will be available at this level for approval" + ".";
                }

                approvalMessage += "</ol>";
                notAuthorisedMsg += "</ol>";
                approvalMessage = userMsg + approvalMessage;
                notAuthorisedMsg = notAuthorisedUserMsg + notAuthorisedMsg;
                combineUseMsg = approvalMessage + notAuthorisedMsg;
                msg += "</br>";
                msg += combineUseMsg;
            }

            status = txnManager.getTransaction(def);
            deleteJEArray(id[1], companyid);
            txnManager.commit(status);
            status = txnManager.getTransaction(def);
            deleteEditedInvoiceDiscount(discountArr, companyid);
            txnManager.commit(status);
            status = txnManager.getTransaction(def);
            deleteEntryInTemp(deleteparam);
            txnManager.commit(status);
        } catch (SessionExpiredException ex) {
            if (status != null) {
                txnManager.rollback(status);
            }
            deleteEntryInTemp(deleteparam);
            msg = ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ServiceException ex) {
            if (status != null) {
                txnManager.rollback(status);
            }
            deleteEntryInTemp(deleteparam);
            msg = ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }catch (AccountingException ex) {
            if (status != null) {
                txnManager.rollback(status);
            }
            deleteEntryInTemp(deleteparam);
            msg = "" + ex.getMessage();
            isAccountingExe=true;
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        }
        catch (Exception ex) {
            if (status != null) {
                txnManager.rollback(status);
            }
            deleteEntryInTemp(deleteparam);
            msg = "" + ex.getMessage();
            if(ex.getMessage()==null && ex.getCause() != null){
            msg = "" + ex.getCause().getMessage();
            }
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
                jobj.put("isAccountingExe", isAccountingExe);
                jobj.put("isDuplicateNoExe", isDuplicateNoExe);
                jobj.put("invid", invid);
                jobj.put("doid", deliveryOid);
                jobj.put("dono", billNo);
                jobj.put("doinvflag", doinvflag);
                jobj.put("inCash", inCash);
                jobj.put(Constants.channelName, channelName);
                jobj.put(Constants.isTaxDeactivated, isTaxDeactivated);

            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
       return jobj;
    }
  
    /**
     * Below method is executed only when Avalara Integration is enabled
     * This code voids previously committed taxes on Avalara in case of edit, then it commits new taxes to Avalara, 
     * and saves the tax details in database table TransactionDetailAvalaraTaxMapping
     * Finally the code updates the taxCommittedOnAvalara flag in Invoice table, which indicates whether or not taxes were successfully committed
     * @param paramJobj
     * @param invoice
     * @param invoiceId
     * @param invoiceNumber
     * @param companyid
     * @param isEdit
     * @param msg
     * @param isCommit - flag to indicate whether taxes are to be committed or not
     * @return 
     * @throws com.krawler.utils.json.base.JSONException 
     */
    @Override
    public JSONObject commitTaxToAvalaraAndSave(JSONObject paramJobj, Invoice invoice, String invoiceId, String invoiceNumber, String companyid, boolean isEdit, String msg, boolean isCommit) throws JSONException {
        JSONObject returnJobj = new JSONObject();
        boolean success = false;
        try {
            accountingHandlerDAOobj.flushHibernateSession();//Synchronize hibernate session with database, i.e. save unsaved changes into database
            accountingHandlerDAOobj.evictObj(invoice);//Remove current 'invoice' object from Hibernate session so that when we fetch invoice object again, we get latest record from database
            KwlReturnObject kwlObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceId);
            invoice = (Invoice) kwlObj.getEntityList().get(0);
            if (isEdit && invoice.isIsTaxCommittedOnAvalara()) {//Void previously committed tax in case of edit
                JSONObject cancelAvalaraTaxJobj = new JSONObject();
                cancelAvalaraTaxJobj.put("CancelCode", "DocDeleted");
                cancelAvalaraTaxJobj.put("DocCode", invoiceNumber);
                cancelAvalaraTaxJobj.put("moduleid", String.valueOf(Constants.Acc_Invoice_ModuleId));
                cancelAvalaraTaxJobj.put(IntegrationConstants.integrationPartyIdKey, IntegrationConstants.integrationPartyId_AVALARA);
                cancelAvalaraTaxJobj.put(Constants.companyKey, companyid);
                try {
                    cancelAvalaraTaxJobj.put(IntegrationConstants.integrationOperationIdKey, IntegrationConstants.avalara_cancelTax);
                    JSONObject cancelTaxResponseJobj = integrationCommonService.processIntegrationRequest(cancelAvalaraTaxJobj);
                    if (cancelTaxResponseJobj.optBoolean(Constants.RES_success, false)) {
                        /**
                         * if void tax request is successful, then update
                         * tax-commit flag in Invoice table Flag
                         * 'isTaxCommittedOnAvalara' indicates whether taxes are
                         * committed on Avalara side or not
                         */
                        cancelAvalaraTaxJobj = new JSONObject();
                        cancelAvalaraTaxJobj.put("invoiceid", invoice.getID());
                        cancelAvalaraTaxJobj.put("isTaxCommittedOnAvalara", false);
                        /**
                         * Adding below keys because these are mandatorily required by 'accInvoiceDAOobj.updateInvoice' method
                         * No changes are being made to these
                         */
                        cancelAvalaraTaxJobj.put("shipdate", invoice.getShipDate());
                        cancelAvalaraTaxJobj.put("approvalstatuslevel", invoice.getApprovestatuslevel());
                        cancelAvalaraTaxJobj.put("istemplate", invoice.getIstemplate());
                        cancelAvalaraTaxJobj.put("isDraft", invoice.isDraft());
                        accInvoiceDAOobj.updateInvoice(cancelAvalaraTaxJobj, null);
                    } else {
                        /**
                         * if void tax request failed, throw exception with
                         * failure message
                         */
                        throw new AccountingException(messageSource.getMessage("acc.integration.taxCommitFailureMsg1", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    }
                } catch (Exception ex) {
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                    String tempMsg = StringUtil.isNullOrEmpty(ex.getMessage()) ? messageSource.getMessage("acc.integration.taxCommitFailureMsg1", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : ex.getMessage();
                    throw new AccountingException(tempMsg);
                }
            }

            JSONObject avalaraSaveTaxJobj = createJsonFromInvoiceObject(paramJobj, invoice, invoiceId, invoiceNumber, invoice.getJournalEntry().getEntryDate(), companyid, isCommit);
            /**
             * Commit tax to Avalara and save in database
             */
            JSONObject taxCommitResponseJobj = integrationCommonService.commitAndSaveTax(avalaraSaveTaxJobj);
            
            /**
             * Update rowTaxAmount in invoice rows after tax commit this code is
             * required in case of cash sales import
             */
            HashSet details = new HashSet<InvoiceDetail>();
            JSONObject rowIdTaxAmountMappingJobj = taxCommitResponseJobj.optJSONObject("rowIdTaxAmountMapping");
            Set<InvoiceDetail> invoiceDetailsSet = invoice.getRows();
            for (InvoiceDetail invoiceDetail : invoiceDetailsSet) {
                String invoiceDetailId = invoiceDetail.getID();
                if (rowIdTaxAmountMappingJobj != null && rowIdTaxAmountMappingJobj.has(invoiceDetailId)) {
                    invoiceDetail.setRowTermAmount(rowIdTaxAmountMappingJobj.optDouble(invoiceDetailId));
                }
                details.add(invoiceDetail);
            }

            try {
                avalaraSaveTaxJobj = new JSONObject();
                avalaraSaveTaxJobj.put("invoiceid", invoice.getID());
                /**
                 * Adding below keys because these are mandatorily required by 'accInvoiceDAOobj.updateInvoice' method
                 * No changes are being made to these
                 */
                avalaraSaveTaxJobj.put("shipdate", invoice.getShipDate());
                avalaraSaveTaxJobj.put("approvalstatuslevel", invoice.getApprovestatuslevel());
                avalaraSaveTaxJobj.put("istemplate", invoice.getIstemplate());
                avalaraSaveTaxJobj.put("isDraft", invoice.isDraft());

                if (isCommit) {
                    boolean isCommitSuccessful = taxCommitResponseJobj.optBoolean(Constants.RES_success, false);
                    avalaraSaveTaxJobj.put("isTaxCommittedOnAvalara", isCommitSuccessful);
                }
                /**
                 * After committing taxes, update tax-commit flag in Invoice
                 * table Flag 'isTaxCommittedOnAvalara' indicates whether
                 * taxes were committed to Avalara successfully or not
                 * Also update tax amounts in invoice rows
                 */
                accInvoiceDAOobj.updateInvoice(avalaraSaveTaxJobj, details);
            } catch (Exception ex) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                throw new AccountingException(messageSource.getMessage("acc.integration.taxCommittedMsg", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
            }
            msg += "<br><br><b>NOTE:</b> " + taxCommitResponseJobj.optString(Constants.RES_msg);
            success = true;
        } catch (AccountingException ex) {
            msg += "<br><br><b>NOTE:</b> " + (StringUtil.isNullOrEmpty(ex.getMessage()) ? messageSource.getMessage("acc.integration.taxCommitFailureMsg", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : ex.getMessage());
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            msg += "<br><br><b>NOTE:</b> " + messageSource.getMessage("acc.integration.taxCommitFailureMsg", null, Locale.forLanguageTag(paramJobj.getString(Constants.language)));
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            returnJobj.put(Constants.RES_msg, msg);
            returnJobj.put(Constants.RES_success, success);
        }
        return returnJobj;
    }
    
    /**
     * Create JSON from Invoice Object for Avalara integration
     * Used only in Avalara integration
     * @param requestJobj
     * @param invoice
     * @param invoiceId
     * @param invoiceNumber
     * @param invoiceDate
     * @param companyid
     * @param isCommit
     * @return
     * @throws ServiceException
     * @throws JSONException
     * @throws AccountingException
     * @throws SessionExpiredException 
     */
    @Override
    public JSONObject createJsonFromInvoiceObject(JSONObject requestJobj, Invoice invoice, String invoiceId, String invoiceNumber, Date invoiceDate, String companyid, boolean isCommit) throws ServiceException, JSONException, AccountingException, SessionExpiredException {
        JSONObject returnJobj = new JSONObject();
        
        JSONObject lineDetailsJobj = createRowsJsonFromInvoiceObject(invoice);
        JSONArray lineDetailJarr = lineDetailsJobj.optJSONArray(Constants.detail);

        BillingShippingAddresses billingShippingAddresses = invoice.getBillingShippingAddresses();
        JSONObject addrObject = new JSONObject();
        if (billingShippingAddresses != null) {
            addrObject.put("address", billingShippingAddresses.getShippingAddress() != null ? billingShippingAddresses.getShippingAddress() : "");
            addrObject.put("city", billingShippingAddresses.getShippingCity() != null ? billingShippingAddresses.getShippingCity() : "");
            addrObject.put("state", billingShippingAddresses.getShippingState() != null ? billingShippingAddresses.getShippingState() : "");
            addrObject.put("country", billingShippingAddresses.getShippingCountry() != null ? billingShippingAddresses.getShippingCountry() : "");
            addrObject.put("postalCode", billingShippingAddresses.getShippingPostal() != null ? billingShippingAddresses.getShippingPostal() : "");
            addrObject.put("recipientName", billingShippingAddresses.getShippingRecipientName() != null ? billingShippingAddresses.getShippingRecipientName() : "");
        }

        returnJobj.put("jeNumber", invoice.getJournalEntry().getEntryNumber());
        returnJobj.put("journalentryId", invoice.getJournalEntry().getID());
        returnJobj.put(IntegrationConstants.shipToAddressForAvalara, addrObject.toString());
        returnJobj.put(Constants.detail, lineDetailJarr != null ? lineDetailJarr.toString() : "[]");
        returnJobj.put(IntegrationConstants.commit, isCommit);
        if (isCommit) {
            returnJobj.put(IntegrationConstants.avalaraDocCode, invoiceNumber);
        }
        //avalaraExemptionCode --> Value of 'AvaTax Exemption Code' dimension
        String avalaraExemptionCode = null;
        if (requestJobj.has(IntegrationConstants.avalaraExemptionCode)) {
            avalaraExemptionCode = requestJobj.getString(IntegrationConstants.avalaraExemptionCode);
        } else if (!StringUtil.isNullOrEmpty(requestJobj.optString(Constants.customfield, null))) {
            avalaraExemptionCode = integrationCommonService.getExemptionCodeFromCustomFieldsJson(requestJobj);
        } else {
            avalaraExemptionCode = integrationCommonService.getExemptionCodeFromRefModule(companyid, null, Constants.Acc_Invoice_ModuleId, invoiceId);
        }
        returnJobj.put(IntegrationConstants.avalaraExemptionCode, avalaraExemptionCode);
        returnJobj.put(Constants.billid, invoiceId);
        returnJobj.put(Constants.billno, invoiceNumber);
        returnJobj.put(Constants.BillDate, authHandler.getDateOnlyFormat().format(invoiceDate));
        /**
         * ERM - 294
         * Pass base currency code for Avalara Integration
         */
        String baseCurrencyId = requestJobj.optString("gcurrencyid");
        KwlReturnObject kwlObj = accountingHandlerDAOobj.getObject(KWLCurrency.class.getName(), baseCurrencyId);
        KWLCurrency baseCurrency = (KWLCurrency) kwlObj.getEntityList().get(0);
        String baseCurrencyCode = baseCurrency != null ? baseCurrency.getCurrencyCode() : "USD";
        returnJobj.put("baseCurrencyCode", baseCurrencyCode);
        returnJobj.put(Constants.currencyKey, invoice.getCurrency() != null ? invoice.getCurrency().getCurrencyID() : null);
        returnJobj.put("currencyCode", invoice.getCurrency() != null ? invoice.getCurrency().getCurrencyCode() : null);
        double exchangeRate = invoice.getExternalCurrencyRate() != 0 ? (1.0d / invoice.getExternalCurrencyRate()) : (invoice.getExchangeRateDetail() != null ? invoice.getExchangeRateDetail().getForeignToBaseExchangeRate() : 0);
        returnJobj.put("exchangeRate", exchangeRate != 0 ? exchangeRate : null);
        returnJobj.put(Constants.customerid, invoice.getCustomer().getID());
        returnJobj.put("customerCode", invoice.getCustomer().getAcccode());
        returnJobj.put("salesPersonCode", invoice.getMasterSalesPerson() != null ? invoice.getMasterSalesPerson().getCode() : "");
        returnJobj.put("salespersonid", invoice.getMasterSalesPerson() != null ? invoice.getMasterSalesPerson().getID() : "");
        returnJobj.put(Constants.moduleid, String.valueOf(Constants.Acc_Invoice_ModuleId));
        returnJobj.put(IntegrationConstants.integrationPartyIdKey, IntegrationConstants.integrationPartyId_AVALARA);
        returnJobj.put(Constants.companyKey, companyid);
        return returnJobj;
    }
    
    private JSONObject createRowsJsonFromInvoiceObject(Invoice invoice) throws ServiceException, JSONException, AccountingException {
        JSONObject returnJobj = new JSONObject();
        JSONArray lineDetailJarr = new JSONArray();
        Set<InvoiceDetail> invoiceDetailsSet = invoice.getRows();
        for (InvoiceDetail row : invoiceDetailsSet) {
            if (row.getInventory() != null) {
                JSONObject lineDetailjobj = new JSONObject();
                lineDetailjobj.put(Constants.productid, row.getInventory().getProduct().getID());
                lineDetailjobj.put("pid", row.getInventory().getProduct().getProductid());
                lineDetailjobj.put("desc", row.getDescription());
                double quantity = row.getInventory().getQuantity();
                lineDetailjobj.put(Constants.quantity, quantity);
                double amountwithouttax = row.getRowExcludingGstAmount();
                if (amountwithouttax == 0) {
                    double rate = row.getRate();
                    Discount discount = row.getDiscount();
                    double discountAmount = discount != null ? discount.getDiscountValue() : 0;
                    amountwithouttax = (rate * quantity) - discountAmount;
                }
                lineDetailjobj.put("amountwithouttax", amountwithouttax);
                lineDetailjobj.put(IntegrationConstants.parentRecordID, row.getID());
                lineDetailjobj.put("journalentryId", invoice.getJournalEntry().getID());
                lineDetailJarr.put(lineDetailjobj);
            }
        }
        returnJobj.put(Constants.detail, lineDetailJarr);
        return returnJobj;
    }
    
 /*Saving of Line Items Details*/   
 public List saveInvoiceJsonNew(JSONObject paramJobj, Map<Integer,List<String>> invDetailTermMap) throws ServiceException, AccountingException, SessionExpiredException, UnsupportedEncodingException {
        String id = null;
        List ll = new ArrayList();
        String jeentryNumber = "";
        String jeSeqFormatId = "";
        String jeIntegerPart = "";
        String jeDatePrefix = "";
        String jeDateAfterPrefix = "";
        String jeDateSuffix = "";
        Invoice invoice = null;
        DeliveryOrder doObj = null;
        ArrayList discountArr = new ArrayList();
        String oldjeid = null;
        String invoiceid = null;
        String repeatedid = null;
        int intervalUnit = 0;
        String intervalType = null;
        Date sdate = null;
        Date nextdate = null;
        Date expdate = null;
        int noOfInvPost = 0;
        int noOfInvRemainPost = 0;
        List mailParams=null;
        String unlinkMessage="";
        String currencyid = null;
        String entryNumber = null;
        String custId = null;
        String porefnumber = null;
        String termid = null;
        String salesPerson = null;
        String methodid = null,dueDate=null;
        boolean gstIncluded =false ; 
        boolean hasRepeatInvoice = false;
        try {
            int istemplate = paramJobj.optString("istemplate",null) != null ? Integer.parseInt(paramJobj.optString("istemplate")) : 0;
            KwlReturnObject result = null;
            String sequenceformat = paramJobj.optString("sequenceformat",null);
            int nocount;
            HashMap<String, Object> requestParams = AccountingManager.getGlobalParamsJson(paramJobj);
            DateFormat df = authHandler.getDateOnlyFormat();           
            String companyid =paramJobj.getString(Constants.companyKey);
            String deliveryOrderid = paramJobj.optString("doid",null);
            
            /* Mobile Application*/
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                custId = (paramJobj.has("CustomerName") && paramJobj.get("CustomerName") != null) ? paramJobj.getString("CustomerName") : null;
                currencyid = paramJobj.optString(Constants.currencyName, null);
                entryNumber = paramJobj.optString("invoiceNumber", "");
                porefnumber = paramJobj.optString("poRefNumber", null);
                termid = (paramJobj.has("terms") && paramJobj.get("terms") != null) ? paramJobj.getString("terms") : null;
                salesPerson = paramJobj.optString(Constants.salesperson, null);
                invoiceid = (paramJobj.has(Constants.billid) && paramJobj.get(Constants.billid) != null) ? paramJobj.getString(Constants.billid) : null;
                gstIncluded = (StringUtil.isNullOrEmpty(paramJobj.optString("gstIncluded", null))) ? false : Boolean.parseBoolean(paramJobj.getString("gstIncluded"));
                methodid=paramJobj.optString("paymentmethodid", null);
                dueDate= paramJobj.optString("dueDate",null)!=null?paramJobj.optString("dueDate"):paramJobj.optString(Constants.BillDate);
            } else {
                custId = paramJobj.optString("customer",null);
                currencyid = (paramJobj.optString(Constants.currencyKey, null) == null ? paramJobj.optString(Constants.globalCurrencyKey) : paramJobj.optString(Constants.currencyKey));
                entryNumber = paramJobj.optString("number",null);
                porefnumber = paramJobj.optString("porefno",null)==null?"":paramJobj.optString("porefno");
                termid =  paramJobj.optString("termid",null);
                salesPerson = paramJobj.optString("salesPerson",null)==null?"":paramJobj.optString("salesPerson");
                invoiceid = paramJobj.optString("invoiceid",null);
                gstIncluded = paramJobj.optString("includingGST",null) == null ? false : Boolean.parseBoolean(paramJobj.optString("includingGST"));
                methodid = paramJobj.optString("pmtmethod",null)!=null?paramJobj.optString("pmtmethod"):"";
                dueDate=paramJobj.optString(InvoiceConstants.duedate);
            }
            
            recId = invoiceid;
            String shipLength = paramJobj.optString("shipLength",null);
            double gstCurrencyRate = paramJobj.optString("gstCurrencyRate",null)!=null?Double.parseDouble(paramJobj.getString("gstCurrencyRate")):0.0;
            String invoicetype = paramJobj.optString("invoicetype",null);
            String jeid = null;
            String transactionDateStr = paramJobj.optString("billdate");
            Date transactionDate = df.parse(df.format(new Date()));
            if (!StringUtil.isNullOrEmpty(transactionDateStr)) {
                transactionDate = df.parse(transactionDateStr);
            }
            Customer customer = null;
            PayDetail paydetail = null;
            String auditMessage="";
            boolean isFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isFixedAsset",null))) ? Boolean.parseBoolean(paramJobj.optString("isFixedAsset")) : false;
            boolean isInvoiceLinkedWithTaxAppliedDO = (!StringUtil.isNullOrEmpty(paramJobj.optString("isInvoiceLinkedWithTaxAppliedDO",null))) ? Boolean.parseBoolean(paramJobj.optString("isInvoiceLinkedWithTaxAppliedDO")) : false;
            boolean isLeaseFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isLeaseFixedAsset",null))) ? Boolean.parseBoolean(paramJobj.optString("isLeaseFixedAsset")) : false;
            boolean isConsignment = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment,null))) ? Boolean.parseBoolean(paramJobj.optString(Constants.isConsignment)) : false;
            boolean RCMApplicable = false;
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("GTAApplicable", null))) {
                RCMApplicable = paramJobj.optBoolean("GTAApplicable", false);
            }
            boolean iscash = StringUtil.isNullOrEmpty(paramJobj.optString("incash",null)) ? false : Boolean.parseBoolean(paramJobj.optString("incash"));
            boolean isEdit = StringUtil.isNullOrEmpty(paramJobj.optString("isEdit",null)) ? false : Boolean.parseBoolean(paramJobj.optString("isEdit"));
            boolean isCopy = StringUtil.isNullOrEmpty(paramJobj.optString("copyInv",null)) ? false : Boolean.parseBoolean(paramJobj.optString("copyInv"));
            boolean isDraft = (!StringUtil.isNullOrEmpty(paramJobj.optString("isDraft",null))) ? Boolean.parseBoolean(paramJobj.optString("isDraft")) : false;
            boolean isSaveDraftRecord = (!StringUtil.isNullOrEmpty(paramJobj.optString("isSaveDraftRecord", null))) ? Boolean.parseBoolean(paramJobj.getString("isSaveDraftRecord")) : false; //SDP-13487
            boolean isAutoSeqForEmptyDraft = (!StringUtil.isNullOrEmpty(paramJobj.optString("isAutoSeqForEmptyDraft", null))) ? Boolean.parseBoolean(paramJobj.getString("isAutoSeqForEmptyDraft")) : false; //SDP-13927 : If Draft already having sequence no. then do not update it
            boolean isSequenceFormatChangedInEdit = (!StringUtil.isNullOrEmpty(paramJobj.optString("isSequenceFormatChangedInEdit", null))) ? Boolean.parseBoolean(paramJobj.getString("isSequenceFormatChangedInEdit")) : false; //SDP-13927 : If Draft already having sequence no. then do not update it
            
            boolean isAllowToEdit = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.IS_INVOICE_ALLOW_TO_EDIT,null))) ? Boolean.parseBoolean(paramJobj.optString(Constants.IS_INVOICE_ALLOW_TO_EDIT)) : false;
            boolean includeProductTax = StringUtil.isNullOrEmpty(paramJobj.optString("includeprotax",null)) ? false : Boolean.parseBoolean(paramJobj.optString("includeprotax"));
            boolean isdropshipchecked = paramJobj.optString("isdropshipchecked",null) != null ? Boolean.parseBoolean(paramJobj.getString("isdropshipchecked")) : false;
            boolean isRoundingAdjustmentApplied = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.IsRoundingAdjustmentApplied, null))) ? Boolean.parseBoolean(paramJobj.getString(Constants.IsRoundingAdjustmentApplied)) : false;
            boolean isEditedPendingDocument = StringUtil.isNullOrEmpty(paramJobj.optString("isEditedPendingDocument",null)) ? false : Boolean.parseBoolean(paramJobj.optString("isEditedPendingDocument"));
            int generatedSource = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.generatedSource,null))) ?Integer.parseInt(paramJobj.optString(Constants.generatedSource,Constants.RECORD_WEB_Application))  : Integer.parseInt(Constants.RECORD_WEB_Application);
            String currentUser = paramJobj.optString(Constants.useridKey);
            boolean isExicseOpeningbalance = false;
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isExicseOpeningbalance"))) {
                isExicseOpeningbalance = Boolean.parseBoolean(paramJobj.optString("isExicseOpeningbalance"));
            }
            boolean isContractMapping = false;  //For Recurring Lease Sales Invoice
            String custWarehouse = paramJobj.optString("custWarehouse",null);
            String movementtype = paramJobj.optString("movementtype",null);
            String formtype = paramJobj.optString("formtypeid",null);
            String excisetypeid = !StringUtil.isNullOrEmpty(paramJobj.optString("excisetypeid",null))? paramJobj.optString("excisetypeid") : null;
            
            boolean partialInvoice = (paramJobj.optString("partialinv",null) != null) ? Boolean.parseBoolean(paramJobj.optString("partialinv")) : false;
            
            String deletedLinkedDocumentID = paramJobj.optString("deletedLinkedDocumentId",null);
            String moduleTemplateId = paramJobj.optString("moduletemplateid",null);
            String accountid = custId;
            KwlReturnObject custresult = null;
            if (!StringUtil.isNullOrEmpty(custId)) {
                custresult = accountingHandlerDAOobj.getObject(Customer.class.getName(), custId);
                customer = (Customer) custresult.getEntityList().get(0);
                
                //When customer id is passed from CRM, the customer may or may not be present
                if (customer == null) {
                    JSONObject response = StringUtil.getErrorResponse("acc.common.erp34", paramJobj, "Customer is not present on Accounting Side.", messageSource);
                    throw ServiceException.FAILURE(response.optString(Constants.RES_MESSAGE), "", false);
                }
                
                if (customer.getAccount() != null) {
                    accountid = customer.getAccount().getID();
                }
            }
            boolean isExciseInvoice = false;
            Invoice originalInvoice=null;
            
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("originalInvoiceId",null))) {
                KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), paramJobj.optString("originalInvoiceId",null));
                originalInvoice = (Invoice) invObj.getEntityList().get(0);
            }
            
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isExciseInvoice",null))) {
                isExciseInvoice = Boolean.parseBoolean(paramJobj.optString("isExciseInvoice"));
            }
            String defaultnatureofpurchase = "";
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("defaultnatureofpurchase",null))) {
                defaultnatureofpurchase = paramJobj.optString("defaultnatureofpurchase");
            }
            String createdby = paramJobj.optString(Constants.useridKey);
            String modifiedby = paramJobj.optString(Constants.useridKey);
            /*
             * isJobWorkOutRemain is true if sales invoice is creating from Aged order work report.
             */
            boolean isjobWorkWitoutGrn=Boolean.parseBoolean(paramJobj.optString("isjobworkwitoutgrn"));
            long createdon = System.currentTimeMillis();
            long updatedon = System.currentTimeMillis();

            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0);
            boolean isApplyTaxToTerms = paramJobj.optBoolean(Constants.isApplyTaxToTerms,false);
            String compids[] = Constants.Companyids_Chkl_And_Marubishi.split(",");
            boolean isFromChklorMarubishi = false;
            for (int cnt = 0; cnt < compids.length; cnt++) {
                String compid = compids[cnt];
                if (compid.equalsIgnoreCase(companyid)) {
                    isFromChklorMarubishi = true;
                }
            }
            /**
             * If Avalara Integration is enabled and tax calculation in Avalara Integration is enabled
             * then we make below method call which creates and adds tax details in requestJson
             * This is used when transaction is created by means other than UI; for example import, REST etc
             */
            if (extraCompanyPreferences != null && extraCompanyPreferences.isAvalaraIntegration()) {
                JSONObject paramsJobj = new JSONObject();
                paramsJobj.put(IntegrationConstants.integrationPartyIdKey, IntegrationConstants.integrationPartyId_AVALARA);
                paramsJobj.put(Constants.companyKey, companyid);
                if (integrationCommonService.isTaxCalculationEnabled(paramsJobj)) {
                    paramJobj = integrationCommonService.createAvalaraTaxDetails(paramJobj, Constants.Acc_Invoice_ModuleId);
                }
            }
            String customfield = (paramJobj.has(Constants.customfield) && paramJobj.get(Constants.customfield) != null) ? paramJobj.getString(Constants.customfield) : null;
            
            KwlReturnObject capresult = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) capresult.getEntityList().get(0);
            if (!StringUtil.isNullOrEmpty(invoiceid)) {
                KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                invoice = (Invoice) invObj.getEntityList().get(0);
                tranID = invoice.getID();
                oldjeid = invoice.getJournalEntry().getID();
                paydetail=invoice.getPayDetail();
                /*
                 * Taking original account in edit and copy Invoice. Refer
                 * SDP-7867.
                 */
                //While editing invoice if customer is changed then take account of new Customer.
                if (invoice.getCustomerEntry() != null && invoice.getCustomer() != null && customer.getID().equals(invoice.getCustomer().getID())) {
                    accountid = invoice.getCustomerEntry().getAccount().getID();
                }
                
                HashMap<String, Object> badMaps = new HashMap<String, Object>();
                badMaps.put(Constants.companyKey,companyid);
                badMaps.put("invoiceid",invoiceid);
                
                KwlReturnObject badDebtMapResult = accInvoiceDAOobj.getBadDebtInvoiceMappingForInvoice(badMaps);
                List mapList = badDebtMapResult.getEntityList();
                if (!mapList.isEmpty()) {
                    throw new AccountingException("This invoice has been claimed so it cannot be edit");
                }
                if (!isAllowToEdit) { // invoice/cash sales allowed to edit
                    result = accInvoiceDAOobj.getDOFromInvoice(invoice.getID(), companyid);
                    if (result.getEntityList().size() > 0) {
                        DeliveryOrderDetail deliveryOrderDetailObj = (DeliveryOrderDetail) result.getEntityList().get(0);
                        if (deliveryOrderDetailObj != null && isEdit) {
                            throw new AccountingException("Cannot Edit Invoice as it is or was already used in Delivery Order.");
                        }
                    }
                    result = accInvoiceDAOobj.getDebitNoteLinkedWithInvoice(invoice.getID(), companyid);
                     if (result.getEntityList().size() > 0 && isEdit) {
                            throw new AccountingException("Cannot Edit Invoice as it is or was already used in Debit Note.");
                    }
                }
                Map<String, Object> addressParams = new HashMap<String, Object>();
                String billingAddress = paramJobj.optString(Constants.BILLING_ADDRESS,null);
                if (!StringUtil.isNullOrEmpty(billingAddress)) {
//                    addressParams = AccountingAddressManager.getAddressParams(request,false);
                    addressParams = AccountingAddressManager.getAddressParamsJson(paramJobj,false);
                } else {//handling the cases when no address coming in edit case 
                    addressParams = AccountingAddressManager.getDefaultCustomerAddressParams(customer.getID(), companyid, accountingHandlerDAOobj);// addressParams = getCustomerDefaultAddressParams(customer,companyid);
                }
                BillingShippingAddresses bsa = invoice.getBillingShippingAddresses();//used to update billing shipping addresses
                addressParams.put("id", bsa != null ? bsa.getID() : "");
                KwlReturnObject addressresult = accountingHandlerDAOobj.saveAddressDetail(addressParams, companyid);
                bsa = (BillingShippingAddresses) addressresult.getEntityList().get(0);
                String addressid = bsa.getID();

                                //Delete Goods Receipt Order Details Term Map  While Update time ... 
                if (extraCompanyPreferences.getLineLevelTermFlag()==1) {
                    if (isEdit) {
                        if (extraCompanyPreferences.isAvalaraIntegration()) {
                            //delete tax details from TransactionDetailAvalaraTaxMapping table when Avalara Integration is enabled
                            deleteAvalaraTaxMappingForInvoice(invoiceid, companyid);
                        } else {
                            KwlReturnObject venresult = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                            Invoice tempInvoice = (Invoice) venresult.getEntityList().get(0);
                            Set<InvoiceDetail> invoiceDetailsobj = tempInvoice.getRows();
                            for (InvoiceDetail temObj : invoiceDetailsobj) {
                                accInvoiceDAOobj.deleteInvoiceDetailsTermMap(temObj.getID());
                            }
                        }
                    } 
                } 

                // delete asset details
                if (invoice.isFixedAssetInvoice() || invoice.isFixedAssetLeaseInvoice()) {
                    boolean updateFlag=false;
                    deleteAssetDetails(invoice, companyid,updateFlag);
                }

                deleteInvoiceContractMappings(invoice, companyid);

                result = accInvoiceDAOobj.getInvoiceInventory(invoiceid);
                //deleting Delivery order row
                if (!StringUtil.isNullOrEmpty(deliveryOrderid)) {
                    
                     // UPDATE THE SO BALANCE QTY - BEFORE EDITING AUTO DO (REF SDP-6947)
                    List<DeliveryOrderDetail> dodetails = Collections.EMPTY_LIST;
                    HashMap<String, Object> doRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList();
                    filter_names.add("deliveryOrder.ID");
                    filter_params.add(deliveryOrderid);
                    doRequestParams.put(Constants.filterNamesKey, filter_names);
                    doRequestParams.put(Constants.filterParamsKey, filter_params);
                    KwlReturnObject podresult = accInvoiceDAOobj.getDeliveryOrderDetails(doRequestParams);
                    dodetails = podresult.getEntityList();
                    if (dodetails != null && !dodetails.isEmpty()) { //update balance quantity to po when creating gr link to pi and pi link to po
                        for (DeliveryOrderDetail cnt : dodetails) {
                            if (cnt.getCidetails() != null && cnt.getCidetails().getSalesorderdetail() != null) {
                                KwlReturnObject Autordresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), cnt.getCidetails().getSalesorderdetail().getID());
                                SalesOrderDetail salesorderdetails = (SalesOrderDetail) Autordresult.getEntityList().get(0);
                                HashMap soMap = new HashMap();
                                soMap.put("sodetails", salesorderdetails.getID());
                                soMap.put(Constants.companyKey, salesorderdetails.getCompany().getCompanyID());
                                soMap.put("balanceqty", cnt.getDeliveredQuantity());
                                soMap.put("add", true);
                                accCommonTablesDAO.updateSalesorderOrderStatus(soMap);
                            }
                        }
                    }
                    
                    KwlReturnObject DOObj = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), deliveryOrderid);
                    doObj = (DeliveryOrder) DOObj.getEntityList().get(0);
                    paramJobj.put("DOSeqNum", doObj.getSeqnumber());
                    paramJobj.put(Constants.DATEPREFIX, doObj.getDatePreffixValue());
                    paramJobj.put(Constants.DATESUFFIX, doObj.getDateSuffixValue());
                    HashMap<String, Object> DeliveryorderMap = new HashMap<String, Object>();
                    DeliveryorderMap.put("doid", deliveryOrderid);
                    DeliveryorderMap.put(Constants.companyKey, companyid);
                    if (isAllowToEdit) {
                        accInvoiceDAOobj.deleteLinkingInformationOfDO(DeliveryorderMap);
                    }
                    accInvoiceDAOobj.updateSOBalanceQtyAfterDO(deliveryOrderid, "", companyid);
                    accInvoiceDAOobj.deleteDeliveryOrdersBatchSerialDetails(DeliveryorderMap);  
                    stockMovementService.removeStockMovementByReferenceId(doObj.getCompany(),deliveryOrderid);
                    DeliveryorderMap.put("isMRPModuleActivated",extraCompanyPreferences.isActivateMRPModule());
                    requestParams.put("isPerpetualValuationActivated", (preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD));
                    DeliveryorderMap.put("isPerpetualValuationActivated", (preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD));
                    if (extraCompanyPreferences != null && !extraCompanyPreferences.isPickpackship() && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) {
                        if (doObj.getInventoryJE() != null) { // delete inventory JE
                            JournalEntry inventoryJE = doObj.getInventoryJE();
                            DeliveryorderMap.put("inventoryjeid", inventoryJE.getID());
                        }
                    }
                    /**
                     * If the pick pack flow is on passing additional fields including DO status for handling pick pack function below.
                     */
                    if (extraCompanyPreferences != null && extraCompanyPreferences.isPickpackship() && !isConsignment && !isFixedAsset && !isLeaseFixedAsset) {
                        String dostatus = doObj.getStatus() != null ? doObj.getStatus().getValue() : "";
                        DeliveryorderMap.put("isPickPackShipOn", extraCompanyPreferences.isPickpackship());
                        DeliveryorderMap.put("status", dostatus);
                    }
                    accInvoiceDAOobj.deleteDeliveryOrdersPermanent(DeliveryorderMap);
                }
                HashMap<String, Object> invoicerequestParams = new HashMap<String, Object>();
                invoicerequestParams.put("invoiceid", invoiceid);
                invoicerequestParams.put(Constants.companyKey, companyid);
                //deleting invoice row
                if (isConsignment) {
                    accInvoiceDAOobj.deleteInvoicesBatchSerialDetails(invoicerequestParams);
                }
                    accInvoiceDAOobj.deleteInvoiceDtails(invoiceid, companyid);
                List list = result.getEntityList();
                Iterator itr = list.iterator();
                while (itr.hasNext()) {
                    String inventoryid = (String) itr.next();
                    accProductObj.deleteInventory(inventoryid, companyid);
                }

                ////Deleting all Invoice Detail discount
                result = accInvoiceDAOobj.getInvoiceDetailsDiscount(invoiceid);
                list = result.getEntityList();
                itr = list.iterator();
                while (itr.hasNext()) {
                    String discountid = (String) itr.next();
                    if (StringUtil.isNullOrEmpty(discountid)) {
                        discountArr.add(discountid);
                    }
                }
                String discountid = (invoice.getDiscount() == null ? null : invoice.getDiscount().getID());
                invoice.setDiscount(null);
                if (StringUtil.isNullOrEmpty(discountid)) {
                    discountArr.add(discountid);
                }

                ////Deleting Invoice Detail Journalentry Detail
                String nl = null;
                HashMap<String, Object> dataMap = new HashMap<String, Object>();
                
                dataMap.put("termid", termid);
                dataMap.put("invoiceid", invoiceid);
                if (!StringUtil.isNullOrEmpty(shipLength)) {
                    dataMap.put("shipLength", shipLength);
                }
                dataMap.put("gstCurrencyRate", gstCurrencyRate);
                
                dataMap.put("invoicetype", invoicetype);
                dataMap.put("otherentryid", nl);
                dataMap.put("shipentryid", nl);
                dataMap.put("taxid", nl);
                dataMap.put("taxentryid", nl);
                dataMap.put("creationDate", transactionDate);
                dataMap.put("customerentryid", nl);
                dataMap.put(Constants.RoundingAdjustmentEntryID, nl);
                dataMap.put("accountid", accountid);
                dataMap.put("createdby", createdby);
                dataMap.put("modifiedby", modifiedby);
                dataMap.put("createdon", createdon);
                dataMap.put("updatedon", updatedon);
                dataMap.put("incash", paramJobj.optString("incash",null));
                dataMap.put("billshipAddressid", addressid);
                dataMap.put("isExciseInvoice", isExciseInvoice);
                if (isdropshipchecked) {
                    dataMap.put("isdropshipchecked", isdropshipchecked);
                }
                dataMap.put(Constants.isApplyTaxToTerms, paramJobj.optBoolean(Constants.isApplyTaxToTerms,false));
                if (!isEdit) {
                    dataMap.put(Constants.generatedSource, generatedSource);
                }
                if (!StringUtil.isNullOrEmpty(moduleTemplateId)) {
                    dataMap.put("moduletemplateid", moduleTemplateId);
                }
                /**
                 * ERP-32829 
                 */
                Country country = extraCompanyPreferences.getCompany().getCountry();
                if (extraCompanyPreferences.isIsNewGST()) {
                    dataMap.put("gstapplicable", paramJobj.optBoolean("GSTApplicable", false));
                    dataMap.put(Constants.isMerchantExporter, paramJobj.optBoolean(Constants.isMerchantExporter, false));
                }
                dataMap.put(Constants.additionalMemo,paramJobj.optString(Constants.additionalMemo,""));
                KwlReturnObject uresult = accInvoiceDAOobj.saveInvoice(dataMap);
                invoice = (Invoice) uresult.getEntityList().get(0);      
                RepeatedInvoices rp = (RepeatedInvoices)invoice.getRepeateInvoice();
                if(rp != null && isLeaseFixedAsset && isEdit){   //Recurring in Edit case
                    hasRepeatInvoice = true;
                    repeatedid = rp.getId();
                    intervalUnit = rp.getIntervalUnit();
                    intervalType = rp.getIntervalType();
                    sdate = rp.getStartDate();
                    nextdate = rp.getNextDate();
                    expdate = rp.getExpireDate();
                    noOfInvPost = rp.getNoOfInvoicespost();
                    noOfInvRemainPost = rp.getNoOfRemainInvoicespost();
                    paramJobj.put("hasRepeatInvoice", hasRepeatInvoice);
                }
                JournalEntry jetemp = invoice.getJournalEntry();
                if (jetemp != null) {
                    jeentryNumber = jetemp.getEntryNumber(); //preserving these data to generate same JE number in edit case                    
                    jeSeqFormatId = jetemp.getSeqformat() == null ? "" : jetemp.getSeqformat().getID();
                    jeIntegerPart = String.valueOf(jetemp.getSeqnumber());
                    jeDatePrefix = jetemp.getDatePreffixValue();
                    jeDateAfterPrefix = jetemp.getDateAfterPreffixValue();
                    jeDateSuffix = jetemp.getDateSuffixValue();
                }

                //Delete old entries and insert new entries again from optimized table in edit case.
                accJournalEntryobj.deleteOnEditAccountJEs_optimized(oldjeid);
                deleteJEDetailsCustomData(oldjeid);

                // Delete Invoice Term Map
                HashMap<String, Object> termReqMap = new HashMap<String, Object>();
                termReqMap.put("invoiceid", invoiceid);
                accInvoiceDAOobj.deleteInvoiceTermMap(termReqMap);
                
                /* Deleting Linking information of Purchase Invoice during Editing Purchase Invoice*/
                termReqMap.put("invoiceid", invoiceid);
                accInvoiceDAOobj.deleteLinkingInformationOfSI(termReqMap);//Deleting linking information 
                
                /* Updating Isopen Flag=0 & Linkflag=0 of SO, CQ & DO during Editing Purchase Invoice*/
                if (!StringUtil.isNullOrEmpty(deletedLinkedDocumentID)) {
                    String[] deletedLinkedDocumentIDArr = deletedLinkedDocumentID.split(",");
                    for (int i = 0; i < deletedLinkedDocumentIDArr.length; i++) {
                        KwlReturnObject venresult = accountingHandlerDAOobj.getObject(Quotation.class.getName(), deletedLinkedDocumentIDArr[i]);
                        Quotation quotation = (Quotation) venresult.getEntityList().get(0);
                        if (quotation != null) {
                            termReqMap.put("isOpen", true);
                            termReqMap.put("quotation", quotation);
                            termReqMap.put("value", "0");
                            accInvoiceDAOobj.updateQuotationLinkflag(termReqMap);
                            /* Preparing audit trial message while unlinking document through Edit*/
                            if (i == 0) {
                                unlinkMessage += " from the Customer Quotation(s) ";
                            }
                            if (unlinkMessage.indexOf(quotation.getQuotationNumber()) == -1) {
                                unlinkMessage += quotation.getQuotationNumber() + ", ";
                            }
                        } else {
                            venresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), deletedLinkedDocumentIDArr[i]);
                            SalesOrder salesorder = (SalesOrder) venresult.getEntityList().get(0);
                            if (salesorder != null) {

                                termReqMap.put("salesOrder", salesorder);
                                termReqMap.put("value", "0");
                                termReqMap.put("isSOOpen", true);
                                accInvoiceDAOobj.updateSOLinkflag(termReqMap);
                                /* Preparing audit trial message while unlinking document through Edit*/
                                if (i == 0) {
                                    unlinkMessage += " from the Sales Order(s) ";
                                }
                                if (unlinkMessage.indexOf(salesorder.getSalesOrderNumber()) == -1) {
                                    unlinkMessage += salesorder.getSalesOrderNumber() + ", ";
                                }
                            } else {
                                venresult = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), deletedLinkedDocumentIDArr[i]);
                                DeliveryOrder deliveryOrder = (DeliveryOrder) venresult.getEntityList().get(0);
                                termReqMap.put("isOpen", true);
                                termReqMap.put("deliveryOrder", deliveryOrder);
                                accInvoiceDAOobj.updateDeliveryOrderStatus(termReqMap);
                                /* Preparing audit trial message while unlinking document through Edit*/
                                if (i == 0) {
                                    unlinkMessage += " from the Delivery Order(s) ";
                                }
                                if (unlinkMessage.indexOf(deliveryOrder.getDeliveryOrderNumber()) == -1) {
                                    unlinkMessage += deliveryOrder.getDeliveryOrderNumber() + ", ";
                                }
                            }
                        }
                    }
                }
                if (!StringUtil.isNullOrEmpty(unlinkMessage) && unlinkMessage.endsWith(", ")) {
                    unlinkMessage = unlinkMessage.substring(0, unlinkMessage.length() - 2);
                }

            } else if (isCopy) {
                /*
                 * Taking original account in edit and copy Invoice. Refer
                 * SDP-7867
                 */
                String oldInvoiceId = paramJobj.optString(Constants.billid, "");
                KwlReturnObject invObj = accountingHandlerDAOobj.getObject(Invoice.class.getName(), oldInvoiceId);
                invoice = (Invoice) invObj.getEntityList().get(0);

                //While copying invoice if customer is changed then take account of new Customer.
                if (invoice != null && invoice.getCustomerEntry() != null && invoice.getCustomer() != null && customer.getID().equals(invoice.getCustomer().getID())) {
                    accountid = invoice.getCustomerEntry().getAccount().getID();
                }
            }
//            String taxid = paramJobj.optString("taxid",null);
            String taxid = "";
            if (paramJobj.optString("taxid").equalsIgnoreCase("None")) {
                taxid = null;
            } else {
                taxid = paramJobj.optString("taxid", null);
            }
            String costCenterId = paramJobj.optString("costcenter",null);
            String customerBankAccountTypeId = paramJobj.optString("customerbankaccounttype",null);
            KwlReturnObject cmp = accountingHandlerDAOobj.getObject(Company.class.getName(), companyid);
            Company company = (Company) cmp.getEntityList().get(0);
            int countryid = company.getCountry() != null ? Integer.parseInt(company.getCountry().getID()) : 0;
            
            double taxamount = 0.0d;
            if(extraCompanyPreferences.getLineLevelTermFlag()!=1){ // Fo Indian company GST Tax is not consider only Term as tax
                taxamount=StringUtil.getDouble(paramJobj.optString("taxamount","0.0"));
            }
            double externalCurrencyRate = StringUtil.getDouble(paramJobj.optString("externalcurrencyrate","1"));
            Discount discount = null;
            double discValue = 0.0;
            double shippingCharges = StringUtil.getDouble(paramJobj.optString("shipping","0"));
            double otherCharges = StringUtil.getDouble(paramJobj.optString("othercharges","0"));
            boolean inCash = Boolean.parseBoolean(paramJobj.optString("incash"));

            String contractId = paramJobj.optString("contractId",null);
            recId = entryNumber;
            String customerid = custId;
            Map<String, Object> oldInvoicePrmt = new HashMap<String, Object>();
            Map<String, Object> invoicePrmt = new HashMap<String, Object>();
            Map<String, Object> newAuditKey = new HashMap<String, Object>();

            
            boolean bankReconsilationEntry = false, bankPayment = false;
            Date clearanceDate = null, startDate = null, endDate = null;
            String bankAccountId = "";
            Map< String, Object> bankReconsilationMap = new HashMap<String, Object>();
            if (!StringUtil.isNullOrEmpty(invoiceid)) {
                invoicePrmt.put("invoiceid", invoiceid);
            }
            if (!StringUtil.isNullOrEmpty(invoicetype)) {
                invoicePrmt.put("invoicetype", invoicetype);
            }
            if (!StringUtil.isNullOrEmpty(shipLength)) {
                invoicePrmt.put("shipLength", shipLength);
            }
            if (!StringUtil.isNullOrEmpty(accountid)) {
                invoicePrmt.put("accountid", accountid);
            }
            if (!StringUtil.isNullOrEmpty(customerid)) {
                invoicePrmt.put("customerid", customerid);
            }
            if (extraCompanyPreferences.getCompany().getCountry()!=null && extraCompanyPreferences.getCompany().getCountry().getID().equals(String.valueOf(Constants.indian_country_id))) {
                invoicePrmt.put("formtype", formtype);
                invoicePrmt.put("excisetypeid", excisetypeid);
                /**
                 * ERP-32829 
                 */
                
            }
            if(extraCompanyPreferences.isIsNewGST()){
                invoicePrmt.put("gstapplicable", paramJobj.optBoolean("GSTApplicable"));
                invoicePrmt.put("RCMApplicable", RCMApplicable);
                invoicePrmt.put(Constants.isMerchantExporter, paramJobj.optBoolean(Constants.isMerchantExporter, false));
            }
            invoicePrmt.put(Constants.additionalMemo,paramJobj.optString(Constants.additionalMemo,""));
            if (StringUtil.isNullOrEmpty(invoiceid)) {
//                String msg = checkSOUsedFlag(request, 2);
                String msg = checkSOUsedFlagJson(paramJobj, 2);
                if (!StringUtil.isNullOrEmpty(msg)) {//Check if SO is already used in DO or not.
                    throw new AccountingException(msg);
                }
            }

            synchronized (this) {
             
                if (!StringUtil.isNullOrEmpty(invoiceid)) {//in edit case checks duplicate     
                    result = accInvoiceDAOobj.getDuplicateInvoiceNumberForEdit(entryNumber, companyid, invoiceid);
                    nocount = result.getRecordTotalCount();
                    if (nocount > 0 && sequenceformat.equals("NA")) {
                        if (inCash) {
                            throw new AccountingException("Sales receipt number '" + entryNumber + "' already exists.");
                        } else {
                            throw new AccountingException("Invoice number '" + entryNumber + "' already exists.");
                        }
                    } else {
                        KwlReturnObject rst = accountingHandlerDAOobj.getObject(Invoice.class.getName(), invoiceid);
                        Invoice inv = (Invoice) rst.getEntityList().get(0);
                        if(isEdit){
//                            setValuesForAuditTrialMessage(inv,request,oldInvoicePrmt,invoicePrmt,inCash,newAuditKey);
                            setValuesForAuditTrialMessage(inv,paramJobj,oldInvoicePrmt,invoicePrmt,inCash,newAuditKey);
                        }
                    }
                } 

                if (sequenceformat.equals("NA")) {//In case of NA checks wheather this number can also be generated by a sequence format or not
                    int mduleid = Constants.Acc_Invoice_ModuleId;
                    if (inCash) {
                        mduleid = Constants.Acc_Cash_Sales_ModuleId;
                    }
                    List list = accCompanyPreferencesObj.checksEntryNumberForSequenceNumber(mduleid, entryNumber, companyid);
                    if (!list.isEmpty()) {
                        boolean isvalidEntryNumber = (Boolean) list.get(0);
                        String formatName = (String) list.get(1);
                        if (!isvalidEntryNumber) {
                            throw new AccountingException(messageSource.getMessage("acc.common.enterdocumentnumber", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + entryNumber + "</b> " + messageSource.getMessage("acc.common.belongsto", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + formatName + "</b>. " + messageSource.getMessage("acc.common.plselectseqformat", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) + " <b>" + formatName + "</b> " + messageSource.getMessage("acc.common.insteadof", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                        }
                    }
                }
                invoicePrmt.put("autogenerated", sequenceformat.equals("NA")?false:true);
            }
            /*
                In edit case of draft where auto-sequence no.is enable and not a save action then we have set entryno as empty to avoid duplication.
            */
            if(isDraft && isAutoSeqForEmptyDraft && !StringUtil.isNullOrEmpty(entryNumber)){
                entryNumber = "";
            }
            /*
             SDP-13923 : User has changed sequence format from "NA" to Auto-Sequence Format and user saved the record again as a draft then empty no.should be empty.
            */
            if(isDraft && !StringUtil.isNullOrEmpty(entryNumber) && isSequenceFormatChangedInEdit && !sequenceformat.equals("NA")){
                entryNumber = "";
            }
            if(isDraft && !isSaveDraftRecord && !StringUtil.isNullOrEmpty(invoiceid) && !sequenceformat.equals("NA") && StringUtil.isNullOrEmpty(entryNumber)){   //SDP-13927 : If Draft already having sequence no. then do not update it
                invoicePrmt.put(InvoiceConstants.entrynumber, "");
            } else if (sequenceformat.equals("NA") || !StringUtil.isNullOrEmpty(invoiceid)) {
                invoicePrmt.put(InvoiceConstants.entrynumber, entryNumber);
            } else {
                invoicePrmt.put(InvoiceConstants.entrynumber, "");
            }
            
            if (originalInvoice!=null && extraCompanyPreferences.getCompany().getCountry()!=null && extraCompanyPreferences.getCompany().getCountry().getID().equals(String.valueOf(Constants.indian_country_id))) {
                invoicePrmt.put("parentInvoice", originalInvoice);//Incase of Supplementary Invoice
                invoicePrmt.put("isSupplementary","1");//Incase of Supplementary Invoice
            }
            invoicePrmt.put("isfavourite", paramJobj.optString("isfavourite",null)==null?"":paramJobj.optString("isfavourite"));
            invoicePrmt.put("isFixedAsset", isFixedAsset);
            invoicePrmt.put("isDraft", isDraft);
            invoicePrmt.put("isInvoiceLinkedWithTaxAppliedDO", (isEdit && !isCopy)?invoice.isLinkedWithTaxAppliedDO():isInvoiceLinkedWithTaxAppliedDO);
            invoicePrmt.put("isLeaseFixedAsset", isLeaseFixedAsset);
            invoicePrmt.put(InvoiceConstants.memo, paramJobj.optString(Constants.memo,null)==null?"":paramJobj.optString(Constants.memo));
            invoicePrmt.put("billto", paramJobj.optString("billto",null)==null?"":paramJobj.optString("billto"));
            invoicePrmt.put("shipaddress", paramJobj.optString("shipaddress",null)==null?"":paramJobj.optString("shipaddress"));
            if (paramJobj.optString(InvoiceConstants.shipdate,null) != null && !StringUtil.isNullOrEmpty(paramJobj.optString(InvoiceConstants.shipdate))) {
                invoicePrmt.put(InvoiceConstants.shipdate, df.parse(paramJobj.optString(InvoiceConstants.shipdate)));
            }
            invoicePrmt.put("porefno", porefnumber);
            invoicePrmt.put(InvoiceConstants.duedate, df.parse(dueDate));
            invoicePrmt.put("template", paramJobj.optString("template",null)==null?"":paramJobj.optString("template"));
            invoicePrmt.put(Constants.companyKey, companyid);
            invoicePrmt.put(Constants.currencyKey, currencyid);
            invoicePrmt.put("externalCurrencyRate", externalCurrencyRate);
            invoicePrmt.put("salesPerson",salesPerson);
            invoicePrmt.put("shipvia", paramJobj.optString("shipvia"));
            invoicePrmt.put(Constants.fob, paramJobj.optString(Constants.fob,null)==null?"":paramJobj.optString(Constants.fob));
            invoicePrmt.put("createdby", createdby);
            invoicePrmt.put("modifiedby", modifiedby);
            invoicePrmt.put("createdon", createdon);
            invoicePrmt.put("updatedon", updatedon);
            if (!StringUtil.isNullOrEmpty(termid)) {
                invoicePrmt.put("termid", termid);
            }
            invoicePrmt.put("partialinv", (paramJobj.optString("partialinv",null) != null) ? Boolean.parseBoolean(paramJobj.optString("partialinv")) : false);
            invoicePrmt.put("gstIncluded", gstIncluded);
            invoicePrmt.put(Constants.isConsignment, isConsignment);
            if (!StringUtil.isNullOrEmpty(custWarehouse)) {
                invoicePrmt.put("custWarehouse", custWarehouse);
            }
            if (!StringUtil.isNullOrEmpty(movementtype)) {
                invoicePrmt.put("movementtype", movementtype);
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("deliveryTime",null))) {
                invoicePrmt.put("deliveryTime", paramJobj.optString("deliveryTime"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("includeprotax",null))) {
                invoicePrmt.put("includeprotax", paramJobj.optString("includeprotax"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.importExportDeclarationNo))) {
                invoicePrmt.put(Constants.importExportDeclarationNo, paramJobj.optString(Constants.importExportDeclarationNo));
            }
              
            if (inCash && !StringUtil.isNullOrEmpty(methodid)) { //in cash when payment method selected
                invoicePrmt.put("paymentMethod",methodid);// ERM-735 Associate Payment Method to custmer
                KwlReturnObject payresult = accountingHandlerDAOobj.getObject(PaymentMethod.class.getName(), methodid);
                PaymentMethod payMethod = (PaymentMethod) payresult.getEntityList().get(0);
                if (payMethod != null) {
                    HashMap pdetailhm = new HashMap();
                    pdetailhm.put("paymethodid", payMethod.getID());
                    pdetailhm.put(Constants.companyKey, companyid);
                    if (paydetail != null) { //For Edit Case                      
                        pdetailhm.put("paydetailid", paydetail.getID());
                    }
                    
                    if (payMethod.getDetailType() != PaymentMethod.TYPE_CASH) {
                        if (paramJobj.optString("paydetail", null) != null && !StringUtil.isNullOrEmpty(paramJobj.optString("paydetail", null))) {
                            HashMap chequehm = new HashMap();
                            JSONObject obj = new JSONObject(paramJobj.optString("paydetail","[]"));
                            if (payMethod.getDetailType() == PaymentMethod.TYPE_BANK) {
                                chequehm.put("chequeno", obj.getString("chequeno"));
                                chequehm.put("description", StringUtil.DecodeText(obj.optString("description")));
                                chequehm.put("bankname", StringUtil.DecodeText(obj.optString("bankname")));
                                chequehm.put("bankmasteritemid", StringUtil.DecodeText(obj.optString("bankmasteritemid")));
                                chequehm.put("duedate", df.parse(obj.getString("payDate")));
                                chequehm.put("companyId", companyid);
                                Map<String, Object> seqchequehm = new HashMap<>();
                                obj.put(Constants.companyKey, companyid);
                                String chequesequenceformat = obj.optString("sequenceformat","NA");
                                String nextChequeNumber = "";
                                /**
                                 * getNextChequeNumber method to generate next sequence number using sequence format,
                                 * also saving the dateprefix and datesuffix in cheque table.
                                 */
                                if (!StringUtil.isNullOrEmpty(chequesequenceformat) && !chequesequenceformat.equals("NA")) {
                                seqchequehm = accCompanyPreferencesObj.getNextChequeNumber(obj);
                            }
                            if (seqchequehm.containsKey(Constants.AUTO_ENTRYNUMBER)) {
                                chequehm.put("chequeno", (String) seqchequehm.get(Constants.AUTO_ENTRYNUMBER));
                            }
                            if (seqchequehm.containsKey(Constants.SEQNUMBER)) {
                                chequehm.put("sequenceNumber", (String) seqchequehm.get(Constants.SEQNUMBER));
                            }
                            if (seqchequehm.containsKey(Constants.DATEPREFIX)) {
                                chequehm.put(Constants.DATEPREFIX, (String) seqchequehm.get(Constants.DATEPREFIX));
                            }
                            if (seqchequehm.containsKey(Constants.DATEAFTERPREFIX)) {
                                chequehm.put(Constants.DATEAFTERPREFIX, (String) seqchequehm.get(Constants.DATEAFTERPREFIX));
                            }
                            if (seqchequehm.containsKey(Constants.DATESUFFIX)) {
                                chequehm.put(Constants.DATESUFFIX, (String) seqchequehm.get(Constants.DATESUFFIX));
                            }
                                KwlReturnObject cqresult = accPaymentDAOobj.addCheque(chequehm);
                                Cheque cheque = (Cheque) cqresult.getEntityList().get(0);
                                pdetailhm.put("chequeid", cheque.getID());
                                
                                /*
                                 * need to save the data to reconcilation
                                 * Cleared or Uncleared
                                 */
                                bankReconsilationEntry = obj.optString("paymentStatus",null) != null ? obj.getString("paymentStatus").equals("Cleared") : false;
                                if (bankReconsilationEntry) {
                                    bankAccountId = paramJobj.optString("bankaccid",null);
                                    startDate = df.parse(paramJobj.optString("startdate"));
                                    endDate = df.parse(paramJobj.optString("enddate"));
                                    clearanceDate = df.parse(obj.getString("clearanceDate"));
                                    bankReconsilationMap.put("bankAccountId", bankAccountId);
                                    bankReconsilationMap.put("startDate", startDate);
                                    bankReconsilationMap.put("endDate", endDate);
                                    bankReconsilationMap.put("clearanceDate", clearanceDate);
                                    bankReconsilationMap.put("endingAmount", 0.0);
                                    bankReconsilationMap.put("companyId", companyid);

                                }
                                
                            } else if (payMethod.getDetailType() == PaymentMethod.TYPE_CARD) {
                                HashMap cardhm = new HashMap();
                                cardhm.put("cardno", obj.getString("cardno"));
                                cardhm.put("nameoncard", obj.getString("nameoncard"));
                                cardhm.put("expirydate", df.parse(obj.getString("expirydate")));
                                cardhm.put("cardtype", obj.getString("cardtype"));
                                cardhm.put("refno", obj.getString("refno"));
                                KwlReturnObject cdresult = accPaymentDAOobj.addCard(cardhm);
                                Card card = (Card) cdresult.getEntityList().get(0);
                                pdetailhm.put("cardid", card.getID());
                            }
                        }
                    }
                    payresult = accPaymentDAOobj.addPayDetail(pdetailhm);
                    paydetail = (PayDetail) payresult.getEntityList().get(0);
                    if (paydetail != null) {
                        invoicePrmt.put("paydetailsid", paydetail.getID());
                    }
                }
            }
            else{         
                    invoicePrmt.put("paymentMethod",StringUtil.isNullOrEmpty(methodid)?"":methodid); //ERM-735 Map default payment method to customer
            }
            invoicePrmt.put("gstCurrencyRate", gstCurrencyRate);

            Map<String, Object> jeDataMap = AccountingManager.getGlobalParamsJson(paramJobj);
            if (istemplate == 2 || StringUtil.isNullOrEmpty(oldjeid)) {
                jeDataMap.put("entrynumber", "");
            } else {
                jeDataMap.put("entrynumber", jeentryNumber);
                jeDataMap.put(Constants.SEQFORMAT, jeSeqFormatId);
                jeDataMap.put(Constants.SEQNUMBER, jeIntegerPart);
                jeDataMap.put(Constants.DATEPREFIX, jeDatePrefix);
                jeDataMap.put(Constants.DATEAFTERPREFIX, jeDateAfterPrefix);
                jeDataMap.put(Constants.DATESUFFIX, jeDateSuffix);
            }
            jeDataMap.put("autogenerated", true);
            jeDataMap.put(InvoiceConstants.entrydate, df.parse(paramJobj.optString(Constants.BillDate)));
            jeDataMap.put(Constants.companyKey, companyid);
            jeDataMap.put(Constants.memo, paramJobj.optString(Constants.memo));
            jeDataMap.put("externalCurrencyRate", externalCurrencyRate);
            invoicePrmt.put("posttext", paramJobj.optString("posttext"));
            jeDataMap.put("createdby", createdby);
            jeDataMap.put(Constants.currencyKey, currencyid);
            jeDataMap.put("costcenterid", costCenterId);
            jeDataMap.put(Constants.Checklocktransactiondate, paramJobj.optString(Constants.BillDate));//for checking lock period ERP-16800
            jeDataMap.put(Constants.isSaveAsDraft, isDraft);
            if (isExicseOpeningbalance) { // is Exicse Opening balance module check lock transaction date.
                jeDataMap.put("isOpeningBalanceOrder", isExicseOpeningbalance);
            }
             
            HashSet jeDetails = new HashSet();
            KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Create Journal entry without JEdetails
            JournalEntry journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
            jeid = journalEntry.getID();
            invoicePrmt.put("journalerentryid", jeid);
            jeDataMap.put("jeid", jeid);

            Map<Inventory, Object> FinalTerm  = null;
            Map<Inventory, Object> supplierDetails  = null;
            String invoiceDetails = paramJobj.optString(Constants.detail,"[]");
            
            if (inCash) {
                if (paydetail != null && paydetail.getPaymentMethod() != null) {
                    accountid = paydetail.getPaymentMethod().getAccount().getID();
                } else {
                    accountid = preferences.getCashAccount().getID();
                }
            }
            
            paramJobj.put("customerAccountid",accountid);
            //Saving line item details
//            List dll = saveInvoiceRows(request, invoiceDetails, jeid, company, jeDetails, currencyid, externalCurrencyRate);
//            if (countryid == Constants.indian_country_id && customer != null && customer.getGSTRegistrationType() != null) {
//                MasterItem gstRegistrationType = customer.getGSTRegistrationType();
//                if (gstRegistrationType != null && gstRegistrationType.getDefaultMasterItem() != null && !StringUtil.isNullOrEmpty(gstRegistrationType.getDefaultMasterItem().getID())) {
//                    paramJobj.put("isUnRegisteredDealer", gstRegistrationType.getDefaultMasterItem().getID().equals(Constants.GSTRegType.get(Constants.GSTRegType_Unregistered)));;
//                }
//            }
            List dll = saveInvoiceRowsJSON(paramJobj, invoiceDetails, jeid, company, jeDetails, currencyid, externalCurrencyRate, invDetailTermMap);
            
            double[] totals = (double[]) dll.get(0);
            double totalPartialDiscount = authHandler.round(totals[3],companyid);
            HashSet<InvoiceDetail> invcdetails = (HashSet<InvoiceDetail>) dll.get(1);
            ArrayList<String> prodList = (ArrayList<String>) dll.get(2);
            if(extraCompanyPreferences.getLineLevelTermFlag()==1){
                    FinalTerm = (Map<Inventory, Object>)dll.get(3);
                }
            if(extraCompanyPreferences.isExciseApplicable() && countryid == Constants.indian_country_id){
                    supplierDetails = (Map<Inventory, Object>)dll.get(4);
                }
            double sumOfDiscountAmount=(double)dll.get(5);                                   //To store the sum of discount amount which is return from saveInvoiceRows of product which does not has discount applied from discount master
            double disc = StringUtil.getDouble(paramJobj.optString("discount","0.0"));
            if (disc > 0) {
                JSONObject discjson = new JSONObject();
                discjson.put("discount", disc);
                discjson.put("inpercent", Boolean.parseBoolean(paramJobj.optString("perdiscount")));
                discjson.put("originalamount", totals[1] - totals[0] + totals[2]);
                discjson.put(Constants.companyKey, companyid);
                KwlReturnObject dscresult = accDiscountobj.addDiscount(discjson);
                discount = (Discount) dscresult.getEntityList().get(0);
                invoicePrmt.put("discountid", discount.getID());
                discValue = discount.getDiscountValue();
                sumOfDiscountAmount+=discount.getDiscountValue();
            }
            discValue += totals[0];

            /*
             * If invoice terms applied then add mapping in against invoice
             */
            double termTotalAmount = 0;
            double termTaxTotalAmount = 0;
            Tax termTax = null; 
            HashMap<String, Double> termAcc = new HashMap<String, Double>();
            HashMap<String, Double> termTaxAmt = new HashMap<String, Double>();
            String InvoiceTerms = paramJobj.optString("invoicetermsmap",null);
            if (!StringUtil.isNullOrEmpty(InvoiceTerms)) {
                JSONArray termsArr = new JSONArray(InvoiceTerms);
                for (int cnt = 0; cnt < termsArr.length(); cnt++) {
                    double termamount = 0;
                    if (gstIncluded) {
                        termamount = termsArr.getJSONObject(cnt).optDouble("termAmountExcludingTax",0);
                    } else {
                        termamount = termsArr.getJSONObject(cnt).optDouble("termamount",0);
                    }
                    double termTaxAmount = termsArr.getJSONObject(cnt).optDouble("termtaxamount", 0);
                    String termTaxId = termsArr.getJSONObject(cnt).optString("termtax",null);
                    if (!StringUtil.isNullOrEmpty(termTaxId)) {
                        KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), termTaxId);
                        termTax = (Tax) txresult.getEntityList().get(0);
                        if (termTaxAmt.containsKey(termTax.getAccount().getID())) {
                            double tempTaxAmount = termTaxAmt.get(termTax.getAccount().getID());
                            termTaxAmt.put(termTax.getAccount().getID(), termTaxAmount + tempTaxAmount);
                        } else {
                            termTaxAmt.put(termTax.getAccount().getID(), termTaxAmount);
                        }
                        termTaxTotalAmount += termTaxAmount;
                    }
                    
                    termTotalAmount += termamount;
                    if (termAcc.containsKey(termsArr.getJSONObject(cnt).getString("glaccount"))) {
                        double tempAmount = termAcc.get(termsArr.getJSONObject(cnt).getString("glaccount"));
                        termAcc.put(termsArr.getJSONObject(cnt).getString("glaccount"), termamount + tempAmount);
                    } else {
                        termAcc.put(termsArr.getJSONObject(cnt).getString("glaccount"), termamount);
                    }
                }
                if(termsArr.length()>0) {
                    invoicePrmt.put(Constants.termsincludegst, Boolean.parseBoolean(paramJobj.optString(Constants.termsincludegst)));
                }
            }
            
//            if (!StringUtil.isNullOrEmpty(taxid)){
//                taxamount = taxamount-termTaxTotalAmount;
//            }
            
            double lineLeveltermTotalAmount = 0;
            String LineDetails = paramJobj.optString(Constants.detail,null);
            if (!StringUtil.isNullOrEmpty(LineDetails) && extraCompanyPreferences.getLineLevelTermFlag()==1 && !RCMApplicable) { // If RCM Applicable  Amount Not added in Invoice amount - 
                JSONArray jArr = new JSONArray(LineDetails);
                for (int i = 0; i < jArr.length(); i++) {
                    JSONObject jobj = jArr.getJSONObject(i);
                    InvoiceTerms = StringUtil.DecodeText((String) jobj.optString("LineTermdetails"));
                    if (!StringUtil.isNullOrEmpty(InvoiceTerms)) {
                        JSONArray termsArr = new JSONArray(InvoiceTerms);
                        for (int cnt = 0; cnt < termsArr.length(); cnt++) {
                            double termamount = termsArr.getJSONObject(cnt).getDouble("termamount");
                            lineLeveltermTotalAmount += termamount;
                        }
                        if (termsArr.length() > 0) {
                            invoicePrmt.put(Constants.termsincludegst, Boolean.parseBoolean(paramJobj.optString(Constants.termsincludegst)));
                        }
                    }
                }
            }
            double totalInvAmount=0.0;
             
            totalInvAmount  = totals[1] + shippingCharges + otherCharges + termTotalAmount + taxamount + termTaxTotalAmount;
            if (partialInvoice) {
                totalInvAmount -= totalPartialDiscount;
            }else{
               totalInvAmount  -= discValue;
            }
            
//            if (!StringUtil.isNullOrEmpty(taxid)){
//                totalInvAmount += termTaxTotalAmount;
//            }
            if(!gstIncluded) {
                totalInvAmount += totals[2];
            }
            //Commented because of ERP-35438
            //isdefaultHeaderMap=Android,iForPOS=POS,isMultitransactions,isMultiGroupCompanyFlag=for Group of Company
//            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true && paramJobj.optBoolean(Constants.isForPos, false) == false && paramJobj.optBoolean(Constants.isMultiGroupCompanyFlag, false) == false) {//we are sending same taxamount from product as well as global level
//                if (!gstIncluded) {
//                    totalInvAmount = totals[1] + shippingCharges + otherCharges - discValue + termTotalAmount + taxamount;
//                } else {
//                    totalInvAmount = totals[1] + shippingCharges + otherCharges - discValue + termTotalAmount;
//                }
//            }
            
            if(lineLeveltermTotalAmount!=0 && extraCompanyPreferences.getLineLevelTermFlag()==1 && !gstIncluded){
                totalInvAmount+=lineLeveltermTotalAmount;
            }
            if (extraCompanyPreferences.isIsNewGST()) {
                /**
                 * For New GST (US and India) tax amount not saved in taxamount
                 * and taxamountinbase columns For New GST Tax Amount will
                 * present in "lineLeveltermTotalAmount" variable ERP-34535
                 */
                taxamount = lineLeveltermTotalAmount;
            }
            //Rounding Adjustment Code Start
            //Rounding Adjustment will always calculated after calculation of totalInvAmount
            String roundingAdjustmentAccountID = "";
            String columnPref = extraCompanyPreferences.getColumnPref();
            if (!StringUtil.isNullOrEmpty(columnPref)) {
                JSONObject prefObj = new JSONObject(columnPref);
                roundingAdjustmentAccountID = prefObj.optString(Constants.RoundingAdjustmentAccountID, "");
            }
            
            if (isRoundingAdjustmentApplied && !StringUtil.isNullOrEmpty(roundingAdjustmentAccountID)) {
                double totalInvAmountAfterRound = Math.round(totalInvAmount);
                double roundingAdjustmentValue = authHandler.round(totalInvAmountAfterRound - totalInvAmount, companyid);
                if (roundingAdjustmentValue != 0) {
                    totalInvAmount = totalInvAmountAfterRound;//Now rounded value becomes total invoice amount
                    JSONObject jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", Math.abs(roundingAdjustmentValue));
                    jedjson.put("accountid", roundingAdjustmentAccountID);
                    jedjson.put("debit", (roundingAdjustmentValue<0)?true:false);
                    jedjson.put("jeid", jeid);
                    KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    
                    invoicePrmt.put(Constants.RoundingAdjustmentEntryID, jed.getID());
                    jeDetails.add(jed);
                }
            }
            invoicePrmt.put(Constants.IsRoundingAdjustmentApplied, isRoundingAdjustmentApplied);
            //Rounding Adjustment Code End

            
            KwlReturnObject bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, totalInvAmount, currencyid, df.parse(paramJobj.optString(Constants.BillDate)),externalCurrencyRate);
            double totalInvAmountinBase =(Double)bAmt.getEntityList().get(0);
            double invoiceamountdue=totalInvAmount;
            double invoiceamountdueinbase=totalInvAmountinBase;
            if(inCash){
                invoiceamountdue=0d;
                invoiceamountdueinbase=0d;
            }
            invoicePrmt.put(Constants.invoiceamountdue, invoiceamountdue);
            invoicePrmt.put("isjobWorkWitoutGrn", isjobWorkWitoutGrn);
            invoicePrmt.put(Constants.invoiceamount, totalInvAmount);
            invoicePrmt.put(Constants.invoiceamountinbase, totalInvAmountinBase);
            invoicePrmt.put(Constants.invoiceamountdueinbase, invoiceamountdueinbase);
            invoicePrmt.put(Constants.discountAmount, partialInvoice ? totalPartialDiscount :discValue);
            // Excise Opening Balance check from Vendor Master ERP-27108 : to hide JE POST
            if (isExicseOpeningbalance) {
                invoicePrmt.put("creationDate", df.parse(paramJobj.optString(Constants.BillDate)));
                invoicePrmt.put("lastModifiedDate", df.parse(paramJobj.optString(Constants.BillDate)));
                invoicePrmt.put("isOpeningBalenceInvoice", true);
                invoicePrmt.put("isNormalInvoice", false);
                invoicePrmt.put("originalOpeningBalanceAmount", totalInvAmount);
                invoicePrmt.put("openingBalanceAmountDue", totalInvAmount);
            }
            double discValueInBase = 0.0d;
            if (partialInvoice) {
                bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, totalPartialDiscount, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), externalCurrencyRate);
                discValueInBase = (Double) bAmt.getEntityList().get(0);
                invoicePrmt.put(Constants.discountAmountInBase, discValueInBase);
            } else {
                bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, discValue, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), externalCurrencyRate);
                discValueInBase = (Double) bAmt.getEntityList().get(0);
                invoicePrmt.put(Constants.discountAmountInBase, discValueInBase);
            }

            List<String> inventoryIDList = new ArrayList();
            JSONArray productDiscountJArr=new JSONArray();
            double lineLevelTermAmount = 0;//used get line level term amount if GST include is option is true
            for (InvoiceDetail invDetail : invcdetails) {
                if(invDetail.getInventory()!=null){
                    inventoryIDList.add(invDetail.getInventory().getID());
                    String productId = invDetail.getInventory().getProduct().getID();
                    Discount invDiscount = invDetail.getDiscount();
                    double discAmountinBase=0;
                    if (invDiscount != null) {
                        double discountVal = invDiscount.getDiscountValue();
                        KwlReturnObject dAmount = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, discountVal, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), externalCurrencyRate);
                        discAmountinBase = (Double) dAmount.getEntityList().get(0);
                    }
                    discAmountinBase = authHandler.round(discAmountinBase, companyid);
                    JSONObject productDiscountObj=new JSONObject();
                    productDiscountObj.put("productId", productId);
                    productDiscountObj.put("discountAmount", discAmountinBase);
                    productDiscountJArr.put(productDiscountObj);
                }
                
                /*
                if GST include is true then add the value in line level term
                */
                 lineLevelTermAmount += invDetail.getLineLevelTermAmount();
            }
            JSONObject jedjson = new JSONObject();
            jedjson.put("srno", jeDetails.size() + 1);
            jedjson.put(Constants.companyKey, companyid);
            jedjson.put("amount", totalInvAmount);
            jedjson.put("accountid", accountid);
            jedjson.put("debit", true);
            jedjson.put("jeid", jeid);
            KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
            JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
            jeDetails.add(jed);
            JSONArray jedForCustomFields = new JSONArray();
            jedForCustomFields.put(jed.getID());
            invoicePrmt.put("customerentryid", jed.getID()); 
//            if (isFixedAsset) {
//                try {
//                    
//                    Map<String, Object> param = new HashMap();
//                    param.put("jed",jed);
//                   
//                        JSONArray jArray = new JSONArray(invoiceDetails);
//                        for (int i = 0; i < jArray.length(); i++) {
//                            JSONObject jobj = jArray.getJSONObject(i);
//                            param.put("jedForCustomFields",jedForCustomFields);
//                            param.put("inventoryID",!StringUtil.isNullOrEmpty(inventoryIDList.get(i)) ? inventoryIDList.get(i) : "");
//                            saveLinelevelCustomFieldData(jobj,param, paramJobj);
//                        }
//                } catch (Exception ex) {
//                    Logger.getLogger(authHandler.class.getName()).log(Level.SEVERE, null, ex);
//                }
//
//            }
            
            if (sumOfDiscountAmount > 0) {
                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", partialInvoice ? totalPartialDiscount : sumOfDiscountAmount);
                jedjson.put("accountid", preferences.getDiscountGiven().getID());
                jedjson.put("debit", true);
                jedjson.put("jeid", jeid);
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);
            }
            if (shippingCharges > 0) {
                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put(Constants.companyKey, companyid);
                jedjson.put("amount", shippingCharges);
                jedjson.put("accountid", preferences.getShippingCharges().getID());
                jedjson.put("debit", false);
                jedjson.put("jeid", jeid);
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jed);
                invoicePrmt.put("shipentryid", jed.getID());

            }
            if (termAcc.size() > 0) {
                for (Map.Entry<String, Double> entry : termAcc.entrySet()) {
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", entry.getValue() > 0 ? entry.getValue() : (entry.getValue() * (-1)));
                    jedjson.put("accountid", entry.getKey());
                    jedjson.put("debit", entry.getValue() > 0 ? false : true);
                    jedjson.put("jeid", jeid);
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                }
            }
             
            if (termTaxAmt.size() > 0 && termTax!= null) {
                for (Map.Entry<String, Double> entry : termTaxAmt.entrySet()) {
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", entry.getValue() > 0 ? entry.getValue() : (entry.getValue() * (-1)));
                    jedjson.put("accountid", entry.getKey());
                    jedjson.put("debit",entry.getValue() > 0 ? false : true);
                    jedjson.put("jeid", jeid);
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                }
            }
            double taxAmountinBase=0;
            double excludingGstAmountInBase=0;
            KwlReturnObject baseAmountObj =null;
            if (!StringUtil.isNullOrEmpty(taxid)) {
                KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), taxid); // (Tax)session.get(Tax.class, taxid);
                Tax tax = (Tax) txresult.getEntityList().get(0);
                if (tax == null) {
                    throw new AccountingException(messageSource.getMessage("acc.so.taxcode", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }
                invoicePrmt.put("taxid", taxid);
                    
                if (taxamount > 0) {
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", taxamount);
                    jedjson.put("accountid", tax.getAccount().getID());
                    jedjson.put("debit", false);
                    jedjson.put("jeid", jeid);
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    invoicePrmt.put("taxentryid", jed.getID());
                }
            }
            /* Add global level tax amount and tax amount in base value */
            invoicePrmt.put("taxAmount", taxamount + termTaxTotalAmount);
            invoicePrmt.put(Constants.isApplyTaxToTerms, paramJobj.optBoolean(Constants.isApplyTaxToTerms,false));
            baseAmountObj = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, taxamount + termTaxTotalAmount, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), externalCurrencyRate);
            taxAmountinBase = (Double) baseAmountObj.getEntityList().get(0);
            taxAmountinBase = authHandler.round(taxAmountinBase, companyid);
            invoicePrmt.put("taxAmountInBase", taxAmountinBase);
            if(gstIncluded){
                excludingGstAmountInBase = (totals[1] - totals[2] ) - discValue + termTotalAmount;
                excludingGstAmountInBase += lineLevelTermAmount;
            }else{
                excludingGstAmountInBase = totals[1] - discValue + termTotalAmount;
            }    
            invoicePrmt.put("excludingGstAmount", excludingGstAmountInBase);
            baseAmountObj = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, excludingGstAmountInBase, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), externalCurrencyRate);
            excludingGstAmountInBase = (Double) baseAmountObj.getEntityList().get(0);
            excludingGstAmountInBase = authHandler.round(excludingGstAmountInBase, companyid);
            invoicePrmt.put("excludingGstAmountInBase", excludingGstAmountInBase);
            
           /* Add line level tax amount and tax amount in base value */
            /**
             * For INDIA/US GST Include product tax option not present, No need to Execute below if Condition code
             */
            if (!extraCompanyPreferences.isIsNewGST() && includeProductTax) {
                invoicePrmt.put("taxAmount", totals[2] + termTaxTotalAmount);
                KwlReturnObject lineLevelTaxAmountinBase = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, totals[2] + termTaxTotalAmount, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), externalCurrencyRate);
                taxAmountinBase = (Double) lineLevelTaxAmountinBase.getEntityList().get(0);
                taxAmountinBase = authHandler.round(taxAmountinBase, companyid);
                invoicePrmt.put("taxAmountInBase", taxAmountinBase);
//                excludingGstAmountInBase=totals[1]-discValue;
//                if (gstIncluded) {
//                   excludingGstAmountInBase=totals[1] - totals[2]-discValue;
//                   excludingGstAmountInBase+=lineLevelTermAmount;
//                }
//                invoicePrmt.put("excludingGstAmount", excludingGstAmountInBase);
//                baseAmountObj = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, excludingGstAmountInBase, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), externalCurrencyRate);
//                excludingGstAmountInBase = (Double) baseAmountObj.getEntityList().get(0);
//                excludingGstAmountInBase = authHandler.round(excludingGstAmountInBase, companyid);
//                invoicePrmt.put("excludingGstAmountInBase", excludingGstAmountInBase);
            }

            jeDataMap.put("jedetails", jeDetails);

            jeDataMap.put("istemplate", istemplate);
            jeDataMap.put("externalCurrencyRate", externalCurrencyRate);
            jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Add Journal entry details
            journalEntry = (JournalEntry) jeresult.getEntityList().get(0);

            if (!StringUtil.isNullOrEmpty(customfield)) {
                JSONArray jcustomarray = new JSONArray(customfield);
                if (paramJobj.optBoolean(Constants.isSquatTransaction)) {
                    jcustomarray = fieldDataManagercntrl.GetJsonArrayUsingFieldIds(jcustomarray, Constants.Acc_Invoice_ModuleId, companyid, true);
                }
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                customrequestParams.put("customarray", jcustomarray);
                customrequestParams.put("modulename", Constants.Acc_JE_modulename);
                customrequestParams.put("moduleprimarykey", Constants.Acc_JEid);
                customrequestParams.put("modulerecid", journalEntry.getID());
                customrequestParams.put(Constants.moduleid, isFixedAsset ? Constants.Acc_FixedAssets_DisposalInvoice_ModuleId : isConsignment?Constants.Acc_ConsignmentInvoice_ModuleId:isLeaseFixedAsset?Constants.LEASE_INVOICE_MODULEID:Constants.Acc_Invoice_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("customdataclasspath", Constants.Acc_BillInv_custom_data_classpath);
                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                    jeDataMap.put("accjecustomdataref", journalEntry.getID());
                    jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);
                }
            }

            KwlReturnObject ERresult = accCurrencyDAOobj.getExcDetailID(requestParams, currencyid, df.parse(paramJobj.optString(Constants.BillDate)), null);
            ExchangeRateDetails erd = (ExchangeRateDetails) ERresult.getEntityList().get(0);
            String erdid = (erd == null) ? null : erd.getID();
            invoicePrmt.put("erdid", erdid);

            invoicePrmt.put("istemplate", istemplate);
            invoicePrmt.put("incash", paramJobj.optString("incash",null));

            if (StringUtil.isNullOrEmpty(invoiceid)) {// Used to save billing and shipping addresses 
                boolean isDefaultAddress = paramJobj.optString("defaultAdress",null) != null ? Boolean.parseBoolean(paramJobj.optString("defaultAdress")) : false;
                Map<String, Object> addressParams = new HashMap<String, Object>();
                if (isDefaultAddress) {
                    addressParams = AccountingAddressManager.getDefaultCustomerAddressParams(customer.getID(), companyid, accountingHandlerDAOobj);// addressParams = getCustomerDefaultAddressParams(customer,companyid);
                } else {
//                    addressParams = AccountingAddressManager.getAddressParams(request,false);
                    addressParams = AccountingAddressManager.getAddressParamsJson(paramJobj,false);
                }
                KwlReturnObject addressresult = accountingHandlerDAOobj.saveAddressDetail(addressParams, companyid);
                BillingShippingAddresses bsa = (BillingShippingAddresses) addressresult.getEntityList().get(0);
                invoicePrmt.put("billshipAddressid", bsa.getID());
            }
            
            JSONObject invjson = new JSONObject(); 
            Set<String> set = invoicePrmt.keySet();
            for (String key : set) {
                invjson.accumulate(key, invoicePrmt.get(key));
            }
            invjson.put(Constants.Checklocktransactiondate, paramJobj.optString(Constants.BillDate));
            invjson.put("isExciseInvoice", isExciseInvoice);
            invjson.put("creationDate", transactionDate);
            invjson.put("defaultnatureofpurchase",defaultnatureofpurchase);
            invjson.put(Constants.isSaveAsDraft, isDraft);
            invjson.put("isExciseInvoice", isExciseInvoice);
            if (!isEdit || isCopy) {
                invjson.put(Constants.generatedSource, generatedSource);
            }
            if (!StringUtil.isNullOrEmpty(moduleTemplateId)) {
                invjson.put("moduletemplateid", moduleTemplateId);
            }
            invjson.put("customerBankAccountTypeId", customerBankAccountTypeId);
            //put Cash Received value in invoice json object
            invjson.put(Constants.CASH_RECEIVED, paramJobj.optDouble(Constants.CASH_RECEIVED, 0.0));
               
            if (isdropshipchecked) {
                    invjson.put("isdropshipchecked", isdropshipchecked);
                }
            
            if (isEditedPendingDocument) {
                invjson.put("isEditedPendingDocument", isEditedPendingDocument);
            }
            
            result = accInvoiceDAOobj.addInvoice(invjson, new HashSet());
            invoice = (Invoice) result.getEntityList().get(0);//Create Invoice without invoice-details.
            HashMap<String, Object> invApproveMap = new HashMap<String, Object>();
            int approvalStatusLevel = 11;
            int pendingApprovalFlag=0;
            int level = (isEdit && !isCopy) ? 0 : invoice.getApprovestatuslevel();
            invApproveMap.put(Constants.companyKey, paramJobj.getString(Constants.companyKey));
            invApproveMap.put("level", level);
            invApproveMap.put("totalAmount", String.valueOf(authHandler.round(totalInvAmountinBase, companyid)));
            invApproveMap.put("currentUser", currentUser);
            invApproveMap.put("fromCreate", true);
            invApproveMap.put("productDiscountMapList", productDiscountJArr);
            invApproveMap.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
            invApproveMap.put("iscash", iscash);
            invApproveMap.put(Constants.PAGE_URL, paramJobj.optString(Constants.PAGE_URL));
            List approvedlevel = null;
            boolean ismailApplicable=false;
                                 
            /*----Check proper variable for EditedPending document-------*/
          
            String postingDateStr = paramJobj.optString("postingDate" ,null);
            JSONObject columnprefObj = new JSONObject();
            boolean sendPendingDocumentsToNextLevel = false;

            List approvalJEList = null;
            String JENumber = "";
            String JEMsg = "";
            List approvalHistoryList = null;
            String roleName = "";
            boolean isAuthorityToApprove = true;
            boolean pendingMessage=true;

            if (!StringUtil.isNullOrEmpty(extraCompanyPreferences.getColumnPref())) {
                columnprefObj = new JSONObject((String) extraCompanyPreferences.getColumnPref());
            }
            if (columnprefObj.has("sendPendingDocumentsToNextLevel") && columnprefObj.get("sendPendingDocumentsToNextLevel") != null && (Boolean) columnprefObj.get("sendPendingDocumentsToNextLevel") != false) {
                sendPendingDocumentsToNextLevel = true;
            }

            /*------If pending document is Edited & Check is activated from system preferences
             *---Then Edit will work same as while approving document
             */
            if (isEditedPendingDocument) {
                level = invoice.getApprovestatuslevel();
                invApproveMap.put("fromCreate", false);
                invApproveMap.put("documentLevel", level);
                if (sendPendingDocumentsToNextLevel) {

                    ismailApplicable = true;
                    invApproveMap.put("level", level);
                    pendingMessage=false;

                }else{
                    invApproveMap.put("isEditedPendingDocumentWithCheckOff", true);
                }
            }
            
            
            if ((isEdit && !isCopy) && invoice.getParentInvoice() != null) {//check for recurring invoice
                /*
                    if we are editing recurred invoice then set its level to 1 if approver is set else directly set approval level to 11 directly. 
                    No need to apply multilevel approval rule for editing recurred invoice as per requirement
                    invoice.getParentInvoice().getRepeateInvoice() - refers to  recurring rule
                 */
                RepeatedInvoices parentsRepeatedinvoice = (RepeatedInvoices)invoice.getParentInvoice().getRepeateInvoice();
                if (parentsRepeatedinvoice!=null && parentsRepeatedinvoice.isAllowToEditRecurredDocument() && !StringUtil.isNullObject(parentsRepeatedinvoice.getApproverOfEditedrecurredInvoice())) {
                    approvalStatusLevel = 1;
                } else {
                    approvalStatusLevel = 11;
                }
                invoicePrmt.put("approvalstatuslevel", approvalStatusLevel);
                
            } else if (!(isLeaseFixedAsset || isConsignment || isFixedAsset || isDraft||istemplate == 2)) {
                
              approvedlevel = approveInvoice(invoice, invApproveMap, ismailApplicable);
              approvalStatusLevel = (Integer)approvedlevel.get(0);
              mailParams = (List)approvedlevel.get(1);
              invoicePrmt.put("approvalstatuslevel", approvalStatusLevel);
            } else {
                invoicePrmt.put("approvalstatuslevel", 11);
            }
            
             int levelOnWhichDocumentIsApproved = invoice.getApprovestatuslevel();
                        
            /*----Write approval code , start block -----  */
            
            /*-----Note:- Keep in mind for recurring invoices--------*/
            
            if(isEditedPendingDocument){
                
                if(sendPendingDocumentsToNextLevel){
                    
                    
                    if (approvalStatusLevel == 11) {

                        HashMap approveJeMap = new HashMap();

                        approveJeMap.put("company", company);
                        approveJeMap.put("salesInvoice", invoice);
                        approveJeMap.put("extraCompanyPreferences", extraCompanyPreferences);
                        approveJeMap.put("postingDateStr", postingDateStr);
                        approveJeMap.put("isEditedPendingDocument", isEditedPendingDocument);
                       
                        approvalJEList = approveRelevantDocumentAttachedToCustomerInvoice(approveJeMap);
                        
                        JENumber = approvalJEList != null ? approvalJEList.get(0).toString() : "";

                        JEMsg = approvalJEList != null ? approvalJEList.get(1).toString() : "";
                    }
                    
                    
                    
                         /*----Block will execute if "Allow Sending Approval Mail" check is activated from system preferences ------*/
                    if (approvalStatusLevel != Constants.NoAuthorityToApprove && preferences.isSendapprovalmail()) {

                        HashMap emailMap = new HashMap();
                        String userName = paramJobj.optString(Constants.username, null);
                        emailMap.put("userName", userName);
                        emailMap.put("company", company);
                        emailMap.put("salesInvoice", invoice);
                        emailMap.put("baseUrl", paramJobj.optString("baseUrl",""));
                        emailMap.put("preferences", preferences);
                        emailMap.put("ApproveMap", invApproveMap);

                       sendApprovalMailIfAllowedFromSystemPreferences(emailMap);
                       

                    }
                    
                    /*--------Save Approval history Code--------  */
                    if (approvalStatusLevel != Constants.NoAuthorityToApprove) {

                        HashMap approvalHistoryMap = new HashMap();
                        String userid = paramJobj.optString(Constants.userid, "");

                        approvalHistoryMap.put("userid", userid);

                        approvalHistoryMap.put("company", company);
                        approvalHistoryMap.put("salesInvoice", invoice);

                        approvalHistoryList = saveApprovalHistory(approvalHistoryMap);
                        roleName = approvalHistoryList != null ? approvalHistoryList.get(0).toString() : "";

                    } else if (approvalStatusLevel == Constants.NoAuthorityToApprove) {
                        /*----If User have no authority to approve------*/
                        isAuthorityToApprove = false;
                        invoicePrmt.put("approvalstatuslevel", invoice.getApprovestatuslevel());
                    }
                    
                    
                }else if (approvalStatusLevel == Constants.NoAuthorityToApprove) {//If User is not authorised to approve
                    isAuthorityToApprove = false;
                     invoicePrmt.put("approvalstatuslevel", invoice.getApprovestatuslevel());
                }
                
            } 
                                            
            /*------------End Block---------------------------------  */
            
            if(approvalStatusLevel!=11 && pendingMessage){
                pendingApprovalFlag=1;
            }else{
                pendingApprovalFlag=0;
            }

            Iterator itr = invcdetails.iterator();
            while (itr.hasNext()) {
                InvoiceDetail ivd = (InvoiceDetail) itr.next();
                if ((pendingApprovalFlag == 1 || istemplate == 2) && ivd.getInventory().isInvrecord()) {
                    Inventory invtry = ivd.getInventory();
                    invtry.setActquantity(invtry.getQuantity());
                    invtry.setQuantity(0);
                }
                ivd.setInvoice(invoice);
                /**
                 * set Job Order Item Number
                 */
                if(ivd.isJobOrderItem()){
                    ivd.setJobOrderItemNumber(invoice.getInvoiceNumber()+"-"+ivd.getSrno());
                }
            }
            invoicePrmt.put("invoiceid", invoice.getID());
            invoicePrmt.put("pendingapproval", pendingApprovalFlag);
            
            invjson = new JSONObject();
            set = invoicePrmt.keySet();
            for (String key : set) {
                invjson.accumulate(key, invoicePrmt.get(key));
            }
            result = accInvoiceDAOobj.updateInvoice(invjson, invcdetails);
            JSONObject jeJobj= new JSONObject();
            HashSet<JournalEntryDetail> details =new HashSet<JournalEntryDetail>();
            if (approvalStatusLevel == 11) {
                jeJobj.put("pendingapproval", 0);
            } else {
                jeJobj.put("pendingapproval", 1);
            }
            jeJobj.put("isDraft", invoice.isDraft());
            jeJobj.put("jeid", journalEntry.getID());
            jeJobj.put(JournalEntryConstants.COMPANYID, journalEntry.getCompany().getCompanyID());
            jeJobj.put("transactionId", invoice.getID());
            jeJobj.put("transactionModuleid", isFixedAsset ? Constants.Acc_FixedAssets_DisposalInvoice_ModuleId : isConsignment ? Constants.Acc_ConsignmentInvoice_ModuleId : isLeaseFixedAsset ? Constants.LEASE_INVOICE_MODULEID : inCash ? Constants.Acc_Cash_Sales_ModuleId : Constants.Acc_Invoice_ModuleId);
            accJournalEntryobj.updateJournalEntry(jeJobj,details);
            invoice = (Invoice) result.getEntityList().get(0);//Add invoice details 
            if (bankReconsilationEntry) {
                bankReconsilationMap.put("clearingamount", invoice.getInvoiceamount());
                bankReconsilationMap.put(Constants.currencyKey, currencyid);
                bankReconsilationMap.put("invoice", invoice);
               
                if (!StringUtil.isNullOrEmpty(oldjeid)) {
                    bankReconsilationMap.put("oldjeid", oldjeid);
                }
                HashMap<String, Object> globalParams = AccountingManager.getGlobalParamsJson(paramJobj);
                saveBankReconsilation(bankReconsilationMap, globalParams);
            }
            if (!bankReconsilationEntry && !StringUtil.isNullOrEmpty(oldjeid)) {
                bankReconsilationMap.put("oldjeid", oldjeid);
                bankReconsilationMap.put("companyId", companyid);
                deleteBankReconcilation(bankReconsilationMap);
            }
            // save contract mapping with invoice
            String linkMode = paramJobj.optString("fromLinkCombo");
            if (linkMode.equalsIgnoreCase(Constants.Delivery_Order) ||linkMode.equalsIgnoreCase(Constants.Lease_Delivery_Order) ||linkMode.equalsIgnoreCase(Constants.Asset_Delivery_Order)) {
                Set<InvoiceContractMapping> contractMappings = getInvoiceContractMappings(paramJobj, invoice);
                HashMap<String, Object> doDataMap = new HashMap<String, Object>();
                if (!contractMappings.isEmpty()) {
                    doDataMap.put("id", invoice.getID());
                    doDataMap.put("contractMappings", contractMappings);
                    accInvoiceDAOobj.updateInvoiceUsingSet(doDataMap);
                }
            } else if (!StringUtil.isNullOrEmpty(contractId)) {// if invoice is being created after renew of contrcat
                Set<InvoiceContractMapping> contractMappings = getInvoiceContractMappingsWithoutDO(invoice, contractId);
                HashMap<String, Object> doDataMap = new HashMap<String, Object>();
                if (!contractMappings.isEmpty()) {
                    doDataMap.put("id", invoice.getID());
                    doDataMap.put("contractMappings", contractMappings);
                    accInvoiceDAOobj.updateInvoiceUsingSet(doDataMap);
                }
            } else if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {// if Contracted Sales Order is Linked with Invoice
                Set<InvoiceContractMapping> contractMappings = getInvoiceContractMappingsFromSO(paramJobj, invoice);
                HashMap<String, Object> doDataMap = new HashMap<String, Object>();
                if (!contractMappings.isEmpty()) {
                    doDataMap.put("id", invoice.getID());
                    doDataMap.put("contractMappings", contractMappings);
                    accInvoiceDAOobj.updateInvoiceUsingSet(doDataMap);
                }
            }
            
            /**
             * When Avalara Integration is enabled, we save tax details in Avalara tax mapping table 'TransactionDetailAvalaraTaxMapping'
             * So there is no need to save InvoiceDetailTermMap in case Avalara Integration is enabled
             */
            if(extraCompanyPreferences.getLineLevelTermFlag()==1 && !extraCompanyPreferences.isAvalaraIntegration()) {
                Set<InvoiceDetail> invoiceDetailsSet = invoice.getRows();
                for (InvoiceDetail invoiceDetail : invoiceDetailsSet) {
                    if (invoiceDetail.getInventory() != null && FinalTerm != null && ((List) FinalTerm.get(invoiceDetail.getInventory()) != null)) {
                        List ll2 = (List) FinalTerm.get(invoiceDetail.getInventory());
                        Iterator itr2 = ll2.iterator();
                        while (itr2.hasNext()) {
                            HashMap<String, Object> termMap = (HashMap<String, Object>) itr2.next();
                            termMap.put("invoiceDetail", invoiceDetail);
                            accInvoiceDAOobj.saveInvoiceDetailTermMap(termMap);
                        }
                    }
                }
            }
            
            if(extraCompanyPreferences.isExciseApplicable() &&  countryid== Constants.indian_country_id) {
                Set<InvoiceDetail> invoiceDetailsSet = invoice.getRows();
                for (InvoiceDetail invoiceDetail : invoiceDetailsSet) {
                    if (invoiceDetail.getInventory() != null && supplierDetails != null && ((List) supplierDetails.get(invoiceDetail.getInventory()) != null)) {
                        List ll2 = (List) supplierDetails.get(invoiceDetail.getInventory());
                        Iterator itr2 = ll2.iterator();
                        while (itr2.hasNext()) {
                            HashMap<String, Object> supplierMap = (HashMap<String, Object>) itr2.next();
                            supplierMap.put("invoiceDetail", invoiceDetail);
                            supplierMap.put("company", company);
                            accInvoiceDAOobj.saveSupplierExciseDetailMap(supplierMap);
                        }
                    }
                }
            }

            String linkedDocuments = "";
            linkMode = paramJobj.optString("fromLinkCombo"); //When adding Sales order link for invoice update link flag(1) in sale order.
            String[] linkNumbers = paramJobj.optString("linkNumber").split(","); // array of linknumbers for multiple sales order
            if (!StringUtil.isNullOrEmpty(linkMode) && linkNumbers.length > 0) {
                if (linkMode.equalsIgnoreCase(Constants.SALESORDER) || linkMode.equalsIgnoreCase("Job Work Order")) {
                    for (int i = 0; i < linkNumbers.length; i++) {
                        if (!StringUtil.isNullOrEmpty(linkNumbers[i])) {
                            KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkNumbers[i]);
                            SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                            HashMap hMap = new HashMap();
                            hMap.put("salesOrder", salesOrder);
                            hMap.put("value", "1");
                            String status = getSalesOrderStatus(salesOrder);
                            boolean isSOOpen = false;
                            if(status.equals("Open")){
                                isSOOpen = true;
                            }
                            hMap.put("isSOOpen", isSOOpen);
                            accInvoiceDAOobj.updateSOLinkflag(hMap);

                            /*
                             * saving linking informaion of Sales Order while
                             * linking with Sales Invoice
                             */

                            HashMap<String, Object> requestParamsLinking = new HashMap<String, Object>();
                            requestParamsLinking.put("linkeddocid", invoice.getID());
                            requestParamsLinking.put("docid", linkNumbers[i]);
                            requestParamsLinking.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                            requestParamsLinking.put("linkeddocno", entryNumber);
                            requestParamsLinking.put("sourceflag", 0);
                            KwlReturnObject result3 = accSalesOrderDAOObj.saveSalesOrderLinking(requestParamsLinking);


                            /*
                             * saving linking informaion of Sales Invoice while
                             * linking with Sales Order
                             */
                            requestParamsLinking.put("linkeddocid", linkNumbers[i]);
                            requestParamsLinking.put("docid", invoice.getID());
                            requestParamsLinking.put(Constants.moduleid, Constants.Acc_Sales_Order_ModuleId);
                            requestParamsLinking.put("linkeddocno", salesOrder.getSalesOrderNumber());
                            requestParamsLinking.put("sourceflag", 1);
                            result3 = accInvoiceDAOobj.saveInvoiceLinking(requestParamsLinking);
                            linkedDocuments += salesOrder.getSalesOrderNumber()+ " ,";
                            /*If SO->SI then SO is manually closed--- */
                            if (isdropshipchecked) {
                                salesOrder.setIsSOClosed(true);
                            }

                        }
                    }
                    linkedDocuments = linkedDocuments.substring(0, linkedDocuments.length() - 1);
                }
            }

            linkMode = paramJobj.optString("fromLinkCombo"); //When adding Quotation link for invoice update link flag(1) in Quotation.
            String[] quolinkNumbers = paramJobj.optString("linkNumber").split(","); // array of linknumbers for multiple Quotation
            if (!StringUtil.isNullOrEmpty(linkMode) && quolinkNumbers.length > 0) {
                if (linkMode.equalsIgnoreCase(Constants.CUSTOMER_QUOTATION)) {
                    for (int i = 0; i < quolinkNumbers.length; i++) {
                        if (!StringUtil.isNullOrEmpty(quolinkNumbers[i])) {
                            updateOpenStatusFlagForSI(quolinkNumbers[i]);
                            
                            /*
                             * saving linking informaion of Customer Quotation
                             * while linking with Sales Invoice
                             */

                            HashMap<String, Object> requestParamsLinking = new HashMap<String, Object>();
                            requestParamsLinking.put("linkeddocid", invoice.getID());
                            requestParamsLinking.put("docid", quolinkNumbers[i]);
                            requestParamsLinking.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                            requestParamsLinking.put("linkeddocno", entryNumber);
                            requestParamsLinking.put("sourceflag", 0);
                            KwlReturnObject result3 = accSalesOrderDAOObj.saveQuotationLinking(requestParamsLinking);


                            /*
                             * saving linking informaion of Sales Invoice while
                             * linking with Customer Quotation
                             */
                            requestParamsLinking.put("linkeddocid", quolinkNumbers[i]);
                            requestParamsLinking.put("docid", invoice.getID());
                            requestParamsLinking.put(Constants.moduleid, Constants.Acc_Customer_Quotation_ModuleId);
                            KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(Quotation.class.getName(), quolinkNumbers[i]);
                            Quotation quotation = (Quotation) rdresult.getEntityList().get(0);
                            requestParamsLinking.put("linkeddocno", quotation.getquotationNumber());
                            requestParamsLinking.put("sourceflag", 1);
                            result3 = accInvoiceDAOobj.saveInvoiceLinking(requestParamsLinking);
                            linkedDocuments += quotation.getquotationNumber()+ " ,";
                        }
                    }
                     linkedDocuments = linkedDocuments.substring(0, linkedDocuments.length() - 1);
                }
            }
               linkMode = paramJobj.optString("fromLinkCombo");
            String[] dolinkNumbers = paramJobj.optString("linkNumber").split(",");
            if (linkMode.equalsIgnoreCase(Constants.Delivery_Order) ||linkMode.equalsIgnoreCase(Constants.Lease_Delivery_Order) ||linkMode.equalsIgnoreCase(Constants.Asset_Delivery_Order)) {
                for (int i = 0; i < dolinkNumbers.length; i++) {
                    if (!StringUtil.isNullOrEmpty(dolinkNumbers[i])) {
                        updateOpenStatusFlagForDOInSI(dolinkNumbers[i]);

                        /*
                         * saving linking informaion of Delivery Order while
                         * linking with Sales Invoice
                         */

                        HashMap<String, Object> requestParamsLinking = new HashMap<String, Object>();
                        requestParamsLinking.put("linkeddocid", invoice.getID());
                        requestParamsLinking.put("docid", dolinkNumbers[i]);
                        requestParamsLinking.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                        requestParamsLinking.put("linkeddocno", entryNumber);
                        requestParamsLinking.put("sourceflag", 0);
                        KwlReturnObject result3 = accInvoiceDAOobj.saveDeliveryOrderLinking(requestParamsLinking);


                        /*
                         * saving linking informaion of Sales Invoice while
                         * linking with Delivery Order
                         */
                        requestParamsLinking.put("linkeddocid", dolinkNumbers[i]);
                        requestParamsLinking.put("docid", invoice.getID());
                        requestParamsLinking.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), dolinkNumbers[i]);
                        DeliveryOrder deliveryorder = (DeliveryOrder) rdresult.getEntityList().get(0);
                        requestParamsLinking.put("linkeddocno", deliveryorder.getDeliveryOrderNumber());
                        requestParamsLinking.put("sourceflag", 1);
                        result3 = accInvoiceDAOobj.saveInvoiceLinking(requestParamsLinking);
                        linkedDocuments += deliveryorder.getDeliveryOrderNumber()+ " ,";
                    }
                }
                 linkedDocuments = linkedDocuments.substring(0, linkedDocuments.length() - 1);
            }

            if (isEdit == true) {
                int moduleid = Constants.Acc_Invoice_ModuleId;
                if (inCash) {
                    moduleid = Constants.Acc_Cash_Sales_ModuleId;
                }
                auditMessage = AccountingManager.BuildAuditTrialMessage(invoicePrmt, oldInvoicePrmt, moduleid, newAuditKey);
            }
            //Insert new entries again in optimized table.
            id = invoice.getID();

            String personalid = invoice.getCustomer().getAccount().getID();
            String accname = invoice.getCustomer().getAccount().getName();
            String invoiceno = invoice.getInvoiceNumber();
            String address = invoice.getCustomer().getBillingAddress();
            String fullShippingAddress = "";
            if (invoice.getBillingShippingAddresses() != null) {
                fullShippingAddress = invoice.getBillingShippingAddresses().getFullShippingAddress();
            }
            ll.add(new String[]{id, oldjeid});
            ll.add(discountArr);
            ll.add((pendingApprovalFlag == 1) ? "Pending Approval" : "Approved");
            ll.add(personalid);
            ll.add(accname);
            ll.add(invoiceno);
            ll.add(address);
            ll.add(totalInvAmount);
            ll.add(journalEntry.getEntryNumber());
           // ll.add(auditMessage); //ERP-13481 [SJ]
            ll.add(fullShippingAddress); 
            if (isLeaseFixedAsset && isEdit && hasRepeatInvoice) {
                ll.add(repeatedid);
                ll.add(intervalUnit);
                ll.add(intervalType);
                ll.add(sdate);
                ll.add(expdate);
                ll.add(noOfInvPost);
                ll.add(nextdate);
                ll.add(noOfInvRemainPost);
            }

            //Save record as template
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("templatename",null)) && (istemplate == 1 || istemplate == 2)) {
                HashMap<String, Object> hashMap = new HashMap<String, Object>();
                String moduletemplateid = paramJobj.optString("moduletemplateid");
                if (!StringUtil.isNullOrEmpty(moduletemplateid)) {
                    hashMap.put("moduletemplateid", moduletemplateid);
                }
                hashMap.put("templatename", paramJobj.optString("templatename"));
                if (!StringUtil.isNullOrEmpty(paramJobj.optString("populateproducttemplate", null)) && paramJobj.optString("populateproducttemplate").equalsIgnoreCase("on")) {
                    hashMap.put("populateproducttemplate", paramJobj.optBoolean("populateproducttemplate", true));
                } else {
                    hashMap.put("populateproducttemplate", false);
                }
                if (!StringUtil.isNullOrEmpty(paramJobj.optString("autogenerateDO", null)) && paramJobj.optString("autogenerateDO").equalsIgnoreCase("on")) {
                    hashMap.put("populateautodointemp", paramJobj.optBoolean("autogenerateDO", true));
                } else {
                    hashMap.put("populateautodointemp", false);
                }
                if (!StringUtil.isNullOrEmpty(paramJobj.optString("populatecustomertemplate", null)) && paramJobj.optString("populatecustomertemplate").equalsIgnoreCase("on")) {
                    hashMap.put("populatecustomertemplate", paramJobj.optBoolean("populatecustomertemplate", true));
                } else {
                    hashMap.put("populatecustomertemplate", false);
                }
                if (inCash) {
                    hashMap.put(Constants.moduleid, Constants.Acc_Cash_Sales_ModuleId);
                } else {
                    hashMap.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                }
                hashMap.put("modulerecordid", invoice.getID());
                hashMap.put(Constants.companyKey, companyid);
                if(!StringUtil.isNullOrEmpty(paramJobj.optString("companyunitid",null))){
                    hashMap.put("companyunitid", paramJobj.optString("companyunitid")); // Added Unit ID if it is present in request
                }
                /**
                 * checks the template name is already exist in create and edit template case
                 */
                result = accountingHandlerDAOobj.getModuleTemplateForTemplatename(hashMap);
                nocount = result.getRecordTotalCount();
                if (nocount > 0) {
                    throw new AccountingException(messageSource.getMessage("acc.tmp.templateNameAlreadyExists", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                }

                accountingHandlerDAOobj.saveModuleTemplate(hashMap);
            }

            if (preferences.isInventoryAccountingIntegration() && (!preferences.isWithInvUpdate() || inCash)) {

                String action = "17";
                boolean isDirectUpdateInvFlag = false;
                if (preferences.isUpdateInvLevel()) {
                    isDirectUpdateInvFlag = true;
                    action = "19";//Direct Inventory Update action
                }

                JSONArray productArray = new JSONArray();
                if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.detail,null))) {
                    JSONArray jArr = new JSONArray(paramJobj.optString(Constants.detail,"[]"));
                    for (int i = 0; i < jArr.length(); i++) {
                        JSONObject jobj = jArr.getJSONObject(i);
                        KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                        Product product = (Product) proresult.getEntityList().get(0);

                        JSONObject productObject = new JSONObject();
                        if (!StringUtil.isNullOrEmpty(invoiceid)) {
                            if (jobj.optDouble("changedQuantity", 0) != 0) {
                                productObject.put("itemUomId", jobj.getString("uomid"));
                                productObject.put("itemBaseUomRate", jobj.getDouble("baseuomrate"));
                                productObject.put("itemQuantity", jobj.getDouble("changedQuantity"));
                                productObject.put("quantity", jobj.getDouble("changedQuantity"));
                                productObject.put("itemCode", product.getProductid());
                                if (isDirectUpdateInvFlag) {
                                    productObject.put("storeid", jobj.optString("invstore"));
                                    productObject.put("locationid", jobj.optString("invlocation"));
                                    productObject.put("rate", jobj.optDouble("rate", 0));
                                }
                                productArray.put(productObject);
                            }
                        } else {
                            productObject.put("itemUomId", jobj.getString("uomid"));
                            productObject.put("itemBaseUomRate", jobj.getDouble("baseuomrate"));
                            productObject.put("itemQuantity", jobj.getDouble("baseuomquantity") * (-1));
                            productObject.put("quantity", jobj.getDouble("quantity") * (-1));
                            productObject.put("itemCode", product.getProductid());
                            if (isDirectUpdateInvFlag) {
                                productObject.put("storeid", jobj.optString("invstore"));
                                productObject.put("locationid", jobj.optString("invlocation"));
                                productObject.put("rate", jobj.optDouble("rate", 0));
                            }
                            productArray.put(productObject);
                        }
                    }

                    if (!StringUtil.isNullOrEmpty(invoiceid)) {
                        if (!StringUtil.isNullOrEmpty(paramJobj.optString("deletedData",null))) {
                            JSONArray deleteArr = new JSONArray(paramJobj.optString("deletedData","[]"));
                            for (int i = 0; i < deleteArr.length(); i++) {
                                JSONObject jobj = deleteArr.getJSONObject(i);

                                KwlReturnObject proresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                                Product product = (Product) proresult.getEntityList().get(0);

                                JSONObject productObject = new JSONObject();
                                productObject.put("itemUomId", jobj.getString("productuomid"));
                                productObject.put("itemBaseUomRate", jobj.getDouble("productbaseuomrate"));
                                productObject.put("itemQuantity", jobj.getDouble("productbaseuomquantity"));
                                productObject.put("quantity", jobj.getDouble("productquantity"));
                                productObject.put("itemCode", product.getProductid());
                                if (isDirectUpdateInvFlag) {
                                    productObject.put("storeid", jobj.optString("productinvstore"));
                                    productObject.put("locationid", jobj.optString("productinvlocation"));
                                    productObject.put("rate", jobj.optDouble("productrate", 0));
                                }
                                productArray.put(productObject);
                            }
                        }
                    }

                    if (productArray.length() > 0) {

                        String sendDateFormat = Constants.yyyyMMdd;
                        DateFormat dateformat = new SimpleDateFormat(sendDateFormat);
                        Date date = df.parse(paramJobj.optString(Constants.BillDate));
                        String stringDate = dateformat.format(date);

                        JSONObject jSONObject = new JSONObject();
                        jSONObject.put("deliveryDate", stringDate);
                        jSONObject.put("dateFormat", sendDateFormat);
                        jSONObject.put("details", productArray);
                        jSONObject.put("orderNumber", entryNumber);
                        jSONObject.put("selling", true);

                        String url =  paramJobj.optString(Constants.inventoryURL);
                        CommonFnController cfc = new CommonFnController();
//                        cfc.updateInventoryLevel(request, jSONObject, url, action);
                        cfc.updateInventoryLevel(paramJobj, jSONObject, url, action);
                    }
                }
            }

            /**
             * Save GST History Customer/Vendor data.
             */
            if (invoice.getCompany().getCountry().getID().equalsIgnoreCase("" + Constants.indian_country_id)) {
                int moduleid = 0;
                if (isFixedAsset) {
                    moduleid = Constants.Acc_FixedAssets_DisposalInvoice_ModuleId;
                } else if (isLeaseFixedAsset) {
                    moduleid = Constants.LEASE_INVOICE_MODULEID;
                } else {
                    moduleid = Constants.Acc_Invoice_ModuleId;
                }
                paramJobj.put("docid", invoice.getID());
                paramJobj.put("moduleid", moduleid);
                fieldDataManagercntrl.createRequestMapToSaveDocHistory(paramJobj);
            }
            String template = " template for record ";
            if (istemplate == 0) {
                template = "";
            }
            String action = "added new";
            if (isEdit == true && isCopy == false) {
                action = "updated";
            }
            if(isLeaseFixedAsset) {
                action += " Lease";
            }
//            /* Preparing Audit trial message if document is linking at teh time of creating */  // Commenting this code for SDP-11270 
//            String linkingMessages = ""; 
//            if (!StringUtil.isNullOrEmpty(linkedDocuments) && !StringUtil.isNullOrEmpty(linkMode)) {
//                linkingMessages = " by Linking to " + linkMode + " " + linkedDocuments;
//            }
//            Map<String, Object> auditRequestParams = new HashMap<String, Object>();
//            auditRequestParams.put(Constants.reqHeader, paramJobj.getString(Constants.reqHeader));
//            auditRequestParams.put(Constants.remoteIPAddress, paramJobj.getString(Constants.remoteIPAddress));
//            auditRequestParams.put(Constants.useridKey, paramJobj.getString(Constants.useridKey));
//            
//            
//            if (!inCash) {
////                auditTrailObj.insertAuditLog(AuditAction.INVOICE_CREATED, "User " + paramJobj.optString(Constants.userfullname) + " has " + action + template + (isConsignment?" Consignment Sales Invoice ":" Customer Invoice ") + recId+linkingMessages+(pendingApprovalFlag==1 ? " "+messageSource.getMessage("acc.field.whichispendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : "") + auditMessage , request, tranID );//    ERP-18011
//                auditTrailObj.insertAuditLog(AuditAction.INVOICE_CREATED, "User " + paramJobj.optString(Constants.userfullname) + " has " + action + template +  (isConsignment?" Consignment Sales Invoice ":isFixedAsset?" Asset Disposal Invoice ":" Customer Invoice ") + recId+linkingMessages+(pendingApprovalFlag==1 ? " "+messageSource.getMessage("acc.field.whichispendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : "") + auditMessage , auditRequestParams, tranID );//    ERP-18011
//                 /*Inserting Entry in Audit trial when any document is unlinking through Edit*/
//                if (!StringUtil.isNullOrEmpty(unlinkMessage)) {
////                    auditTrailObj.insertAuditLog(action, "User " + paramJobj.optString(Constants.userfullname) + " has unlinked " + "Sales Invoice " + recId + unlinkMessage + ".", request, recId);
//                    auditTrailObj.insertAuditLog(action, "User " + paramJobj.optString(Constants.userfullname) + " has unlinked " + "Sales Invoice " + recId + unlinkMessage + ".", auditRequestParams, recId);
//                }
//
//                } else if (entryNumber != null) {
////                auditTrailObj.insertAuditLog(AuditAction.CASH_SALES_CREATED, "User " + paramJobj.optString(Constants.userfullname) + " has " + action + template + " Cash Sales " + recId+(pendingApprovalFlag==1 ? " "+messageSource.getMessage("acc.field.whichispendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : "") + auditMessage, request, tranID);
//                auditTrailObj.insertAuditLog(AuditAction.CASH_SALES_CREATED, "User " + paramJobj.optString(Constants.userfullname) + " has " + action + template + " Cash Sales " + recId+(pendingApprovalFlag==1 ? " "+messageSource.getMessage("acc.field.whichispendingforApproval", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))) : "") + auditMessage, auditRequestParams, tranID);
//                }
            String moduleName =Constants. moduleID_NameMap.get(Acc_Invoice_ModuleId);
            if(isLeaseFixedAsset){
                moduleName = Constants. moduleID_NameMap.get(LEASE_INVOICE_MODULEID);
            }
            if(iscash){
                moduleName = Constants.CASH_SALE;
            }
            if(isFixedAsset){
                moduleName = Constants.DISPOSAL_INVOICE;
            }
            if(isConsignment){
                moduleName = Constants.moduleID_NameMap.get(Acc_ConsignmentInvoice_ModuleId);
            }

            DocumentEmailSettings documentEmailSettings = null;
            KwlReturnObject documentEmailresult = accountingHandlerDAOobj.getObject(DocumentEmailSettings.class.getName(), paramJobj.getString(Constants.companyKey));
            documentEmailSettings = documentEmailresult != null ? (DocumentEmailSettings) documentEmailresult.getEntityList().get(0) : null;
            if (extraCompanyPreferences != null) {
                boolean sendmail = false;
                boolean isEditMail = false;
                if (StringUtil.isNullOrEmpty(invoiceid)) { // create new case 
                    if (isLeaseFixedAsset && documentEmailSettings.isLeaseInvoiceGenerationMail()) {
                        sendmail = true;
                    } else if (isConsignment && documentEmailSettings.isConsignmentInvoiceGenerationMail()) {
                        sendmail = true;
                    } else if (isFixedAsset && documentEmailSettings.isAssetDisposalInvoiceGenerationMail()) {
                        sendmail = true;
                    } else if (documentEmailSettings.isSalesInvoiceGenerationMail() && pendingApprovalFlag != 1) {
                        sendmail = true;
                    }
                } else { // edit case
                        isEditMail = true;
                        if (isLeaseFixedAsset && documentEmailSettings.isLeaseInvoiceUpdationMail()) {
                            sendmail = true;
                        } else if (isConsignment && documentEmailSettings.isConsignmentInvoiceUpdationMail()) {
                            sendmail = true;
                        } else if (isFixedAsset && documentEmailSettings.isAssetDisposalInvoiceUpdationMail()) {
                            sendmail = true;
                        } else if (documentEmailSettings.isSalesInvoiceUpdationMail()&& pendingApprovalFlag != 1) {
                            sendmail = true;
                        }

                    
                }

                if (sendmail) {           //if allow to send alert mail when option selected in companypreferences
                    String userMailId="",userName="",currentUserid="";
                    String createdByEmail = "";
                    String createdById = "";
                    HashMap<String, Object> requestParams1= AccountingManager.getEmailNotificationParamsJson(paramJobj);
                    if(requestParams1.containsKey("userfullName")&& requestParams1.get("userfullName")!=null){
                        userName=(String)requestParams1.get("userfullName");
                    }
                    if(requestParams1.containsKey("usermailid")&& requestParams1.get("usermailid")!=null){
                        userMailId=(String)requestParams1.get("usermailid");
                    }
                    if(requestParams1.containsKey(Constants.useridKey)&& requestParams1.get(Constants.useridKey)!=null){
                        currentUserid=(String)requestParams1.get(Constants.useridKey);
                    }
                    List<String> mailIds = new ArrayList();
                    if (!StringUtil.isNullOrEmpty(userMailId)) {
                        mailIds.add(userMailId);
                    }
                    /*
                     if Edit mail option is true then get userid and Email id of document creator.
                    */
                     if (isEditMail) {
                         if (invoice != null && invoice.getCreatedby() != null) {
                             createdByEmail = invoice.getCreatedby().getEmailID();
                             createdById = invoice.getCreatedby().getUserID();
                         }
                         /*
                          if current user userid == document creator userid then don't add creator email ID in List.
                          */
                         if (!StringUtil.isNullOrEmpty(createdByEmail) && !(currentUserid.equalsIgnoreCase(createdById))) {
                             mailIds.add(createdByEmail);
                         }
                     }
                    String[] temp = new String[mailIds.size()];
                    String[] tomailids = mailIds.toArray(temp);
                    String srNumber = entryNumber;
                    accountingHandlerDAOobj.sendSaveTransactionEmails(srNumber, moduleName, tomailids, userName, isEditMail, companyid);
                }
                
                
                // Check if invoice has contract mapping then set it as recurring
                if (StringUtil.isNullOrEmpty(invoiceid)) {// only for create new case
                    
                    boolean isNotAReplacementInvoice = true;
                    
                    // in DO Linking Case, gett docontractmapping of DO and find out that, this do is for replacement or not
                    if (linkMode.equalsIgnoreCase(Constants.Delivery_Order)) {
                        boolean isReplacementDO = isReplacementDO(paramJobj);
                        if (isReplacementDO) {
                            isNotAReplacementInvoice = false;
                        }
                    } else if (linkMode.equalsIgnoreCase(Constants.SALESORDER)) {// if Contracted Sales Order is Linked with Invoice
                        boolean isReplacementSO = isReplacementSO(paramJobj);
                        if (isReplacementSO) {
                            isNotAReplacementInvoice = false;
                        }
                    }
                    
                    if (invoice.getContractMappings() != null && !invoice.getContractMappings().isEmpty() && isNotAReplacementInvoice) {

                        Contract contract = null;
                        isContractMapping = true;
                        paramJobj.put("isContractMapping", isContractMapping);
                        Set<InvoiceContractMapping> contractMappings = invoice.getContractMappings();
                        for (InvoiceContractMapping contractMapping : contractMappings) {
                            contract = contractMapping.getContract();
                        }

                        if (contract != null && contract.getInvoiceFrequency()!=null && !contract.getInvoiceFrequency().equals("other") && (contract.getNumberOfPeriods()-1)>1) {// in case of frequency type other no need to set invoice as recurring, and one invoice is being create in saveInvoice method
                            HashMap<String, Object> repeatMap = new HashMap<String, Object>();
                            
                            // Calculate next invoice date according to invoice creation date,
                            // ie next invoice date = invoice creation date+duration
                            Date nextRecurringDate = getRecurringInvoiceNextDate(invoice, contract,paramJobj);
                            repeatMap.put("startDate", nextRecurringDate);
                            repeatMap.put("expireDate", contract.getEndDate());
                            repeatMap.put("interval", 1);// as it is daily , weekely, monthly, yearly
                            repeatMap.put("NoOfpost", contract.getNumberOfPeriods()-1);// as first invoice is being create at here
                            repeatMap.put("intervalType", contract.getInvoiceFrequency());// as it is daily , weekely, monthly, yearly
                            repeatMap.put("invoiceid", invoice.getID());
                            repeatMap.put("isactivate", true);
                            repeatMap.put("userdf", authHandler.getUserDateFormatterWithoutTimeZone(paramJobj));
                            repeatMap.put("PendingApprove", invoice.getPendingapproval());// as it is daily , weekely, monthly, yearly
                            RepeatedInvoices repeatinv = saveRepeatInvoice(repeatMap);
                            if (repeatinv != null && isLeaseFixedAsset) {    //Only for Newly created invoice
                                ll.add(repeatinv.getId());
                                ll.add(1);  //repeatinv.getIntervalUnit();  Default 1 for Contract based Invoice
                                ll.add(repeatinv.getIntervalType());
                                ll.add(repeatinv.getStartDate());
                                ll.add(repeatinv.getExpireDate());
                                ll.add(repeatinv.getNoOfInvoicespost());
                                ll.add(repeatinv.getNextDate());
                                ll.add(repeatinv.getNoOfRemainInvoicespost());
                                paramJobj.put("isRepeatInvoiceCreated", true);
                            }
                            
                        }

                    }
                }
                
            }//if(extraCompanyPreferences)
           ll.add(mailParams);
           ll.add(unlinkMessage);
           ll.add(linkedDocuments);
           ll.add(auditMessage);
           ll.add(pendingApprovalFlag);
           ll.add(invoice);
           
            /*-----Added parameter is relevant while Editing pending document-------*/
            ll.add(roleName);
            ll.add(isAuthorityToApprove);
            ll.add(sendPendingDocumentsToNextLevel);
            ll.add(JENumber);
            ll.add(JEMsg);
            ll.add(levelOnWhichDocumentIsApproved);
           
        } catch (ParseException ex) {
            //Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        } catch (JSONException ex) {
            //Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }catch (ScriptException ex) {
            //Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }catch (MessagingException ex) {
            //Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }

        return ll;
    }

    /**
     * Method to delete tax details from TransactionDetailAvalaraTaxMapping table when Avalara Integration is enabled
     * @param companyid
     * @param invoiceid
     * @throws JSONException
     * @throws ServiceException 
     */
    private void deleteAvalaraTaxMappingForInvoice(String invoiceid, String companyid) throws JSONException, ServiceException {
        Map<String, String> requestParamsForInvoiceDetialIDs = new HashMap<>();
        requestParamsForInvoiceDetialIDs.put("fetchColumn", "ID");
        requestParamsForInvoiceDetialIDs.put("tableName", "InvoiceDetail");
        requestParamsForInvoiceDetialIDs.put("companyColumn", "company.companyID");
        requestParamsForInvoiceDetialIDs.put(Constants.companyKey, companyid);
        requestParamsForInvoiceDetialIDs.put("condtionColumn", "invoice.ID");
        requestParamsForInvoiceDetialIDs.put("condtionColumnvalue", invoiceid);
        KwlReturnObject invoiceDetailIDsKwlObj = accountingHandlerDAOobj.populateMasterInformation(requestParamsForInvoiceDetialIDs);
        List<String> invoiceDetailIDsList = invoiceDetailIDsKwlObj.getEntityList();
        if (invoiceDetailIDsList != null && !invoiceDetailIDsList.isEmpty()) {
            //to create a comma separated string of InvoiceDetail IDs for 'IN' subquery
            String invoiceDetailIDsStr = org.springframework.util.StringUtils.collectionToDelimitedString(invoiceDetailIDsList, ",", "'", "'");
            JSONObject avalaraTaxDeleteJobj = new JSONObject();
            avalaraTaxDeleteJobj.put(IntegrationConstants.parentRecordID, invoiceDetailIDsStr);
            integrationCommonService.deleteTransactionDetailTaxMapping(avalaraTaxDeleteJobj);
        }
    }
 
    public RepeatedInvoices saveRepeatInvoice(HashMap<String, Object> dataMap) throws ServiceException {
        RepeatedInvoices rinvoice = null;
        try {
            Date startDate = (Date) dataMap.get("startDate");
            Date expireDate = (Date) dataMap.get("expireDate");
            int interval = (Integer) dataMap.get("interval");
            int NoOfpost = (Integer) dataMap.get("NoOfpost");
            boolean isactivate = false;
            if (dataMap.containsKey("isactivate")) {
                isactivate = (Boolean) dataMap.get("isactivate");
            }
            int PendingApprove = (Integer) dataMap.get("PendingApprove");
            String intervalType = (String) dataMap.get("intervalType");
            String invoiceid = (String) dataMap.get("invoiceid");
            DateFormat userdf = (DateFormat)dataMap.get("userdf");
            HashMap<String, Object> requestMap = new HashMap<String, Object>();

            requestMap.put("intervalUnit", interval);
            requestMap.put("NoOfpost", NoOfpost);
            requestMap.put("intervalType", intervalType);
            requestMap.put("startDate", startDate);
            requestMap.put("isactivate", isactivate);
            requestMap.put("nextDate", startDate);
            requestMap.put("expireDate", expireDate);

            KwlReturnObject rObj = accInvoiceDAOobj.saveRepeateInvoiceInfo(requestMap);
            rinvoice = (RepeatedInvoices) rObj.getEntityList().get(0);

            JSONObject invjson = new JSONObject();
            invjson.put("invoiceid", invoiceid);
            invjson.put("repeateid", rinvoice.getId());
            invjson.put("pendingapproval", PendingApprove);

            accInvoiceDAOobj.updateInvoice(invjson, null);
            for (int i = 0; i < rinvoice.getNoOfInvoicespost(); i++) {
                HashMap<String, Object> dataMapformemo = new HashMap<String, Object>();
                dataMapformemo.put("no", i + 1);
                Date mdate = rinvoice.getStartDate();                
                Calendar c = Calendar.getInstance();
                c.setTime(mdate);
                c.add(Calendar.DATE, i);
                mdate = c.getTime();
                String memodate = userdf.format(mdate);
                dataMapformemo.put(Constants.memo, "Invoice"+memodate);                
                dataMapformemo.put("RepeatedInvoiceID", rinvoice.getId());
                accJournalEntryobj.saveRepeateJEMemo(dataMapformemo);
            }
        } catch (JSONException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("saveRepeatInvoice : " + ex.getMessage(), ex);
        } catch (ServiceException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            throw ServiceException.FAILURE("saveRepeatInvoice : " + ex.getMessage(), ex);
        }
        return rinvoice;
    }
    
    public Date getRecurringInvoiceNextDate(Invoice invoice, Contract contract, JSONObject paramJobj) throws SessionExpiredException, ParseException, JSONException {
        Date date = null;
        Date nextRecurringDate = new Date();
        SimpleDateFormat sdfm = new SimpleDateFormat("MMMM d, yyyy hh:mm:ss aa");
        if (invoice != null) {
            date = sdfm.parse(paramJobj.getString(Constants.BillDate));//using this date formater because date taking one day before for CDT time zone
            Calendar cal = Calendar.getInstance();
            cal.setTime(date);

            Date calDate = null;

            String intervalType = contract.getInvoiceFrequency();

            if (intervalType.equals("day")) {
                cal.add(Calendar.DATE, 1);
                String calString = authHandler.getDateOnlyFormat().format(cal.getTime());
                try {
                    calDate = authHandler.getDateOnlyFormat().parse(calString);
                } catch (ParseException ex) {
                    calDate = cal.getTime();
                    Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
                }
                nextRecurringDate = calDate;
            } else if (intervalType.equals("week")) {
                cal.add(Calendar.WEEK_OF_YEAR, 1);
                String calString = authHandler.getDateOnlyFormat().format(cal.getTime());
                try {
                    calDate = authHandler.getDateOnlyFormat().parse(calString);
                } catch (ParseException ex) {
                    calDate = cal.getTime();
                    Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
                }
                nextRecurringDate = calDate;
            } else if (intervalType.equals("month")) {
                cal.add(Calendar.MONTH, 1);
                String calString = authHandler.getDateOnlyFormat().format(cal.getTime());
                try {
                    calDate = authHandler.getDateOnlyFormat().parse(calString);
                } catch (ParseException ex) {
                    calDate = cal.getTime();
                    Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
                }
                nextRecurringDate = calDate;
            }

        }
        return nextRecurringDate;
    }

    public boolean isReplacementSO(JSONObject paramJobj) throws ServiceException {
        boolean isReplacementSO = false;
        String[] salesOrderIds = paramJobj.optString("linkNumber","").split(",");

        for (int i = 0; i < salesOrderIds.length; i++) {
            KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), salesOrderIds[i]);
            SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
            if (salesOrder.isIsReplacementSO() || salesOrder.getLeaseOrMaintenanceSO() == 2) {
                isReplacementSO = true;
            }
        }
        return isReplacementSO;
    }
   
   
   //Appending values in Map to build Audit Trial
    public void setValuesForAuditTrialMessage(Invoice oldgrd,JSONObject paramJobj,Map<String,Object> oldgreceipt, Map<String,Object> greceipthm, boolean inCash, Map<String, Object>newAuditKey) throws SessionExpiredException {
         DateFormat df = authHandler.getDateOnlyFormat();
        try {
             Map fieldCheck=new HashMap<String, String>();
          fieldCheck.put("",""); 
            
             //Setting values in map for oldgreceipt
            if (oldgrd != null) {
                if (oldgrd.getTermid() != null) {
                    KwlReturnObject olddebittermresult = accountingHandlerDAOobj.getObject(Term.class.getName(), oldgrd.getTermid().getID());
                    Term term = (Term) olddebittermresult.getEntityList().get(0);
                    oldgreceipt.put(Constants.DebitTermName, term.getTermname());
                    newAuditKey.put(Constants.DebitTermName, "Debit Term");
                }
                KwlReturnObject currobretrurnlist = accountingHandlerDAOobj.getObject(KWLCurrency.class.getName(), oldgrd.getCurrency().getCurrencyID());
                KWLCurrency oldcurrencyobj = (KWLCurrency) currobretrurnlist.getEntityList().get(0);
                KwlReturnObject customerbretrurnlist = accountingHandlerDAOobj.getObject(Customer.class.getName(), oldgrd.getCustomer().getID());
                Customer oldcustomer = (Customer) customerbretrurnlist.getEntityList().get(0);
                   oldgreceipt.put(Constants.CustomerName, oldcustomer.getName());
                   newAuditKey.put(Constants.CustomerName, "Customer");
                   oldgreceipt.put(InvoiceConstants.entrynumber, oldgrd.getInvoiceNumber());
                   newAuditKey.put(InvoiceConstants.entrynumber, "Entry Number");
                   oldgreceipt.put(Constants.CurrencyName, oldcurrencyobj.getName());//Currency name
                   newAuditKey.put(Constants.CurrencyName, "Currency");
                   oldgreceipt.put(InvoiceConstants.memo, StringUtil.isNullOrEmpty(oldgrd.getMemo()) ? "" : oldgrd.getMemo());
                   newAuditKey.put(InvoiceConstants.memo, "Memo");

                  oldgreceipt.put("shipvia", StringUtil.isNullOrEmpty(oldgrd.getShipvia()) ? "" : oldgrd.getShipvia());
                  newAuditKey.put("shipvia", "Ship Via");
                  oldgreceipt.put(Constants.fob, StringUtil.isNullOrEmpty(oldgrd.getFob()) ? "" : oldgrd.getFob());
                  newAuditKey.put(Constants.fob, "FOB");
                  oldgreceipt.put(InvoiceConstants.duedate, oldgrd.getDueDate() != null ? df.parse(df.format(oldgrd.getDueDate())) : "");
                  newAuditKey.put(InvoiceConstants.duedate, "Due Date");
                  oldgreceipt.put(InvoiceConstants.shipdate, oldgrd.getShipDate() != null ? df.parse(df.format(oldgrd.getShipDate())) : "");
                  newAuditKey.put(InvoiceConstants.shipdate, "Ship Date");
                  oldgreceipt.put(InvoiceConstants.entrydate, oldgrd.getCreationDate() != null ? df.parse(df.format(oldgrd.getCreationDate())) : df.parse(df.format(oldgrd.getJournalEntry().getEntryDate())));
                  newAuditKey.put(InvoiceConstants.entrydate, "Entry Date");
            } 
            
                //Setting values in map for greceipthm
            String termid = null, currencyid = null, custId = null;
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                custId = (paramJobj.has("CustomerName") && paramJobj.get("CustomerName") != null) ? paramJobj.getString("CustomerName") : null;
                currencyid = paramJobj.optString(Constants.currencyName, null);
                termid = (paramJobj.has("terms") && paramJobj.get("terms") != null) ? paramJobj.getString("terms") : null;
            } else {
                custId = paramJobj.optString(InvoiceConstants.customerid, null);
                currencyid = paramJobj.optString(InvoiceConstants.currencyid, null);
                termid = paramJobj.optString("termid", null);
            }

            if (!inCash) {
                KwlReturnObject debittermresult = accountingHandlerDAOobj.getObject(Term.class.getName(), termid);
                Term term = (Term) debittermresult.getEntityList().get(0);
                greceipthm.put(Constants.DebitTermName, term.getTermname());//Debit Term Name
            }

            KwlReturnObject newcurrencyreturnobj = accountingHandlerDAOobj.getObject(KWLCurrency.class.getName(),currencyid);
            KWLCurrency newcurrencyobj = (KWLCurrency) newcurrencyreturnobj.getEntityList().get(0);
            greceipthm.put(Constants.CurrencyName, newcurrencyobj.getName());//Currencey name
            KwlReturnObject currobretrurnlist = accountingHandlerDAOobj.getObject(Customer.class.getName(), custId);
            Customer newvendor = (Customer) currobretrurnlist.getEntityList().get(0);
           greceipthm.put(Constants.CustomerName, newvendor.getName());//Vendor Name
            
        } catch (Exception ex) {
             Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
    }  
    
  private List saveInvoiceRowsJSON(JSONObject paramJobj, String invoiceDetails, String jeid, Company company, HashSet jeDetails, String currencyid, Double externalCurrencyRate,Map<Integer,List<String>> invDetailTermMap) throws ServiceException, SessionExpiredException, AccountingException, UnsupportedEncodingException {
        HashSet hs = new HashSet(), rows = new HashSet();
        Map<Inventory, List<HashMap>> FinalTerm = new HashMap<Inventory, List<HashMap>>();
        Map<Inventory, List<HashMap>> supplierDetails = new HashMap<Inventory, List<HashMap>>();
        ArrayList<String> prodList = new ArrayList<String>();
        double totaldiscount = 0, totalamount = 0, taxamount = 0,partamount = 0,partialDiscount=0,totalPartialDiscount=0;
        double sumOfDiscountAmount=0.0;                              //To store the sum of discount amount which is return from saveInvoiceRows of product which does not has discount applied from discount master
        List ll = new ArrayList();
        try {
            int countryid = Integer.parseInt(company.getCountry().getID());
            String companyid = company.getCompanyID();
            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
            KwlReturnObject extraCompanyPreferencesObj = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extraCompanyPreferencesObj.getEntityList().get(0);
            boolean gstIncluded =false;        
            /* Mobile Application*/
            if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                gstIncluded = (StringUtil.isNullOrEmpty(paramJobj.optString("gstIncluded", null))) ? false : Boolean.parseBoolean(paramJobj.getString("gstIncluded"));
            } else {
                gstIncluded = paramJobj.optString("includingGST", null) == null ? false : Boolean.parseBoolean(paramJobj.optString("includingGST"));
            }
            String customerAccountid= paramJobj.optString("customerAccountid");
            /*
             * isJobWorkOutRemain is true if sales invoice is creating from Aged order work report.
             */
            boolean isjobworkwitoutgrn = (!StringUtil.isNullOrEmpty(paramJobj.optString("isjobworkwitoutgrn",null))) ? Boolean.parseBoolean(paramJobj.optString("isjobworkwitoutgrn")) : false;
            
            boolean isFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isFixedAsset",null))) ? Boolean.parseBoolean(paramJobj.optString("isFixedAsset")) : false;
            boolean isLeaseFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isLeaseFixedAsset",null))) ? Boolean.parseBoolean(paramJobj.optString("isLeaseFixedAsset")) : false;
            boolean isConsignment = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment,null))) ? Boolean.parseBoolean(paramJobj.optString(Constants.isConsignment)) : false;
            boolean includeProductTax = StringUtil.isNullOrEmpty(paramJobj.optString("includeprotax",null)) ? false : Boolean.parseBoolean(paramJobj.optString("includeprotax"));
            boolean RCMApplicable = false;
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("GTAApplicable", null))) {
                RCMApplicable = paramJobj.optBoolean("GTAApplicable", false);
            }
            boolean isLinkedWithDO = false;
            boolean partialInv = (paramJobj.optString("partialinv",null) != null) ? Boolean.parseBoolean(paramJobj.optString("partialinv")) : false;
            JournalEntry journalEntry = null;
            JSONArray jArr = new JSONArray(invoiceDetails);
            Set<String> productNameRCMNotActivate = new HashSet<String>();
            for (int i = 0; i < jArr.length(); i++) {

                JSONObject jobj = jArr.getJSONObject(i);
                InvoiceDetail row = new InvoiceDetail();
                JournalEntryDetail jed;
                
                if (jobj.has("srno")) {
                    row.setSrno(jobj.getInt("srno"));
                    List termidslist = new ArrayList();
                    if (!StringUtil.isNullOrEmpty(jobj.optString("termids"))) {
                        String[] termids = jobj.optString("termids").split(",");
                        for (String id : termids) {
                            if (!StringUtil.isNullOrEmpty(id)) {
                                termidslist.add(id);
                            }
                        }
                        invDetailTermMap.put(jobj.getInt("srno"), termidslist);
                    }
                } else {
                    row.setSrno(i+1);
                }
                
                /*
                 * isJobWorkOutRemain is true if sales invoice is creating from Aged order work report.
                 */
                if (isjobworkwitoutgrn) {
                    if (jobj.has(Constants.billid)) {
                        row.setJobworkId(jobj.optString(Constants.billid));
                    }
                    if (isjobworkwitoutgrn) {
                        row.setIsjobWorkWitoutGrn(isjobworkwitoutgrn);
                    }
                    if (jobj.has("selectedJobStockOutid")) {
                        double qty=Double.parseDouble((String)jobj.optString("quantity"));
                        accProductObj.updateJobWorkDetailsAsClose(jobj.optString("selectedJobStockOutid"), companyid);
                        row.setInterstoretransferId(jobj.optString("selectedJobStockOutid"));
                    }
                }
                if(gstIncluded){
                    if(jobj.has("lineleveltermamount")){
                        row.setLineLevelTermAmount(jobj.optDouble("lineleveltermamount",0));
                    }
                }
                row.setWasRowTaxFieldEditable(true);// this field has been added after making row tax field editable its value will be set always true from its implementation. i.e from 28-jan-2014.REASON -  when Row Tax Amount field was not editable then tax calculation was taking place according to tax percent, as selected From Tax combo in JS Side.
                
                if (jobj.has("priceSource")) {
                    row.setPriceSource(!StringUtil.isNullOrEmpty(jobj.optString("priceSource")) ? StringUtil.DecodeText(jobj.optString("priceSource")) : "");
                }
                
                if (!StringUtil.isNullOrEmpty(jobj.optString("desc"))) {
                    try {
                        row.setDescription(StringUtil.DecodeText(jobj.optString("desc")));
                    } catch (Exception ex) {
                        row.setDescription(jobj.optString("desc"));
                    }
                }
                
                if (jobj.has("discountjson")) {
                    String discountjson=jobj.optString("discountjson", "");
                    discountjson=!StringUtil.isNullOrEmpty(discountjson)?StringUtil.decodeString(discountjson):"";
                    row.setDiscountJson(discountjson);
                }
                
                KwlReturnObject prdresult = accountingHandlerDAOobj.getObject(Product.class.getName(), jobj.getString(Constants.productid));
                Product product = (Product) prdresult.getEntityList().get(0);

                double profitLossAmt = 0d;

                JSONArray jedForCustomFields = new JSONArray();
                
/**
                 * Put job order item data
                 */
                if (jobj.optBoolean("joborderitem", false)) {
                    row.setJobOrderItem(true);
                } else {
                    row.setJobOrderItem(false);
                }

                if (!StringUtil.isNullOrEmpty(jobj.optString("invstore"))) {
                    row.setInvstoreid(jobj.optString("invstore"));
                } else {
                    row.setInvstoreid("");
                }

                if (!StringUtil.isNullOrEmpty(jobj.optString("invlocation"))) {
                    row.setInvlocid(jobj.optString("invlocation"));
                } else {
                    row.setInvlocid("");
                }

                String linkMode = paramJobj.optString("fromLinkCombo");
                boolean updateInventoryFlag = (preferences.isWithInvUpdate()) ? false : true;

                partamount = (jobj.has("partamount") && (!StringUtil.isNullOrEmpty(jobj.get("partamount").toString()))) ? jobj.getDouble("partamount") : 0.0;
                row.setPartamount(partamount);
                partialDiscount = (jobj.has("partialDiscount") && (!StringUtil.isNullOrEmpty(jobj.get("partialDiscount").toString()))) ? jobj.getDouble("partialDiscount") : 0.0;
                partialDiscount = authHandler.round(partialDiscount, companyid);
                row.setPartialDiscount(partialDiscount);
                totalPartialDiscount += partialDiscount;
                double gstCurrencyRate = (jobj.has("gstCurrencyRate") && (!StringUtil.isNullOrEmpty(jobj.get("gstCurrencyRate").toString()))) ? jobj.getDouble("gstCurrencyRate") : 0.0;
                row.setGstCurrencyRate(gstCurrencyRate);

                if (!StringUtil.isNullOrEmpty(linkMode)) {
                    if (linkMode.equalsIgnoreCase(Constants.SALESORDER) || linkMode.equalsIgnoreCase("Job Work Order")) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        SalesOrderDetail rd = (SalesOrderDetail) rdresult.getEntityList().get(0);
                        row.setSalesorderdetail(rd);

                        if (updateInventoryFlag && partialInv) {
                            double sodAmount = rd.getQuantity() * 100;

                            double invDetailAmount = getInvoiceDetailAMount(rd);
                            invDetailAmount += jobj.getDouble("quantity") * partamount;
                            if (sodAmount > invDetailAmount) {
                                updateInventoryFlag = false;
                            }
                        }
                    } else if (linkMode.equalsIgnoreCase(Constants.Delivery_Order) || linkMode.equalsIgnoreCase(Constants.Lease_Delivery_Order) || linkMode.equalsIgnoreCase(Constants.Asset_Delivery_Order)) {
                        isLinkedWithDO = true;
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrderDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        DeliveryOrderDetail deliveryOrderDetail = (DeliveryOrderDetail) rdresult.getEntityList().get(0);
                        row.setDeliveryOrderDetail(deliveryOrderDetail);
                    } else if (linkMode.equalsIgnoreCase(Constants.CUSTOMER_QUOTATION)) {
                        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(QuotationDetail.class.getName(), (StringUtil.isNullOrEmpty(jobj.getString("linkto"))) ? jobj.getString("rowid") : jobj.getString("savedrowid"));
                        QuotationDetail quotationDetail = (QuotationDetail) rdresult.getEntityList().get(0);
                        row.setQuotationDetail(quotationDetail);
                    }
                }
                row.setCompany(company);
                if (storageHandlerImpl.GetSATSCompanyId().contains(companyid)) {  //This is sats specific code 
                    if (jobj.has("dependentType")) {
                        row.setDependentType(StringUtil.isNullOrEmpty(jobj.getString("dependentType")) ? jobj.getString("dependentTypeNo") : jobj.getString("dependentType"));
                    }
                    if (jobj.has("inouttime")) {
                        row.setInouttime(!StringUtil.isNullOrEmpty(jobj.getString("inouttime")) ? jobj.getString("inouttime") : "");
                    }
                    if (jobj.has("showquantity")) {
                        row.setShowquantity(!StringUtil.isNullOrEmpty(jobj.getString("showquantity")) ? jobj.getString("showquantity") : "");
                    }
                    if (jobj.has("istimeinterval")) {
                        row.setIstimeinterval(!StringUtil.isNullOrEmpty(jobj.getString("istimeinterval")) ? Boolean.parseBoolean(jobj.getString("istimeinterval")) : false);
                    }
                }
                row.setRate(jobj.getDouble("rate"));
                if (jobj.has("pricingbandmasterid") && !StringUtil.isNullOrEmpty(jobj.optString("pricingbandmasterid"))) {
                    row.setPricingBandMasterid(jobj.optString("pricingbandmasterid"));
                }

                prodList.add(jobj.getString(Constants.productid));

                JSONObject inventoryjson = new JSONObject();
                inventoryjson.put(Constants.productid, jobj.getString(Constants.productid));
                inventoryjson.put("quantity", jobj.getDouble("quantity"));
                
                if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {
                    if (jobj.has("uomname")) {
                        inventoryjson.put("uomid", jobj.getString("uomname"));
                    }
                } else {
                    if (jobj.has("uomid")) {
                        inventoryjson.put("uomid", jobj.getString("uomid"));
                    }
                }

                if (jobj.has("baseuomquantity") && jobj.get("baseuomquantity") != null) {
                    inventoryjson.put("baseuomquantity", updateInventoryFlag ? jobj.getDouble("baseuomquantity") : 0);
                    inventoryjson.put("actquantity", updateInventoryFlag ? 0 : jobj.getDouble("baseuomquantity"));
                    inventoryjson.put("baseuomrate", jobj.getDouble("baseuomrate"));
                } else {
                    inventoryjson.put("baseuomquantity", updateInventoryFlag ? jobj.getDouble("quantity") : 0);
                    inventoryjson.put("actquantity", updateInventoryFlag ? 0 : jobj.getDouble("quantity"));
                    inventoryjson.put("baseuomrate", jobj.getDouble("baseuomrate"));
                }
                inventoryjson.put("invrecord", updateInventoryFlag ? true : false);
                if (isLeaseFixedAsset) {
                    inventoryjson.put("leaseFlag", isLeaseFixedAsset);
                }

                inventoryjson.put("description", jobj.optString("desc"));
                if (storageHandlerImpl.GetSATSCompanyId().contains(companyid) && jobj.has("dependentType")) {  //This is sats specific code 
                    inventoryjson.put("dependentType", jobj.getString("dependentType"));
                }
                if (isConsignment) {
                    if (jobj.has("baseuomquantity") && jobj.get("baseuomquantity") != null) {
                        inventoryjson.put("consignuomquantity", -jobj.getDouble("baseuomquantity"));
                    }
                    inventoryjson.put(Constants.isConsignment, isConsignment);
                }
                if(jobj.has("rateIncludingGst")) {
                    row.setRateincludegst(jobj.optDouble("rateIncludingGst",0));
                }
                if(jobj.has("productweightperstockuom")) {
                    inventoryjson.put("productweightperstockuom", jobj.optDouble("productweightperstockuom",0));
                }
                if(jobj.has("productweightincludingpakagingperstockuom")) {
                    inventoryjson.put("productweightincludingpakagingperstockuom", jobj.optDouble("productweightincludingpakagingperstockuom",0));
                }
                if(jobj.has("productvolumeperstockuom")) {
                    inventoryjson.put("productvolumeperstockuom", jobj.optDouble("productvolumeperstockuom",0));
                }
                if(jobj.has("productvolumeincludingpakagingperstockuom")) {
                    inventoryjson.put("productvolumeincludingpakagingperstockuom", jobj.optDouble("productvolumeincludingpakagingperstockuom",0));
                }
                inventoryjson.put("carryin", false);
                inventoryjson.put("defective", false);
                inventoryjson.put("newinventory", false);
                inventoryjson.put(Constants.companyKey, companyid);
                inventoryjson.put("updatedate", authHandler.getDateOnlyFormat().parse(paramJobj.optString(Constants.BillDate)));
                KwlReturnObject invresult = accProductObj.addInventory(inventoryjson);
                Inventory inventory = (Inventory) invresult.getEntityList().get(0);

                row.setInventory(inventory);
                double rate = row.getRate();
                double rowAmount = 0;
                if(gstIncluded) {
                    rate = jobj.optDouble("rateIncludingGst",0);
                }
                /**
                 * IF Invoice is RCM Applicable and Product is not RCM //ERP-34970(ERM-534)
                 * Applicable
                 */
                if (countryid == Constants.indian_country_id && RCMApplicable) {
                    Product productObj = row.getInventory().getProduct();
                    if (productObj != null && !productObj.isRcmApplicable()) {
                        productNameRCMNotActivate.add(product.getName());
                        //throw new AccountingException(messageSource.getMessage("acc.common.rcmforproductnotactivated.SI.text", new Object[]{productObj.getName()}, null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    }
                }
                rowAmount = authHandler.round(rate * jobj.getDouble("quantity"), companyid);
                rowAmount=authHandler.round(rowAmount, companyid);
                double rowdiscount = 0;
                if (partamount != 0.0) {
                    rowAmount = rowAmount * (partamount / 100);
                }
                totalamount += rowAmount;
                Discount discount = null;
                double disc = 0;
                int rowdisc = 0;
                
                if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true) {//Mobile Application
                    if (jobj.has("discount") && !StringUtil.isNullOrEmpty(jobj.optString("discount", null))) {
                        disc = Double.parseDouble(jobj.optString("discount", "0.0"));
                    }
                    if (jobj.has("discountType") && !StringUtil.isNullOrEmpty(jobj.optString("discountType", null)))  {
                        rowdisc = Integer.parseInt(jobj.getString("discountType"));
                    }
                } else {
                    if (jobj.has("prdiscount")) {
                        disc = jobj.getDouble("prdiscount");
                    }
                    if (jobj.has("discountispercent")) {
                        rowdisc = jobj.getInt("discountispercent");
                    }
                }
                
                String rowtaxid = "";
                if (!StringUtil.isNullOrEmpty(jobj.optString("prtaxid", null)) && jobj.optString("prtaxid").equalsIgnoreCase("None")) {
                    rowtaxid = null;
                } else {
                    rowtaxid = jobj.optString("prtaxid",null);
                }
                double rowtaxamount = 0d;
                double rowTaxAmtInBase = 0d;
//                double lineleveltaxtermamount = 0d;
//                double lineleveltaxtermamountInBase = 0d;
                double rowTaxPercent = 0;
                double rowExcludingGstAmount=0d;
                double rowExcludingGstAmountInBase=0d;
                KwlReturnObject bAmt = null,jeResult=null;
                
                Tax rowtax = null;
                HashMap<String, Object> requestParams = new HashMap();
                if (!requestParams.containsKey("gcurrencyid") && !StringUtil.isNullOrEmpty(jeid)) {
                    jeResult=accountingHandlerDAOobj.getObject(JournalEntry.class.getName(), jeid); 
                    journalEntry = (JournalEntry) jeResult.getEntityList().get(0);
                    requestParams.put("gcurrencyid", journalEntry.getCompany().getCurrency().getCurrencyID());
                    requestParams.put("companyid", journalEntry.getCompany().getCompanyID());
                    
                }
                if (!StringUtil.isNullOrEmpty(rowtaxid) && includeProductTax) {
                    KwlReturnObject txresult = accountingHandlerDAOobj.getObject(Tax.class.getName(), rowtaxid); 
                    rowtax = (Tax) txresult.getEntityList().get(0);
                    if (rowtax == null) {
                        throw new AccountingException(messageSource.getMessage("acc.so.taxcode", null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
                    } else {
                        row.setTax(rowtax);
                        rowtaxamount = StringUtil.getDouble(jobj.getString("taxamount"));
//                        rowtaxamount += lineleveltaxtermamount;
                        rowTaxPercent = jobj.optDouble("taxpercent",0);
                        row.setRowTaxAmount(rowtaxamount);
                        /*Save Row tax amount in base*/
                        bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, rowtaxamount, journalEntry.getCurrency().getCurrencyID(), journalEntry.getEntryDate(), journalEntry.getExternalCurrencyRate());
                        rowTaxAmtInBase = (Double) bAmt.getEntityList().get(0);
                        rowTaxAmtInBase = authHandler.round(rowTaxAmtInBase, companyid);
                        row.setRowTaxAmountInBase(rowTaxAmtInBase);
                        taxamount += rowtaxamount;
                        
                        
//                        lineleveltaxtermamount = StringUtil.getDouble(jobj.optString("lineleveltaxtermamount","0"));
//                        row.setRowTermTaxAmount(lineleveltaxtermamount);
//                        bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, lineleveltaxtermamount, journalEntry.getCurrency().getCurrencyID(), journalEntry.getEntryDate(), journalEntry.getExternalCurrencyRate());
//                        lineleveltaxtermamountInBase = (Double) bAmt.getEntityList().get(0);
//                        lineleveltaxtermamountInBase = authHandler.round(lineleveltaxtermamountInBase, companyid);
//                        row.setRowTermTaxAmountInBase(lineleveltaxtermamountInBase);
                        row.setIsUserModifiedTaxAmount((boolean) jobj.optBoolean(Constants.isUserModifiedTaxAmount, false));
                    }
                }
                double discountAmt = 0.0;
                if (disc != 0.0) {
                    JSONArray discountJArr = new JSONArray();
                    String discountjsonStr = "";
                    double quantityForDiscount = jobj.optDouble("quantity", 0);
//                    double rate = jobj.optDouble("rate", 0);
                    JSONObject discountmasterObj = null;
                    if (jobj.has("discountjson")) {
                        discountjsonStr = jobj.optString("discountjson","");
                    }
                    if (!StringUtil.isNullOrEmpty(discountjsonStr)) {
                        discountjsonStr = StringUtil.DecodeText(discountjsonStr);
                        discountmasterObj = new JSONObject(discountjsonStr);
                    }
                    if (discountmasterObj != null && discountmasterObj.has("data")) {
                        discountJArr = discountmasterObj.getJSONArray("data");
                    }
                    JSONObject jedjson = new JSONObject();
                    KwlReturnObject jedresult = null;
                    if (discountJArr.length() > 0) {
                        for (int j = 0; j < discountJArr.length(); j++) {
                            JSONObject discountMasterJObj = discountJArr.getJSONObject(j);
                            discountAmt = discountMasterJObj.optInt("discounttype") == 1 ? ((rowAmount) * (discountMasterJObj.optDouble("discountvalue") / 100)) : discountMasterJObj.optDouble("discountvalue");
                            discountAmt = authHandler.round(discountAmt, companyid);
                            jedjson.put("srno", jeDetails.size() + 1);
                            jedjson.put(Constants.companyKey, companyid);
                            jedjson.put("amount", discountAmt);
                            jedjson.put("accountid", discountMasterJObj.optString("discountaccount"));
                            jedjson.put("debit", true);
                            jedjson.put("jeid", jeid);
                            jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                            jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                            jeDetails.add(jed);
                        }
                    }else{
                        discountAmt = rowdisc == 1 ? ((rowAmount) * (disc / 100)) : disc;
//                        if (partialInv && rowdisc == 0) {
//                            discountAmt = partialDiscount;
//                        }
                        sumOfDiscountAmount+=authHandler.round(discountAmt, companyid);
                    } 
                        JSONObject discjson = new JSONObject();
                        discjson.put("discount", disc);
                        discjson.put("inpercent", (rowdisc == 1) ? true : false);
                        discjson.put("originalamount", rowAmount);
                        discjson.put(Constants.companyKey, companyid);
                        KwlReturnObject dscresult = accDiscountobj.addDiscount(discjson);
                        discount = (Discount) dscresult.getEntityList().get(0);
                        row.setDiscount(discount);
                        rowdiscount = discount.getDiscountValue();
                        totaldiscount += rowdiscount;
                    }
                
                /*Below code is used to save exlcuding gst amt and excluding gst amount in base*/
                rowExcludingGstAmount = rowAmount;
                if (gstIncluded) {
                    rowExcludingGstAmount -= rowdiscount;
                    rowExcludingGstAmount += jobj.optDouble("lineleveltermamount", 0);
                    double taxAppliedOn = 0;
                    taxAppliedOn = (100 * rowExcludingGstAmount) / (100 + rowTaxPercent);
                    rowExcludingGstAmount = taxAppliedOn;
                } else {
                    if (partialInv && row.getDiscount() != null && !row.getDiscount().isInPercent()) {
                        rowExcludingGstAmount -= (rowdiscount * row.getPartamount()) / 100;
                    } else {
                        rowExcludingGstAmount -= rowdiscount;
                    }
                }
                rowExcludingGstAmount = authHandler.round(rowExcludingGstAmount, companyid);
                row.setRowExcludingGstAmount(rowExcludingGstAmount);
                /*Save Excluding GST amount  in base*/
                if (journalEntry != null) {
                    bAmt = accCurrencyDAOobj.getCurrencyToBaseAmount(requestParams, rowExcludingGstAmount, journalEntry.getCurrency().getCurrencyID(), journalEntry.getEntryDate(), journalEntry.getExternalCurrencyRate());
                    rowExcludingGstAmountInBase = (Double) bAmt.getEntityList().get(0);
                }
                rowExcludingGstAmountInBase = authHandler.round(rowExcludingGstAmountInBase, companyid);
                row.setRowExcludingGstAmountInBase(rowExcludingGstAmountInBase);
                
                if (isConsignment && jobj.has("batchdetails") && jobj.getString("batchdetails") != null) {
                    String batchDetails = jobj.getString("batchdetails");
                    
                    /*Mobile Application*/
                     if (paramJobj.optBoolean(Constants.isdefaultHeaderMap, false) == true && product.isIsBatchForProduct() && product.isIsSerialForProduct()) {
                        JSONObject jsobj =accProductModuleService.manipulateBatchDetailsforMobileApps(batchDetails, inventory.getProduct().getID(), paramJobj);
                        if (jsobj.get("batchdetails") != null && !StringUtil.isNullOrEmpty(jsobj.optString("batchdetails", null))) {
                            batchDetails = jsobj.getString("batchdetails");
                        }
                    }
                    if (!StringUtil.isNullOrEmpty(batchDetails)) {
//                        saveInvNewBatch(batchDetails, inventory, request,row.getInventory().getID());
                        saveInvNewBatch(batchDetails, inventory, paramJobj,row.getInventory().getID());

                    }
                }
                
                List<HashMap> Tlist = null;
                double indainMulTax = 0.0d;
                if (extraCompanyPreferences.getLineLevelTermFlag()==1 && jobj.has("LineTermdetails") && !StringUtil.isNullOrEmpty((String) jobj.optString("LineTermdetails"))) {
                    Tlist = mapInvoiceDetailTerms(StringUtil.DecodeText((String) jobj.optString("LineTermdetails")), row.getInventory(),paramJobj.optString(Constants.useridKey), extraCompanyPreferences.isAvalaraIntegration());
                    for (HashMap listData : Tlist) {
                        indainMulTax += Double.parseDouble(listData.get("termamount").toString());
                    }
                }
                
                    JSONObject jedjson = new JSONObject();
                    JSONObject sepatratedjedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    if (isFixedAsset) {
                        double assetCost = 0;
                        double assetDep = 0;
                        profitLossAmt = jobj.optDouble("profitLossAmt", 0);
                        JSONArray assetArr = new JSONArray(jobj.getString("assetDetails"));
                        for (int assetCount = 0; assetCount < assetArr.length(); assetCount++) {
                            assetDep = 0;
                            JSONObject assetJson = assetArr.getJSONObject(assetCount);
                            String assetDetailId = assetJson.getString("assetId");
                            double assetSellAmount = assetJson.optDouble("sellAmount",0);

                            KwlReturnObject accresult = accountingHandlerDAOobj.getObject(AssetDetails.class.getName(), assetDetailId);
                            AssetDetails ad = (AssetDetails) accresult.getEntityList().get(0);

                            assetCost += ad.getCost();

                            HashMap<String, Object> assetParams = new HashMap<String, Object>();
                            assetParams.put("assetDetailsId", assetDetailId);
                            assetParams.put(Constants.companyKey, paramJobj.getString(Constants.companyKey));
                            assetParams.put("assetDetails", true);
                            KwlReturnObject assResult = accProductObj.getAssetDepreciationDetail(assetParams);
                            List<AssetDepreciationDetail> assList = assResult.getEntityList();
                            for (AssetDepreciationDetail depreciationDetail : assList) {
                                assetDep += depreciationDetail.getPeriodAmount();
                            }
                            /**
                             * Case : As per case mentioned case in this ticket , profitLossAmt is not calculated because it is calculated on "afteredit" of asset-grid
                             * in this case profitLossAmt was getting zero,so due to below code, one JE detail was not post
                             * Now profitLossAmt is calculated on java side.
                             */
                            if (jobj.optDouble("profitLossAmt", 0) == 0) {
                                double temporaryDiff = 0d;
                                double actualcost = (ad.getCost() - assetDep);
                                if (Math.abs(actualcost - assetSellAmount) > 0.0000000001) {
                                    temporaryDiff = (assetSellAmount - actualcost);
                                }
                                profitLossAmt = profitLossAmt + temporaryDiff;
                            }
                            
                            JSONObject jedJsonDep = new JSONObject();
                            jedJsonDep.put("srno", jeDetails.size() + 1);
                            jedJsonDep.put(Constants.companyKey, companyid);
                            jedJsonDep.put("amount", assetDep);
                            jedJsonDep.put("accountid", product.getDepreciationProvisionGLAccount().getID());
                            jedJsonDep.put("debit", true);
                            jedJsonDep.put("jeid", jeid);
                            KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedJsonDep);
                            jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                            jeDetails.add(jed);
                            jedForCustomFields.put(jed.getID());
                        }
                        jedjson.put("amount", assetCost);
                        /**
                         * Code is moved
                         * Post JE details against SellAssetGLAccount of Asset.
                         */
                        if (profitLossAmt != 0) {
                            if (gstIncluded) {
                               profitLossAmt=profitLossAmt+discountAmt;
                            }
                            JSONObject jedjsonObj = new JSONObject();
                            jedjsonObj.put("srno", jeDetails.size() + 1);
                            jedjsonObj.put(Constants.companyKey, companyid);
                            jedjsonObj.put("amount", (profitLossAmt < 0) ? (-1 * profitLossAmt) : profitLossAmt);
                            jedjsonObj.put("accountid", product.getSellAssetGLAccount().getID());
                            jedjsonObj.put("debit", (profitLossAmt < 0) ? true : false);
                            jedjsonObj.put("jeid", jeid);
                            KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjsonObj);
                            jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                            jeDetails.add(jed);
                            jedForCustomFields.put(jed.getID());
                        }
                    } else {
                        /*
                            For JE Detail Entry for sales amount = rowAmount - Tax Amount
                        */
                        
                        double JElineAmount = rowAmount; // Row Amount Not Include Gst(Tax)
                        
                        if (gstIncluded) { // Check For  Row Amount Include Gst(Tax)
                            if (extraCompanyPreferences.getLineLevelTermFlag()==1) { //Indian Company Including mul Tax
                                JElineAmount -= indainMulTax;
                            } else {
                                JElineAmount -= rowtaxamount;
                            }
                        }
                        
                        jedjson.put("amount", JElineAmount);
                    }
                    
//                if (countryid == Constants.indian_country_id) {
//                    String customerId = paramJobj.optString("customer",null);
//                    Customer customer = null;
//                    if (!StringUtil.isNullOrEmpty(customerId)) {
//                        KwlReturnObject custresult = accountingHandlerDAOobj.getObject(Customer.class.getName(), customerId);
//                        customer = (Customer) custresult.getEntityList().get(0);
//                    }
//                    if (customer.isInterstateparty() && customer.isCformapplicable()) { //Vendor Level interstatechange is true and c form is true
//                        if (product.getInterStateSalesAccountCForm() != null) {
//                            jedjson.put("accountid", product.getInterStateSalesAccountCForm().getID());
//                        } else {
//                            throw new AccountingException("Please Map Inter State and C Form  Transactions Accounts  ( Product Name : " + product.getName() + " ) at Product Master  to proceed further.");
//                        }
//
//                    } else if (customer.isInterstateparty() && !customer.isCformapplicable()) { //Vendor Level interstatechange is true and c form is false
//                        if (product.getInterStateSalesAccount() != null) {
//                            jedjson.put("accountid", product.getInterStateSalesAccount().getID());
//                        } else {
//                            throw new AccountingException("Please Map Inter State Transactions Accounts ( Product Name : " + product.getName() + " )  at Product Master  to proceed further.");
//                        }
//                    }else {
//                        jedjson.put("accountid", product.getSalesAccount().getID()); //Vendor Level interstatechange is false and c form is false
//                    }
//                    
                    if (jobj.has("productaccountid") && !StringUtil.isNullOrEmpty((String) jobj.optString("productaccountid")) && countryid == Constants.indian_country_id) {// If Invoice Line Level Change the account it will show line level Account Only
                        jedjson.put("accountid", (String) jobj.getString("productaccountid"));
                    } else {
                        jedjson.put("accountid", product.getSalesAccount().getID());
                    }
                    jedjson.put("debit", false);
                    jedjson.put("jeid", jeid);
                    KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    row.setSalesJED(jed);

                    row.setDeferredJeDetailId(jed.getID());

                    // Add Custom fields details 
                    if (!StringUtil.isNullOrEmpty(jobj.optString(Constants.customfield,null))) {
                        JSONArray jcustomarray = new JSONArray(jobj.optString(Constants.customfield, "[]"));
                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        customrequestParams.put("customarray", jcustomarray);
                        customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
                        customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);// Constants.Acc_JEDetail_recdetailId
                        customrequestParams.put("modulerecid", jed.getID());
                        customrequestParams.put("recdetailId", row.getInventory().getID());
                        customrequestParams.put(Constants.moduleid,isFixedAsset ?  Constants.Acc_FixedAssets_DisposalInvoice_ModuleId: isConsignment?Constants.Acc_ConsignmentInvoice_ModuleId:isLeaseFixedAsset?Constants.LEASE_INVOICE_MODULEID:Constants.Acc_Invoice_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        customrequestParams.put("customdataclasspath", Constants.Acc_BillInvDetail_custom_data_classpath);
                        KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                        if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                            jedjson.put("accjedetailcustomdata", jed.getID());
                            jedjson.put("jedid", jed.getID());
                            jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                        }
                       
                        /*
                         * Post additional jedetail if dimension is tagged for
                         * matching financial reports in advance search
                         */

                        sepatratedjedjson = new JSONObject();
                        sepatratedjedjson.put("srno", jeDetails.size() + 1);
                        sepatratedjedjson.put(Constants.companyKey, companyid);
                        sepatratedjedjson.put("amount", rowExcludingGstAmount);
                        sepatratedjedjson.put("accountid", customerAccountid);
                        sepatratedjedjson.put("debit", true);
                        sepatratedjedjson.put("jeid", jeid);
                        sepatratedjedjson.put("mainjedid", jed.getID());
                        sepatratedjedjson.put(Constants.ISSEPARATED, true);
                        jedresult = accJournalEntryobj.addJournalEntryDetails(sepatratedjedjson);
                        JournalEntryDetail controllAccjed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                        jeDetails.add(controllAccjed);
                        jedForCustomFields.put(controllAccjed.getID());

//                        if (rowdiscount > 0) {
//                            sepatratedjedjson = new JSONObject();
//                            sepatratedjedjson.put("srno", jeDetails.size() + 1);
//                            sepatratedjedjson.put(Constants.companyKey, companyid);
//                            sepatratedjedjson.put("amount", rowdiscount);
//                            sepatratedjedjson.put("accountid", preferences.getDiscountGiven().getID());
//                            sepatratedjedjson.put("debit", true);
//                            sepatratedjedjson.put("jeid", jeid);
//                            sepatratedjedjson.put("mainjedid", jed.getID());
//                            sepatratedjedjson.put(Constants.ISSEPARATED, true);
//                            jedresult = accJournalEntryobj.addJournalEntryDetails(sepatratedjedjson);
//                            JournalEntryDetail rowdiscountjed = (JournalEntryDetail) jedresult.getEntityList().get(0);
//                            jeDetails.add(rowdiscountjed);
//                            jedForCustomFields.put(rowdiscountjed.getID());
//                        }

                    }
                    // Add Custom fields details for Product
                    if (!StringUtil.isNullOrEmpty(jobj.optString("productcustomfield", ""))) {
                        JSONArray jcustomarray = new JSONArray(jobj.optString("productcustomfield", "[]"));
                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        customrequestParams.put("customarray", jcustomarray);
                        customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
                        customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);
                        customrequestParams.put("modulerecid", jed.getID());
                        customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                        customrequestParams.put("recdetailId", inventory.getID());
                        customrequestParams.put("productId", row.getInventory().getProduct().getID());
                        customrequestParams.put(Constants.companyKey, companyid);
                        customrequestParams.put("customdataclasspath", Constants.Acc_JEDetail_Productcustom_data_classpath);
                        /*
                         * Rich Text Area is put in json if User have not selected any data for this field. ERP-ERP-37624
                         */
                        customrequestParams.put("productIdForRichRext", row.getInventory().getProduct().getID());                    
                        fieldDataManagercntrl.setRichTextAreaForProduct(customrequestParams);
                        KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                        if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                            jedjson.put("accjedetailproductcustomdataref", jed.getID());
                            jedjson.put("jedid", jed.getID());
                            jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                        }
                }
                    
//                jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
//                row.setSalesJED(jed);
                if (rowtax != null) {
                    /*
                        Define JE detail entry for Product line level Tax 
                    */
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put(Constants.companyKey, companyid);
                    jedjson.put("amount", rowtaxamount);
                    jedjson.put("accountid", rowtax.getAccount().getID());
                    jedjson.put("debit", false);
                    jedjson.put("jeid", jeid);
                    KwlReturnObject taxjedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) taxjedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    row.setGstJED(jed);
                    
                    if (!StringUtil.isNullOrEmpty(jobj.optString(Constants.customfield, null))) {
                        JSONArray jcustomarray = new JSONArray(jobj.optString(Constants.customfield, "[]"));
                        HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
                        customrequestParams.put("customarray", jcustomarray);
                        customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
                        customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);// Constants.Acc_JEDetail_recdetailId
                        customrequestParams.put("modulerecid", jed.getID());
                        customrequestParams.put("recdetailId", row.getInventory().getID());
                        customrequestParams.put(Constants.moduleid, isFixedAsset ? Constants.Acc_FixedAssets_DisposalInvoice_ModuleId : isConsignment ? Constants.Acc_ConsignmentInvoice_ModuleId : isLeaseFixedAsset ? Constants.LEASE_INVOICE_MODULEID : Constants.Acc_Invoice_ModuleId);
                        customrequestParams.put(Constants.companyKey, companyid);
                        customrequestParams.put("customdataclasspath", Constants.Acc_BillInvDetail_custom_data_classpath);
                        KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                        if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                            jedjson.put("accjedetailcustomdata", jed.getID());
                            jedjson.put("jedid", jed.getID());
                            jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
                        }
                        /*
                         * Post additional jedetail if dimension is tagged for
                         * matching financial reports in advance search
                         */
                        sepatratedjedjson = new JSONObject();
                        sepatratedjedjson.put("srno", jeDetails.size() + 1);
                        sepatratedjedjson.put(Constants.companyKey, companyid);
                        sepatratedjedjson.put("amount", rowtaxamount);
                        sepatratedjedjson.put("accountid", customerAccountid);
                        sepatratedjedjson.put("debit", true);
                        sepatratedjedjson.put("jeid", jeid);
                        sepatratedjedjson.put("mainjedid", jed.getID());
                        sepatratedjedjson.put(Constants.ISSEPARATED, true);
                        jedresult = accJournalEntryobj.addJournalEntryDetails(sepatratedjedjson);
                        JournalEntryDetail controllAccjed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                        jeDetails.add(controllAccjed);
                        jedForCustomFields.put(controllAccjed.getID());
                    }
                    
                    /*
                        Define JE detail entry for Product line level Term Tax
                    */
//                    if(lineleveltaxtermamount!=0) {
//                        jedjson = new JSONObject();
//                        jedjson.put("srno", jeDetails.size() + 1);
//                        jedjson.put(Constants.companyKey, companyid);
//                        jedjson.put("amount", lineleveltaxtermamount);
//                        jedjson.put("accountid", rowtax.getAccount().getID());
//                        jedjson.put("debit", false);
//                        jedjson.put("jeid", jeid);
//                        taxjedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
//                        jed = (JournalEntryDetail) taxjedresult.getEntityList().get(0);
//                        jeDetails.add(jed);
//
//                        if (!StringUtil.isNullOrEmpty(jobj.optString(Constants.customfield, null))) {
//                            JSONArray jcustomarray = new JSONArray(jobj.optString(Constants.customfield, "[]"));
//                            HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
//                            customrequestParams.put("customarray", jcustomarray);
//                            customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
//                            customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);// Constants.Acc_JEDetail_recdetailId
//                            customrequestParams.put("modulerecid", jed.getID());
//                            customrequestParams.put("recdetailId", row.getInventory().getID());
//                            customrequestParams.put(Constants.moduleid, isFixedAsset ? Constants.Acc_FixedAssets_DisposalInvoice_ModuleId : isConsignment ? Constants.Acc_ConsignmentInvoice_ModuleId : isLeaseFixedAsset ? Constants.LEASE_INVOICE_MODULEID : Constants.Acc_Invoice_ModuleId);
//                            customrequestParams.put(Constants.companyKey, companyid);
//                            customrequestParams.put("customdataclasspath", Constants.Acc_BillInvDetail_custom_data_classpath);
//                            KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
//                            if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
//                                jedjson.put("accjedetailcustomdata", jed.getID());
//                                jedjson.put("jedid", jed.getID());
//                                jedresult = accJournalEntryobj.updateJournalEntryDetails(jedjson);
//                            }
//                            /*
//                             * Post additional jedetail if dimension is tagged
//                             * for matching financial reports in advance search
//                             */
//                            sepatratedjedjson = new JSONObject();
//                            sepatratedjedjson.put("srno", jeDetails.size() + 1);
//                            sepatratedjedjson.put(Constants.companyKey, companyid);
//                            sepatratedjedjson.put("amount", lineleveltaxtermamount);
//                            sepatratedjedjson.put("accountid", customerAccountid);
//                            sepatratedjedjson.put("debit", true);
//                            sepatratedjedjson.put("jeid", jeid);
//                            sepatratedjedjson.put("mainjedid", jed.getID());
//                            sepatratedjedjson.put(Constants.ISSEPARATED, true);
//                            jedresult = accJournalEntryobj.addJournalEntryDetails(sepatratedjedjson);
//                            JournalEntryDetail controllAccjed = (JournalEntryDetail) jedresult.getEntityList().get(0);
//                            jeDetails.add(controllAccjed);
//                            jedForCustomFields.put(controllAccjed.getID());
//                        }
//                    }
                }
               
                    try {
                        Map<String, Object> param = new HashMap();
                        param.put("jedForCustomFields",jedForCustomFields);
                        param.put("inventoryID", !StringUtil.isNullOrEmpty(row.getInventory().getID()) ? row.getInventory().getID() : "");
                        saveLinelevelCustomFieldData(jobj, param, paramJobj);
                    } catch (Exception ex) {
                        Logger.getLogger(authHandler.class.getName()).log(Level.SEVERE, null, ex);
                    }
                
                
                // save assets
                int assetSoldFlag = 1;

                if (isLinkedWithDO) {
                    assetSoldFlag = 2;
                }

                if (isLeaseFixedAsset) {// in case of leasing its value will be 0
                    assetSoldFlag = 0;
                }

                boolean isFromSalesReturn = false;

                if (isFixedAsset || (isLeaseFixedAsset && product.isAsset())) {
                    /*Get request parameters */
                    Set<AssetDetails> assetDetailsSet = saveAssetDetails(paramJobj, jobj.getString(Constants.productid), jobj.getString("assetDetails"), assetSoldFlag, isLinkedWithDO, true, isLeaseFixedAsset, isFromSalesReturn, false, false, profitLossAmt);
                    Set<AssetInvoiceDetailMapping> assetInvoiceDetailMappings =saveAssetInvoiceDetailMapping(row.getInventory().getID(), assetDetailsSet, companyid, Constants.Acc_Invoice_ModuleId);
                }
                if(jobj.has("recTermAmount")) {
                    row.setRowTermAmount(jobj.optDouble("recTermAmount",0));
                }
                if(jobj.has("OtherTermNonTaxableAmount")) {
                    row.setOtherTermNonTaxableAmount(jobj.optDouble("OtherTermNonTaxableAmount",0));
                }
                
              // Indian Details Valuation Type -- start                
                if(countryid == Constants.indian_country_id ){
                    if (jobj.has("productMRP") && !StringUtil.isNullOrEmpty(jobj.getString("productMRP"))) {
                        row.setMrpIndia(jobj.getDouble("productMRP"));
                    }
                    if(jobj.has("valuationType") && !StringUtil.isNullOrEmpty(jobj.getString("valuationType"))){ // Excise Details
                       row.setExciseValuationType(jobj.getString("valuationType"));
                       if((Constants.QUENTITY).equals(jobj.getString("valuationType"))){
                           if(jobj.has("reortingUOMExcise") && !StringUtil.isNullOrEmpty(jobj.getString("reortingUOMExcise"))){
                               UnitOfMeasure reportingUom=null;
                               KwlReturnObject custresult = accountingHandlerDAOobj.getObject(UnitOfMeasure.class.getName(),jobj.getString("reortingUOMExcise"));
                               reportingUom = (UnitOfMeasure) custresult.getEntityList().get(0);
                               row.setReportingUOMExcise(reportingUom);
                           }
                           if(jobj.has("reortingUOMSchemaExcise") && !StringUtil.isNullOrEmpty(jobj.getString("reortingUOMSchemaExcise"))){
                               UOMschemaType reportingUom=null;
                               KwlReturnObject custresult = accountingHandlerDAOobj.getObject(UOMschemaType.class.getName(),jobj.getString("reortingUOMSchemaExcise"));
                               reportingUom = (UOMschemaType) custresult.getEntityList().get(0);
                               row.setReportingSchemaTypeExcise(reportingUom);
                           }
                       }
                    }
                    if(jobj.has("valuationTypeVAT") && !StringUtil.isNullOrEmpty(jobj.getString("valuationTypeVAT"))){ // VAT Details
                       row.setVatValuationType(jobj.getString("valuationTypeVAT"));
                       if( (Constants.QUENTITY).equals(jobj.getString("valuationTypeVAT"))){
                           if(jobj.has("reportingUOMVAT") &&!StringUtil.isNullOrEmpty(jobj.getString("reportingUOMVAT"))){
                               UnitOfMeasure reportingUom=null;
                               KwlReturnObject custresult = accountingHandlerDAOobj.getObject(UnitOfMeasure.class.getName(), jobj.getString("reportingUOMVAT"));
                                 reportingUom = (UnitOfMeasure) custresult.getEntityList().get(0);
                                 row.setReportingUOMVAT(reportingUom);
                           }
                           if(jobj.has("reportingUOMSchemaVAT") && !StringUtil.isNullOrEmpty(jobj.getString("reportingUOMSchemaVAT"))){
                               UOMschemaType reportingUom=null;
                               KwlReturnObject custresult = accountingHandlerDAOobj.getObject(UOMschemaType.class.getName(),jobj.getString("reportingUOMSchemaVAT"));
                               reportingUom = (UOMschemaType) custresult.getEntityList().get(0);
                               row.setReportingSchemaVAT(reportingUom);
                           }
                       }
                    }
                }
                // Indian Details Valuation Type -- start 
                rows.add(row);
                if (extraCompanyPreferences.getLineLevelTermFlag()==1 && jobj.has("LineTermdetails") && !StringUtil.isNullOrEmpty((String) jobj.optString("LineTermdetails")) && !Tlist.isEmpty() && !RCMApplicable) { // JE POST For Line levelTax(Term) For India
                    for (HashMap listData : Tlist) {
                        jedjson = new JSONObject();
                        jedjson.put("srno", jeDetails.size() + 1);
                        jedjson.put(Constants.companyKey, companyid);
                        jedjson.put("amount", listData.get("termamount"));
                        jedjson.put("accountid", listData.get("accountid"));
                        jedjson.put("debit", false);
                        jedjson.put("jeid", jeid);
                        jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                        jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                        jeDetails.add(jed);
                        row.setGstJED(jed);
                    }
                }
                
                if(extraCompanyPreferences.getLineLevelTermFlag()==1 && jobj.has("LineTermdetails") && !StringUtil.isNullOrEmpty((String)jobj.optString("LineTermdetails")) && !Tlist.isEmpty()){
                        Tlist =  mapInvoiceDetailTerms(StringUtil.DecodeText((String)jobj.optString("LineTermdetails")), row.getInventory(),paramJobj.optString(Constants.useridKey), extraCompanyPreferences.isAvalaraIntegration());
                }
                if (extraCompanyPreferences.getLineLevelTermFlag()==1) {
                    /**
                     * Save GST History Customer/Vendor data.
                     */
                    jobj.put("detaildocid", row.getInventory().getID());
                    jobj.put("moduleid", isFixedAsset?Constants.Acc_FixedAssets_DisposalInvoice_ModuleId:Constants.Acc_Invoice_ModuleId);
                    fieldDataManagercntrl.createRequestMapToSaveTaxClassHistory(jobj);
                }
                FinalTerm.put(inventory, Tlist);
                
                // Supplier Excise Details -- Start
                List<HashMap> listSupplierdetails = null;
                if (jobj.has("supplierExciseDetails") && !StringUtil.isNullOrEmpty((String) jobj.optString("supplierExciseDetails")) && extraCompanyPreferences.isExciseApplicable()) {
                    listSupplierdetails = mapSupplierExciseDetails(StringUtil.DecodeText((String) jobj.optString("supplierExciseDetails")), row.getInventory(),paramJobj.optString(Constants.useridKey));
                }
                supplierDetails.put(inventory, listSupplierdetails);
                // Supplier Excise Details -- End
            }
            if (countryid == Constants.indian_country_id && RCMApplicable && !productNameRCMNotActivate.isEmpty()) {
                throw new AccountingException(messageSource.getMessage("acc.common.rcmforproductnotactivated.SI.text", new Object[]{StringUtils.join(productNameRCMNotActivate, ", ")}, null, Locale.forLanguageTag(paramJobj.getString(Constants.language))));
            }
            
        } catch (ParseException ex) {
            throw ServiceException.FAILURE("saveInvoiceRows : " + ex.getMessage(), ex);
        } catch (JSONException ex) {
            throw ServiceException.FAILURE("saveInvoiceRows : " + ex.getMessage(), ex);
        }
        ll.add(new double[]{totaldiscount, totalamount, taxamount,totalPartialDiscount});
        ll.add(rows);
        ll.add(prodList);
        ll.add(FinalTerm);
        ll.add(supplierDetails);
        ll.add(sumOfDiscountAmount);
        return ll;
    }   
 
     public List mapSupplierExciseDetails(String supplierObj, Inventory invObj, String userid) throws ServiceException {
        List ll = new ArrayList();
        try {
            JSONArray grArr = new JSONArray(supplierObj);
            for (int cnt = 0; cnt < grArr.length(); cnt++) {
                JSONObject temp = grArr.getJSONObject(cnt);
                HashMap<String, Object> termMap = new HashMap<String, Object>();
                termMap.put("goodsreceiptid", temp.has("goodsreceiptid")? temp.getString("goodsreceiptid") :"");
                termMap.put("goodReceiptName", temp.has("invoiceName")? temp.getString("invoiceName") :"");
                termMap.put("goodReceiptDate", temp.has("invoiceDate")? temp.getString("invoiceDate") :"");
                termMap.put("vendorid", temp.has("vendorid")? temp.getString("vendorid") :"");
                termMap.put("natureofpurchaseId", temp.has("natureofpurchaseId")? temp.getString("natureofpurchaseId") :"");
                termMap.put("actualQuantity", temp.has("actualQuantity") && !StringUtil.isNullOrEmpty(temp.getString("actualQuantity")) ? Integer.parseInt(temp.getString("actualQuantity")):0);
                termMap.put("quantityUtilized", temp.has("availableQuantity") && !StringUtil.isNullOrEmpty(temp.getString("availableQuantity")) ? Integer.parseInt(temp.getString("availableQuantity")):0);
                ll.add(termMap);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return ll;
    } 
  
    public List mapInvoiceDetailTerms(String termsObj, Inventory invObj, String userid, boolean isAvalaraIntegration) throws ServiceException {
        List ll = new ArrayList();
        try {
            JSONArray termsArr = new JSONArray(termsObj);
            for (int cnt = 0; cnt < termsArr.length(); cnt++) {
                JSONObject temp = termsArr.getJSONObject(cnt);
                HashMap<String, Object> termMap = new HashMap<String, Object>();
                if (!isAvalaraIntegration) {
                    termMap.put("term", temp.has("termid")? temp.getString("termid") : temp.getString("id"));
                }
                termMap.put("termamount", Double.parseDouble(temp.getString("termamount")));
                double percentage = 0;
                if (!StringUtil.isNullOrEmpty(temp.getString("termpercentage"))) {
                    percentage = Double.parseDouble(temp.getString("termpercentage"));
                }
                termMap.put("termpercentage", percentage);
                termMap.put("assessablevalue",temp.has("assessablevalue")?Double.parseDouble(temp.getString("assessablevalue")):0);
                termMap.put("creationdate", new Date());
                if (temp.has("accountid") && !StringUtil.isNullOrEmpty(temp.getString("accountid"))) {
                    termMap.put("accountid", temp.getString("accountid"));
                }
                termMap.put("userid", userid);
                double purchaseValueOrSaleValue = 0;
                double deductionOrAbatementPercent = 0;
                
                if (temp.has("purchasevalueorsalevalue") && !StringUtil.isNullOrEmpty(temp.getString("purchasevalueorsalevalue"))) {
                    purchaseValueOrSaleValue = Double.parseDouble(temp.getString("purchasevalueorsalevalue"));
                }
                if (temp.has("deductionorabatementpercent") && !StringUtil.isNullOrEmpty(temp.getString("deductionorabatementpercent"))) {
                    deductionOrAbatementPercent = Double.parseDouble(temp.getString("deductionorabatementpercent"));
                }
                termMap.put("purchasevalueorsalevalue", purchaseValueOrSaleValue);
                termMap.put("deductionorabatementpercent", deductionOrAbatementPercent);
                /**
                 * ERP-32829 
                 */
                termMap.put("isDefault", temp.optString("isDefault", "false"));
                termMap.put("productentitytermid", temp.optString("productentitytermid"));
                if (temp.has("taxtype") && !StringUtil.isNullOrEmpty(temp.getString("taxtype"))) {
                    termMap.put("taxtype", temp.getInt("taxtype"));
                    if (temp.has("taxvalue") && !StringUtil.isNullOrEmpty(temp.getString("taxvalue"))) {
                        if(temp.getInt("taxtype")==0){ // If Flat
                            termMap.put("termamount", temp.getDouble("termamount"));
                        }else { // Else Percentage
                            termMap.put("termpercentage", temp.getDouble("taxvalue"));
                        }
                    }
                }
                
                ll.add(termMap);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return ll;
    }    
    
    public Set<InvoiceContractMapping> getInvoiceContractMappingsFromSO(JSONObject paramJObj, Invoice invoice) throws ServiceException, AccountingException, JSONException {
        String[] salesOrderIds = paramJObj.getString("linkNumber").split(",");
        Set<InvoiceContractMapping> contractMappings = new HashSet<InvoiceContractMapping>();
        for (int i = 0; i < salesOrderIds.length; i++) {
            if (!StringUtil.isNullOrEmpty(salesOrderIds[i])) {
                KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), salesOrderIds[i]);
                SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                Contract contract = salesOrder.getContract();
                Company company = salesOrder.getCompany();
                if (contract != null) {

                    InvoiceContractMapping invoiceContractMapping = new InvoiceContractMapping();
                    invoiceContractMapping.setCompany(company);
                    invoiceContractMapping.setContract(contract);
                    invoiceContractMapping.setInvoice(invoice);
                    contractMappings.add(invoiceContractMapping);

                }
            }
        }
        return contractMappings;
    }  
  
@Override   
 public String getSalesOrderStatus(SalesOrder so) throws ServiceException {
        String result = "Closed";
        try {
            Set<SalesOrderDetail> orderDetail = so.getRows();
            Iterator ite = orderDetail.iterator();
            boolean fullInv = false;
            while (ite.hasNext()) {
                SalesOrderDetail soDetail = (SalesOrderDetail) ite.next();
                double qua = 0.0;

                double quantPartTtInv = 0.0;
                double resultValue = soDetail.getQuantity();
                
                /*Fetching invoice details rows linked from 
                 *this particular sales order rows 
                 */
                    KwlReturnObject idresult = accInvoiceDAOobj.getIDFromSOD(soDetail.getID());
                    List list = idresult.getEntityList();
                    Iterator ite1 = list.iterator();            

                while (ite1.hasNext()) {
                    InvoiceDetail ge = (InvoiceDetail) ite1.next();
                   
                    /*Checking if Invoice is linked with SO partially */
                    if (ge.getInvoice().isPartialinv()) {
                        double quantity = ge.getInventory().getQuantity();
                        quantPartTtInv += quantity * ge.getPartamount();
                    } else {
                        fullInv = true;
                        qua += ge.getInventory().getQuantity();
                    }

                }

                if (fullInv) {
                    resultValue = soDetail.getQuantity() - qua;
                } else {
                    if (soDetail.getQuantity() * 100 > quantPartTtInv) {
                        resultValue = soDetail.getQuantity() - qua;
                    } else {
                        resultValue = 0;
                    }
                }
      
                /* If sales order rows in invoice is used partially, 
                 *then status is open
                 */
                if (resultValue > 0) {
                        result = "Open";
                        break;
                    }

                }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accInvoiceController.getSalesOrderStatus : " + ex.getMessage(), ex);
            }
        return result;
    }
  
@Override  
  public void updateOpenStatusFlagForDOInSI(String linkNumbers) throws ServiceException {
        HashMap hMap = new HashMap();
        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), linkNumbers);
        DeliveryOrder deliveryOrder = (DeliveryOrder) rdresult.getEntityList().get(0);
        Set<DeliveryOrderDetail> rows = deliveryOrder.getRows();
        Iterator itrCQD = rows.iterator();
        double resultValue = 0;
        boolean isOpen = false;
        while (itrCQD.hasNext()) {
            DeliveryOrderDetail row = (DeliveryOrderDetail) itrCQD.next();
            KwlReturnObject idresult = accInvoiceDAOobj.getIDFromDOD(row.getID());//fetching data from invoice detail.
            List list = idresult.getEntityList();
            Iterator iteDoD = list.iterator();
            double qua = 0.0;
            boolean fullInv = false;
            double quantPartTtInv = 0.0;
            while (iteDoD.hasNext()) {
                InvoiceDetail inv = (InvoiceDetail) iteDoD.next();
                if (inv.getInvoice().isPartialinv()) {
                    double quantity = inv.getInventory().getQuantity();
                    quantPartTtInv += quantity * inv.getPartamount();
                } else {
                    fullInv = true;
                    qua += inv.getInventory().getQuantity();
                }
            }


            if (fullInv) {
                resultValue = row.getDeliveredQuantity() - qua;
            } else {
                if (row.getDeliveredQuantity() * 100 > quantPartTtInv) {
                    resultValue = row.getDeliveredQuantity() - qua;
                } else {
                    resultValue = 0;
                }
            }


            if (resultValue > 0) {
                isOpen = true;
                break;
            }
        }
        hMap.put("isOpen", isOpen);
        hMap.put("deliveryOrder", deliveryOrder);
        accInvoiceDAOobj.updateDeliveryOrderStatus(hMap);

    } 

@Override
    public void updateOpenStatusFlagForSI(String linkNumbers) throws ServiceException {
        HashMap hMap = new HashMap();
        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(Quotation.class.getName(), linkNumbers);
        Quotation quotation = (Quotation) rdresult.getEntityList().get(0);
        Set<QuotationDetail> rows = quotation.getRows();
        Iterator itrCQD = rows.iterator();
        boolean isOpen = false;
        while (itrCQD.hasNext()) {
            QuotationDetail row = (QuotationDetail) itrCQD.next();
            KwlReturnObject idresult = accInvoiceDAOobj.getINVDFromQD(row.getID());
            List list = idresult.getEntityList();
            Iterator itePOD = list.iterator();
            double qua = 0.0;
            while (itePOD.hasNext()) {
                InvoiceDetail pod = (InvoiceDetail) itePOD.next();
                qua += pod.getInventory().getQuantity();
            }
            double addobj = row.getQuantity() - qua;
            if (addobj > 0) {
                hMap.put("isOpen", true);
                isOpen = true;
                break;
            }
        }
        hMap.put("isOpen", isOpen);
        hMap.put("quotation", quotation);
        hMap.put("value", "1");
        accInvoiceDAOobj.updateQuotationLinkflag(hMap);
    }
  
    public boolean isReplacementDO(JSONObject paramJObj) throws ServiceException {
        boolean isReplacementDO = false;
        String[] deliveryOrderIds = paramJObj.optString("linkNumber").split(",");

        for (int i = 0; i < deliveryOrderIds.length; i++) {
            KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), deliveryOrderIds[i]);
            DeliveryOrder deliveryOrder = (DeliveryOrder) rdresult.getEntityList().get(0);
            Set<DOContractMapping> dOContractMappings = deliveryOrder.getdOContractMappings();
            for (DOContractMapping contractMapping : dOContractMappings) {
                if (contractMapping.getProductReplacement() != null) {
                    isReplacementDO = true;
                }
            }
        }
        return isReplacementDO;
    } 
    
    public void saveInvNewBatch(String batchJSON, Inventory inventory, JSONObject paramJobj, String documentId) throws JSONException, ParseException, SessionExpiredException, ServiceException, UnsupportedEncodingException, AccountingException {
        JSONArray jArr = new JSONArray(batchJSON);
        double ActbatchQty = 1;
        double batchQty = 0;
        boolean isLocationForProduct = false;
        boolean isWarehouseForProduct = false;
        boolean isBatchForProduct = false;
        boolean isSerialForProduct = false;
        boolean isConsignment = false;
        boolean isRowForProduct = false;
        boolean isRackForProduct = false;
        boolean isBinForProduct = false;
        DateFormat df = authHandler.getDateOnlyFormat();
        String companyid = paramJobj.getString(Constants.companyKey);
        if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment, null))) {
            isConsignment = Boolean.parseBoolean(paramJobj.optString(Constants.isConsignment));
        }
        if (!StringUtil.isNullOrEmpty(inventory.getProduct().getID())) {
            KwlReturnObject prodresult = accProductObj.getObject(Product.class.getName(), inventory.getProduct().getID());
            Product product = (Product) prodresult.getEntityList().get(0);
            isLocationForProduct = product.isIslocationforproduct();
            isWarehouseForProduct = product.isIswarehouseforproduct();
            isBatchForProduct = product.isIsBatchForProduct();
            isSerialForProduct = product.isIsSerialForProduct();
            isRowForProduct = product.isIsrowforproduct();
            isRackForProduct = product.isIsrackforproduct();
            isBinForProduct = product.isIsbinforproduct();
        }

        //Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
        for (int i = 0; i < jArr.length(); i++) {
            JSONObject jSONObject = new JSONObject(jArr.get(i).toString());
            if (jSONObject.has("quantity") && !jSONObject.getString("quantity").equals("undefined") && !jSONObject.getString("quantity").isEmpty()) {
                ActbatchQty = jSONObject.getDouble("quantity");
            }
            if (batchQty == 0) {
                batchQty = jSONObject.getDouble("quantity");
            }
            if ((isLocationForProduct || isWarehouseForProduct || isBatchForProduct || isRowForProduct || isRackForProduct || isBinForProduct) && (batchQty == ActbatchQty)) {
                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", jSONObject.getString("quantity"));
                documentMap.put("batchmapid", jSONObject.getString("purchasebatchid"));
                documentMap.put("documentid", documentId);
                documentMap.put("transactiontype", "2");//This is invoice Type Tranction  
                if (jSONObject.has("mfgdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("mfgdate"))) {
                    documentMap.put("mfgdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("mfgdate")));
                }
                if (jSONObject.has("expdate") && !StringUtil.isNullOrEmpty(jSONObject.getString("expdate"))) {
                    documentMap.put("expdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expdate")));
                }


                if (!isBatchForProduct && !isSerialForProduct) {
                    HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
                    ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
                    filter_names.add("company.companyID");
                    filter_params.add(companyid);

                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("warehouse"))) {
                        String warehouse = jSONObject.getString("warehouse");
                        filter_names.add("warehouse.id");
                        filter_params.add(warehouse);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("location"))) {
                        String location = jSONObject.getString("location");
                        filter_names.add("location.id");
                        filter_params.add(location);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("row"))) {
                        String row = jSONObject.getString("row");
                        filter_names.add("row.id");
                        filter_params.add(row);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("rack"))) {
                        String rack = jSONObject.getString("rack");
                        filter_names.add("rack.id");
                        filter_params.add(rack);
                    }
                    if (!StringUtil.isNullOrEmpty(jSONObject.getString("bin"))) {
                        String bin = jSONObject.getString("bin");
                        filter_names.add("bin.id");
                        filter_params.add(bin);
                    }

                    filter_names.add("product");
                    filter_params.add(inventory.getProduct().getID());

                    filterRequestParams.put("filter_names", filter_names);
                    filterRequestParams.put("filter_params", filter_params);
                    filterRequestParams.put("order_by", order_by);
                    filterRequestParams.put("order_type", order_type);
                    KwlReturnObject result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
                    List listResult = result.getEntityList();
                    Iterator itrResult = listResult.iterator();
                    Double quantityToDue = ActbatchQty;
                    while (itrResult.hasNext()) {
                        if (quantityToDue > 0) {
                            NewProductBatch newProductBatch = (NewProductBatch) itrResult.next();
                            double Qty = newProductBatch.getQuantity();
                            double dueQty = newProductBatch.getQuantitydue();
                            HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                            batchUpdateQtyMap.put("id", newProductBatch.getId());
                            if ((Qty - dueQty) > 0) {
                                if (quantityToDue > (Qty - dueQty)) {
                                    if (isConsignment) {
                                        batchUpdateQtyMap.put("consignquantity", String.valueOf((-(Qty - dueQty))));//in do we are adding consignquantity and for return removing consignquantity
                                        batchUpdateQtyMap.put("qty", String.valueOf((-(Qty - dueQty))));
                                    }
                                    quantityToDue = quantityToDue - (Qty - dueQty);

                                } else {
                                    if (isConsignment) {
                                        batchUpdateQtyMap.put("consignquantity", String.valueOf((-(quantityToDue))));//in do we are adding consignquantity and for return removing consignquantity
                                        batchUpdateQtyMap.put("qty", String.valueOf(-(quantityToDue)));
                                    }
                                    quantityToDue = quantityToDue - quantityToDue;

                                }
                                documentMap.put("batchmapid", newProductBatch.getId());
                                accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);

                            }
                        }

                    }

                } else {

                    HashMap<String, Object> batchUpdateQtyMap = new HashMap<String, Object>();
                    batchUpdateQtyMap.put("qty", String.valueOf(-(Double.parseDouble(jSONObject.getString("quantity")))));
                    if (isConsignment) {
                        batchUpdateQtyMap.put("consignquantity", String.valueOf(-(Double.parseDouble(jSONObject.getString("quantity")))));
                    }
                    batchUpdateQtyMap.put("id", jSONObject.getString("purchasebatchid"));
                    accCommonTablesDAO.saveBatchAmountDue(batchUpdateQtyMap);

                }

                accCommonTablesDAO.saveBatchDocumentMapping(documentMap);
            }

            batchQty--;

            if (isSerialForProduct) {  //if serial no option is on then only save the serial no details 

                HashMap<String, Object> documentMap = new HashMap<String, Object>();
                documentMap.put("quantity", 1);
                documentMap.put("serialmapid", jSONObject.getString("purchaseserialid"));
                documentMap.put("documentid", documentId);
                documentMap.put("transactiontype", "2");//This is invoice Type Tranction  
                if (jSONObject.has("expstart") && !StringUtil.isNullOrEmpty(jSONObject.getString("expstart"))) {
                    documentMap.put("expfromdate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expstart")));
                }
                if (jSONObject.has("expend") && !StringUtil.isNullOrEmpty(jSONObject.getString("expend"))) {
                    documentMap.put("exptodate", authHandler.getDateOnlyFormat().parse(jSONObject.getString("expend")));
                }

                accCommonTablesDAO.saveSerialDocumentMapping(documentMap);
                HashMap<String, Object> serialUpdateQtyMap = new HashMap<String, Object>();
                serialUpdateQtyMap.put("qty", "-1");
                serialUpdateQtyMap.put("consignquantity", "-1");
                serialUpdateQtyMap.put("id", jSONObject.getString("purchaseserialid"));
                accCommonTablesDAO.saveSerialAmountDue(serialUpdateQtyMap);

            } else {
                batchQty = 0;
            }
        }
    }   
   
@Override 
    public HashMap mapExciseDetails(String invid, JSONObject temp,JSONObject paramJobj) throws ServiceException {
        HashMap<String, Object> exciseMap = new HashMap<String, Object>();
        try {
            exciseMap.put("id", temp.has("id") ? temp.getString("id") : "");
            exciseMap.put("invoiceid", invid);
            exciseMap.put("suppliers", temp.has("suppliers") ? temp.getString("suppliers") : "");
            exciseMap.put("supplierTINSalesTAXNo", temp.has("supplierTINSalesTAXNo") ? temp.getString("supplierTINSalesTAXNo") : "");
            exciseMap.put("supplierExciseRegnNo", temp.has("supplierExciseRegnNo") ? temp.getString("supplierExciseRegnNo") : "");
            exciseMap.put("cstnumber", temp.has("cstnumber") ? temp.getString("cstnumber") : "");
            exciseMap.put("supplierRange", temp.has("supplierRange") ? temp.getString("supplierRange") : "");
            exciseMap.put("supplierCommissionerate", temp.has("supplierCommissionerate") ? temp.getString("supplierCommissionerate") : "");
            exciseMap.put("supplierAddress", temp.has("supplierAddress") ? temp.getString("supplierAddress") : "");
            if (temp.has("supplierState") && !temp.getString("supplierState").equals("")) {
                exciseMap.put("supplierState", temp.has("supplierState") ? temp.getString("supplierState") : "");
            }
            exciseMap.put("supplierImporterExporterCode", temp.has("supplierImporterExporterCode") ? temp.getString("supplierImporterExporterCode") : "");
            exciseMap.put("supplierDivision", temp.has("supplierDivision") ? temp.getString("supplierDivision") : "");
            exciseMap.put("manufacturername", temp.has("manufacturername") ? temp.getString("manufacturername") : "");
            exciseMap.put("manufacturerExciseRegnNo", temp.has("manufacturerExciseRegnNo") ? temp.getString("manufacturerExciseRegnNo") : "");
            exciseMap.put("manufacturerRange", temp.has("manufacturerRange") ? temp.getString("manufacturerRange") : "");
            exciseMap.put("manufacturerCommissionerate", temp.has("manufacturerCommissionerate") ? temp.getString("manufacturerCommissionerate") : "");
            exciseMap.put("manufacturerDivision", temp.has("manufacturerDivision") ? temp.getString("manufacturerDivision") : "");
            exciseMap.put("manufacturerAddress", temp.has("manufacturerAddress") ? temp.getString("manufacturerAddress") : "");
            exciseMap.put("manufacturerImporterExporterCode", temp.has("manufacturerImporterExporterCode") ? temp.getString("manufacturerImporterExporterCode") : "");
            exciseMap.put("InvoicenoManuFacture", temp.has("InvoicenoManuFacture") ? temp.getString("InvoicenoManuFacture") : "");
            if (temp.has("InvoiceDateManuFacture") && temp.get("InvoiceDateManuFacture") != null && !temp.get("InvoiceDateManuFacture").equals("")) {
                exciseMap.put("InvoiceDateManuFacture", authHandler.getDateOnlyFormat().parse(temp.getString("InvoiceDateManuFacture")));
            }
            exciseMap.put("registrationType", temp.has("registrationType") ? temp.getString("registrationType") : "");
            exciseMap.put("UnitName", temp.has("UnitName") ? temp.getString("UnitName") : "");
            exciseMap.put("ECCNo", temp.has("ECCNo") ? temp.getString("ECCNo") : "");
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return exciseMap;
    }
     
    private void deleteEntryInTemp(Map deleteparam) {
        try {
            String invoiceno = deleteparam.get("invoiceno").toString();
            String dono = deleteparam.get("dono").toString();
            String companyid = deleteparam.get(Constants.companyKey).toString();
            accCommonTablesDAO.deleteTransactionInTemp(invoiceno, companyid, Constants.Acc_Invoice_ModuleId);
            if (deleteparam.containsKey("isautocreatedo") && deleteparam.get("isautocreatedo") != null) {
                accCommonTablesDAO.deleteTransactionInTemp(dono, companyid, Constants.Acc_Delivery_Order_ModuleId);
            }
        } catch (ServiceException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    public List mapInvoiceTerms(String InvoiceTerms, String ID, String userid, boolean isDO) throws ServiceException {
        List ll = new ArrayList();
        try {
            JSONArray termsArr = new JSONArray(InvoiceTerms);
            for (int cnt = 0; cnt < termsArr.length(); cnt++) {
                JSONObject temp = termsArr.getJSONObject(cnt);
                HashMap<String, Object> termMap = new HashMap<String, Object>();
                termMap.put("term", temp.getString("id"));
                termMap.put("termamount", Double.parseDouble(temp.getString("termamount")));
                termMap.put("termtaxamount", temp.optDouble("termtaxamount",0));
                termMap.put("termtaxamountinbase", temp.optDouble("termtaxamountinbase",0));
                termMap.put("termtax", temp.optString("termtax",null));
                termMap.put("termAmountExcludingTax", temp.optDouble("termAmountExcludingTax",0));
                termMap.put("termAmountExcludingTaxInBase", temp.optDouble("termAmountExcludingTaxInBase",0));
                termMap.put("termamountinbase", temp.optDouble("termamountinbase",0));
                double percentage = 0;
                if (!StringUtil.isNullOrEmpty(temp.getString("termpercentage"))) {
                    percentage = Double.parseDouble(temp.getString("termpercentage"));
                }
                termMap.put("termpercentage", percentage);
                termMap.put("creationdate", new Date());
                termMap.put("userid", userid);
                termMap.put("invoicedetail",temp.optString("invoicedetail"));
                if (isDO) {
                    termMap.put("deliveryOrderID", ID);
                    accInvoiceDAOobj.saveDeliveryOrderTermMap(termMap);
                } else {
                    termMap.put("invoice", ID);
                    accInvoiceDAOobj.saveInvoiceTermMap(termMap);
                }
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return ll;
    }
    
     
    public synchronized String updateJEEntryNumberForNewJE(JSONObject paramJobj, JournalEntry JE, String companyid, String sequenceFormat, int approvedLevel) throws ServiceException {
        String entryNumber = "";
        try {
            Map<String, Object> jeDataMap = AccountingManager.getGlobalParamsJson(paramJobj);
            String nextJEAutoNo = null;
            boolean seqformat_oldflag = false;//StringUtil.getBoolean(request.getParameter("seqformat_oldflag"));
            String nextAutoNoInt = "";
            String datePrefix = "";
            String dateafterPrefix = "";
            String dateSuffix = "";
	    boolean isDraft = false;
            if (seqformat_oldflag) {
                nextJEAutoNo = accCompanyPreferencesObj.getNextAutoNumber(companyid, StaticValues.AUTONUM_JOURNALENTRY, sequenceFormat);
            } else {
                Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, sequenceFormat, seqformat_oldflag,JE.getEntryDate());
                nextJEAutoNo = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                nextAutoNoInt = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                datePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                dateafterPrefix = (String)seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                dateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                jeDataMap.put(Constants.SEQFORMAT, sequenceFormat);                
                jeDataMap.put(Constants.DATEPREFIX, datePrefix);
                jeDataMap.put(Constants.DATEAFTERPREFIX, dateafterPrefix);
                jeDataMap.put(Constants.DATESUFFIX, dateSuffix);
                entryNumber = nextJEAutoNo;
		if(paramJobj.has("isDraft")){
                    isDraft = paramJobj.optBoolean("isDraft", false);                    
                }
                if(isDraft){
                    entryNumber = "";    //SDP-13487 -  Set JE No. and its auto count empty.    //ERP-38357 : If isDraft=TRUE then JE No.will not be create / update.
                    nextAutoNoInt = "";
                }
                // ERP-38100
                if(!StringUtil.isNullOrEmpty(nextAutoNoInt)){
                    jeDataMap.put(Constants.SEQNUMBER, nextAutoNoInt);                    
                }

            }
            jeDataMap.put("entrydate", JE.getEntryDate());
            jeDataMap.put(Constants.companyKey, companyid);
            jeDataMap.put("entrynumber", entryNumber);
            jeDataMap.put("jeid", JE.getID());
            jeDataMap.put("istemplate", JE.getIstemplate());
            jeDataMap.put("isReval", JE.getIsReval());
            jeDataMap.put("isDraft", JE.isDraft());
            jeDataMap.put("pendingapproval", approvedLevel);                
            KwlReturnObject je1result = accJournalEntryobj.saveJournalEntry(jeDataMap);
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return entryNumber;
    }
    
    
    /*----------Fucntion for approving JE at the time of Editing Document ------------*/
    public synchronized String updateJEEntryNumberForNewJE(Map<String, Object> jeDataMap, JournalEntry JE, String companyid, String sequenceFormat, int approvedLevel) {
        String entryNumber = "";
        try {
            //Map<String, Object> jeDataMap = AccountingManager.getGlobalParams(request);
            String nextJEAutoNo = null;
            boolean seqformat_oldflag = false;
            String nextAutoNo = "";
            String nextAutoNoInt = "";
            String datePrefix = "";
            String dateafterPrefix = "";
            String dateSuffix = "";
            String postingDateStr = jeDataMap.containsKey("postingDate") && jeDataMap.get("postingDate") != null ? (String) jeDataMap.get("postingDate") : "";
            DateFormat df = authHandler.getDateOnlyFormat();
            Date postingDate = null;
            Map<String, Object> paramMap = new HashMap<>();
            paramMap.put("id", companyid);
            Object exPrefObject = kwlCommonTablesDAOObj.getRequestedObjectFields(ExtraCompanyPreferences.class, new String[]{"columnPref"}, paramMap);
            JSONObject jObj = StringUtil.isNullObject(exPrefObject) ? new JSONObject() : new JSONObject(exPrefObject.toString());
            boolean isPostingDateCheck = false;
            if (!StringUtil.isNullObject(jObj) && jObj.has(Constants.IS_POSTING_DATE_CHECK) && jObj.get(Constants.IS_POSTING_DATE_CHECK) != null && jObj.optBoolean(Constants.IS_POSTING_DATE_CHECK, false)) {
                isPostingDateCheck = true;
            }
            if (!StringUtil.isNullOrEmpty(postingDateStr)) {
                postingDate = df.parse(postingDateStr);
            }
            if (seqformat_oldflag) {
                nextJEAutoNo = accCompanyPreferencesObj.getNextAutoNumber(companyid, StaticValues.AUTONUM_JOURNALENTRY, sequenceFormat);
            } else {
                Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                if (postingDate != null && isPostingDateCheck) {
                    seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, sequenceFormat, seqformat_oldflag, postingDate);
                } else {
                    seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, sequenceFormat, seqformat_oldflag, JE.getEntryDate());
                }
                nextJEAutoNo = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                nextAutoNoInt = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                datePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                dateafterPrefix = (String) seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                dateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                jeDataMap.put(Constants.SEQFORMAT, sequenceFormat);
                jeDataMap.put(Constants.SEQNUMBER, nextAutoNoInt);
                jeDataMap.put(Constants.DATEPREFIX, datePrefix);
                jeDataMap.put(Constants.DATEAFTERPREFIX, dateafterPrefix);
                jeDataMap.put(Constants.DATESUFFIX, dateSuffix);
                entryNumber = nextJEAutoNo;

            }
            if (isPostingDateCheck && postingDate != null) {
                jeDataMap.put("entrydate", postingDate);
            } else {
                jeDataMap.put("entrydate", JE.getEntryDate());
            }
            jeDataMap.put("companyid", companyid);
            jeDataMap.put("entrynumber", entryNumber);
            jeDataMap.put("jeid", JE.getID());
            jeDataMap.put("istemplate", JE.getIstemplate());
            jeDataMap.put("isReval", JE.getIsReval());
            jeDataMap.put("isDraft", JE.isDraft());
            jeDataMap.put("pendingapproval", approvedLevel);
            KwlReturnObject je1result = accJournalEntryobj.saveJournalEntry(jeDataMap);
        } catch (Exception e) {
            Logger.getLogger(accJournalEntryController.class.getName()).log(Level.SEVERE, null, e);
        }

        return entryNumber;
    }
    
    /**
     * Description: Method for importing and validating Sales Invoices.
     *
     * @param paramJobj
     * @return
     */
//    public JSONObject importInvoicesJSON(JSONObject paramJobj) {
//        JSONObject jobj = new JSONObject();
//        try {
//            String doAction = paramJobj.getString("do");
//
//            if (doAction.compareToIgnoreCase("import") == 0) {
//                importInvoiceThreadobj.add(paramJobj);
//                    if (!importInvoiceThreadobj.isIsworking()) {
//                        Thread t = new Thread(importInvoiceThreadobj);
//                        t.setPriority(7);
//                        t.start();
//                    } 
////                jobj = importInvoiceRecordsForCSV(paramJobj);
//            } else if (doAction.compareToIgnoreCase("validateData") == 0) {
//                String eParams = paramJobj.getString("extraParams");
//                JSONObject extraParams = StringUtil.isNullOrEmpty(eParams) ? new JSONObject() : new JSONObject(eParams);
//
//                HashMap<String, Object> requestParams = importHandler.getImportRequestParams(paramJobj);
//                requestParams.put("extraParams", extraParams);
//                requestParams.put("extraObj", null);
//                requestParams.put("servletContext", paramJobj.get("servletContext"));
//
//                jobj = importHandler.validateFileData(requestParams);
//                jobj.put(Constants.RES_success, true);
//            }
//        } catch (Exception ex) {
//            try {
//                jobj.put(Constants.RES_success, false);
//                jobj.put(Constants.RES_msg, "" + ex.getMessage());
//            } catch (JSONException jex) {
//                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, jex);
//            }
//        }
//        return jobj;
//    }

    /**
     * Description: Method for business logic of import Sales Invoices.
     *
     * @param requestJobj
     * @return
     * @throws AccountingException
     * @throws IOException
     * @throws SessionExpiredException
     * @throws JSONException
     */
//    public JSONObject importInvoiceRecordsForCSV(JSONObject requestJobj) throws AccountingException, IOException, SessionExpiredException, JSONException {
//        JSONObject returnObj = new JSONObject();
//        String msg = "";
//        int total = 0, failed = 0;
//        String fileName = requestJobj.getString("filename");
//        String companyID = requestJobj.getString(Constants.companyKey);
//        String masterPreference = requestJobj.getString("masterPreference");
//        boolean issuccess = true;
//        boolean isAlreadyExist = false;
//        boolean isRecordFailed = false;
//        boolean isGenerateDeliveryOrder = false;
//        FileInputStream fileInputStream = null;
//        CsvReader csvReader = null;
//        HashMap<String, Object> invoiceDataMap = new HashMap<>();
//        Map <String,Object> rowDetailMap = new HashMap<>();
//        Map <String,List<JSONObject>> batchMap = new HashMap<>();
//        Map <String,List<Object>> batchSerialMap = new HashMap<>();
//        JSONArray batchDetailArr = new JSONArray();
//        Set<String> uniqueLineLevelRecordKeyList = new HashSet<>(); // Hashset to identify duplicate line level and inner line level record (InvoiceNumber + Product + Warehouse + Location + Batch)
//        JSONObject paramJobj = new JSONObject();
//        JSONArray rows = new JSONArray();
//        JSONArray invoiceTermDetailsArray = new JSONArray();
//        String prevRow = "";
//        String prevInvNo = "";
//        double totaldiscount = 0, totalamount = 0;
//        double totalBatchQty=0;
//        String entryNumber = "";
//        boolean imported=false;
//        boolean isCashTransaction=requestJobj.optBoolean("incash", false);
//
//        try {
//            String dateFormat = null, dateFormatId = requestJobj.getString("dateFormat");
//            if (!StringUtil.isNullOrEmpty(dateFormatId)) {
//                KwlReturnObject kdfObj = accountingHandlerDAOobj.getObject(KWLDateFormat.class.getName(), dateFormatId);
//                KWLDateFormat kdf = (KWLDateFormat) kdfObj.getEntityList().get(0);
//
//                dateFormat = kdf != null ? kdf.getJavaForm() : null;
//            }
//            DateFormat df = new SimpleDateFormat(dateFormat);
//            df.setLenient(false);
//            requestJobj.put(Constants.importdf, df); //sending this format for Processing batch details
//
//            SimpleDateFormat sdf = new SimpleDateFormat("MMMM d, yyyy hh:mm:ss aa");
//            boolean isSlaesTerm=true;
//            LinkedHashMap<String,InvoiceTermsSales> salesTermMap= getSlaestermMapByNameKey(companyID,isSlaesTerm);
//            
//            KwlReturnObject extraPref = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyID);
//            ExtraCompanyPreferences extrareferences = (ExtraCompanyPreferences) extraPref.getEntityList().get(0);
//            Boolean isCurrencyCode = extrareferences.isCurrencyCode();
//
//            KwlReturnObject cap = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyID);
//            CompanyAccountPreferences preferences = (CompanyAccountPreferences) cap.getEntityList().get(0);
//            String destinationDirectory = storageHandlerImpl.GetDocStorePath() + "importplans";
//            File filePath = new File(destinationDirectory + File.separator + fileName);
//            fileInputStream = new FileInputStream(filePath);
//            String delimiterType = requestJobj.getString("delimiterType");
//            csvReader = new CsvReader(new InputStreamReader(fileInputStream), delimiterType);
//
//            JSONObject resjson = new JSONObject(requestJobj.getString("resjson"));
//            JSONArray jSONArray = resjson.getJSONArray("root");
//            HashMap<String, Integer> columnConfig = new HashMap<>();
//            for (int i = 0; i < jSONArray.length(); i++) {
//                JSONObject jSONObject = jSONArray.getJSONObject(i);
//                columnConfig.put(jSONObject.getString("dataindex"), jSONObject.getInt("csvindex"));
//            }
//
//            Set invoiceTermIDsForSingleInvoice=new HashSet<>();
//            int cnt = 0;
//            StringBuilder failedRecords = new StringBuilder();
//            StringBuilder singleInvociceFailedRecords = new StringBuilder();// Invoive with one row of failure record then all rows will be included in failure file
//            int singleInvoiceFailureRecoredCount = 0;//  count of total invoice rows in import file
//            Set<String> failureList = new HashSet<>(); // set of invoice having failyure record's
//            
//            HashMap currencyMap = accSalesOrderServiceobj.getCurrencyMap(isCurrencyCode);
//
//            while (csvReader.readRecord()) {
//                String failureMsg = "";
//                boolean isfailurerecord = false; // used to keep track Invoice Row  failure/correct
//                String[] recarr = csvReader.getValues();
//
//                if (cnt == 0) {
//                    failedRecords.append(accSalesOrderServiceobj.createCSVrecord(recarr)).append("\" \"");
//                } else if (cnt == 1) {
//                    failedRecords.append("\n").append(accSalesOrderServiceobj.createCSVrecord(recarr)).append("\"Error Message\"");
//                } else {
//                    try {
//                        String currencyID = requestJobj.getString(Constants.globalCurrencyKey);
//                       /*****************************Validating Global Level Data *****************************/
//                        entryNumber = "";
//                        if (columnConfig.containsKey("invoiceNumber")) {
//                            entryNumber = recarr[(Integer) columnConfig.get("invoiceNumber")].replaceAll("\"", "").trim();
//                            if (StringUtil.isNullOrEmpty(entryNumber)) {
//                                failureMsg += "Invoice Number is not available. ";
//                            }
//                        } else {
//                            failureMsg += "Invoice Number column is not found. ";
//                        }
//
//                        Date billDate = null;
//                        if (columnConfig.containsKey("billdate")) {
//                            String customerQutationDateStr = recarr[(Integer) columnConfig.get("billdate")].replaceAll("\"", "").trim();
//
//                            if (StringUtil.isNullOrEmpty(customerQutationDateStr)) {
//                                failureMsg += "Invoice Date is not available. ";
//                            } else {
//                                try {
//                                    billDate = df.parse(customerQutationDateStr);
//                                } catch (Exception ex) {
//                                    failureMsg += "Incorrect date format for Invoice Date, Please specify values in " + dateFormat + " format. ";
//                                }
//                            }
//                        } else {
//                            failureMsg += "Invoice Date column is not found. ";
//                        }
//                        
//                        String poRefNumber = "";
//                        if (columnConfig.containsKey("poRefNumber")) {
//                            poRefNumber = recarr[(Integer) columnConfig.get("poRefNumber")].replaceAll("\"", "").trim();
//                        }
//                        String exportDeclarationNo = "";
//                        if (columnConfig.containsKey(Constants.importExportDeclarationNo)) {
//                            exportDeclarationNo = recarr[columnConfig.get(Constants.importExportDeclarationNo)].replaceAll("\"", "").trim();
//                        }
//
//                        String costCenterID = "";
//                        if (columnConfig.containsKey("costcenter")) {
//                            String costCenterName = recarr[(Integer) columnConfig.get("costcenter")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(costCenterName)) {
//                                costCenterID = accSalesOrderServiceobj.getCostCenterIDByName(costCenterName, companyID);
//                                if (StringUtil.isNullOrEmpty(costCenterID)) {
//                                    failureMsg += "Cost Center is not found for name " + costCenterName + ". ";
//                                }
//                            }
//                        }
//
//                        Date dueDate = null;
//                        if (!isCashTransaction) {
//                            if (columnConfig.containsKey("dueDate")) {
//                                String dueDateStr = recarr[(Integer) columnConfig.get("dueDate")].replaceAll("\"", "").trim();
//
//                                if (StringUtil.isNullOrEmpty(dueDateStr)) {
//                                    failureMsg += "Due Date is not available. ";
//                                } else {
//                                    dueDate = df.parse(dueDateStr);
//                                }
//                            } else {
//                                failureMsg += "Due Date column is not found. ";
//                            }
//                        }
//                        
//                        String customerID = "";
//
//                        /*
//                         * 1. Customer Code
//                         */
//                        if (columnConfig.containsKey("CustomerCode")) {
//                            String customerCode = recarr[(Integer) columnConfig.get("CustomerCode")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(customerCode)) {
//                                Customer customer = getCustomerByCode(customerCode, companyID);
//                                if (customer != null) {
//                                    customerID = customer.getID();
//                                } else {
//                                    throw new AccountingException(messageSource.getMessage("acc.field.CustomerCodeisnotavailable", null, Locale.forLanguageTag(requestJobj.getString(Constants.language))) + customerCode);
//                                }
//                            }
//                        }
//                        
//                        /*
//                         * 2. Customer Name if customerID is empty it menas
//                         * customer is not found for given code. so need to
//                         * serch data on name
//                         */
//                        if (StringUtil.isNullOrEmpty(customerID)) {
//                            if (columnConfig.containsKey("CustomerName")) {
//                                String customerName = recarr[(Integer) columnConfig.get("CustomerName")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(customerName)) {
//                                    Customer customer = null;
//                                    KwlReturnObject retObj = accCustomerDAOObj.getCustomerByName(customerName, companyID);
//                                    if (retObj != null && !retObj.getEntityList().isEmpty()) {
//                                        customer = (Customer) retObj.getEntityList().get(0);
//                                    }
//                                    if (customer != null) {
//                                        customerID = customer.getID();
//                                    } else {
//                                        failureMsg += messageSource.getMessage("acc.field.CustomerisnotfoundforCustomerCodeName", null, Locale.forLanguageTag(requestJobj.getString(Constants.language)));
//                                    }
//                                } else {
//                                    failureMsg += messageSource.getMessage("acc.field.CustomerisnotfoundforCustomerCodeName", null, Locale.forLanguageTag(requestJobj.getString(Constants.language)));
//                                }
//                            } else {
//                                failureMsg += messageSource.getMessage("acc.field.CustomerisnotfoundforCustomerCodeName", null, Locale.forLanguageTag(requestJobj.getString(Constants.language)));
//                            }
//                        }
//
//                        String termID = "";
//                        if (!isCashTransaction) {
//                            if (columnConfig.containsKey("terms")) {
//                                String termName = recarr[(Integer) columnConfig.get("terms")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(termName)) {
//                                    termID = accSalesOrderServiceobj.getTermIDByName(termName, companyID);
//                                    if (StringUtil.isNullOrEmpty(termID)) {
//                                        failureMsg += "Credit Term is not found for name " + termName + ". ";
//                                    }
//                                } else {
//                                    failureMsg += "Credit Term is not available. ";
//                                }
//                            } else {
//                                failureMsg += "Credit Term column is not found. ";
//                            }
//                        }
//
//                        String memo = "";
//                        if (columnConfig.containsKey(Constants.memo)) {
//                            memo = recarr[(Integer) columnConfig.get(Constants.memo)].replaceAll("\"", "").trim();
//                        }
//
//                        String shipVia = "";
//                        if (columnConfig.containsKey("shipvia")) {
//                            shipVia = recarr[(Integer) columnConfig.get("shipvia")].replaceAll("\"", "").trim();
//                        }
//                        /*
//                        Ship date as Delivery Date for Invoice module
//                        */
//                        Date shipDate = null;
//                        if (columnConfig.containsKey("shipdate")) {
//                            String shipDateStr = recarr[(Integer) columnConfig.get("shipdate")].replaceAll("\"", "").trim();
//
//                            if (!StringUtil.isNullOrEmpty(shipDateStr)) {
//                                try {
//                                    shipDate = df.parse(shipDateStr);
//                                } catch (Exception ex) {
//                                    failureMsg += "Incorrect date format for Ship Date, Please specify values in " + dateFormat + " format. ";
//                                }
//                            }
//                        }
//
//                        String fob = "";
//                        if (columnConfig.containsKey(Constants.fob)) {
//                            fob = recarr[(Integer) columnConfig.get(Constants.fob)].replaceAll("\"", "").trim();
//                        }
//
//                        String salesPersonID = "";
//                        if (columnConfig.containsKey("salesperson")) {
//                            String salesPersonName = recarr[(Integer) columnConfig.get("salesperson")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(salesPersonName)) {
//                                salesPersonID = accSalesOrderServiceobj.getSalesPersonIDByName(salesPersonName, companyID);
//                                if (StringUtil.isNullOrEmpty(salesPersonID)) {
//                                    failureMsg += "Sales Person is not found for name " + salesPersonName + ". ";
//                                }
//                            }
//                        }
//
//                        if (isCurrencyCode ? columnConfig.containsKey("currencyCode") : columnConfig.containsKey("currencyName")) {
//                            String currencyStr = isCurrencyCode ? recarr[(Integer) columnConfig.get("currencyCode")].replaceAll("\"", "").trim() : recarr[(Integer) columnConfig.get("currencyName")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(currencyStr)) {
//                                currencyID = accSalesOrderServiceobj.getCurrencyId(currencyStr, currencyMap);
//
//                                if (StringUtil.isNullOrEmpty(currencyID)) {
//                                    failureMsg += messageSource.getMessage("acc.field.ImportProductExceptionFormat", null, Locale.forLanguageTag(requestJobj.getString(Constants.language))) + ". ";
//                                }
//                            } else {
//                                if (!masterPreference.equalsIgnoreCase("1")) {
//                                    failureMsg += "Currency is not available. ";
//                                }
//                            }
//                        }
//
//                        isGenerateDeliveryOrder = false;
//                        if (columnConfig.containsKey("generateDeliveryOrder")) {
//                            String generateGoodsReceipt = recarr[(Integer) columnConfig.get("generateDeliveryOrder")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(generateGoodsReceipt)) {
//                                if (generateGoodsReceipt.equalsIgnoreCase("TRUE")) {
//                                    isGenerateDeliveryOrder = true;
//                                } else if (generateGoodsReceipt.equalsIgnoreCase("FALSE")) {
//                                    isGenerateDeliveryOrder = false;
//                                } else {
//                                    throw new AccountingException("Format you entered for Generate Delivery Order is not correct. It should be like \"TRUE\" or \"FALSE\"");
//                                }
//                            } else {
//                                isGenerateDeliveryOrder = false;
//                            }
//                        }
//
//                        String deliveryOrderNo = "";
//                        if (columnConfig.containsKey("deliveryOrderNo")) {
//                            deliveryOrderNo = recarr[(Integer) columnConfig.get("deliveryOrderNo")].replaceAll("\"", "").trim();
//                            if (isGenerateDeliveryOrder) {
//                                if (StringUtil.isNullOrEmpty(deliveryOrderNo)) {
//                                    failureMsg += "Delivery Order Number is not available. ";
//                                } 
//                            }
//                        }
//
//                        boolean isIncludingGST = false;
//                        /**
//                         * If Avalara Integration is enabled, then includingGST flag is always false
//                         */
//                        if (columnConfig.containsKey("gstIncluded") && !extrareferences.isAvalaraIntegration()) {
//                            String isIncludingGSTStr = recarr[(Integer) columnConfig.get("gstIncluded")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(isIncludingGSTStr)) {
//                                if (isIncludingGSTStr.equalsIgnoreCase("TRUE")) {
//                                    isIncludingGST = true;
//                                } else if (isIncludingGSTStr.equalsIgnoreCase("FALSE")) {
//                                    isIncludingGST = false;
//                                } else {
//                                    failureMsg += "Format you entered for Include GST is not correct. It should be like \"TRUE\" or \"FALSE\". ";
//                                }
//                            }
//                        }
//
//                        boolean isIncludeProductTax = false;
//                        if (columnConfig.containsKey("includeprotax")) {
//                            String isIncludeProductTaxStr = recarr[(Integer) columnConfig.get("includeprotax")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(isIncludeProductTaxStr)) {
//                                if (isIncludeProductTaxStr.equalsIgnoreCase("Yes")) {
//                                    isIncludeProductTax = true;
//                                } else if (isIncludeProductTaxStr.equalsIgnoreCase("No")) {
//                                    isIncludeProductTax = false;
//                                } else {
//                                    failureMsg += "Format you entered for Include Product Tax is not correct. It should be like \"Yes\" or \"No\". ";
//                                }
//                            }
//                        }
//
//                        if (isIncludingGST && !isIncludeProductTax) {
//                            failureMsg += "If value Including GST is \"TRUE\" then value of Include Product Tax should be \"Yes\". ";
//                        }
//
//                        boolean isIncludeTotalTax = false;
//                        if (columnConfig.containsKey("taxincluded")) {
//                            String isIncludeTotalTaxStr = recarr[(Integer) columnConfig.get("taxincluded")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(isIncludeTotalTaxStr)) {
//                                if (isIncludeTotalTaxStr.equalsIgnoreCase("Yes")) {
//                                    isIncludeTotalTax = true;
//                                } else if (isIncludeTotalTaxStr.equalsIgnoreCase("No")) {
//                                    isIncludeTotalTax = false;
//                                } else {
//                                    failureMsg += "Format you entered for Include Total Tax is not correct. It should be like \"Yes\" or \"No\". ";
//                                }
//                            }
//                        }
//
//                        if (isIncludeProductTax && isIncludeTotalTax) {
//                            failureMsg += "If value of Include Product Tax is \"Yes\" then value of Include Total Tax should be \"No\".";
//                        }
//
//                        String taxID = "";
//                        if (columnConfig.containsKey("taxid")) {
//                            String taxCode = recarr[(Integer) columnConfig.get("taxid")].replaceAll("\"", "").trim();
//                            if (!StringUtil.isNullOrEmpty(taxCode)) {
//                                Tax tax = accSalesOrderServiceobj.getGSTByCode(taxCode, companyID);
//                                if (tax == null) {
//                                    failureMsg += "Tax Code is not found for code " + taxCode;
//                                } else {
//                                    taxID = tax.getID();
//                                }
//                            } else {
//                                if (!isIncludingGST && !isIncludeProductTax && isIncludeTotalTax) {
//                                    failureMsg += "Tax Code is not available. ";
//                                }
//                            }
//                        } else {
//                            if (!isIncludingGST && !isIncludeProductTax && isIncludeTotalTax) {
//                                failureMsg += "Tax Code column is not found. ";
//                            }
//                        }
//                        
//                     /***************************** Validating Invoice Term Data *****************************/
//                        boolean isNewInvoiceRecord = (!prevInvNo.equalsIgnoreCase(entryNumber) || entryNumber.equalsIgnoreCase(""));
//                        if(isNewInvoiceRecord){
//                            invoiceTermIDsForSingleInvoice = new HashSet<>();
//                        }
//                        boolean isAllInvoiceTermDataisEmpty = isAllTermInvoiceInformationIsEmpty(columnConfig, recarr);
//                        InvoiceTermsSales termsSales = null;
//                        int termType = 0;
//                        double termValue = 0;
//                        if (!isAllInvoiceTermDataisEmpty) {
//                            String termName = "";
//                            if (columnConfig.containsKey("invoiceterm")) {
//                                termName = recarr[(Integer) columnConfig.get("invoiceterm")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(termName)) {
//                                    if (salesTermMap.containsKey(termName.toLowerCase()) && salesTermMap.get(termName.toLowerCase()) != null) {//while putting key in salesTermMap we have putted it as lowercase hence checkinh here with lowercase
//                                        termsSales = salesTermMap.get(termName.toLowerCase());
//                                    }
//                                    if (termsSales == null) {
//                                        failureMsg += "Invoice Term " + termName + " is not avilable.";
//                                    } 
//                                    if (termsSales != null) {
//                                        boolean added = invoiceTermIDsForSingleInvoice.add(termsSales.getId());
//                                        if (!added) {
//                                        /*If- sucessfully added it means user has applying term first time. 
//                                          else- user has already applied and trying to give twice which is invalid case for single invoice */
//                                            failureMsg += "Invoice Term " + termName + " is already applied for invoice " + entryNumber + ".";
//                                        }
//                                    }
//                                   
//                                } 
//                            } else {
//                                failureMsg += "Invoice Term column is not found. ";
//                            }
//
//
//                            String termTypeStr = "";
//                            if (columnConfig.containsKey("termtype")) {
//                                termTypeStr = recarr[(Integer) columnConfig.get("termtype")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(termTypeStr)) {
//                                    if (termTypeStr.equalsIgnoreCase("percentage")) {
//                                        termType = 1;
//                                    } else if (termTypeStr.equalsIgnoreCase("flat")) {
//                                        termType = 2;
//                                    } else {
//                                        failureMsg += "Incorrect value " + termTypeStr + " found in column Term Type. It should be like \"Percentage\" or \"Flat\". ";
//                                    }
//                                } else {
//                                    failureMsg += "Empty data found in column Term Type";
//                                }
//                            } else {
//                                failureMsg += "Term Type column is not found. ";
//                            }
//
//
//                            String termValueStr = "";
//                            if (columnConfig.containsKey("termvalue")) {
//                                termValueStr = recarr[(Integer) columnConfig.get("termvalue")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(termValueStr)) {
//                                    try {
//                                        termValue = authHandler.round(Double.parseDouble(termValueStr), companyID);
//                                    } catch (Exception ex) {
//                                        failureMsg += "Incorrect numeric value for Term Value, Please ensure that value type of Term Value matches with the Term Value. ";
//                                    }
//                                } else {
//                                    failureMsg += "Empty data found in column Term Value.";
//                                }
//                            } else {
//                                failureMsg += "Term Value column is not found. ";
//                            }
//                        }
//                        
//                        /**
//                         * **********Code for validating Global Level Data is
//                         * same or different************
//                         */
//                        if (!isNewInvoiceRecord && StringUtil.isNullOrEmpty(failureMsg) && paramJobj.length()>0 ) {//when old invoice repeating
//                            // Global Level Mandatory Fields
//                            String mismatchColumns = "";
//                            if (paramJobj.has("termid")) {// Credit term
//                                if (!paramJobj.optString("termid", "").equals(termID)) {
//                                    mismatchColumns += "Credit Term,";
//                                }
//                            }
//                            if (paramJobj.has(Constants.currencyKey)) {// Currency
//                                if (!paramJobj.optString(Constants.currencyKey, "").equals(currencyID)) {
//                                    mismatchColumns += "Currency,";
//                                }
//                            }
//                            if (paramJobj.has("customer")) {// Cudtomer Code
//                                if (!paramJobj.optString("customer", "").equals(customerID)) {
//                                    mismatchColumns += "Customer Code,";
//                                }
//                            }
//
//                            if (paramJobj.has("numberDo")) {// Delivery Order Number
//                                if (!paramJobj.optString("numberDo", "").equals(deliveryOrderNo)) {
//                                    mismatchColumns += "Delivery Order Number,";
//                                }
//                            }
//                            if (paramJobj.has("duedate") && !StringUtil.isNullOrEmpty(paramJobj.optString("duedate", null)) && dueDate != null) {// Due Date
//                                if (!paramJobj.optString("duedate").equals(sdf.format(dueDate))) {
//                                    mismatchColumns += "Due date,";
//                                }
//                            }
//                            if (paramJobj.has("billdate") && !StringUtil.isNullOrEmpty(paramJobj.optString("billdate", null)) && billDate != null) {//// Invoice Date
//                                if (!paramJobj.optString("billdate").equals(sdf.format(billDate))) {
//                                    mismatchColumns += "Invoice Date,";
//                                }
//                            }
//
//                            //Global Level Non Mandatory Fields
//
//                            if (paramJobj.has("isAutoCreateDO")) {// Delivery Order Number
//                                if (!paramJobj.optString("isAutoCreateDO", "").equals(String.valueOf(isGenerateDeliveryOrder))) {
//                                    mismatchColumns += "Generate Delivery Order,";
//                                }
//                            } else if (isGenerateDeliveryOrder) {
//                                mismatchColumns += "Generate Delivery Order,";
//                            }
//
//                            if (paramJobj.has("porefno")) {
//                                if (!paramJobj.optString("porefno", "").equalsIgnoreCase(poRefNumber)) {
//                                    mismatchColumns += "PO Reference Number,";
//                                }
//                            }
//                            if (paramJobj.has("costcenter")) {
//                                if (!paramJobj.optString("costcenter", "").equals(costCenterID)) {
//                                    mismatchColumns += "Cost Center,";
//                                }
//                            }
//                            if (paramJobj.has("salesPerson")) {
//                                if (!paramJobj.optString("salesPerson", "").equals(salesPersonID)) {
//                                    mismatchColumns += "Sales Person,";
//                                }
//                            }
//                            if (paramJobj.has("includingGST")) {
//                                if (!paramJobj.optString("includingGST", "").equals(String.valueOf(isIncludingGST))) {
//                                    mismatchColumns += "Including GST,";
//                                }
//                            }
//                            if (paramJobj.has("includeprotax")) {
//                                if (!paramJobj.optString("includeprotax", "").equals(String.valueOf(isIncludeProductTax))) {
//                                    mismatchColumns += "Include Product Tax,";
//                                }
//                            }
//                            if (paramJobj.has("taxid")) {
//                                if (isIncludeTotalTax && StringUtil.isNullOrEmpty(paramJobj.optString("taxid", ""))) {//This condition true menas column Include Total Tax has differnt value
//                                    mismatchColumns += "Include Total Tax,";
//                                } else {
//                                    String matchTaxID = "";
//                                    if (isIncludeTotalTax) {
//                                        matchTaxID = taxID;
//                                    }
//                                    if (!paramJobj.optString("taxid", "").equals(matchTaxID)) {
//                                        mismatchColumns += "Tax Code,";
//                                    }
//                                }
//                            }
//                            if (!StringUtil.isNullOrEmpty(mismatchColumns)) {
//                                mismatchColumns = mismatchColumns.substring(0, mismatchColumns.length() - 1);
//                                failureMsg += "Data for Global columns " + mismatchColumns + " are found different, data should be same at Global Level.";
//                            }
//                        }
//                        
//                        /*
//                         Below code is Cash Sales import related fields 
//                        */
//                        Date chequeDate = null;
//                        Date clearanceDate = null;
//                        PaymentMethod payMethod = null;
//                        String ChequeNo = "";
//                        String bankName = "";
//                        String bankNameMasterItemID = "";
//                        boolean cleared = false;
//                        String ChequeDesc = "";
//                        String payMethodId = "";
//                        if (isCashTransaction) {
//                            if (columnConfig.containsKey("paymentmethodid")) {
//                                String paymentMethodStr = recarr[(Integer) columnConfig.get("paymentmethodid")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(paymentMethodStr)) {
//                                    KwlReturnObject retObj = accMasterItemsDAOobj.getPaymentMethodIdFromName(paymentMethodStr, companyID);
//                                    if (retObj != null && !retObj.getEntityList().isEmpty()) {
//                                        payMethod = (PaymentMethod) retObj.getEntityList().get(0);
//                                        payMethodId = payMethod.getID();
//                                    }
//                                    if (payMethod == null) {
//                                        failureMsg += "Payment Method is not found for " + paymentMethodStr + ". ";
//                                    }
//                                } else {
//                                    failureMsg += "Payment Method is not available. ";
//                                }
//                            } else {
//                                failureMsg += "Payment Method column is not found. ";
//                            }
//
//                            if (columnConfig.containsKey("chequeno")) {
//                                ChequeNo = recarr[(Integer) columnConfig.get("chequeno")].replaceAll("\"", "").trim();
//                            }
//
//                            if (columnConfig.containsKey("bankname")) {
//                                bankName = recarr[(Integer) columnConfig.get("bankname")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(bankName)) {
//                                    KwlReturnObject returnObject = importDao.getBankNameMasterItemName(companyID, bankName);
//                                    if (returnObject.getEntityList().isEmpty()) {
//                                        failureMsg += "Incorrect Bank Name type value for Bank Name. Please add new Bank Name as \"" + bankName + "\" with other details.";
//                                    } else {
//                                        MasterItem masterItem = (MasterItem) returnObject.getEntityList().get(0);
//                                        bankNameMasterItemID = masterItem.getID();
//                                    }
//                                } else {
//                                    if (payMethod != null && payMethod.getDetailType() == Constants.bank_detail_type) {
//                                        failureMsg += "Empty data found in Bank Name, cannot set empty data for Bank Name if Payment Method is selected as Bank.";
//                                    }
//                                }
//                            } else {
//                                if (payMethod != null && payMethod.getDetailType() == Constants.bank_detail_type) {
//                                    failureMsg += "Bank Name column is not found. ";
//                                }
//                            }
//
//                            if (columnConfig.containsKey("chequedate")) {
//                                String chequeDateStr = recarr[(Integer) columnConfig.get("chequedate")].replaceAll("\"", "").trim();
//
//                                if (StringUtil.isNullOrEmpty(chequeDateStr)) {
//                                    if (payMethod != null && payMethod.getDetailType() != PaymentMethod.TYPE_CASH) {
//                                        failureMsg += "Cheque Date is not available. ";
//                                    }
//                                } else {
//                                    try {
//                                        chequeDate = df.parse(chequeDateStr);
//                                    } catch (Exception ex) {
//                                        failureMsg += "Incorrect date format for Cheque Date, Please specify values in " + dateFormat + " format. ";
//                                    }
//                                }
//                            } else {
//                                if (payMethod != null && payMethod.getDetailType() != PaymentMethod.TYPE_CASH) {
//                                    failureMsg += "Cheque Date column is not found. ";
//                                }
//                            }
//
//                            if (columnConfig.containsKey("paymentStatus")) {
//                                String paymentStatusStr = recarr[(Integer) columnConfig.get("paymentStatus")].replaceAll("\"", "").trim();
//                                if (StringUtil.isNullOrEmpty(paymentStatusStr)) {
//                                    if (payMethod != null && payMethod.getDetailType() == Constants.bank_detail_type) {
//                                        failureMsg += "Payment Status is not available. ";
//                                    }
//                                } else {
//                                    if (paymentStatusStr.equalsIgnoreCase("Cleared")) {
//                                        cleared = true;
//                                    } else if (paymentStatusStr.equalsIgnoreCase("Uncleared")) {
//                                        cleared = false;
//                                    } else {
//                                        failureMsg += "Incorrect Payment Status type value for Payment Status. It should be either Cleared or Uncleared. ";
//                                    }
//                                }
//                            } else {
//                                if (payMethod != null && payMethod.getDetailType() == Constants.bank_detail_type) {
//                                    failureMsg += "Payment Status column is not found. ";
//                                }
//                            }
//
//                            if (columnConfig.containsKey("clearanceDate")) {
//                                if (payMethod.getDetailType() != PaymentMethod.TYPE_CASH && cleared) { // when payment type is other than cash and payment sttus is clear then only need of clerance date. So its validation
//                                    String clearenceDateStr = recarr[(Integer) columnConfig.get("clearanceDate")].replaceAll("\"", "").trim();
//                                    if (!StringUtil.isNullOrEmpty(clearenceDateStr)) {
//                                        try {
//                                            clearanceDate = df.parse(clearenceDateStr);
//                                            if (chequeDate.compareTo(clearanceDate) > 0) {
//                                                failureMsg += "Clearence date should be greter than Cheque date.";
//                                            }
//                                        } catch (ParseException ex) {
//                                            failureMsg += "Incorrect date format for Clearence Date, Please specify values in " + dateFormat + " format.";
//                                        }
//                                    } else {
//                                        failureMsg += "You have entered the Payment Status as Cleared. So you cannot set empty data for Clearence Date.";
//                                    }
//                                }
//                            } else {
//                                if (payMethod.getDetailType() != PaymentMethod.TYPE_CASH && cleared) {
//                                    failureMsg += "Clearance Date column is not found. ";
//                                }
//                            }
//
//                            if (columnConfig.containsKey("chequedescription")) {
//                                ChequeDesc = recarr[(Integer) columnConfig.get("chequedescription")].replaceAll("\"", "").trim();
//                            }
//                        }
//
//                        
//                     /***************************** Validating Line Level Data *****************************/
//                        //Product Level data can be empty when number of Terms more than Line Item. So this variable used to find Is all column of line level is empty or not
//                        boolean isAllLineLevelDataIsEmpty=isAllLineLevelInformationIsEmpty(columnConfig,recarr);
//                        
//                        Product product = null;
//                        double quantity = 0;
//                        double unitPrice = 0;
//                        double unitPriceIncludingGST = 0;
//                        UnitOfMeasure uom = null;
//                        int rowdisc = 1;
//                        String rowtaxamount = "0";
//                        Tax rowtax = null;
//                        double discountValue = 0;
//                        // Line Level and Invoice Term related data can not be empty at the same time. Also user can not keep line level data empty for first record of invoice
//                        if (isAllLineLevelDataIsEmpty && (isNewInvoiceRecord || isAllInvoiceTermDataisEmpty)){
//                            failureMsg += "Empty data found for all Line Item columns.";
//                        } else if (!isAllLineLevelDataIsEmpty) {
//                            if (columnConfig.containsKey("productID")) {
//                                String productID = recarr[(Integer) columnConfig.get("productID")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(productID)) {
//                                    product = accSalesOrderServiceobj.getProductByProductID(productID, companyID);
//                                    if (product == null) {
//                                        failureMsg += "Product ID is not found for " + productID + ". ";
//                                    }
//                                } else {
//                                    failureMsg += "Product ID is not available. ";
//                                }
//                            } else {
//                                failureMsg += "Product ID column is not found. ";
//                            }
//
//                            if (columnConfig.containsKey("quantity")) {
//                                String quantityStr = recarr[(Integer) columnConfig.get("quantity")].replaceAll("\"", "").trim();
//                                if (StringUtil.isNullOrEmpty(quantityStr)) {
//                                    failureMsg += "Quantity is not available. ";
//                                } else {
//                                    try {
//                                        quantity =Double.parseDouble(quantityStr);
//                                    } catch (Exception ex) {
//                                        failureMsg += "Incorrect numeric value for Quantity, Please ensure that value type of Quantity matches with the Quantity. ";
//                                    }
//                                }
//                            } else {
//                                failureMsg += "Quantity column is not found. ";
//                            }
//
//                            if (columnConfig.containsKey("rate")) {
//                                String unitPriceStr = recarr[(Integer) columnConfig.get("rate")].replaceAll("\"", "").trim();
//                                if (StringUtil.isNullOrEmpty(unitPriceStr)) {
//                                    failureMsg += "Unit Price is not available. ";
//                                } else {
//                                    try {
//                                        unitPrice =Double.parseDouble(unitPriceStr);
//                                        if (unitPrice < 0 ) {
//                                            failureMsg +="Unit Price should not be negative.";
//                                        }
//                                    } catch (Exception ex) {
//                                        failureMsg += "Incorrect numeric value for Unit Price, Please ensure that value type of Unit Price matches with the Unit Price. ";
//                                    }
//                                }
//                            } else {
//                                failureMsg += "Unit Price column is not found. ";
//                            }
//
//                            if (columnConfig.containsKey("rateIncludingGst")) {
//                                String unitPriceIncludingGSTStr = recarr[(Integer) columnConfig.get("rateIncludingGst")].replaceAll("\"", "").trim();
//                                if (isIncludingGST && StringUtil.isNullOrEmpty(unitPriceIncludingGSTStr)) {
//                                    failureMsg +="Unit Price Including GST is not available. ";
//                                } else if (!StringUtil.isNullOrEmpty(unitPriceIncludingGSTStr)) {
//                                    try {
//                                        unitPriceIncludingGST = Double.parseDouble(unitPriceIncludingGSTStr);
//                                        if (unitPriceIncludingGST < 0 ) {
//                                            failureMsg +="Unit Price Including GST should not be negative.";
//                                        }
//                                    } catch (Exception ex) {
//                                        failureMsg += "Incorrect numeric value for Unit Price Including GST, Please ensure that value type of Unit Price matches with the Unit Price Including GST. ";
//                                    }
//                                }
//                            } else {
//                                if (isIncludingGST) {
//                                    failureMsg +="Unit Price Including GST column is not found. ";
//                                }
//                            }
//
//                            if (columnConfig.containsKey("uomname")) {
//                                String productUOMName = recarr[(Integer) columnConfig.get("uomname")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(productUOMName)) {
//                                    uom = accSalesOrderServiceobj.getUOMByName(productUOMName, companyID);
//                                    if (uom == null) {
//                                        if (!masterPreference.equalsIgnoreCase("1")) {
//                                            failureMsg += "Product Unit Of Measure is not found for " + productUOMName + ". ";
//                                        }
//                                    }
//                                } else {
//                                    if (!masterPreference.equalsIgnoreCase("1")) {
//                                        failureMsg += "Product Unit Of Measure is not available. ";
//                                    }
//                                }
//                            }
//
//                            String discountTypeStr = "";
//                            if (columnConfig.containsKey("discountType")) {
//                                discountTypeStr = recarr[(Integer) columnConfig.get("discountType")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(discountTypeStr)) {
//                                    if (discountTypeStr.equalsIgnoreCase("Percentage")) {
//                                        rowdisc = 1;
//                                    } else if (discountTypeStr.equalsIgnoreCase("Flat")) {
//                                        rowdisc = 0;
//                                    } else {
//                                        failureMsg += "Format you entered is not correct. It should be like \"Percentage\" or \"Flat\". ";
//                                    }
//                                }
//                            }
//
//
//                            if (columnConfig.containsKey("discount")) {
//                                String discountStr = recarr[(Integer) columnConfig.get("discount")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(discountStr)) {
//                                    try {
//                                        discountValue = Double.parseDouble(discountStr);
//                                        if (discountValue < 0 ) {
//                                            failureMsg +="Discount should not be negative.";
//                                        }
//                                    } catch (Exception ex) {
//                                        failureMsg += "Incorrect numeric value for Discount, Please ensure that value type of Discount matches with the Discount. ";
//                                    }
//                                }
//                            }
//
//
//                            if (columnConfig.containsKey("prtaxid")) {
//                                String taxCode = recarr[(Integer) columnConfig.get("prtaxid")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(taxCode)) {
//                                    rowtax = accSalesOrderServiceobj.getGSTByCode(taxCode, companyID);
//                                    if (rowtax == null) {
//                                        failureMsg += "Product Tax is not found for name " + taxCode + ". ";
//                                    }
//                                } else {
//                                    if (isIncludeProductTax) {
//                                        failureMsg += "Product Tax is not available. ";
//                                    }
//                                }
//                            } else {
//                                if (isIncludeProductTax) {
//                                    failureMsg += "Product Tax column is not found. ";
//                                }
//                            }
//
//                            if (columnConfig.containsKey("taxamount")) {
//                                rowtaxamount = recarr[(Integer) columnConfig.get("taxamount")].replaceAll("\"", "").trim();
//                                if (!StringUtil.isNullOrEmpty(rowtaxamount)) {
//                                    try {
//                                        double rowtaxamountvalue = Double.parseDouble(rowtaxamount);
//                                        if (rowtaxamountvalue < 0) {
//                                            failureMsg += "Tax Amount should not be negative.";
//                                        }
//                                    } catch (Exception ex) {
//                                        failureMsg += "Incorrect numeric value for Tax Amount. ";
//                                    }
//                                }
//                            }
//                        }
//                        
//                        
//                          // Warehouse Location Batch detail validation
//                        
//                        boolean isLocationForProduct = false;
//                        boolean isWarehouseForProduct = false;
//                        boolean isBatchForProduct = false;
//                        boolean isSerialForProduct = false;
//                        boolean isRowForProduct = false;
//                        boolean isRackForProduct = false;
//                        boolean isBinForProduct = false;
//                        String mfgdate = null;
//                        String expdate = null;
//                        String expstart = null;
//                        String expend = null;
//                        double batchquantity = 0;
//                        String serialName = "";
//                        String batchName = "";
//                     
//                        InventoryWarehouse warehouseObj = null;
//                        InventoryLocation locationObj = null;
//                        NewProductBatch batchObj = null;
//                        NewBatchSerial newBatchSerial= null;
//                        StoreMaster rowObj = null;
//                        StoreMaster rackObj = null;
//                        StoreMaster binObj = null;
//                        if (product != null) {
//                            if (isGenerateDeliveryOrder && (product.isIswarehouseforproduct() && product.isIslocationforproduct())) {
//                                Map<String, Object> requestMap = new HashMap<>();
//                                requestMap.put("isSalesTransaction", true); // Need to send true for Sales Transactions
//                                requestMap.put("product", product);
//                                requestMap.put("columnConfig", columnConfig);
//                                requestMap.put("recarr", recarr);
//                                requestMap.put("companyID", companyID);
//                                requestMap.put("failureMsg", failureMsg);
//                                requestMap.put("masterPreference", masterPreference);
//                                requestMap.put("df", df);
//                                requestMap.put("dateFormat", dateFormat);
//                                Map<String, Object> returnMap = accProductModuleService.validateBatchSerialDetail(requestMap);
//                                if (returnMap.containsKey("isWarehouseForProduct") && returnMap.get("isWarehouseForProduct") != null) {
//                                    isWarehouseForProduct = (boolean) returnMap.get("isWarehouseForProduct");
//                                }
//                                if (returnMap.containsKey("isLocationForProduct") && returnMap.get("isLocationForProduct") != null) {
//                                    isLocationForProduct = (boolean) returnMap.get("isLocationForProduct");
//                                }
//                                if (returnMap.containsKey("isBatchForProduct") && returnMap.get("isBatchForProduct") != null) {
//                                    isBatchForProduct = (boolean) returnMap.get("isBatchForProduct");
//                                }
//                                if (returnMap.containsKey("isSerialForProduct") && returnMap.get("isSerialForProduct") != null) {
//                                    isSerialForProduct = (boolean) returnMap.get("isSerialForProduct");
//                                }
//                                if (returnMap.containsKey("isRowForProduct") && returnMap.get("isRowForProduct") != null) {
//                                    isRowForProduct = (boolean) returnMap.get("isRowForProduct");
//                                }
//                                if (returnMap.containsKey("isRackForProduct") && returnMap.get("isRackForProduct") != null) {
//                                    isRackForProduct = (boolean) returnMap.get("isRackForProduct");
//                                }
//                                if (returnMap.containsKey("isBinForProduct") && returnMap.get("isBinForProduct") != null) {
//                                    isBinForProduct = (boolean) returnMap.get("isBinForProduct");
//                                }
//
//                                if (returnMap.containsKey("warehouseObj") && returnMap.get("warehouseObj") != null) {
//                                    warehouseObj = (InventoryWarehouse) returnMap.get("warehouseObj");
//                                }
//                                if (returnMap.containsKey("locationObj") && returnMap.get("locationObj") != null) {
//                                    locationObj = (InventoryLocation) returnMap.get("locationObj");
//                                }
//                                if (returnMap.containsKey("batchObj") && returnMap.get("batchObj") != null) {
//                                    batchObj = (NewProductBatch) returnMap.get("batchObj");
//                                }
//                                if (returnMap.containsKey("serialObj") && returnMap.get("serialObj") != null) {
//                                    newBatchSerial = (NewBatchSerial) returnMap.get("serialObj");
//                                }
//                                if (returnMap.containsKey("rowObj") && returnMap.get("rowObj") != null) {
//                                    rowObj = (StoreMaster) returnMap.get("rowObj");
//                                }
//                                if (returnMap.containsKey("rackObj") && returnMap.get("rackObj") != null) {
//                                    rackObj = (StoreMaster) returnMap.get("rackObj");
//                                }
//                                if (returnMap.containsKey("binObj") && returnMap.get("binObj") != null) {
//                                    binObj = (StoreMaster) returnMap.get("binObj");
//                                }
//                                if (returnMap.containsKey("mfgdate") && returnMap.get("mfgdate") != null) {
//                                    mfgdate = (String) returnMap.get("mfgdate");
//                                }
//                                if (returnMap.containsKey("expdate") && returnMap.get("expdate") != null) {
//                                    expdate = (String) returnMap.get("expdate");
//                                }
//                                if (returnMap.containsKey("expstart") && returnMap.get("expstart") != null) {
//                                    expstart = (String) returnMap.get("expstart");
//                                }
//                                if (returnMap.containsKey("expend") && returnMap.get("expend") != null) {
//                                    expend = (String) returnMap.get("expend");
//                                }
//                                if (returnMap.containsKey("batchName") && returnMap.get("batchName") != null) {
//                                    batchName = (String) returnMap.get("batchName");
//                                }
//                                if (returnMap.containsKey("serialName") && returnMap.get("serialName") != null) {
//                                    serialName = (String) returnMap.get("serialName");
//                                }
//
//                                if (returnMap.containsKey("failureMsg") && returnMap.get("failureMsg") != null) {
//                                    failureMsg = (String) returnMap.get("failureMsg");
//                                }
//                                if (returnMap.containsKey("batchquantity") && returnMap.get("batchquantity") != null) {
//                                    batchquantity = (double) returnMap.get("batchquantity");
//                                    totalBatchQty += batchquantity;
//                                }
//                                
//                                if (prevRow.equalsIgnoreCase("") || !prevRow.equalsIgnoreCase(entryNumber + product.getProductid())) {
//                                    prevRow = entryNumber + product.getProductid();
//                                    totalBatchQty = batchquantity;
//                                }
//                                if (totalBatchQty > quantity) {
//                                    failureMsg += "Batch Quantity can't be greater than Product Quantity. ";
//                                }
//
//                            }
//                        }
//
//                        
//
//                        
////                        if (!StringUtil.isNullOrEmpty(failureMsg)) {
////                            failureList.add(entryNumber);
////                        }
//                        JSONObject job = new JSONObject();
//                        if (StringUtil.isNullOrEmpty(failureMsg) && !isAllLineLevelDataIsEmpty) { // If all Validation is Done then we can check Quantity available
//                            
//                            
//                            job.put("transType", "2");
//                            job.put("isEdit", false);
//                            job.put("linkflag", false);
//                            job.put("isfromdo", true);
//                            job.put("fromSubmit", false);
//                            job.put("isforReturn", false);
//                            job.put(Constants.companyKey, companyID);
//
//                            JSONObject detailObj = new JSONObject();
//                            detailObj.put(Constants.productid, product.getID());
//                           
//                            detailObj.put("isWarehouseForProduct", isWarehouseForProduct);
//                            detailObj.put("isLocationForProduct", isLocationForProduct);
//                            detailObj.put("isBatchForProduct", isBatchForProduct);
//                            detailObj.put("isSerialForProduct", isSerialForProduct);
//                            detailObj.put("isRowForProduct", isRowForProduct);
//                            detailObj.put("isRackForProduct", isRackForProduct);
//                            detailObj.put("isBinForProduct", isBinForProduct);
//                            detailObj.put("warehouse", warehouseObj != null ? warehouseObj.getId() : "");
//                            detailObj.put("location", locationObj != null ? locationObj.getId() : "");
//                            detailObj.put("batchObj", batchObj != null ? batchObj.getId():"");
////                    detailObj.put("serialName", serialName);
//                            detailObj.put("row", rowObj != null ? rowObj.getId() : "");
//                            detailObj.put("rack", rackObj != null ? rackObj.getId() : "");
//                            detailObj.put("bin", binObj != null ? binObj.getId() : "");
//                            detailObj.put("quantity", batchquantity);
//                            JSONArray detailSubArr=new JSONArray();
//                            detailSubArr.put(detailObj);
//
//                            //job.put("batchdetails", deatilArr);
//                            
//                            JSONObject detailArrObj=new JSONObject();
//                            detailArrObj.put("batchdetails", detailSubArr);
//                            JSONArray detailArr=new JSONArray();
//                            detailArr.put(detailArrObj);
//                            job.put("detail", detailArr);
//                            
//                            if (!extrareferences.isIsnegativestockforlocwar()) {
//                                JSONObject resultObject = getBatchRemainingQuantityForImport(job);
//                                if (resultObject.has("prodname") && !StringUtil.isNullOrEmpty(resultObject.optString("prodname", ""))) {
//
//                                    failureMsg += "Quantity for Product " + resultObject.optString("prodname", "") + " is not available in particular Location/Warehouse";
//                                }
//                            }
//                        }
//                       
//                        // creating json
//                        if (!prevInvNo.equalsIgnoreCase(entryNumber) || entryNumber.equalsIgnoreCase("")) {//This is the case when invoice number changes. i.e new invoice case
//
//                            if (failureList.contains(prevInvNo)) {
//                                failed += singleInvoiceFailureRecoredCount;
//                                failedRecords.append(singleInvociceFailedRecords);
//                                singleInvociceFailedRecords = new StringBuilder();
//                                singleInvoiceFailureRecoredCount = 0;
//                            }
//
//                            if ((rowDetailMap.size() > 0 || rows.length()>0) && !isAlreadyExist && !isRecordFailed) {
//                                JSONArray invoiceTermArrayDetails = new JSONArray();
//                                double amountAfterRemovingDiscount = totalamount - totaldiscount;
//                                if (invoiceTermDetailsArray.length() > 0) {
//                                    Map<String, Object> invoiceTermMap = new HashMap();
//                                    invoiceTermMap.put("invoiceTermDetailsArray", invoiceTermDetailsArray);
//                                    invoiceTermMap.put("amountAfterRemovingDiscount", amountAfterRemovingDiscount);
//                                    invoiceTermMap.put(Constants.companyid, companyID);
//                                    invoiceTermArrayDetails = getInvoiceTermDetailsArray(invoiceTermMap, salesTermMap);
//                                    paramJobj.put("invoicetermsmap", invoiceTermArrayDetails.toString());
//                                }
//                                double taxamount = 0.0;
//                                if (!StringUtil.isNullOrEmpty(paramJobj.optString("taxid", null))) {
//                                    taxamount = getGlobalTaxAmount(paramJobj, companyID, amountAfterRemovingDiscount);
//                                }
//                                paramJobj.put("taxamount", String.valueOf(taxamount));
//                                if (isIncludingGST) {
//                                    /*
//                                     * When Including GST is true then we need
//                                     * to recalculate line level tax,unit price
//                                     * and invoiceterm amount accordingly Below
//                                     * method does the same.
//                                     */
//                                    Map<String, Object> invoiceMap = new HashMap();
//                                    invoiceMap.put(Constants.companyid, companyID);
//                                    invoiceMap.put("amountAfterRemovingDiscount", amountAfterRemovingDiscount);
//                                    invoiceMap.put("billdate", billDate);
//                                    updateLineLevelTaxUnitPriceOnIncludeGST(rows, invoiceTermArrayDetails, invoiceMap);
//                                }
//                                // on next document saving current documents rows
//                                if (rowDetailMap.size() > 0 && !(product.getProducttype().getID().equals(Producttype.SERVICE) || product.getProducttype().getID().equals(Producttype.NON_INVENTORY_PART))) {
//                                    Map<String, Object> resultMap = manipulateRowDetails(rowDetailMap, batchSerialMap, batchMap, batchDetailArr, failedRecords, singleInvociceFailedRecords, totalBatchQty, isRecordFailed, rows,isGenerateDeliveryOrder);
//                                    if (resultMap.containsKey("isRecordFailed")) {
//                                        isRecordFailed = (boolean) resultMap.get("isRecordFailed");
//                                        if(isRecordFailed){
//                                            if(!failureList.contains(prevInvNo)) {
//                                                failureList.add(prevInvNo);
//                                            }
//                                            failed += singleInvoiceFailureRecoredCount;
//                                            if (singleInvociceFailedRecords.toString().length() > 0) {
//                                                failedRecords.append(singleInvociceFailedRecords);
//                                            }
//                                        }  
//                                    }
//                                    if (resultMap.containsKey("batchMap") && resultMap.get("batchMap") != null) {
//                                        batchMap = (Map<String, List<JSONObject>>) resultMap.get("batchMap");
//                                    }
//                                }
//                                if (!isRecordFailed) {
//                                    paramJobj.put(Constants.detail, rows.toString());
//                                    paramJobj.put(Constants.PAGE_URL,  requestJobj.optString(Constants.PAGE_URL));
//                                    // for save
//                                    saveInvoice(paramJobj);
//                                    imported=true;
//                                }
//                                
//                            }
//                            
//                            // reset variables
//                            totaldiscount = 0;
//                            totalamount = 0;
//                            paramJobj = new JSONObject();
//                            rows = new JSONArray();
//                            invoiceTermDetailsArray = new JSONArray();
//                            isRecordFailed = false;
//                            isAlreadyExist = false;
//                            rowDetailMap = new HashMap<>();
//                            batchSerialMap = new HashMap<>();
//                            batchDetailArr = new JSONArray();
//                            //below variable are get initialized to give correct failure and sucess
//                            singleInvociceFailedRecords = new StringBuilder();
//                            singleInvoiceFailureRecoredCount = 0;
//                            prevInvNo = entryNumber;
//
//                            KwlReturnObject result = accInvoiceDAOobj.getInvoiceCount(entryNumber, companyID);
//                            int nocount = result.getRecordTotalCount();
//                            if (nocount > 0) {
//                                isAlreadyExist = true;
//                                failureList.add(entryNumber);
//                                failureMsg += "Invoice number'" + entryNumber + "' already exists.";
//                            }
//
//                            /*ERP- 38099*/
//                            if (isGenerateDeliveryOrder) {
//                                KwlReturnObject doResult = accInvoiceDAOobj.getDeliveryOrderCount(deliveryOrderNo, companyID);
//                                if (doResult.getRecordTotalCount() > 0) {
//                                    isAlreadyExist = true;
//                                    failureList.add(entryNumber);
//                                    failureMsg += "Delivery Order Number " + deliveryOrderNo + " is already exist. ";
//                                }
//                            } 
//                            if (!StringUtil.isNullOrEmpty(failureMsg)) {
//                                failureList.add(entryNumber);
//                                throw new AccountingException(failureMsg);
//                            }
//
//                            // For create custom field array
//                            JSONArray customJArr = accSalesOrderServiceobj.createGlobalCustomFieldArrayForImport(requestJobj, jSONArray, recarr, df, Constants.Acc_Invoice_ModuleId);
//
//                            // For getting exchange rate
//                            double exchangeRateForTransaction = accSalesOrderServiceobj.getExchangeRateForTransaction(requestJobj, billDate, currencyID);
//
//                            String sequenceFormatID = "NA";
//                            boolean autogenerated = false;
//                            if (!StringUtil.isNullOrEmpty(entryNumber)) {
//                                Map<String, String> sequenceNumberDataMap = new HashMap<String, String>();
//                                sequenceNumberDataMap.put("moduleID", String.valueOf(Constants.Acc_Invoice_ModuleId));
//                                sequenceNumberDataMap.put("entryNumber", entryNumber);
//                                sequenceNumberDataMap.put("companyID", companyID);
//                                List list = importHandler.checksEntryNumberForSequenceNumber(sequenceNumberDataMap);
//                                if (!list.isEmpty()) {
//                                    boolean isvalidEntryNumber = (Boolean) list.get(0);
//                                    if (!isvalidEntryNumber) {
//                                        String formatID = (String) list.get(2);
//                                        int intSeq = (Integer) list.get(3);
//                                        paramJobj.put(Constants.SEQNUMBER, intSeq);
//                                        paramJobj.put(Constants.SEQFORMAT, formatID);
//                                        autogenerated = true;
//                                        sequenceFormatID = formatID;
//                                    }
//                                }
//                            }
//
//                            String deliveryOrderSequenceformatID = "NA";
//                            if (!StringUtil.isNullOrEmpty(deliveryOrderNo)) {
//                                Map<String, String> sequenceNumberDataMap = new HashMap<String, String>();
//                                sequenceNumberDataMap.put("moduleID", String.valueOf(Constants.Acc_Delivery_Order_ModuleId));
//                                sequenceNumberDataMap.put("entryNumber", deliveryOrderNo);
//                                sequenceNumberDataMap.put("companyID", companyID);
//                                List list = importHandler.checksEntryNumberForSequenceNumber(sequenceNumberDataMap);
//                                if (!list.isEmpty()) {
//                                    boolean isvalidEntryNumber = (Boolean) list.get(0);
//                                    if (!isvalidEntryNumber) {
//                                        String formatID = (String) list.get(2);
//                                        int intSeq = (Integer) list.get(3);
//                                        paramJobj.put("DOSeqNum", intSeq);
//                                        deliveryOrderSequenceformatID = formatID;
//                                    }
//                                }
//                            }
//
//                            // param obj
//                            paramJobj.put(Constants.companyKey, companyID);
//                            paramJobj.put(Constants.globalCurrencyKey, requestJobj.getString(Constants.globalCurrencyKey));
//                            paramJobj.put(Constants.useridKey, requestJobj.getString(Constants.useridKey));
//                            paramJobj.put(Constants.lid, requestJobj.getString(Constants.useridKey));
//                            paramJobj.put(Constants.userfullname, requestJobj.getString(Constants.userfullname));
//                            paramJobj.put(Constants.reqHeader, requestJobj.getString(Constants.reqHeader));
//                            paramJobj.put(Constants.remoteIPAddress, requestJobj.getString(Constants.remoteIPAddress));
//                            paramJobj.put(Constants.language, requestJobj.getString(Constants.language));
//                            paramJobj.put(Constants.timezonedifference, requestJobj.optString(Constants.timezonedifference));
//                            paramJobj.put(Constants.currencyKey, currencyID);
//                            if (isGenerateDeliveryOrder == true) {
//                                paramJobj.put("autogenerateDO", "on");
//                                paramJobj.put("isAutoCreateDO", "true");
//                                paramJobj.put(Constants.fromLinkComboAutoDO, "Sales Invoice");
//                            }
//                            paramJobj.put("number", entryNumber);
//                            paramJobj.put("numberDo", deliveryOrderNo);
//                            paramJobj.put("sequenceformat", sequenceFormatID);
//                            paramJobj.put("autogenerated", autogenerated);
//                            paramJobj.put(Constants.sequenceformatDo, deliveryOrderSequenceformatID);
//                            paramJobj.put("customer", customerID);
//                            paramJobj.put("porefno", poRefNumber);
//                            paramJobj.put("costcenter", costCenterID);
//                            paramJobj.put("defaultAdress", "true");
//                            paramJobj.put(Constants.memo, memo);
//                            paramJobj.put("posttext", "");
//                            paramJobj.put("term", termID);//while saving delivery order term key is used
//                            paramJobj.put("termid", termID);
//                            paramJobj.put("billdate", sdf.format(billDate));
//                            paramJobj.put("perdiscount", "false");
//                            paramJobj.put("discount", "0");
//                            paramJobj.put("includingGST", String.valueOf(isIncludingGST));
//                            paramJobj.put("gstIncluded", String.valueOf(isIncludingGST));
//                            if (shipDate != null) {
//                                paramJobj.put("shipdate", sdf.format(shipDate));
//                            }
//                            paramJobj.put("shipvia", shipVia);
//                            paramJobj.put(Constants.fob, fob);
//                            paramJobj.put("isfavourite", "false");
//                            paramJobj.put("salesPerson", salesPersonID);
//                            paramJobj.put("externalcurrencyrate", String.valueOf(exchangeRateForTransaction));
//                            paramJobj.put("istemplate", "0");
//                            paramJobj.put("taxamount", "0");
//                            paramJobj.put("invoicetermsmap", "[]");
//                            paramJobj.put("termsincludegst", "false");
//                            paramJobj.put("fromLinkCombo", "");
//                            paramJobj.put("linkFrom", "");
//                            paramJobj.put("linkNumber", "");
//                            paramJobj.put("templatename", "");
//                            paramJobj.put(Constants.customfield, customJArr.toString());
//                            paramJobj.put("isEdit", "false");
//                            paramJobj.put("copyInv", "false");
//                            paramJobj.put("isDraft", "false");
//                            paramJobj.put("includeprotax", "false");
//                            paramJobj.put("shipLength", "1");
//                            paramJobj.put("incash", isCashTransaction);
//                             //put Cash Sales related fields
//                            if(isCashTransaction){
//                                //create payment details json
//                                JSONObject payDetail = new JSONObject();
//                                payDetail.put("chequeno", ChequeNo);
//                                payDetail.put("description",ChequeDesc);
//                                payDetail.put("bankname", bankName);
//                                payDetail.put("paymentStatus", cleared ? "Cleared" : "Uncleared");
//                                payDetail.put("bankmasteritemid", bankNameMasterItemID);
//                                payDetail.put("payDate", chequeDate != null ? sdf.format(chequeDate) : "");
//                                payDetail.put("clearanceDate", clearanceDate != null ? sdf.format(clearanceDate) : "");
//                                //put payment method details in map
//                                paramJobj.put("pmtmethod", payMethodId);
//                                paramJobj.put("paydetail", payDetail.toString());
//                            }
//                            paramJobj.put(Constants.importExportDeclarationNo, exportDeclarationNo);
//
//                            if (isIncludeTotalTax) {
//                                paramJobj.put("taxid", taxID);
//                            } else {
//                                paramJobj.put("taxid", "");
//                            }
//
//                            paramJobj.put("deletedLinkedDocumentId", "");
//                            paramJobj.put("invoicetype", "");
//                            paramJobj.put("seqformat_oldflag", "false");
//                            paramJobj.put("includeprotax", String.valueOf(isIncludeProductTax));
//                            if (dueDate != null) {
//                                paramJobj.put("duedate", sdf.format(dueDate));
//                            }else if(isCashTransaction){//For Cash Sales invoice put due date as bill date
//                                paramJobj.put("duedate", sdf.format(billDate));
//                            }
//                            SimpleDateFormat formatter = (SimpleDateFormat) authHandler.getGlobalDateFormat();
//                            paramJobj.put(Constants.Checklocktransactiondate, formatter.format(billDate));
//
//
//
//                            Map<String, Object> requestParams = new HashMap<>();
//                            requestParams.put(Constants.companyKey, companyID);
//                            CompanyPreferencesCMN.checkLockPeriod(accCompanyPreferencesObj, requestParams, billDate, false);
//                            CompanyPreferencesCMN.checkActiveDateRange(accCompanyPreferencesObj, requestJobj, billDate);
//                        } // end global details
//                        
//                        if (!StringUtil.isNullOrEmpty(failureMsg) && (StringUtil.isNullOrEmpty(prevInvNo) || prevInvNo.equalsIgnoreCase(entryNumber))) {
//                             throw new AccountingException(failureMsg);
//                        }
//
//                        if (!isAllInvoiceTermDataisEmpty && termsSales!=null) {// When Invoice Term given then put in an array
//                            JSONObject termDetail = new JSONObject();
//                            termDetail.put("invoiceTerm", termsSales);
//                            termDetail.put("isPercentage", (termType == 1) ? true : false);
//                            termDetail.put("termValue", termValue);
//                            invoiceTermDetailsArray.put(termDetail);
//                        }
//                        // For Line level details
//                        if (!isAllLineLevelDataIsEmpty && !isRecordFailed) {//When number of Invoice Terms is greater than in that case product can be empty. So no need to execute below code 
//                            double conversionFactor = 1;
//                            // Add Custom fields details of line items
//                            JSONArray lineCustomJArr = accSalesOrderServiceobj.createLineLevelCustomFieldArrayForImport(requestJobj, jSONArray, recarr, df, Constants.Acc_Invoice_ModuleId);
//
//                            String key = entryNumber + product.getProductid();
//                            JSONObject obj = new JSONObject();
//                            if (product.isIswarehouseforproduct() && product.isIslocationforproduct()) {   // For batch Serial Flow
//                                String newLineLevelKey = key;
//                                if (isWarehouseForProduct && warehouseObj != null) {
//                                    key = key + warehouseObj.getName();
//                                    obj.put("warehouse", warehouseObj.getId());
//                                }
//                                if (isLocationForProduct && locationObj != null) {
//                                    key = key + locationObj.getName();
//                                    obj.put("location", locationObj.getId());
//                                }
//                                
//                                // check if inner line level record combination is duplicate (InvoiceNumber + Product + Warehouse + Location + Batch)
//                                if(uniqueLineLevelRecordKeyList.contains(key + batchName)){// Duplicate found then reset all variables and throw failure message.
//                                    rowDetailMap = new HashMap<>();
//                                    batchMap = new HashMap<>();
//                                    batchSerialMap = new HashMap<>();
//                                    batchDetailArr = new JSONArray();
//                                    paramJobj = new JSONObject();
//                                    rows = new JSONArray();
//                                    throw new AccountingException("Duplicate record found for InvoiceNumber, Product, Warehouse, Location and Batch.");
//                                } else {
//                                    uniqueLineLevelRecordKeyList.add(key + batchName);
//                                }
//                                
//                                if (isRowForProduct && rowObj != null) {
//                                    obj.put("row", rowObj.getId());
//                                }
//                                if (isRackForProduct && rackObj != null) {
//                                    obj.put("rack", rackObj.getId());
//                                }
//                                if (isBinForProduct && binObj != null) {
//                                    obj.put("bin", binObj.getId());
//                                }
//                                obj.put("quantity",  batchquantity);
//                                obj.put("isBatchForProduct", isBatchForProduct);
//                                obj.put("purchasebatchid", batchObj != null? batchObj.getId():""); // passeed Batch Id to Update the Quantity form given batch
//                                if (isBatchForProduct) {
//                                    obj.put("batch", batchName);
//                                    obj.put("mfgdate", mfgdate);
//                                    obj.put("expdate", expdate);
//                                    obj.put("isSerialForProduct", isSerialForProduct);
//
//
//                                    String batchKey = isBatchForProduct ? key + batchName : key;
//                                    if (batchMap.containsKey(batchKey)) {
//                                        List<JSONObject> list = batchMap.get(batchKey);
//                                        list.add(obj);
//                                        batchMap.put(batchKey, list);
//                                    } else {
//                                        List<JSONObject> list = new ArrayList<>();
//                                        list.add(obj);
//                                        batchMap.put(batchKey, list);
//                                    }
//                                }
//                                if (isSerialForProduct) {
//                                    obj.put("purchaseserialid", newBatchSerial !=null ? newBatchSerial.getId():"");
//                                    obj.put("serialno", serialName);
//                                    obj.put("serialnoid", "");
//                                    obj.put("expstart", expstart);
//                                    obj.put("expend", expend);
//
//                                    String batchKey = isBatchForProduct ? key + batchName : key;
//                                    if (batchSerialMap.containsKey(batchKey)) {
//                                        List<Object> list = batchSerialMap.get(batchKey);
//                                        list.add(serialName);
//                                        batchSerialMap.put(batchKey, list);
//                                    } else {
//                                        List<Object> list = new ArrayList<>();
//                                        list.add(serialName);
//                                        batchSerialMap.put(batchKey, list);
//                                    }
//                                }
//                                if (!rowDetailMap.containsKey(newLineLevelKey)) {// If Entry No + Productid is changed then it is new line level, so process previous batch stuff of previous line level.
//                                    if (rowDetailMap.size() > 0 && !(product.getProducttype().getID().equals(Producttype.SERVICE) || product.getProducttype().getID().equals(Producttype.NON_INVENTORY_PART))) {
//                                        Map<String, Object> resultMap = manipulateRowDetails(rowDetailMap, batchSerialMap, batchMap, batchDetailArr, failedRecords, singleInvociceFailedRecords, totalBatchQty, isRecordFailed, rows,isGenerateDeliveryOrder);
//                                        if (resultMap.containsKey("isRecordFailed")) {
//                                            isRecordFailed = (boolean) resultMap.get("isRecordFailed");
//                                            if (isRecordFailed) {
//                                                if(!failureList.contains(entryNumber)) {
//                                                    failureList.add(entryNumber);
//                                                }
//                                                paramJobj = new JSONObject();
//                                                rows = new JSONArray();
//                                            }
//                                        }
//                                        if (resultMap.containsKey("batchMap") && resultMap.get("batchMap") != null) {
//                                            batchMap = (Map<String, List<JSONObject>>) resultMap.get("batchMap");
//                                        }
//                                        rowDetailMap = new HashMap<>();
//                                        batchSerialMap = new HashMap<>();
//                                        batchDetailArr = new JSONArray();
//                                    }
//
//
//                                    if (!isRecordFailed) {
//                                        JSONObject detailData = new JSONObject();
//                                        detailData.put(Constants.productid, (product != null) ? product.getID() : "");
//                                        detailData.put("rate", unitPrice);
//                                        if (isIncludingGST) {
//                                            detailData.put("rateIncludingGst", unitPriceIncludingGST);
//                                        }
//                                        detailData.put("priceSource", "");
//                                        detailData.put("quantity", String.valueOf(quantity));
//                                        detailData.put("uomid", (uom != null) ? uom.getID() : "");
//                                        detailData.put("baseuomquantity", quantity * conversionFactor);
//                                        detailData.put("baseuomrate", String.valueOf(conversionFactor));
//                                        detailData.put("dependentType", "");
//                                        detailData.put("inouttime", "");
//                                        detailData.put("showquantity", "");
//                                        detailData.put("desc", (product != null) ? product.getDescription() : "");
//                                        detailData.put("invstore", "");
//                                        detailData.put("invlocation", "");
//                                        detailData.put("rowid", "");
//                                        detailData.put("prdiscount", String.valueOf(discountValue));
//                                        detailData.put("discountispercent", String.valueOf(rowdisc));
//                                        if (!StringUtil.isNullOrEmpty(paramJobj.optString("includeprotax", "")) && paramJobj.getString("includeprotax").equalsIgnoreCase("true") && rowtax != null) {
//                                            detailData.put("prtaxid", rowtax.getID());
//                                            detailData.put("taxamount", rowtaxamount);
//                                        } else {
//                                            detailData.put("prtaxid", "");
//                                            detailData.put("taxamount", "0");
//                                        }
//                                        detailData.put("linkto", "");
//                                        detailData.put("savedrowid", "");
//                                        detailData.put("recTermAmount", "");
//                                        detailData.put("OtherTermNonTaxableAmount", "");
//                                        detailData.put("productcustomfield", "[{}]");
//                                        detailData.put("LineTermdetails", "");
//                                        detailData.put("productMRP", "");
//                                        detailData.put("valuationType", "");
//                                        detailData.put("reortingUOMExcise", "");
//                                        detailData.put("reortingUOMSchemaExcise", "");
//                                        detailData.put("valuationTypeVAT", "");
//                                        detailData.put("reportingUOMVAT", "");
//                                        detailData.put("reportingUOMSchemaVAT", "");
//                                        detailData.put(Constants.customfield, lineCustomJArr.toString());
//                                        if (product != null && (product.getProducttype().getID().equals(Producttype.SERVICE) || product.getProducttype().getID().equals(Producttype.NON_INVENTORY_PART))) {
//                                         detailData.put("noQuantityMatchingRequire", true);
//                                        }
//
//                                        double rate = unitPrice;
//                                        if (paramJobj.optString("includingGST", "").equalsIgnoreCase("true")) {
//                                            rate = unitPriceIncludingGST;
//                                        }
//                                        double rowAmount = rate * quantity;
//                                        rowAmount = rowAmount;
//                                        totalamount += rowAmount;
//
//                                        double rowdiscount = discountValue;
//                                        if (rowdisc == 1) { // for percent disc
//                                            rowdiscount = (rowAmount * discountValue) / 100;
//                                        }
//                                        rowdiscount = rowdiscount;
//                                        detailData.put("prdrowiscount", String.valueOf(rowdiscount));
//
//                                        totaldiscount += rowdiscount;
//                                        rowDetailMap.put(newLineLevelKey, detailData);
//                                        batchDetailArr.put(obj);
//                                    }
//                                } else {
//                                    batchDetailArr.put(obj);
//                                }
//
//                            } else {
//                                // for already existing row having batch details and next product don't have batchdetails. to first row details then process current 
//                                if (rowDetailMap.size() > 0 && !(product.getProducttype().getID().equals(Producttype.SERVICE) || product.getProducttype().getID().equals(Producttype.NON_INVENTORY_PART))) {
//                                    Map<String, Object> resultMap = manipulateRowDetails(rowDetailMap, batchSerialMap, batchMap, batchDetailArr, failedRecords, singleInvociceFailedRecords, totalBatchQty, isRecordFailed, rows,isGenerateDeliveryOrder);
//                                    if (resultMap.containsKey("isRecordFailed")) {
//                                        isRecordFailed = (boolean) resultMap.get("isRecordFailed");
//                                        if (isRecordFailed) {
//                                            if(!failureList.contains(entryNumber)) {
//                                                failureList.add(entryNumber);
//                                            }
//                                            paramJobj = new JSONObject();
//                                            rows = new JSONArray();
//                                        }
//                                    }
//                                    if (resultMap.containsKey("batchMap") && resultMap.get("batchMap") != null) {
//                                        batchMap = (Map<String, List<JSONObject>>) resultMap.get("batchMap");
//                                    }
//                                    rowDetailMap = new HashMap<>();
//                                    batchSerialMap = new HashMap<>();
//                                    batchDetailArr = new JSONArray();
//                                }
//                                
//                                if(uniqueLineLevelRecordKeyList.contains(key)){
//                                    throw new AccountingException("Duplicate record found for InvoiceNumber and Product.");
//                                } else {
//                                    uniqueLineLevelRecordKeyList.add(key);
//                                }
//
//                                if (!isRecordFailed) {
//                                   JSONObject detailData = new JSONObject();
//                                    detailData.put(Constants.productid, (product != null) ? product.getID() : "");
//                                    detailData.put("rate", unitPrice);
//                                    if (isIncludingGST) {
//                                        detailData.put("rateIncludingGst", unitPriceIncludingGST);
//                                    }
//                                    detailData.put("priceSource", "");
//                                    detailData.put("quantity", String.valueOf(quantity));
//                                    detailData.put("uomid", (uom != null) ? uom.getID() : "");
//                                    detailData.put("baseuomquantity", quantity * conversionFactor);
//                                    detailData.put("baseuomrate", String.valueOf(conversionFactor));
//                                    detailData.put("dependentType", "");
//                                    detailData.put("inouttime", "");
//                                    detailData.put("showquantity", "");
//                                    detailData.put("desc", (product != null) ? product.getDescription() : "");
//                                    detailData.put("invstore", "");
//                                    detailData.put("invlocation", "");
//                                    detailData.put("rowid", "");
//                                    detailData.put("prdiscount", String.valueOf(discountValue));
//                                    detailData.put("discountispercent", String.valueOf(rowdisc));
//                                    if (!StringUtil.isNullOrEmpty(paramJobj.optString("includeprotax", "")) && paramJobj.getString("includeprotax").equalsIgnoreCase("true") && rowtax != null) {
//                                        detailData.put("prtaxid", rowtax.getID());
//                                        detailData.put("taxamount", rowtaxamount);
//                                    } else {
//                                        detailData.put("prtaxid", "");
//                                        detailData.put("taxamount", "0");
//                                    }
//                                    detailData.put("linkto", "");
//                                    detailData.put("savedrowid", "");
//                                    detailData.put("recTermAmount", "");
//                                    detailData.put("OtherTermNonTaxableAmount", "");
//                                    detailData.put("productcustomfield", "[{}]");
//                                    detailData.put("LineTermdetails", "");
//                                    detailData.put("productMRP", "");
//                                    detailData.put("valuationType", "");
//                                    detailData.put("reortingUOMExcise", "");
//                                    detailData.put("reortingUOMSchemaExcise", "");
//                                    detailData.put("valuationTypeVAT", "");
//                                    detailData.put("reportingUOMVAT", "");
//                                    detailData.put("reportingUOMSchemaVAT", "");
//                                    detailData.put(Constants.customfield, lineCustomJArr.toString());
//
//                                    double rate = unitPrice;
//                                    if (paramJobj.optString("includingGST", "").equalsIgnoreCase("true")) {
//                                        rate = unitPriceIncludingGST;
//                                    }
//                                    double rowAmount = rate * quantity;
//                                    rowAmount = rowAmount;
//                                    totalamount += rowAmount;
//
//                                    double rowdiscount = discountValue;
//                                    if (rowdisc == 1) { // for percent disc
//                                        rowdiscount = (rowAmount * discountValue) / 100;
//                                    }
//                                    rowdiscount = rowdiscount;
//                                    detailData.put("prdrowiscount", String.valueOf(rowdiscount));
//
//                                    totaldiscount += rowdiscount;
//
//                                    rows.put(detailData);
//                                }
//                            }
//                        }
//                    } catch (Exception ex) {
////                        failed++;
//                        isRecordFailed = true;
//                        isfailurerecord = true;
//                        String errorMsg = "";
//                        if (ex.getMessage() != null) {
//                            errorMsg = ex.getMessage();
//                        } else if (ex.getCause() != null) {
//                            errorMsg = ex.getCause().getMessage();
//                        }
//                        if(!failureList.contains(entryNumber)) {
////                                failed += singleInvoiceFailureRecoredCount;
//                            if(singleInvoiceFailureRecoredCount > 0 ){
//                                failedRecords.append(singleInvociceFailedRecords);
//                                singleInvociceFailedRecords = new StringBuilder();
//                            }
//                            prevInvNo = entryNumber;
//                            failureList.add(entryNumber);
//                        }
//                        singleInvoiceFailureRecoredCount++;
//                        singleInvociceFailedRecords.append("\n").append(accSalesOrderServiceobj.createCSVrecord(recarr)).append("\"").append(errorMsg.replaceAll("\"", "")).append("\"");
//                    }
//                    if (!isfailurerecord) {
//                        singleInvoiceFailureRecoredCount++;
//                        singleInvociceFailedRecords.append("\n").append(accSalesOrderServiceobj.createCSVrecord(recarr)).append("\"").append(" ").append("\"");
//                    }
//                    total++;
//                }
//                cnt++;
//            }
//
//            // save last record
//            if (!isAlreadyExist && !isRecordFailed) {
//                JSONArray invoiceTermArrayDetails = new JSONArray();
//                double amountAfterRemovingDiscount = totalamount - totaldiscount;
//                if (invoiceTermDetailsArray.length() > 0) {
//                    Map<String, Object> invoiceTermDetailMap = new HashMap();
//                    invoiceTermDetailMap.put("invoiceTermDetailsArray", invoiceTermDetailsArray);
//                    invoiceTermDetailMap.put("amountAfterRemovingDiscount", amountAfterRemovingDiscount);
//                    invoiceTermArrayDetails = getInvoiceTermDetailsArray(invoiceTermDetailMap, salesTermMap);
//                    paramJobj.put("invoicetermsmap", invoiceTermArrayDetails.toString());
//                }
//                double taxamount = 0.0;
//                if (!StringUtil.isNullOrEmpty(paramJobj.optString("taxid", null))) {
//                    taxamount = getGlobalTaxAmount(paramJobj, companyID, amountAfterRemovingDiscount);
//                }
//                if (paramJobj.optString("includingGST", "").equalsIgnoreCase("true")) {
//                    /*
//                     * When Including GST is true then we need to recalculate
//                     * line level tax,unit price and invoiceterm amount
//                     * accordingly Below method does the same.
//                     */
//                    Map<String, Object> invoiceMap = new HashMap();
//                    invoiceMap.put(Constants.companyid, companyID);
//                    invoiceMap.put("amountAfterRemovingDiscount", amountAfterRemovingDiscount);
//                    invoiceMap.put("billdate", sdf.parse(paramJobj.getString("billdate")));
//                    updateLineLevelTaxUnitPriceOnIncludeGST(rows, invoiceTermArrayDetails, invoiceMap);
//                }
//                paramJobj.put("taxamount", String.valueOf(taxamount));
//                    Map<String, Object> resultMap = manipulateRowDetails(rowDetailMap, batchSerialMap, batchMap, batchDetailArr, failedRecords, singleInvociceFailedRecords, totalBatchQty, isRecordFailed, rows,isGenerateDeliveryOrder);
//                    if (resultMap.containsKey("isRecordFailed")) {
//                        isRecordFailed = (boolean) resultMap.get("isRecordFailed");
//                        if (!isRecordFailed) {
//                            rowDetailMap = new HashMap<>();
//                            batchSerialMap = new HashMap<>();
//                            batchDetailArr = new JSONArray();
//                        }
//                    }
//                    if (resultMap.containsKey("batchMap") && resultMap.get("batchMap") != null) {
//                        batchMap = (Map<String, List<JSONObject>>) resultMap.get("batchMap");
//                    }
//                
//                if(!isRecordFailed){
//                    paramJobj.put(Constants.detail, rows.toString());
//                    // for save
//                    paramJobj.put(Constants.PAGE_URL,  requestJobj.optString(Constants.PAGE_URL));
//                    saveInvoice(paramJobj);
//                    imported=true;
//                }
//            }
//            if (isRecordFailed) {// only if last invoice is failed
//                failed += singleInvoiceFailureRecoredCount; // last interation failure record
//                if (singleInvoiceFailureRecoredCount > 0) {
//                    failedRecords.append(singleInvociceFailedRecords);
//                }
//            }
//            if (failed > 0) {
//                importHandler.createFailureFiles(fileName, failedRecords, ".csv");
//            }
//
//            int success =(imported==true)? (total - failed):0;
//            failed=(imported==true)? failed:total;
//            if (total == 0) {
//                msg = "Empty file.";
//            } else if (success == 0) {
//                msg = "Failed to import all the records.";
//            } else if (success == total) {
//                msg = "All records are imported successfully.";
//            } else {
//                msg = "Imported " + success + " record" + (success > 1 ? "s" : "") + " successfully";
//                msg += (failed == 0 ? "." : " and failed to import " + failed + " record" + (failed > 1 ? "s" : "") + ".");
//            }
//        } catch (Exception ex) {
//            issuccess = false;
//            msg = "" + ex.getMessage();
//
//            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
//            throw new AccountingException("Error While Importing Records.");
//        } finally {
//            fileInputStream.close();
//            csvReader.close();
//
//            // For saving import log
//            accSalesOrderServiceobj.saveImportLog(requestJobj, msg, total, failed, Constants.Acc_Invoice_ModuleId);
//
//            try {
//                returnObj.put(Constants.RES_success, issuccess);
//                returnObj.put(Constants.RES_msg, msg);
//                returnObj.put("totalrecords", total);
//                returnObj.put("successrecords", total - failed);
//                returnObj.put("failedrecords", failed);
//                returnObj.put("filename", ImportLog.getActualFileName(fileName));
//                returnObj.put("Module", Constants.Acc_Invoice_ModuleId);
//            } catch (JSONException ex) {
//                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
//            }
//        }
//
//        return returnObj;
//    }
    
    public Map<String,Object> manipulateRowDetails(Map<String, Object> rowDetailMap, Map<String, List<Object>> batchSerialMap, Map<String, List<JSONObject>> batchMap, JSONArray batchDetailArr, StringBuilder failedRecords, StringBuilder singleInvociceFailedRecords, double totalBatchQty, boolean isRecordFailed, JSONArray rows,boolean isGenerateDeliveryOrder) {
            Map<String,Object> dataMap=new HashMap<>();
            try {
                List<String> batchKeyList = new ArrayList(batchMap.size());
                for (String batchKey : batchMap.keySet()) {
                    double rowQty = 0;
                    List<JSONObject> list = (List<JSONObject>) batchMap.get(batchKey);
                    double batchQty = 0.0;
                    if (!list.isEmpty()) {
                        for (JSONObject obj1 : list) {
                            if (obj1.has("quantity")) {
                                batchQty += obj1.optDouble("quantity", 0.0);
                            }
                            break; //getting quantity from first row only for same batch
                        }
                    }
                    rowQty += batchQty;
                    if (batchSerialMap.containsKey(batchKey)) {
                        List serialList = batchSerialMap.get(batchKey);
                        if (!serialList.isEmpty() && serialList.size() != batchQty) {
                            throw new AccountingException("Product batch quantity and serial quantity does not match");
                        } else {
                            batchKeyList.add(batchKey);
                        }
                    }
                }
                for (String batchKey : batchKeyList) { // Removing checked Batches
                    batchMap.remove(batchKey);
                }

                for (String keydetail : rowDetailMap.keySet()) {
                    JSONObject jObj = (JSONObject) rowDetailMap.get(keydetail);
                    double rowQunatity = jObj.has("dquantity") ? jObj.optDouble("dquantity", 0.0) : jObj.optDouble("quantity", 0.0);
                    double batchQty = 0;
                    for (int i = 0; i < batchDetailArr.length(); i++) {
                        JSONObject batchObj = (JSONObject) batchDetailArr.get(i);
                        if (batchObj.has("quantity") && batchObj.get("quantity") != null) {
                            batchQty += (double) batchObj.optDouble("quantity", 0);
                        }
                    }
                    if (rowQunatity != batchQty && !(jObj.has("noQuantityMatchingRequire") && jObj.optBoolean("noQuantityMatchingRequire")) && isGenerateDeliveryOrder) {
                        throw new AccountingException("Product quantity and product batch quantity does not match");
                    }
                    jObj.put("batchdetails", batchDetailArr.toString());
                    rows.put(jObj);
                }
                
            } catch (Exception ex) {
                String errorMsg = ex.getMessage();
                isRecordFailed = true;
                if (ex.getMessage() != null) {
                    errorMsg = ex.getMessage();
                } else if (ex.getCause() != null) {
                    errorMsg = ex.getCause().getMessage();
                }
                singleInvociceFailedRecords.append(errorMsg.replaceAll("\"", "")).append("\"");

            }
            dataMap.put("batchMap",batchMap);
            dataMap.put("totalBatchQty",totalBatchQty);
            dataMap.put("isRecordFailed", isRecordFailed);
            return dataMap;
    }

    @Override
    public void updateLineLevelTaxUnitPriceOnIncludeGST(JSONArray rows, JSONArray invoiceTermArrayDetails, Map<String, Object> invoiceMap) {
        try {
            String companyid = "";
            if (invoiceMap.containsKey(Constants.companyid) && invoiceMap.get(Constants.companyid) != null) {
                companyid = (String) invoiceMap.get(Constants.companyid);
            }
            double totalTermAmt = 0;
            if (invoiceTermArrayDetails.length() > 0) {// When Invoice have invoices Term the we need to distribute it on line level, So doing sum for total invoice term
                for (int index = 0; invoiceTermArrayDetails.length() > index; index++) {
                    try {
                        totalTermAmt += invoiceTermArrayDetails.getJSONObject(index).optDouble("termamount", 0);
                    } catch (JSONException ex) {
                        Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }
            double amountAfterRemovingDiscount = 0;// This variable will hold total Line level Amt after removing discount amount
            if (invoiceMap.containsKey("amountAfterRemovingDiscount") && invoiceMap.get("amountAfterRemovingDiscount") != null) {
                amountAfterRemovingDiscount = (double) invoiceMap.get("amountAfterRemovingDiscount");
            }
            Date billDate = invoiceMap.containsKey("billdate") ? (Date) invoiceMap.get("billdate") : null;
            for (int index = 0; index < rows.length(); index++) {
                JSONObject rowObj = rows.getJSONObject(index);
                double rateIncludingGst = rowObj.getDouble("rateIncludingGst");//Since this method is called only when Including GST is true. SO this is mandatory value and hence getDouble Method used.
                double prdiscount = rowObj.optDouble("prdrowiscount", 0);//Since this method is called only when Including GST is true. SO this is mandatory value
                double quantity = rowObj.optDouble("quantity", 1);
                String prtaxid = rowObj.optString("prtaxid", "");
                
                double rowAmtAfterDiscount = authHandler.round((rateIncludingGst * quantity) - prdiscount, companyid);
                // Logic for finding line level term
                // First finding ratio of row level amount to total some of row level amount
                // Then multiplying this ratio with total Term amount.
                // Resultent will be line level term amount
                double lineLevelTermAmt = 0;
                if (amountAfterRemovingDiscount != 0 && rowAmtAfterDiscount != 0) {//Practically both will never 0 but applying check for avaiding math exception
                    lineLevelTermAmt = (rowAmtAfterDiscount / amountAfterRemovingDiscount) * totalTermAmt; //ratio multiply by total term amount
                    lineLevelTermAmt = authHandler.round(lineLevelTermAmt, companyid);
                }
                double taxPercentage = 0;
                if (!StringUtil.isNullOrEmpty(prtaxid)) {
                    HashMap<String, Object> taxParams = new HashMap<>();
                    taxParams.put("transactiondate", billDate);
                    taxParams.put("taxid", prtaxid);
                    taxParams.put(Constants.companyid, companyid);
                    KwlReturnObject taxResult = accTaxObj.getTax(taxParams);
                    Object[] taxRow = (Object[]) taxResult.getEntityList().get(0);
                    taxPercentage = (double) taxRow[1];
                }
                double amountWithTerm = rowAmtAfterDiscount + lineLevelTermAmt;
                double totalPriceWithTerm = authHandler.round((amountWithTerm * 100) / (100 + taxPercentage), companyid);
                double rowTaxAmt = amountWithTerm - totalPriceWithTerm;
                double unitPriceAfterGSTtax = authHandler.round(totalPriceWithTerm / quantity, companyid);
                rows.getJSONObject(index).put("rate", unitPriceAfterGSTtax);
                rows.getJSONObject(index).put("lineleveltermamount", lineLevelTermAmt);
                rows.getJSONObject(index).put("taxamount", rowTaxAmt);
            }
        } catch (JSONException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ServiceException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    @Override
    public double getGlobalTaxAmount(JSONObject paramJobj, String companyid, double amountAfterRemovingDiscount) {
        try {
            SimpleDateFormat sdf = new SimpleDateFormat("MMMM d, yyyy hh:mm:ss aa");
            String taxid = paramJobj.getString("taxid");
            double termAmountForTax = 0.0;
            if (paramJobj.has("invoicetermsmap") && !StringUtil.isNullOrEmpty(paramJobj.optString("invoicetermsmap", null))) {//No need to execute below code code if there is no Invoice Term to import
                JSONArray termsArr = new JSONArray(paramJobj.getString("invoicetermsmap"));
                JSONObject taxHavingTermObj = new JSONObject();
                accTaxObj.getTerms(taxid, taxHavingTermObj);
                if (taxHavingTermObj.has("termid")) {
                    String[] termIDs = taxHavingTermObj.optString("termid", "").split(",");
                    for (int index = 0; index < termIDs.length; index++) {
                        String termid = termIDs[index];
                        for (int arrayIndex = 0; arrayIndex < termsArr.length(); arrayIndex++) {
                            JSONObject termObject = termsArr.getJSONObject(arrayIndex);
                            if (termid.equals(termObject.optString("id", ""))) {
                                termAmountForTax += termObject.optDouble("termamount", 0);
                                break;//Once Term found no need to continue loop for termsArr
                            }
                        }
                    }
                }
            }
            HashMap<String, Object> taxParams = new HashMap<>();
            taxParams.put("transactiondate", sdf.parse(paramJobj.getString("billdate")));
            taxParams.put("taxid", taxid);
            taxParams.put(Constants.companyid, companyid);
            KwlReturnObject taxResult = accTaxObj.getTax(taxParams);
            Object[] taxRow = (Object[]) taxResult.getEntityList().get(0);
            double taxPercentage = (double) taxRow[1];
            double taxamount = ((amountAfterRemovingDiscount + termAmountForTax) * taxPercentage) / 100;
            taxamount = authHandler.round(taxamount, companyid);
            return taxamount;
        } catch (JSONException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ParseException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ServiceException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return 0;
    }

//    public LinkedHashMap<String, InvoiceTermsSales> getSlaestermMapByNameKey(String companyid, boolean isSlaesTerm) {
//        LinkedHashMap<String, InvoiceTermsSales> salesTermMap = new LinkedHashMap<>();//LinkedHashMap used for keeping order
//        HashMap hashMap = new HashMap();
//        hashMap.put("companyid", companyid);
//        hashMap.put("salesOrPurchaseFlag", String.valueOf(isSlaesTerm));
//        KwlReturnObject result = accAccountDAOobj.getInvoiceTerms(hashMap);
//        List<InvoiceTermsSales> termList = result.getEntityList();
//        for (InvoiceTermsSales sales : termList) {
//            salesTermMap.put(sales.getTerm().toLowerCase(), sales);
//        }
//        return salesTermMap;
//    }

    @Override
    public JSONArray getInvoiceTermDetailsArray(Map<String, Object> requestMap, LinkedHashMap<String, InvoiceTermsSales> salesTermMap) {
        JSONArray array = new JSONArray();

        JSONArray invoiceTermDetailArray = new JSONArray();
        if (requestMap.containsKey("invoiceTermDetailsArray") && requestMap.get("invoiceTermDetailsArray") != null) {
            invoiceTermDetailArray = (JSONArray) requestMap.get("invoiceTermDetailsArray");
        }
        double amountAfterRemovingDiscount = 0;
        if (requestMap.containsKey("amountAfterRemovingDiscount") && requestMap.get("amountAfterRemovingDiscount") != null) {
            amountAfterRemovingDiscount = (double) requestMap.get("amountAfterRemovingDiscount");
        }
        String companyid = "";
        if (requestMap.containsKey(Constants.companyid) && requestMap.get(Constants.companyid) != null) {
            companyid = (String) requestMap.get(Constants.companyid);
        }

        for (Map.Entry<String, InvoiceTermsSales> entry : salesTermMap.entrySet()) {//Loop of invoices Term available database  
            InvoiceTermsSales termsSales = entry.getValue();
            for (int i = 0; i < invoiceTermDetailArray.length(); i++) {try {
                //Loop of invoices Term available in imoprted file
                JSONObject invoiceTermObj = invoiceTermDetailArray.getJSONObject(i);
                InvoiceTermsSales sales = (InvoiceTermsSales) invoiceTermObj.get("invoiceTerm");
                if (termsSales.getId().equals(sales.getId())) {//When Term found in imported file as well
                    boolean isPercentage = invoiceTermObj.optBoolean("isPercentage", false);
                    double termValue = invoiceTermObj.optDouble("termValue", 0);

                    JSONObject invoiceDetail = new JSONObject();
                    invoiceDetail.put("id", sales.getId());
                    invoiceDetail.put("glaccount", sales.getAccount().getID());

                    if (isPercentage) {
                        try {
                            double subtotal = 0;
                            double termAmount = 0;
                            double percentage = Math.abs(termValue);//Since term percentage can't be negative hence taking absolute value
                            
                            if (percentage != 0 && amountAfterRemovingDiscount != 0) {
                                String[] formulids = sales.getFormulaids().split(",");
                                for (int index = 0; index < formulids.length; index++) {
                                    String forlmula = formulids[index];
                                    if (forlmula.equalsIgnoreCase("Basic")) {
                                        subtotal += amountAfterRemovingDiscount;
                                    } else {
                                        for (int arrayIndex = 0; arrayIndex < array.length(); arrayIndex++) {
                                            try {
                                                JSONObject termRecord = array.getJSONObject(arrayIndex);
                                                if (forlmula.equals(termRecord.optString("id", ""))) {
                                                    subtotal += termRecord.optDouble("termamount", 0);
                                                    break;//once Record found no need to execute for loop on array
                                                }
                                            } catch (JSONException ex) {
                                                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                                            }
                                        }
                                    }
                                }
                                if (sales.getSign() == 0) {// If value is zero then Sign will be negative
                                    termAmount = subtotal * (percentage / 100) * -1;
                                } else {
                                    termAmount = subtotal * (percentage / 100);
                                }
                            }
                            invoiceDetail.put("termpercentage", Math.abs(termValue));
                            invoiceDetail.put("termamount", authHandler.round(termAmount, companyid));
                        } catch (JSONException ex) {
                            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    } else {
                        try {
                            invoiceDetail.put("termpercentage", "");
                            invoiceDetail.put("termamount", authHandler.round(termValue, companyid));
                        } catch (JSONException ex) {
                            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    }
                    array.put(invoiceDetail);
                }
                } catch (JSONException ex) {
                    Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
        return array;
    }

    public boolean isAllLineLevelInformationIsEmpty(HashMap<String, Integer> columnConfig, String[] recarr) {
        boolean isEmptyLineLevelData = true;
        Set<String> configSet = new HashSet<>();
        configSet.add("productID");//Product Code
        configSet.add("quantity");//Quantity
        configSet.add("rate");//Unit Price
        configSet.add("rateIncludingGst"); //Unit Price Including GST
        configSet.add("uomname"); //UOM
        configSet.add("discountType");//Discount Type
        configSet.add("discount");//Discount
        configSet.add("taxamount");//Tax Amount
        for (String configName : configSet) {
            if (columnConfig.containsKey(configName)) {
                String configValue = recarr[(Integer) columnConfig.get(configName)].replaceAll("\"", "").trim();
                if (!StringUtil.isNullOrEmpty(configValue)) {
                    isEmptyLineLevelData = false;
                    break;
                }
            }
        }
        return isEmptyLineLevelData;
    }
//
//    public boolean isAllTermInvoiceInformationIsEmpty(HashMap<String, Integer> columnConfig, String[] recarr) {
//        boolean isEmptyLineLevelData = true;
//        Set<String> configSet = new HashSet<>();
//        configSet.add("invoiceterm");//Invoice Term
//        configSet.add("termtype");//Term Type
//        configSet.add("termvalue");//Term Value
//        for (String configName : configSet) {
//            if (columnConfig.containsKey(configName)) {
//                String configValue = recarr[(Integer) columnConfig.get(configName)].replaceAll("\"", "").trim();
//                if (!StringUtil.isNullOrEmpty(configValue)) {
//                    isEmptyLineLevelData = false;
//                    break;
//                }
//            }
//        }
//        return isEmptyLineLevelData;
//    }
    @Override
    public JSONObject getBatchRemainingQuantity(JSONObject paramJobj) {
        JSONObject jobj = new JSONObject();
        boolean issuccess = false;
        String msg = "";
        JSONArray detailsArray = new JSONArray();
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("CF_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

        TransactionStatus status = txnManager.getTransaction(def);
        try {
            double quantity = 0;
            boolean isEdit = false;
            boolean fromSubmit = false;
            boolean isfromdo = false;
            boolean isforReturn = false;
            boolean linkflag = false;
            boolean isVendor = false;
            boolean readOnly = false;
            boolean allowTosave=true;
//            boolean isSufficientBomQty=true;
            String productName = "";
            String companyId = paramJobj.getString(Constants.companyKey);
            String batchdetails = paramJobj.optString("batchdetails", null);
            String transType = paramJobj.optString("transType", null);
            String productType = paramJobj.optString("producttype", null);
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isEdit", null))) {
                isEdit = Boolean.parseBoolean(paramJobj.optString("isEdit"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isfromdo", null))) {
                isfromdo = Boolean.parseBoolean(paramJobj.optString("isfromdo"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isforReturn", null))) {
                isforReturn = Boolean.parseBoolean(paramJobj.optString("isforReturn"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("fromSubmit", null))) {
                fromSubmit = Boolean.parseBoolean(paramJobj.optString("fromSubmit"));
            }

            if (!StringUtil.isNullOrEmpty(paramJobj.optString("linkflag", null))) {
                linkflag = Boolean.parseBoolean(paramJobj.optString("linkflag"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("readOnly", null))) {
                readOnly = Boolean.parseBoolean(paramJobj.optString("readOnly"));
            }
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyId);
            ExtraCompanyPreferences extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
            if (isfromdo) {
                String detail = paramJobj.optString(Constants.detail, "[]");
                detailsArray = new JSONArray(detail);
                for (int k = 0; k < detailsArray.length(); k++) {                    
                    JSONObject detailsobj = detailsArray.getJSONObject(k);
                    if (detailsobj.has("batchdetails") && detailsobj.getString("batchdetails") != null) {
                        batchdetails = detailsobj.optString("batchdetails", "");
                    }
                    if (!StringUtil.isNullOrEmpty(batchdetails)) {
                        JSONArray batchDetailsArray = new JSONArray(batchdetails);
                        for (int i = 0; i < batchDetailsArray.length(); i++) {
                            isVendor = false;
                            JSONObject batchObj = batchDetailsArray.optJSONObject(i);
                            String purchasebatchid = batchObj.optString("purchasebatchid", "");
                            String documentid = batchObj.optString("documentid", "");     
                             if(!StringUtil.isNullOrEmpty(transType) && isEdit && (Integer.parseInt(transType)==Constants.Acc_Cash_Sales_ModuleId || Integer.parseInt(transType)==Constants.Acc_Invoice_ModuleId) && StringUtil.isNullOrEmpty(documentid)){    
                                documentid = paramJobj.optString("documentid");             // Edit case for cash sales or sales invoice  (ERP-39951)
                                if (isEdit && StringUtil.isNullOrEmpty(documentid)) {
                                    documentid = detailsobj.optString("docrowid");          // saving cash sales or invoice
                                }
                            }
                            int type = 1;
                            if (batchObj.has("stocktype") && !StringUtil.isNullOrEmpty(batchObj.getString("stocktype")) && "0".equals(batchObj.getString("stocktype"))) {
                                isVendor = true;
                                type = Integer.parseInt(batchObj.getString("stocktype"));
                            }
                            double qty = 0.0;
                            String locationid = batchObj.optString("location", "");
                            String warehouseid = batchObj.optString("warehouse", "");
                            qty = batchObj.optDouble("quantity", 0.0);
                            String productid = batchObj.getString(Constants.productid);
                            String prodname = "";
                            Product product = null;
                            KwlReturnObject prodresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
                            product = prodresult != null ? (Product) prodresult.getEntityList().get(0) : null;
//                            if (product.isAutoAssembly() && !isSufficientBomQty) {    //Commented this code to read the assembly product name for which we do not have enough quantity
//                                break;  //In SO, if any of the product from Grid do not have enough quantity and autoAssembly flag is a TRUE then skip the next iteration and do not save the transaction.
//                            }
                             jobj.put("isBatchForProduct", product.isIsBatchForProduct());
                             jobj.put("isSerialForProduct", product.isIsSerialForProduct());
                            if (product.isIsSerialForProduct() || product.isIsBatchForProduct()) {
                                continue;
                            }
                            if (product != null) {
                                prodname = product.getName();
                            }
                            // For checking if ingredients quantity is fullfilled for customer assembly also.
                            boolean isAssemblyProduct = (Producttype.ASSEMBLY.equals(product.getProducttype().getID()) || Producttype.CUSTOMER_ASSEMBLY.equals(product.getProducttype().getID())) ? true : false;
                            boolean isAutoAssembly = product.isAutoAssembly();
                            
                            quantity = getNewBatchRemainingQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag);
                            if ((StringUtil.isNullOrEmpty(locationid) && StringUtil.isNullOrEmpty(warehouseid))) {
                                if (product.isblockLooseSell()) {
                                    KwlReturnObject result = accProductObj.getAvailableQuantityInSelectedUOM(product.getID(), product.getUnitOfMeasure().getID());
                                    quantity = result.getEntityList().get(0) == null ? 0 : Double.parseDouble(result.getEntityList().get(0).toString());
                                } else {
                                    quantity = product.getAvailableQuantity();
                                }
                                prodname = "";
                                jobj.put("nolocationwarehouse", true);
                                KwlReturnObject result2 = accProductObj.getAssemblyLockQuantity(product.getID()); //get the lock quantity locked in assembly type of product in SO
                                Double assmblyLockQuantity = (Double) (result2.getEntityList().get(0) == null ? 0.0 : result2.getEntityList().get(0));
                                KwlReturnObject result1 = accProductObj.getLockQuantity(product.getID());//get the lock quantity locked in inventory type of product in  all SO
                                Double SoLockQuantity = (Double) (result1.getEntityList().get(0) == null ? 0.0 : result1.getEntityList().get(0));
                                quantity = quantity - (assmblyLockQuantity + SoLockQuantity);
                            } else {
                                quantity = getNewBatchRemainingQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag, type);
                            }
                            if (isVendor) {

                                if ((StringUtil.isNullOrEmpty(locationid) && StringUtil.isNullOrEmpty(warehouseid))) {
                                    KwlReturnObject result4 = accProductObj.getVendorConsignedQuantity(product.getID());
                                    quantity = result4.getEntityList().get(0) == null ? 0 : Double.parseDouble(result4.getEntityList().get(0).toString());
                                } else {
                                    quantity = getNewBatchRemainingVendQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag);
                                }
                            }
                            // if it is assembly type product and autoAssembly feature is on then check for BOM product's Qty for creating build.
                            //If sufficient qty is not present in BOM then do not allow to create DO
                            boolean isQtySufficient=true;
                            if (isAssemblyProduct && isAutoAssembly && qty > quantity) {
                                HashMap<String, Object> requestParams = new HashMap<String, Object>();
                                requestParams.put(Constants.productid, productid);
                                requestParams.put(Constants.currencyKey, paramJobj.getString(Constants.globalCurrencyKey));
                                KwlReturnObject result = accProductObj.getAssemblyItems(requestParams);
                                Iterator itr = result.getEntityList().iterator();
                                double maxBuildQty = 0;
                                boolean isFirst = true;
                                while (itr.hasNext()) {
                                    Object[] row = (Object[]) itr.next();
                                    ProductAssembly passembly = (ProductAssembly) row[0];
                                    String bomProductId = passembly.getSubproducts() != null ? passembly.getSubproducts().getID() : "";
                                    double actQty = passembly.getActualQuantity();
                                    double bomProductQty = 0;
                                    bomProductQty = getNewBatchRemainingQuantity(locationid, warehouseid, companyId, bomProductId, "", transType, isEdit, "", false);
                                    /*
                                        SDP-12875 : Below method has written to calculate Blocked quantity of Assembly Product's BOM.
                                        So balance quantity for BOM will be its available qty - blocked qty.
                                    */
                                    int moduleid = 0;
                                    if (!StringUtil.isNullOrEmpty(transType)) {
                                        moduleid = Integer.parseInt(transType);
                                    }
                                    if(moduleid == Constants.Acc_Sales_Order_ModuleId){//As of now, I am checking this for SO to avoid impact in other module
                                        KwlReturnObject bomLockQty = accProductObj.getBOMProductLockQuantity(passembly.getProduct().getID(), bomProductId);//get the lock quantity locked in inventory type of product in  all SO
                                        Double bomproductLockQty = (Double) (bomLockQty.getEntityList().get(0) == null ? 0.0 : bomLockQty.getEntityList().get(0));
                                        bomProductQty = bomProductQty - bomproductLockQty;
                                    }
                                    if (maxBuildQty >= bomProductQty || isFirst) {
                                        maxBuildQty = bomProductQty;
                                        isFirst = false;
                                    }
                                    if ((qty * actQty) > bomProductQty) {
                                        isQtySufficient=false;
                                        quantity = 0;
                                        break;
                                    }
                                }
                                jobj.put("maxBuildQty", authHandler.formattedQuantity(maxBuildQty, companyId));
                                jobj.put("isQtySufficient", isQtySufficient);
                                if(!isQtySufficient){
                                    if(!productName.equals("")){
                                        productName += (", "+ prodname);
                                    } else{
                                        productName += prodname;                                        
                                    }
                                }
                                jobj.put("productName", productName);   //For SO Module only in invoice.js.
                                //isSufficientBomQty = isQtySufficient;
                            } else if (isAssemblyProduct && !isAutoAssembly && qty > quantity && !extraCompanyPreferences.isIsnegativestockforlocwar()) {
                                jobj.put("isQtySufficient", false);
                            }
                            if (isforReturn ? (qty > quantity) : (quantity < qty)) {
                              if(isAssemblyProduct && isAutoAssembly){
                                  jobj.put("prodname", prodname);
                                  if (!isQtySufficient) { // For Assembly product with Auto Assembly on and Qnantity is not sufficient for build
                                        quantity = 0;
                                        break;
                                    }
                                }else{
                                    jobj.put("prodname", prodname); // For Normal Products with Combination of Assembly Product
                                    quantity = 0;
                                    break;
                                }
                            }else if (extraCompanyPreferences.isAllowZeroQuantityForProduct() && qty > quantity) {
                                allowTosave=false;
                                break;
                            }
                        }
                    }
                }
            } else {
                if (!StringUtil.isNullOrEmpty(batchdetails)) {
                    JSONArray batchDetailsArray = new JSONArray(batchdetails);
                    for (int i = 0; i < batchDetailsArray.length(); i++) {
                        isVendor = false;
                        JSONObject batchObj = batchDetailsArray.optJSONObject(i);
                        String purchasebatchid = batchObj.optString("purchasebatchid", "");
                        String documentid = batchObj.optString("documentid", "");
                        if(!StringUtil.isNullOrEmpty(transType) && isEdit && (Integer.parseInt(transType)==Constants.Acc_Cash_Sales_ModuleId || Integer.parseInt(transType)==Constants.Acc_Invoice_ModuleId) && StringUtil.isNullOrEmpty(documentid)){
                            documentid = paramJobj.optString("documentid");          // Edit case for cash sales or sales invoice  (ERP-39951)
                            if(isEdit && StringUtil.isNullOrEmpty(documentid)){
                            documentid = paramJobj.optString("docrowid");    
                            }
                        }
                        int type = 1;
                        if (batchObj.has("stocktype") && !StringUtil.isNullOrEmpty(batchObj.getString("stocktype")) && "0".equals(batchObj.getString("stocktype"))) {
                            isVendor = true;
                            type = Integer.parseInt(batchObj.getString("stocktype"));
                        }
                        double qty = 0.0;
                        String locationid = batchObj.optString("location");
                        String warehouseid = batchObj.optString("warehouse");
                        String row = batchObj.optString("row");
                        String rack = batchObj.optString("rack");
                        String bin = batchObj.optString("bin");
                        qty = batchObj.optDouble("quantity", 0.0);
                        String productid = batchObj.optString(Constants.productid);
                        KwlReturnObject prodresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
                        Product product = prodresult != null ? (Product) prodresult.getEntityList().get(0) : null;
                        if ((StringUtil.isNullOrEmpty(locationid) && StringUtil.isNullOrEmpty(warehouseid))) {
                            if (product.isblockLooseSell()) {
                                KwlReturnObject result = accProductObj.getAvailableQuantityInSelectedUOM(product.getID(), product.getUnitOfMeasure().getID());
                                quantity = result.getEntityList().get(0) == null ? 0 : Double.parseDouble(result.getEntityList().get(0).toString());
                            } else {
                                quantity = product.getAvailableQuantity();
                            }

                            KwlReturnObject result2 = accProductObj.getAssemblyLockQuantity(product.getID()); //get the lock quantity locked in assembly type of product in SO
                            Double assmblyLockQuantity = (Double) (result2.getEntityList().get(0) == null ? 0.0 : result2.getEntityList().get(0));
                            KwlReturnObject result1 = accProductObj.getLockQuantity(product.getID());//get the lock quantity locked in inventory type of product in  all SO
                            Double SoLockQuantity = (Double) (result1.getEntityList().get(0) == null ? 0.0 : result1.getEntityList().get(0));
                            quantity = quantity - (assmblyLockQuantity + SoLockQuantity);

                        } else {
                            /*for job work assembly product we fetch remaining quantity acoording to bomcode for selected batch*/
                            if (!StringUtil.isNullOrEmpty(productType) && productType.equals("Job Work Assembly")){
                                String bomid = paramJobj.optString("bomid", null);
                                String batch = paramJobj.optString("batch", null);
                                quantity = accMasterItemsDAOobj.getBOMRemainingQuantityForJobWorkAssembly(productid, companyId, warehouseid, locationid, batch, bomid);
                            } else {
                                quantity = getNewBatchRemainingQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag, type,row,rack,bin, readOnly);
                            }
                        }
                        if (isVendor) {

                            if ((StringUtil.isNullOrEmpty(locationid) && StringUtil.isNullOrEmpty(warehouseid))) {
                                KwlReturnObject result4 = accProductObj.getVendorConsignedQuantity(product.getID());
                                quantity = result4.getEntityList().get(0) == null ? 0 : Double.parseDouble(result4.getEntityList().get(0).toString());
                            } else {
                                quantity = getNewBatchRemainingVendQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag);
                            }
                        }
                        if (fromSubmit) {  // on submit window check all rows quantity are availble otherwise make quantty unavaiabale
                            if (authHandler.roundQuantity(quantity, companyId) < qty) {
                                quantity = 0;
                                break;
                            }
                        }
                    }
                }
            }
            if (extraCompanyPreferences.isAllowZeroQuantityForProduct() && isfromdo) {
                jobj.put("allowtosave", allowTosave);
            }
            jobj.put("quantity", authHandler.formattedQuantity(quantity, companyId));
            issuccess = true;
            msg = "Batch Remaining Quantity has been received successfully.";
            txnManager.commit(status);
        } catch (Exception ex) {
            txnManager.rollback(status);
            msg = ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            }
        }
        return jobj;
    }
    /**
     * Get Remaining qty for product in default warehouse and location case
     */
    public JSONObject getBatchRemainingQuantityforAssembly(JSONObject paramJobj) {
        JSONObject jobj = new JSONObject();
        boolean issuccess = false;
        String msg = "";
        JSONArray detailsArray = new JSONArray();
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("CF_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = txnManager.getTransaction(def);
        try {
            double quantity = 0;
            boolean isEdit = false;
            boolean invalidrecpresent = false;
            boolean readOnly = false;
            List productArr = new ArrayList();
            String companyId = paramJobj.getString(Constants.companyKey);
            String batchdetails = paramJobj.optString("batchdetails", null);
            String transType = paramJobj.optString("transType", null);
            ExtraCompanyPreferences extraCompanyPreferences = null;
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyId);
            extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
            boolean isActivateMRPModule =false; 
            if(extraCompanyPreferences!=null){
            isActivateMRPModule=extraCompanyPreferences.isActivateMRPModule();
            } 
                        
            if (!StringUtil.isNullOrEmpty(batchdetails)) {
                JSONArray batchDetailsArray = new JSONArray(batchdetails);
                for (int i = 0; i < batchDetailsArray.length(); i++) {
                    JSONObject batchObj = batchDetailsArray.optJSONObject(i);
                    String purchasebatchid = batchObj.optString("purchasebatchid", "");
                    String documentid = batchObj.optString("documentid", "");
                    int type = 1;
                    if (batchObj.has("stocktype") && !StringUtil.isNullOrEmpty(batchObj.getString("stocktype")) && "0".equals(batchObj.getString("stocktype"))) {
                        type = Integer.parseInt(batchObj.getString("stocktype"));
                    }
                    double qty = 0.0;
                    String locationid = batchObj.optString("location");
                    String warehouseid = batchObj.optString("warehouse");
                    String row = batchObj.optString("row");
                    String rack = batchObj.optString("rack");
                    String bin = batchObj.optString("bin");
                    qty = batchObj.optDouble("quantity", 0.0);
                    int componentType = 0;
                    if (batchObj.has("componentType")) {
                        componentType = batchObj.optInt("componentType");

                    }
                    String productid = batchObj.optString(Constants.productid);
                    KwlReturnObject prodresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
                    Product product = prodresult != null ? (Product) prodresult.getEntityList().get(0) : null;
//                    String locationid = product.getLocation().getId();
//                    String warehouseid = product.getWarehouse().getId();
                    if (!(componentType == 2 || componentType == 3)) {
                        quantity = getNewBatchRemainingQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, false, type, row, rack, bin, readOnly);

                        
                        /**
                         * If MRP module is activated
                         * do not check required quantity is less than available quantity. 
                         */
                        if (!isActivateMRPModule) {               
                            if (quantity < qty) {
                                productArr.add(product.getName());
                                invalidrecpresent = true;
                            }

                        }
                    }
                }
            }
            issuccess = true;
            if (invalidrecpresent) {
                msg = productArr.toString();
            }
            jobj.put("invalidrecpresent", invalidrecpresent);
            txnManager.commit(status);
        } catch (Exception ex) {
            txnManager.rollback(status);
            msg = ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            }
        }
        return jobj;
    }
    
    @Override
    public JSONObject getBatchRemainingQuantityForImport(JSONObject paramJobj) {
        JSONObject jobj = new JSONObject();
        boolean issuccess = false;
        String msg = "";
        JSONArray detailsArray = new JSONArray();
        try {
            double quantity = 0;
            boolean isEdit = false;
            boolean isfromdo = false;
            boolean isforReturn = false;
            boolean linkflag = false;
            boolean isVendor = false;
            String companyId = paramJobj.getString(Constants.companyKey);
            String batchdetails = paramJobj.optString("batchdetails", null);
            String transType = paramJobj.optString("transType", null);
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isEdit", null))) {
                isEdit = Boolean.parseBoolean(paramJobj.optString("isEdit"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isfromdo", null))) {
                isfromdo = Boolean.parseBoolean(paramJobj.optString("isfromdo"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("isforReturn", null))) {
                isforReturn = Boolean.parseBoolean(paramJobj.optString("isforReturn"));
            }
            if (!StringUtil.isNullOrEmpty(paramJobj.optString("linkflag", null))) {
                linkflag = Boolean.parseBoolean(paramJobj.optString("linkflag"));
            }
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyId);
            ExtraCompanyPreferences extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
            if (isfromdo) {
                String detail = paramJobj.optString(Constants.detail, "[]");
                detailsArray = new JSONArray(detail);
                for (int k = 0; k < detailsArray.length(); k++) {
                    JSONObject detailsobj = detailsArray.getJSONObject(k);
                    if (detailsobj.has("batchdetails") && detailsobj.getString("batchdetails") != null) {
                        batchdetails = detailsobj.optString("batchdetails", "");
                    }
                    if (!StringUtil.isNullOrEmpty(batchdetails)) {
                        JSONArray batchDetailsArray = new JSONArray(batchdetails);
                        for (int i = 0; i < batchDetailsArray.length(); i++) {
                            isVendor = false;
                            JSONObject batchObj = batchDetailsArray.optJSONObject(i);
                            String purchasebatchid = batchObj.optString("purchasebatchid", "");
                            String documentid = batchObj.optString("documentid", "");
                            int type = 1;
                            if (batchObj.has("stocktype") && !StringUtil.isNullOrEmpty(batchObj.getString("stocktype")) && "0".equals(batchObj.getString("stocktype"))) {
                                isVendor = true;
                                type = Integer.parseInt(batchObj.getString("stocktype"));
                            }
                            double qty = 0.0;
                            String locationid = batchObj.optString("location", "");
                            String warehouseid = batchObj.optString("warehouse", "");
                            qty = batchObj.optDouble("quantity", 0.0);
                            String productid = batchObj.getString(Constants.productid);
                            String prodname = "";
                            Product product = null;
                            KwlReturnObject prodresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
                            product = prodresult != null ? (Product) prodresult.getEntityList().get(0) : null;
                            if (product != null) {
                                prodname = product.getName();
                            }
                            // For checking if ingredients quantity is fullfilled for customer assembly also.
                            boolean isAssemblyProduct = (Producttype.ASSEMBLY.equals(product.getProducttype().getID()) || Producttype.CUSTOMER_ASSEMBLY.equals(product.getProducttype().getID())) ? true : false;
                            boolean isAutoAssembly = product.isAutoAssembly();
                            
                            quantity = getNewBatchRemainingQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag);
                            if ((StringUtil.isNullOrEmpty(locationid) && StringUtil.isNullOrEmpty(warehouseid))) {
                                if (product.isblockLooseSell()) {
                                    KwlReturnObject result = accProductObj.getAvailableQuantityInSelectedUOM(product.getID(), product.getUnitOfMeasure().getID());
                                    quantity = result.getEntityList().get(0) == null ? 0 : Double.parseDouble(result.getEntityList().get(0).toString());
                                } else {
                                    quantity = product.getAvailableQuantity();
                                }
                                prodname = "";
                                jobj.put("nolocationwarehouse", true);
                                KwlReturnObject result2 = accProductObj.getAssemblyLockQuantity(product.getID()); //get the lock quantity locked in assembly type of product in SO
                                Double assmblyLockQuantity = (Double) (result2.getEntityList().get(0) == null ? 0.0 : result2.getEntityList().get(0));
                                KwlReturnObject result1 = accProductObj.getLockQuantity(product.getID());//get the lock quantity locked in inventory type of product in  all SO
                                Double SoLockQuantity = (Double) (result1.getEntityList().get(0) == null ? 0.0 : result1.getEntityList().get(0));
                                quantity = quantity - (assmblyLockQuantity + SoLockQuantity);
                            } else {
                                quantity = getNewBatchRemainingQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag, type);
                            }
                            if (isVendor) {

                                if ((StringUtil.isNullOrEmpty(locationid) && StringUtil.isNullOrEmpty(warehouseid))) {
                                    KwlReturnObject result4 = accProductObj.getVendorConsignedQuantity(product.getID());
                                    quantity = result4.getEntityList().get(0) == null ? 0 : Double.parseDouble(result4.getEntityList().get(0).toString());
                                } else {
                                    quantity = getNewBatchRemainingVendQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag);
                                }
                            }
                            // if it is assembly type product and autoAssembly feature is on then check for BOM product's Qty for creating build.
                            //If sufficient qty is not present in BOM then do not allow to create DO
                            boolean isQtySufficient=true;
                            if (isAssemblyProduct && isAutoAssembly && qty > quantity) {
                                HashMap<String, Object> requestParams = new HashMap<String, Object>();
                                requestParams.put(Constants.productid, productid);
                                requestParams.put(Constants.currencyKey, paramJobj.getString(Constants.globalCurrencyKey));
                                KwlReturnObject result = accProductObj.getAssemblyItems(requestParams);
                                Iterator itr = result.getEntityList().iterator();
                                double maxBuildQty = 0;
                                boolean isFirst = true;
                                while (itr.hasNext()) {
                                    Object[] row = (Object[]) itr.next();
                                    ProductAssembly passembly = (ProductAssembly) row[0];
                                    String bomProductId = passembly.getSubproducts() != null ? passembly.getSubproducts().getID() : "";
                                    double actQty = passembly.getActualQuantity();
                                    double bomProductQty = 0;
                                    bomProductQty = getNewBatchRemainingQuantity(locationid, warehouseid, companyId, bomProductId, "", transType, isEdit, "", false);
                                    if (maxBuildQty >= bomProductQty || isFirst) {
                                        maxBuildQty = bomProductQty;
                                        isFirst = false;
                                    }
                                    if ((qty * actQty) > bomProductQty) {
                                        isQtySufficient=false;
                                        quantity = 0;
                                        break;
                                    }
                                }
                                jobj.put("maxBuildQty", authHandler.formattedQuantity(maxBuildQty, companyId));
                                jobj.put("isQtySufficient", isQtySufficient);
                            } else if (isAssemblyProduct && !isAutoAssembly && qty > quantity && !extraCompanyPreferences.isIsnegativestockforlocwar()) {
                                jobj.put("isQtySufficient", false);
                            }
                            if (isforReturn ? (qty > quantity) : (quantity < qty)) {
                              if(isAssemblyProduct && isAutoAssembly){
                                    if(!isQtySufficient){ // For Assembly product with Auto Assembly on and Qnantity is not sufficient for build
                                        jobj.put("prodname", prodname);
                                        quantity = 0;
                                        break;
                                    }
                                }else{
                                    jobj.put("prodname", prodname); // For Normal Products with Combination of Assembly Product
                                    quantity = 0;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            jobj.put("quantity", authHandler.formattedQuantity(quantity, companyId));
            issuccess = true;
        } catch (Exception ex) {
            msg = ex.getMessage();
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
            } catch (JSONException ex) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
            }
        }
        return jobj;
    }
    
    @Override
    public double getNewBatchRemainingQuantity(String locationid, String warehouseid, String companyId, String productid, String purchasebatchid, String transType, boolean isEdit, String documentid, boolean linkflag) throws ServiceException {
        return getNewBatchRemainingQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag, 1);
    }
    
    private double getNewBatchRemainingQuantity(String locationid, String warehouseid, String companyId, String productid, String purchasebatchid, String transType, boolean isEdit, String documentid, boolean linkflag, int type) throws ServiceException {
        return getNewBatchRemainingQuantity(locationid, warehouseid, companyId, productid, purchasebatchid, transType, isEdit, documentid, linkflag, type, null, null, null,false);
    }

    private double getNewBatchRemainingQuantity(String locationid, String warehouseid, String companyId, String productid, String purchasebatchid, String transType, boolean isEdit, String documentid, boolean linkflag, int type,String row,String rack,String bin, boolean readOnly) throws ServiceException {
        double quantity = 0.0;
        double srquantity = 0.0;
        try {
            HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
            HashMap<String, Object> filterRequestParamsforEdit = new HashMap<String, Object>();
            ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
            ArrayList filter_namesforEdit = new ArrayList(), filter_paramsforEdit = new ArrayList(), order_byforEdit = new ArrayList(), order_typeforEdit = new ArrayList();
            filter_names.add("company.companyID");
            filter_params.add(companyId);
            boolean isnegativestockforlocwar = false;
            ExtraCompanyPreferences extraCompanyPreferences = null;
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyId);
            extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;
            KwlReturnObject prodresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
            Product product = prodresult != null ? (Product) prodresult.getEntityList().get(0) : null;
            boolean isBatchForProduct = false;
            boolean isSerialForProduct = false;
            if (product != null) {
                isBatchForProduct = product.isIsBatchForProduct();
                isSerialForProduct = product.isIsSerialForProduct();
            }
            isnegativestockforlocwar = extraCompanyPreferences.isIsnegativestockforlocwar();
            if (!StringUtil.isNullOrEmpty(warehouseid)) {
                filter_names.add("warehouse.id");
                filter_params.add(warehouseid);
            }
            if (type == 0) {
                filter_names.add(">(consignquantity)");
                filter_params.add(0.0);
            }
            if (!StringUtil.isNullOrEmpty(locationid)) {
                filter_names.add("location.id");
                filter_params.add(locationid);
            }
            if (!StringUtil.isNullOrEmpty(row)) {
                filter_names.add("row.id");
                filter_params.add(row);
            }
            if (!StringUtil.isNullOrEmpty(rack)) {
                filter_names.add("rack.id");
                filter_params.add(rack);
            }
            if (!StringUtil.isNullOrEmpty(bin)) {
                filter_names.add("bin.id");
                filter_params.add(bin);
            }
            if (!StringUtil.isNullOrEmpty(purchasebatchid)) {
                filter_names.add("id");
                filter_params.add(purchasebatchid);
            }

            filter_names.add("product");
            filter_params.add(productid);

            filterRequestParams.put("filter_names", filter_names);
            filterRequestParams.put("filter_params", filter_params);
            filterRequestParams.put("order_by", order_by);
            filterRequestParams.put("order_type", order_type);
            KwlReturnObject result = accMasterItemsDAOobj.getNewBatches(filterRequestParams, false, false);
            int inttransType = 0;
            int transTypeForConsignmentQty = 0;
            int moduleid=0;
            if (!StringUtil.isNullOrEmpty(transType)) {
                inttransType = Integer.parseInt(transType);
                moduleid = Integer.parseInt(transType);
            }

            //as while saving consignment deliveryorder we are not saving  consignment moduleid we are saving normal do id so we are not getting the data from consignment moduleid
            if (inttransType == Constants.Acc_ConsignmentDeliveryOrder_ModuleId) {
                transTypeForConsignmentQty=Constants.Acc_ConsignmentDeliveryOrder_ModuleId;//In ConsignmentDeliveryOrder we display consignment quantity, for this purpose this variable will be used
                inttransType = Constants.Acc_Delivery_Order_ModuleId;
            }
            HashMap<String, Object> requestParams = new HashMap<>();
            requestParams.put("product", productid);
            /*
             * Fetching Unfreed WO details 
             */
            KwlReturnObject reslut1 = accMasterItemsDAOobj.getLBDMforConsumedUnfreeWODetail(requestParams);
            List lbdmids = reslut1.getEntityList();
            /*
             * Creating set of newProductBatch ids to which is linked to unfreed WO details
             */
            Set<String> newProdBatIdSet = new HashSet<String>();
            if (!lbdmids.isEmpty()) {
                for (Object lbdmId : lbdmids.toArray()) {
                    KwlReturnObject result2 = accountingHandlerDAOobj.getObject(LocationBatchDocumentMapping.class.getName(), lbdmId.toString());
                    LocationBatchDocumentMapping lbdmObj = (LocationBatchDocumentMapping) result2.getEntityList().get(0);
                    if (lbdmObj != null) {
                        newProdBatIdSet.add(lbdmObj.getBatchmapid().getId());
                    }
                }
            }
            List<NewProductBatch> listResult = result.getEntityList();
            for (NewProductBatch newProductBatch : listResult) {
                HashMap<String, Object> filterParamsForPRBatch = new HashMap<String, Object>();
                ArrayList PRfilter_names = new ArrayList(), PRfilter_params = new ArrayList();
                HashMap<String, Object> filterParamsForPRCustBatch = new HashMap<String, Object>();
                ArrayList PRCustfilter_names = new ArrayList(), PRCustfilter_params = new ArrayList();
                if (inttransType == Constants.Acc_Sales_Return_ModuleId || inttransType == Constants.Acc_ConsignmentSalesReturn_ModuleId) {
                    if (inttransType == Constants.Acc_Sales_Return_ModuleId) {
                        PRfilter_names.add("ispurchasereturn");
                        PRfilter_params.add(false);
                        PRfilter_names.add("transactiontype");
                        PRfilter_params.add(27);
                        PRfilter_names.add("batchmapid.id");
                        PRfilter_params.add(newProductBatch.getId());
                        filterParamsForPRBatch.put("filter_names", PRfilter_names);
                        filterParamsForPRBatch.put("filter_params", PRfilter_params);
                        KwlReturnObject PRresult = accMasterItemsDAOobj.getPRBatchQuantity(filterParamsForPRBatch);
                        List locationResult = PRresult.getEntityList();
                        Iterator LocitrResult = locationResult.iterator();
                        while (LocitrResult.hasNext()) {
                            LocationBatchDocumentMapping locationBatchDocumentMapping = (LocationBatchDocumentMapping) LocitrResult.next();
                            //ERP-39168 : To display only link DO quantity to Sales Return Serial Window
                            if (linkflag){
                                if(documentid.equals(locationBatchDocumentMapping.getDocumentid())){
                                    quantity = quantity + locationBatchDocumentMapping.getQuantity();
                                }
                            }
                            else{
                                quantity = quantity + locationBatchDocumentMapping.getQuantity();
                            }
                        }
                    } else if (inttransType == Constants.Acc_ConsignmentSalesReturn_ModuleId) {
                        //To Check quantity in Customer warehouse while creating Sales Return linking with DO.
                        PRCustfilter_names.add("ispurchasereturn"); 
                        PRCustfilter_params.add(false);
                        PRCustfilter_names.add("transactiontype");
                        PRCustfilter_params.add(28);
                        PRCustfilter_names.add("batchmapid.id");
                        PRCustfilter_params.add(newProductBatch.getId());
                        if (!StringUtil.isNullOrEmpty(documentid)) {
                            PRCustfilter_names.add("documentid");
                            PRCustfilter_params.add(documentid);
                        }
                        filterParamsForPRCustBatch.put("filter_names", PRCustfilter_names);
                        filterParamsForPRCustBatch.put("filter_params", PRCustfilter_params);
                        KwlReturnObject PRCustresult = accMasterItemsDAOobj.getPRBatchQuantity(filterParamsForPRCustBatch);
                        List locationCustResult = PRCustresult.getEntityList();
                        Iterator LocCustitrResult = locationCustResult.iterator();
                        while (LocCustitrResult.hasNext()) {
                            LocationBatchDocumentMapping locationBatchDocumentMapping = (LocationBatchDocumentMapping) LocCustitrResult.next();
                            quantity = quantity + locationBatchDocumentMapping.getQuantity();
                        }
                     }
                    //for Sales return we are showing those quantity whose DO has been made
                    HashMap<String, Object> filterParamsForSRBatch = new HashMap<String, Object>();
                    ArrayList SRfilter_names = new ArrayList(), SRfilter_params = new ArrayList();
                    SRfilter_names.add("ispurchasereturn");
                    SRfilter_params.add(false);
                    SRfilter_names.add("transactiontype");
                    SRfilter_params.add(29);
                    SRfilter_names.add("batchmapid.id");
                    SRfilter_params.add(newProductBatch.getId());

                    SRfilter_names.add("stocktype");
                    SRfilter_params.add(type);

                    if (!StringUtil.isNullOrEmpty(documentid)) {
                        SRfilter_names.add("documentid");
                        SRfilter_params.add(documentid);
                    }

                    filterParamsForSRBatch.put("filter_names", SRfilter_names);
                    filterParamsForSRBatch.put("filter_params", SRfilter_params);
                    if(linkflag && inttransType == Constants.Acc_Sales_Return_ModuleId){
                        //If partial quantity of DO/SI is returned and again same DO/SI is linked then available qunatity = quantity in DO.SI - quantity which is already returned.(DeliveryOrderGrid.js)
                        srquantity = accInvoiceDAOobj.getReturnQuantityofDOorSIForSR(documentid, companyId,newProductBatch.getId());
                    }else{
                        KwlReturnObject SRresult = accMasterItemsDAOobj.getPRBatchQuantity(filterParamsForSRBatch);
                        List SRLocResult = SRresult.getEntityList();
                        Iterator SRLocitrResult = SRLocResult.iterator();
                        while (SRLocitrResult.hasNext()) {
                            LocationBatchDocumentMapping locationBatchDocumentMapping = (LocationBatchDocumentMapping) SRLocitrResult.next();
                            srquantity = srquantity + locationBatchDocumentMapping.getQuantity();
                        }
                    }
                    quantity = quantity - srquantity;
                } else if (inttransType == Constants.Acc_Invoice_ModuleId || inttransType == Constants.Acc_Delivery_Order_ModuleId || inttransType == Constants.Acc_Purchase_Return_ModuleId  || inttransType == Constants.Acc_ConsignmentRequest_ModuleId || inttransType == Constants.Acc_Cash_Sales_ModuleId){
                    if (!StringUtil.isNullOrEmpty(documentid)) {
                        //To Check quantity in Customer warehouse while creating Sales Return linking with DO.
                        PRCustfilter_names.add("ispurchasereturn");
                        PRCustfilter_params.add(false);
                        PRCustfilter_names.add("transactiontype");
                        PRCustfilter_params.add(20);
                        PRCustfilter_names.add("batchmapid.id");
                        PRCustfilter_params.add(newProductBatch.getId());
                        if (!StringUtil.isNullOrEmpty(documentid)) {
                            PRCustfilter_names.add("documentid");
                            PRCustfilter_params.add(documentid);
                        }
                        filterParamsForPRCustBatch.put("filter_names", PRCustfilter_names);
                        filterParamsForPRCustBatch.put("filter_params", PRCustfilter_params);
                        KwlReturnObject PRCustresult = accMasterItemsDAOobj.getPRBatchQuantity(filterParamsForPRCustBatch);
                        List locationCustResult = PRCustresult.getEntityList();
//                        Iterator LocCustitrResult = locationCustResult.iterator();
                        double dueQty = newProductBatch.getQuantitydue();
                        double consQty = newProductBatch.getConsignquantity();
                        double lockQty = 0.0;
                        double avlqty = 0.0;
//                    if (!newProdBatIdSet.contains(newProductBatch.getId())) {
                        lockQty = newProductBatch.getLockquantity();
                        if (linkflag && locationCustResult.size() > 0) {
                            avlqty = dueQty;
                        } else {
                            avlqty = dueQty - lockQty;
                        }
                        if (avlqty > 0) {
                            quantity = quantity + avlqty;
                        } else if (!(isBatchForProduct || isSerialForProduct) && avlqty < 0) {
                            quantity = quantity + avlqty;
                        }
                    } else {
                        double avlqty = newProductBatch.getQuantitydue() - newProductBatch.getLockquantity();
                        double consQty = newProductBatch.getConsignquantity() - newProductBatch.getLockquantity();
                        double lockQty = 0.0;
                        if (avlqty > 0) {
                            quantity = quantity + avlqty;
                        } else if ((isnegativestockforlocwar && !(isBatchForProduct || isSerialForProduct)) && avlqty < 0) {
                            quantity = quantity + avlqty;
                        }
                    }  
                    
                } else {
                    double dueQty = newProductBatch.getQuantitydue();
                    double consQty = newProductBatch.getConsignquantity();
                    double lockQty = 0.0;
//                    if (!newProdBatIdSet.contains(newProductBatch.getId())) {
                    if (!linkflag) {
                            lockQty = newProductBatch.getLockquantity();
                    }
//                    }
                    //as avaiable quabtity should be  quantitydue- lock quantity otherwise those batches which
                    double avlqty = dueQty - lockQty;
                    if (avlqty > 0) {
                        quantity = quantity + avlqty;
                    } else if ((isnegativestockforlocwar && !(isBatchForProduct || isSerialForProduct)) && avlqty > 0) {
                        quantity = quantity + avlqty;
                    }
                }
            }
            boolean ispickpackdo=extraCompanyPreferences.isPickpackship()&&moduleid==Constants.Acc_Delivery_Order_ModuleId?true:false;
            if (isEdit && !StringUtil.isNullOrEmpty(documentid) && !ispickpackdo && !readOnly) {

                if (!StringUtil.isNullOrEmpty(warehouseid)) {
                    filter_namesforEdit.add("batchmapid.warehouse.id");
                    filter_paramsforEdit.add(warehouseid);
                }
                if (!StringUtil.isNullOrEmpty(locationid)) {
                    filter_namesforEdit.add("batchmapid.location.id");
                    filter_paramsforEdit.add(locationid);
                }
                if (!StringUtil.isNullOrEmpty(purchasebatchid)) {
                    filter_namesforEdit.add("batchmapid.id");
                    filter_paramsforEdit.add(purchasebatchid);
                }
                if (!StringUtil.isNullOrEmpty(documentid)) {
                    filter_namesforEdit.add("documentid");
                    filter_paramsforEdit.add(documentid);
                }

                filter_namesforEdit.add("ispurchasereturn");
                if (inttransType == Constants.Acc_Purchase_Return_ModuleId||inttransType == Constants.Acc_ConsignmentPurchaseReturn_ModuleId) {
                    filter_paramsforEdit.add(true);
                } else {
                    filter_paramsforEdit.add(false);
                }
                if (inttransType == Constants.Acc_Invoice_ModuleId || inttransType == Constants.Acc_Cash_Sales_ModuleId) {
                    inttransType = 27;
                }
                filter_namesforEdit.add("transactiontype");
                filter_paramsforEdit.add(inttransType);

                filter_namesforEdit.add("stocktype");
                filter_paramsforEdit.add(type);

                filterRequestParamsforEdit.put("filter_names", filter_namesforEdit);
                filterRequestParamsforEdit.put("filter_params", filter_paramsforEdit);                
                KwlReturnObject PRresult = accMasterItemsDAOobj.getPRBatchQuantity(filterRequestParamsforEdit);
                List locationResult = PRresult.getEntityList();
                Iterator LocitrResult = locationResult.iterator();
                while (LocitrResult.hasNext()) {
                    LocationBatchDocumentMapping locationBatchDocumentMapping = (LocationBatchDocumentMapping) LocitrResult.next();
                        quantity = quantity + locationBatchDocumentMapping.getQuantity();
                    }
            }else {
                /**
                 * ERM-270
                 * Commenting this code for issue in Edit case of Pick Pack DO mutiple batch quantities get added into all batches.
                 * 
                 * /
                /**
                 * Get Batch remaining quantity in Edit case of Pick DO
                 */
//                Map reqParam = new HashMap();       
//                reqParam.put("dodid", documentid);
//                reqParam.put("locationid", locationid);
//                reqParam.put("warehouseid", warehouseid);
//                KwlReturnObject result1 = accMasterItemsDAOobj.getBatchRemainingQtyFromIST(reqParam);
//                List l = result1.getEntityList();
//                for (Iterator it = l.iterator(); it.hasNext();) {
//                    quantity = quantity + (double) it.next();
//
//                }
            }

        } catch (Exception ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("AccInvoiceModuleServiceImpl.getBatchRemainingQuantity() -: " + ex.getMessage(), ex);
        }
        return authHandler.roundQuantity(quantity, companyId);
    }
   private double getNewBatchRemainingVendQuantity(String locationid, String warehouseid, String companyId, String productid, String purchasebatchid, String transType, boolean isEdit, String documentid, boolean linkflag) throws ServiceException {
        double avlQty = 0;
        try {
            HashMap<String, Object> filterRequestParams = new HashMap<String, Object>();
            ArrayList filter_names = new ArrayList(), filter_params = new ArrayList(), order_by = new ArrayList(), order_type = new ArrayList();
            filter_names.add("company.companyID");
            filter_params.add(companyId);
            if (!StringUtil.isNullOrEmpty(warehouseid)) {
                filter_names.add("warehouse.id");
                filter_params.add(warehouseid);
            }
            if (!StringUtil.isNullOrEmpty(locationid)) {
                filter_names.add("location.id");
                filter_params.add(locationid);
            }
            if (!StringUtil.isNullOrEmpty(purchasebatchid)) {
                filter_names.add("id");
                filter_params.add(purchasebatchid);
            }

            filter_names.add("product");
            filter_params.add(productid);

            filterRequestParams.put("filter_names", filter_names);
            filterRequestParams.put("filter_params", filter_params);
            filterRequestParams.put("order_by", order_by);
            filterRequestParams.put("order_type", order_type);
            KwlReturnObject result = accMasterItemsDAOobj.getNewBatchesForVendor(filterRequestParams,false,false);
            List<NewProductBatch> listResult = result.getEntityList();
            for (NewProductBatch newProductBatch : listResult) {
                avlQty += newProductBatch.getConsignquantity();
            }
        }
        catch(Exception ex){
             Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("AccInvoiceModuleServiceImpl.getBatchRemainingQuantity() -: " + ex.getMessage(), ex);
        }
        return avlQty;
    }

    @Override
    public void revertGIROFileGenerationStatus(HashMap<String, Object> map)  {
        try{
            String companyId =  (String) (map.containsKey("companyId")?map.get("companyId"):"");
            String invoiceIds = (String) (map.containsKey("invoiceIds")?map.get("invoiceIds"):"");
            
            if(!StringUtil.isNullOrEmpty(invoiceIds)){
                String[] invoices = invoiceIds.split(",");
                String id="";
                KwlReturnObject result = null;
                Invoice invoice = null;
                for(int i=0; i<invoices.length;i++){
                    id = invoices[i];
                    result = accountingHandlerDAOobj.getObject(Invoice.class.getName(), id);
                    invoice = (Invoice)result.getEntityList().get(0);
                    
                    if(invoice.isIsGIROFileGeneratedForUOBBank()){
                        invoice.setIsGIROFileGeneratedForUOBBank(false);
                        invoice.setPaymentMethodUsedForUOB(null);
                    } else {
                        invoice.setIsGIROFileGeneratedForUOBBank(true);
                    }
                }
            }
        } catch (Exception ex){
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    /*-----Function is used to Update Lock Quantity related information for DO---------- */
    @Override
     public JSONObject updateLockQuantityCalculation(HashMap<String, Object> requestParams) throws ServiceException {
        
         SalesOrderDetail salesOrderDetail = (SalesOrderDetail) requestParams.get("salesOrderDetail");

         String companyId = (String) requestParams.get("companyId");
         
         boolean isLock = false;
        boolean isbatchlockedinSO = false;
        boolean isSeriallockedinSO = false;
        HashSet<String> productReplacementIds = new HashSet<String>();
        JSONObject jobj = new JSONObject();
        try {

            String sodid = salesOrderDetail.getID();
            double soLockQuantity = salesOrderDetail.getLockquantity();
            double soLockQuantitydue = salesOrderDetail.getLockquantitydue();
            double lockQuantity = 0;
            Product sodProductid = salesOrderDetail.getProduct();  //get the product of salesorderdetail
            if ((authHandler.calculateBaseUOMQuatity(salesOrderDetail.getBalanceqty(), salesOrderDetail.getBaseuomrate(), companyId)) >= soLockQuantity) {  //if delivered quantity is greater than salesorder lock quantity then we have lock quantity only of SO
                lockQuantity = soLockQuantity;
            } else {

                lockQuantity = soLockQuantity - salesOrderDetail.getBalanceqty();  //if delivered quantity is less than lock quantity then we have lock quantity of total lock in so- deliverd

                lockQuantity = soLockQuantity - (authHandler.calculateBaseUOMQuatity(salesOrderDetail.getBalanceqty(), salesOrderDetail.getBaseuomrate(), companyId));  //if delivered quantity is less than lock quantity then we have lock quantity of total lock in so- deliverd

            }
            isLock = accInvoiceDAOobj.getSalesorderStatus(salesOrderDetail.getSalesOrder().getSalesOrderNumber(), companyId);   //get sales order status whether is locked or not
            if (!StringUtil.isNullOrEmpty(sodid)) {
                isbatchlockedinSO = accInvoiceDAOobj.getSalesorderBatchStatus(sodid, companyId);   //get sales order status whether is locked or not
            }
            if (!StringUtil.isNullOrEmpty(sodid)) {
                isSeriallockedinSO = accInvoiceDAOobj.getSalesorderSerialStatus(sodid, companyId);   //get sales order status whether is locked or not
            }
            if (isLock) {
                if (sodProductid.getProducttype().getID().equals(Producttype.ASSEMBLY)) {   //check type of product if assembly type of product is there then update quantity in assemby lock quantity for its sub products
                    KwlReturnObject result2 = accInvoiceDAOobj.getAssemblySubProductList(sodProductid.getID());
                    List list = result2.getEntityList();
                    Iterator itr = list.iterator();
                    while (itr.hasNext()) {
                        Object[] oj = (Object[]) itr.next();
                        String assmblyid = oj[0].toString();
                        accInvoiceDAOobj.updateAssemblyLockQuantity(assmblyid, lockQuantity);  //update the quantity for assbley auantity if its delivered

                    }
                }

                if (soLockQuantity > 0 && lockQuantity <= soLockQuantity) {
                    accInvoiceDAOobj.updateSOLockQuantity(sodid, (authHandler.calculateBaseUOMQuatity(salesOrderDetail.getBalanceqty(), salesOrderDetail.getBaseuomrate(), companyId)), companyId);  //updte salesorder lock  quntity for all type of products
                }
                if (soLockQuantitydue > 0 && lockQuantity <= soLockQuantitydue) {
                    accCommonTablesDAO.updateSOLockQuantitydue(sodid, (authHandler.calculateBaseUOMQuatity(salesOrderDetail.getBalanceqty(), salesOrderDetail.getBaseuomrate(), companyId)), companyId);
                }

            }
            /* Function is being use to update balance quantity of SO, Commented because It was already handled */

            if (salesOrderDetail.getProductReplacementDetail() != null) {
                // update status of Product Replacement request status for each quantity as well as for over all request.
                ProductReplacementDetail productReplacementDetail = salesOrderDetail.getProductReplacementDetail();

                makeProductReplacementIdsSetAndupdateProductReplacementDetails(productReplacementDetail, productReplacementIds, companyId, salesOrderDetail.getBalanceqty());

            } else if (salesOrderDetail.getQuotationDetail() != null && salesOrderDetail.getQuotationDetail().getProductReplacementDetail() != null) {// is so is created by linking with lease quotation and lease quotation is created by linking with product replacement.
                // update status of Product Replacement request status for each quantity as well as for over all request.
                ProductReplacementDetail productReplacementDetail = salesOrderDetail.getQuotationDetail().getProductReplacementDetail();

               makeProductReplacementIdsSetAndupdateProductReplacementDetails(productReplacementDetail, productReplacementIds, companyId, salesOrderDetail.getBalanceqty());
            }
            jobj.put("isLock", isLock);
            jobj.put("isbatchlockedinSO", isbatchlockedinSO);
            jobj.put("isSeriallockedinSO", isLock);

        } catch (ServiceException ex) {
            throw ServiceException.FAILURE("saveInvoiceDetail : " + ex.getMessage(), ex);
        } catch (JSONException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return jobj;
    }
     /**
      * @Desc : Save Stock Out while shipping DO
      * @param requestParams
      * @return
      * @throws ServiceException
      * @throws JSONException
      * @throws ParseException
      * @throws SeqFormatException 
      */
     @Override
     public JSONObject saveStockOutfromDO(Map requestParams) throws ServiceException, JSONException, ParseException, SeqFormatException, AccountingException {
        JSONObject jSONObject = new JSONObject();
        String record = "";
        String companyId = "";
        String userId = "";
        String customer = "";
        String productids = "";
        String customfield = "",lineLevelCustomData = "";
        HttpServletRequest request = null;
        String dono = "";
        String seqNo = "";
        String adjustmentReason = "";
        DateFormat df = new SimpleDateFormat(Constants.MMMMdyyyy);
        try {
            if (requestParams.containsKey("stockOutData")) {
                record = (String) requestParams.get("stockOutData");
            }
            if (requestParams.containsKey("request")) {
                request = (HttpServletRequest) requestParams.get("request");
            }
            if (requestParams.containsKey("customer")) {
                customer = (String) requestParams.get("customer");
            }
            if (requestParams.containsKey("companyId")) {
                companyId = (String) requestParams.get("companyId");
            }
            if (requestParams.containsKey("userId")) {
                userId = (String) requestParams.get("userId");
            }
            if (requestParams.containsKey("adjustmentReason")) {
                adjustmentReason = (String) requestParams.get("adjustmentReason");
            }
            if (requestParams.containsKey(Constants.customfield)) {
                customfield = (String) requestParams.get(Constants.customfield);
            }
            if (requestParams.containsKey(Constants.LineLevelCustomData)) {
                lineLevelCustomData = (String) requestParams.get(Constants.LineLevelCustomData);
            }
            KwlReturnObject jeresult = accountingHandlerDAOobj.getObject(Company.class.getName(), companyId);
            Company company = (Company) jeresult.getEntityList().get(0);
            jeresult = accountingHandlerDAOobj.getObject(User.class.getName(), userId);
            User user = (User) jeresult.getEntityList().get(0);
            JSONArray jArr = new JSONArray(record);
            ExtraCompanyPreferences extraCompanyPreferences = null;
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyId);
            extraCompanyPreferences = (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0);
            KwlReturnObject capresult = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyId);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) capresult.getEntityList().get(0);
            String dodid = "";
            SeqFormat seqFormat = null;
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jObj = jArr.optJSONObject(i);
                String deliveryorder = jObj.optString("deliveryorder");
                dodid = jObj.optString("dodid");
                seqFormat = seqService.getDefaultSeqFormat(company, ModuleConst.STOCK_ADJUSTMENT);
                seqNo = seqFormat != null ? seqService.getNextFormatedSeqNumber(seqFormat) : deliveryorder;
                String donumber="";
                //ERM-999 adding Memo to identify Pick Pack generated Stock Out entries
                if (!StringUtil.isNullOrEmpty(dodid)) {
                    KwlReturnObject dodkwl = accountingHandlerDAOobj.getObject(DeliveryOrderDetail.class.getName(), dodid);
                    DeliveryOrderDetail dodetail = (DeliveryOrderDetail) (dodkwl.getEntityList().isEmpty() ? null : dodkwl.getEntityList().get(0));
                    donumber = dodetail != null && !StringUtil.isNullOrEmpty(dodetail.getDeliveryOrder().getDeliveryOrderNumber()) ? dodetail.getDeliveryOrder().getDeliveryOrderNumber() : "";
                }
                String productId = jObj.optString("productid");
                productids += productids + ",";
                String shipdo = jObj.optString("shipdo");
                String storeId = jObj.optString("storeId");
                String uomId = jObj.optString("uomid");
                String memo = jObj.optString("memo");
                String remark = jObj.optString("remark", "");
                String date = jObj.optString("bussinessDate");
                Date bussinessDate = df.parse(date);
                String adjustmentType = jObj.optString("adjustmentType");
                String costCenterId = jObj.optString("costcenter");
                double quantity = jObj.optDouble("quantity", 0);
                double shipqty = jObj.optDouble("shipqty", 0);
                double dquantity = jObj.optDouble("dquantity", 0);
                double baseuomrate = jObj.optDouble("baseuomrate", 1);

                double amount = jObj.optDouble("purchaseprice", 0);
                String reason = jObj.optString("reason");
                Store fromStore = storeService.getStoreById(storeId);
                jeresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productId);
                Product product = (Product) jeresult.getEntityList().get(0);

                jeresult = accountingHandlerDAOobj.getObject(UnitOfMeasure.class.getName(), uomId);
                UnitOfMeasure uom = (UnitOfMeasure) jeresult.getEntityList().get(0);

                jeresult = accountingHandlerDAOobj.getObject(CostCenter.class.getName(), costCenterId);
                CostCenter costCenter = (CostCenter) jeresult.getEntityList().get(0);

                KwlReturnObject kwlObj = accountingHandlerDAOobj.getObject(MasterItem.class.getName(), adjustmentReason);
                MasterItem masterItem = (MasterItem) kwlObj.getEntityList().get(0);

                StockAdjustment stockAdjustment = new StockAdjustment(product, fromStore, uom, quantity*baseuomrate, amount, bussinessDate);
                stockAdjustment.setTransactionNo(seqNo);
                stockAdjustment.setRemark(remark);
                stockAdjustment.setCostCenter(costCenter);
                stockAdjustment.setAdjustmentType(!StringUtil.isNullOrEmpty(adjustmentType) ? adjustmentType : null);
                stockAdjustment.setReason(reason);
//                            stockAdjustment.setChallanno(challanno);
                stockAdjustment.setFinalQuantity(0);
//              stockAdjustment.setMemo(memo); //ERM-999 Custom Memo to identify Pick Pack generated SA entries 
                stockAdjustment.setMemo((StringUtil.isNullOrEmpty(donumber) ? (Constants.pickPack_DO_SA_Memo) : (Constants.pickPack_DO_SA_Memo + donumber)));
                stockAdjustment.setStockAdjustmentReason(adjustmentReason);
                
                // Create Journal Entry Number for wastage case
                double totalFinalQuantity = 0;
                JournalEntry inventoryJE = null;

                Set<StockAdjustmentDetail> adjustmentDetailSet = new HashSet<StockAdjustmentDetail>();
                JSONArray stockDetails = jObj.optJSONArray("stockDetails");
                for (int x = 0; x < stockDetails.length(); x++) {
                    JSONObject detailObj = stockDetails.optJSONObject(x);
                    String locationId = detailObj.optString("locationId");
                    String rowId = detailObj.optString("rowId");
                    String rackId = detailObj.optString("rackId");
                    String binId = detailObj.optString("binId");
                    String batchName = detailObj.optString("batchName");
                    String serialNames = detailObj.optString("serialNames");
                    String skuFields = detailObj.optString("skuFields");
                    String approvalSerials = detailObj.optString("approvalSerials");
                    double qty = detailObj.optDouble("quantity");
                    String mfgdate = detailObj.optString("mfgdate");
                    String expdate = detailObj.optString("expdate");
                    String warrantyexpfromdate = detailObj.optString("warrantyexpfromdate");
                    String warrantyexptodate = detailObj.optString("warrantyexptodate");

                    Location location = locationService.getLocation(locationId);
                    StoreMaster row = null;
                    if (product.isIsrowforproduct()) {
                        row = storeService.getStoreMaster(rowId);
                    }
                    StoreMaster rack = null;
                    if (product.isIsrackforproduct()) {
                        rack = storeService.getStoreMaster(rackId);
                    }
                    StoreMaster bin = null;
                    if (product.isIsbinforproduct()) {
                        bin = storeService.getStoreMaster(binId);
                    }
                    if (StringUtil.isNullOrEmpty(warrantyexpfromdate) || warrantyexpfromdate.split(",").length == 0) {
                        warrantyexpfromdate = expdate;
                    }
                    if (StringUtil.isNullOrEmpty(warrantyexptodate) || warrantyexptodate.split(",").length == 0) {
                        warrantyexptodate = expdate;
                    }

                    if (quantity > 0 && (product.isIsSerialForProduct() || product.isIsBatchForProduct()) && (!StringUtil.isNullOrEmpty(expdate) && expdate.split(",").length > 0) && (!StringUtil.isNullOrEmpty(warrantyexpfromdate)) && !StringUtil.isNullOrEmpty(warrantyexptodate) || (!StringUtil.isNullOrEmpty(skuFields))) {
                        Map<String, Object> tempTablMap = new HashMap<String, Object>();
                        tempTablMap.put("serials", serialNames);
                        tempTablMap.put("mfgdate", mfgdate);
                        tempTablMap.put("expdate", expdate);
                        tempTablMap.put("warrantyexpfromdate", warrantyexpfromdate);
                        tempTablMap.put("warrantyexptodate", warrantyexptodate);
                        tempTablMap.put("skufields", skuFields);

                        stockAdjustmentService.saveSADetailInTemporaryTable(product, fromStore, location, batchName, tempTablMap);
//                                stockAdjustmentService.saveSADetailInTemporaryTable(product, fromStore, location, batchName, serialNames, mfgdate, expdate, warrantyexpfromdate, warrantyexptodate, skuFields);
                    }
                    String finalSerialNames = serialNames;
                    double finalQuantity = qty;
                    if (product.isIsSerialForProduct()) {
                        if (!StringUtil.isNullOrEmpty(approvalSerials)) {
                            String[] adjSerialArr = serialNames.split(",");
                            String[] approvalSerialArr = approvalSerials.split(",");
                            Set<String> adjSerialSet = new HashSet<String>(Arrays.asList(adjSerialArr));
                            Set<String> approvalSerialSet = new HashSet<String>(Arrays.asList(approvalSerialArr));
                            adjSerialSet.removeAll(approvalSerialSet);
                            finalSerialNames = "";
                            for (String serial : adjSerialSet) {
                                if (StringUtil.isNullOrEmpty(finalSerialNames)) {
                                    finalSerialNames = serial;
                                } else {
                                    finalSerialNames += "," + serial;
                                }
                            }
                            finalQuantity = adjSerialSet.size();

                        }
                        totalFinalQuantity += finalQuantity;
                    } else {
                        finalQuantity = 0;
                        totalFinalQuantity = 0;
                        finalSerialNames = null;
                    }

                    StockAdjustmentDetail sad = new StockAdjustmentDetail();
                    sad.setStockAdjustment(stockAdjustment);
                    sad.setLocation(location);
                    sad.setRow(row);
                    sad.setRack(rack);
                    sad.setBin(bin);

                    sad.setBatchName(batchName);
                    sad.setSerialNames(serialNames);
                    sad.setFinalSerialNames(finalSerialNames);
                    sad.setQuantity(-qty);
                    sad.setFinalQuantity(-finalQuantity);
                    adjustmentDetailSet.add(sad);

                }
                stockAdjustment.setFinalQuantity(totalFinalQuantity*baseuomrate);
                stockAdjustment.setStockAdjustmentDetail(adjustmentDetailSet);
                if (product.getInventoryAccount() != null && !StringUtil.isNullOrEmpty(adjustmentType) && (adjustmentType.equalsIgnoreCase("Stock Sales") || adjustmentType.equalsIgnoreCase("Stock Out") || adjustmentType.equalsIgnoreCase("Stock In")) && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) {
                    // Create Journal Entry Number for MRP module
                    String oldjeid = "";
                    String jeentryNumber = "";
                    String jeIntegerPart = "";
                    String jeDatePrefix = "";
                    String jeDateAfterPrefix = "";
                    String jeDateSuffix = "";
                    String jeSeqFormatId = "";
                    boolean jeautogenflag = false;
                    if (StringUtil.isNullOrEmpty(oldjeid)) {
                        synchronized (this) {
                            Map<String, Object> JEFormatParams = new HashMap<>();
                            JEFormatParams.put("moduleid", Constants.Acc_GENERAL_LEDGER_ModuleId);
                            JEFormatParams.put("modulename", CompanyPreferencesConstants.AUTOJOURNALENTRY);
                            JEFormatParams.put("companyid", companyId);
                            JEFormatParams.put("isdefaultFormat", true);
                            kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
                            SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
                            Map<String, Object> seqNumberMap = new HashMap<String, Object>();
                            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyId, StaticValues.AUTONUM_JOURNALENTRY, format.getID(), false, bussinessDate);
                            jeentryNumber = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
                            jeIntegerPart = (String) seqNumberMap.get(Constants.SEQNUMBER);//integer Part
                            jeDatePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
                            jeDateAfterPrefix = (String) seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
                            jeDateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part
                            jeSeqFormatId = format.getID();
                            jeautogenflag = true;
                        }
                    }
                    Map<String, Object> jeDataMap = AccountingManager.getGlobalParams(request);
                    jeDataMap.put("entrynumber", jeentryNumber);
                    jeDataMap.put("autogenerated", jeautogenflag);
                    jeDataMap.put(Constants.SEQFORMAT, jeSeqFormatId);
                    jeDataMap.put(Constants.SEQNUMBER, jeIntegerPart);
                    jeDataMap.put(Constants.DATEPREFIX, jeDatePrefix);
                    jeDataMap.put(Constants.DATEAFTERPREFIX, jeDateAfterPrefix);
                    jeDataMap.put(Constants.DATESUFFIX, jeDateSuffix);
                    jeDataMap.put("entrydate", bussinessDate);
                    jeDataMap.put("companyid", companyId);
                    jeDataMap.put("memo", "Stock Adjustment JE for " + product.getName());
                    jeDataMap.put("createdby", sessionHandlerImpl.getUserid(request));
                    jeDataMap.put("currencyid", sessionHandlerImpl.getCurrencyID(request));
                    jeDataMap.put("transactionModuleid", Constants.Inventory_Stock_Adjustment_ModuleId);
                    jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap); // Create Journal entry without JEdetails
                    inventoryJE = (JournalEntry) jeresult.getEntityList().get(0);
                    stockAdjustment.setInventoryJE(inventoryJE);
                    HashSet jeDetails = new HashSet();
                    JSONObject jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put("companyid", companyId);
                    if (adjustmentType.equalsIgnoreCase("Stock Sales") || adjustmentType.equalsIgnoreCase("Stock Out")) { // Downward Direction-Stock OUT
                        jedjson.put("amount", authHandler.round(((quantity * amount) * (-1)), Constants.AMOUNT_DIGIT_AFTER_DECIMAL));
                    } else {
                        jedjson.put("amount", authHandler.round(quantity * amount, Constants.AMOUNT_DIGIT_AFTER_DECIMAL));
                    }
                    if (adjustmentType.equalsIgnoreCase("Stock Sales") || adjustmentType.equalsIgnoreCase("Stock Out")) {// Upward Direction-Stock IN
                        jedjson.put("debit", false);
                    } else {
                        jedjson.put("debit", true);
                    }
                    jedjson.put("accountid", product.getInventoryAccount().getID());
                    jedjson.put("jeid", inventoryJE.getID());
                    KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put("companyid", companyId);
                    if (adjustmentType.equalsIgnoreCase("Stock Sales") || adjustmentType.equalsIgnoreCase("Stock Out")) { // Downward Direction-Stock OUT
                        jedjson.put("amount", authHandler.round(((quantity * amount) * (-1)), Constants.AMOUNT_DIGIT_AFTER_DECIMAL));
                    } else {
                        jedjson.put("amount", authHandler.round(quantity * amount, Constants.AMOUNT_DIGIT_AFTER_DECIMAL));
                    }
                    /**
                     *For Pick Pack Ship DO the JE entry after Shipping should have COGS account instead of SA account as it is a system generated Stock out.
                     */
                    if (extraCompanyPreferences.isPickpackship() && product.getCostOfGoodsSoldAccount()!=null) {
                        jedjson.put("accountid", product.getCostOfGoodsSoldAccount().getID());
                    } else {
                        jedjson.put("accountid", product.getStockAdjustmentAccount().getID());
                    }
                    if (adjustmentType.equalsIgnoreCase("Stock Sales") || adjustmentType.equalsIgnoreCase("Stock Out")) { // Downward Direction-Stock OUT
                        jedjson.put("debit", true);
                    } else {
                        jedjson.put("debit", false);
                    }
                    jedjson.put("jeid", inventoryJE.getID());
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    inventoryJE.setDetails(jeDetails);
                    accJournalEntryobj.saveJournalEntryDetailsSet(jeDetails);
                }
//                            if (!StringUtil.isNullOrEmpty(qApproval)) {
//                                sendForQAApproval = Boolean.parseBoolean(qApproval);
//                            }

//                            if (sendForQAApproval) {
//                                if ((StringUtil.isNullOrEmpty(extraCompanyPreferences.getInspectionStore()) && StringUtil.isNullOrEmpty(extraCompanyPreferences.getRepairStore()))) {
//                                    throw new InventoryException(InventoryException.Type.NULL, "QA Store and Repair Store are not set in Company Preferences.");
//                                } else if ((StringUtil.isNullOrEmpty(extraCompanyPreferences.getInspectionStore()))) {
//                                    throw new InventoryException(InventoryException.Type.NULL, "QA Store is not set in Company Preferences.");
//                                } else if (StringUtil.isNullOrEmpty(extraCompanyPreferences.getRepairStore())) {
//                                    throw new InventoryException(InventoryException.Type.NULL, "Repair Store is not set in Company Preferences.");
//                                }
//                            }
                HashMap<String, Object> requestparams = new HashMap<>();
//                            requestparams.put("locale", RequestContextUtils.getLocale(request));
//                            requestparams.put(Constants.LineLevelCustomData, linelevelcustomdata);
                requestparams.put("customer", customer);
                requestparams.put(Constants.LineLevelCustomData, lineLevelCustomData);
                stockAdjustmentService.requestStockAdjustment(user, stockAdjustment, false, false, customfield, requestparams);
                jSONObject.put("stockoutid", stockAdjustment.getId());
                jSONObject.put("dodid", dodid);
                if (inventoryJE != null) {
                    inventoryJE.setTransactionId(stockAdjustment.getId());
                }

                /**
                 * Update DOIST mapping
                 */
                Map<String, Object> map = new HashMap();
                map.put("dod", dodid);
                /** ERP-33533 :The code for DODISTMapping is based on handling without uomrate hence changing the SA Final Quantity again without uom conversion
                 *  as the conversion is later handled in further functions packing and shipping.
                 */
                if (baseuomrate != 1) {
                    stockAdjustment.setQuantity(quantity);
                }
                map.put("stockadjustment", stockAdjustment);
//            /**
//             * get DOIST mapping id
//             */
//            List list=accInvoiceDAOobj.getDOISTMapping(map);
//            if(list!=null && list.get(0)!=null){
//                map.put("id", (String)list.get(0));
                istService.saveDODISTMapping(map);
//                seqService.updateSeqNumber(seqFormat);
//            }
                /**
                 * Save Shipping Delivery Details
                 */
                map.put("actualqty", dquantity);
                map.put("shipqty", shipqty);
                map.put("productid", productId);
                map.put("companyid", companyId);
                map.put("shipdo", shipdo);
                map.put("stockadjustmentid", stockAdjustment.getId());
                KwlReturnObject doresult = accInvoiceDAOobj.saveShippingDeliveryOrderDetails(map);
            }
            jSONObject.put("productids", productids);
            jSONObject.put("seqFormat", seqFormat);
        } catch(SeqFormatException ex){
           throw new AccountingException(messageSource.getMessage("acc.field.AddSASequenceFormat", null, RequestContextUtils.getLocale(request)));
        }catch (Exception ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        }
        return jSONObject;
    }
     
              
         /*--------------  Function to save custom/Dimension field of Invoice from DO backend--------*/

    public void saveCustomFieldsForInvoice(HashMap<String, Object> requestParams) throws ServiceException, AccountingException {
        JSONObject obj = new JSONObject();

    try{
            String companyid = (String) requestParams.get("companyid");
            String journalEntryId = (String) requestParams.get("journalEntryId");
            DeliveryOrder deliveryOrder = (DeliveryOrder) requestParams.get("deliveryOrder");
              HashMap<String, Object> jeDataMap = (HashMap<String, Object>) requestParams.get("jeDataMap");
            /* Getting Sales Order Custom/Dimension field*/
            Map<String, Object> variableMap = new HashMap<String, Object>();
            DeliveryOrderCustomData deliveryOrderCustomData = (DeliveryOrderCustomData) deliveryOrder.getDeliveryOrderCustomData();

            HashMap<String, String> replaceFieldMap = new HashMap<String, String>();
            HashMap<String, String> customFieldMap = new HashMap<String, String>();
            HashMap<String, String> customDateFieldMap = new HashMap<String, String>();
            HashMap<String, Object> fieldrequestParams = new HashMap();
            fieldrequestParams.put(Constants.filter_names, Arrays.asList(Constants.companyid, Constants.moduleid));
            fieldrequestParams.put(Constants.filter_values, Arrays.asList(companyid, Constants.Acc_Delivery_Order_ModuleId));
            HashMap<String, Integer> fieldMap = accAccountDAOobj.getFieldParamsCustomMap(fieldrequestParams, replaceFieldMap, customFieldMap, customDateFieldMap);

            if (deliveryOrderCustomData != null) {
                AccountingManager.setCustomColumnValues(deliveryOrderCustomData, fieldMap, replaceFieldMap, variableMap);
                boolean isExport = false;
                JSONObject params = new JSONObject();
                params.put(Constants.companyKey, companyid);
                params.put(Constants.isExport, isExport);
                params.put(Constants.isdefaultHeaderMap, false);

                params.put(Constants.browsertz, "");

                fieldDataManagercntrl.addCustomData(variableMap, customFieldMap, customDateFieldMap, obj, params);
            }

            /* Written a function to fetch custom field from fieldparams against fieldlabel
             where moduleid will be invoice  
                          
             */
            HashMap requestParams1 = new HashMap();
            JSONArray jcustomarray = new JSONArray();
            JSONObject jsonObject = new JSONObject();
            Iterator ite = obj.keys();
            String fieldLabel = "";
            String fieldValue = "";

            requestParams1.put(Constants.filter_names, Arrays.asList(Constants.Acc_custom_field, Constants.companyid, Constants.moduleid));
            FieldParams fieldParams = null;
            while (ite.hasNext()) {
                fieldLabel = (String) ite.next();
                fieldValue = obj.getString(fieldLabel);

                requestParams1.put(Constants.filter_values, Arrays.asList(fieldLabel, companyid, Constants.Acc_Invoice_ModuleId));

                /* Fetching custom/dimension field "field Label" wise */
                List result1 = accAccountDAOobj.getFieldParamsFieldLabelWise(requestParams1); // get custom field module wise from fieldlabel
                if (result1 != null && result1.size() > 0) {

                    fieldParams = (FieldParams) result1.get(0);

                    jsonObject.put("fieldid", fieldParams.getId());

                    /* If multiselect drop down then fetching actual value instead of id */
                    if (fieldParams.getFieldtype() == Constants.MULTISELECTCOMBO || fieldParams.getFieldtype() == Constants.FIELDSET) {

                        HashMap<String, Object> fieldParamsMap = new HashMap<String, Object>();
                        fieldParamsMap.put("companyid", companyid);
                        fieldParamsMap.put("moduleid", Constants.Acc_Delivery_Order_ModuleId);
                        fieldParamsMap.put("filedname", fieldLabel);
                        String multiSelectId = fieldManagerDAOobj.getFieldParamsId(fieldParamsMap);
                        fieldValue = fieldManagerDAOobj.getParamsValue(multiSelectId, fieldValue);
                    }

                    jsonObject.put("xtype", fieldParams.getFieldtype());
                    jsonObject.put("fieldname", fieldParams.getFieldname());
                    jsonObject.put(fieldParams.getFieldname(), "Col" + fieldParams.getColnum());
                    jsonObject.put("refcolumn_name", "Col" + fieldParams.getRefcolnum());

                    if (fieldParams.getFieldtype() == Constants.SINGLESELECTCOMBO || fieldParams.getFieldtype() == Constants.MULTISELECTCOMBO || fieldParams.getFieldtype() == Constants.FIELDSET) {
                        String ids = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), fieldValue);     // get ids for module using values and field id  
                        fieldValue = ids;

                    }
                    jsonObject.put("Col" + fieldParams.getColnum(), fieldValue);
                    jsonObject.put("fieldDataVal", fieldValue);

                    jcustomarray.put(jsonObject);
                }

                /* Saving Custom field for invoice module */
                HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
               
                customrequestParams.put("customarray", jcustomarray);
                customrequestParams.put("modulename", Constants.Acc_JE_modulename);
                customrequestParams.put("moduleprimarykey", Constants.Acc_JEid);
                customrequestParams.put("modulerecid", journalEntryId);
                customrequestParams.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
                customrequestParams.put(Constants.companyKey, companyid);
                customrequestParams.put("customdataclasspath", Constants.Acc_BillInv_custom_data_classpath);
                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                    jeDataMap.put("accjecustomdataref", journalEntryId);
                    accJournalEntryobj.saveJournalEntry(jeDataMap);
                }

            }
        } catch (JSONException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } catch (ServiceException ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    
    
    /* Fetching Term details for Delivery Order */
    public JSONArray getTermDetailsForDeliveryOrder(String id) throws ServiceException {
        JSONArray jArr = new JSONArray();
        try {
            HashMap<String, Object> requestParam = new HashMap();

            requestParam.put("deliveryOrderID", id);
            KwlReturnObject curresult = accInvoiceDAOobj.getDOTermMap(requestParam);

            List<DeliveryOrderTermMap> termMap = curresult.getEntityList();
            for (DeliveryOrderTermMap deliveryOrderTermMap : termMap) {
                InvoiceTermsSales mt = deliveryOrderTermMap.getTerm();
                JSONObject jsonobj = new JSONObject();
                jsonobj.put("id", mt.getId());
                jsonobj.put("term", mt.getTerm());
                jsonobj.put("glaccount", mt.getAccount().getID());
                jsonobj.put("sign", mt.getSign());
                jsonobj.put("formula", mt.getFormula());
                jsonobj.put("termpercentage", deliveryOrderTermMap.getPercentage());
                jsonobj.put("termamount", deliveryOrderTermMap.getTermamount());
                jArr.put(jsonobj);
            }

        } catch (JSONException ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        }
        return jArr;
    }
     
     
    /**
     * @desc : Update DO Status by checking qty
     * @param map
     * @throws ServiceException
     */
    public void setDOStatus(Map<String, Object> map) throws ServiceException {
        if (map.containsKey("dodid")) {
            String dodid = (String) map.get("dodid");
            boolean isship = true;
            KwlReturnObject custresult = accountingHandlerDAOobj.getObject(DeliveryOrderDetail.class.getName(), dodid);
            DeliveryOrderDetail orderDetail = (DeliveryOrderDetail) custresult.getEntityList().get(0);
            DeliveryOrder deliveryOrder = orderDetail.getDeliveryOrder();
            Set<DeliveryOrderDetail> deliveryOrderDetails = deliveryOrder.getRows();
            for (DeliveryOrderDetail deliveryOrderDetail : deliveryOrderDetails) {
                if (deliveryOrderDetail.getProduct() != null && (deliveryOrderDetail.getProduct().getProducttype().getID().equals(Constants.SERVICE) || deliveryOrderDetail.getProduct().getProducttype().getID().equals(Constants.NON_INVENTORY_PART))) {
                    continue;
                }
                double shipqty = 0d;
                double delqty = deliveryOrderDetail.getDeliveredQuantity();
                map.clear();
                map.put("dodid", deliveryOrderDetail.getID());
                KwlReturnObject kwlReturnObject = accInvoiceDAOobj.getShippingQty(map);
                List<DeliveryDetailInterStoreLocationMapping> deliveryDetailInterStoreLocationMappings = kwlReturnObject.getEntityList();
                for (DeliveryDetailInterStoreLocationMapping deliveryDetailInterStoreLocationMapping : deliveryDetailInterStoreLocationMappings) {
                    shipqty = shipqty + deliveryDetailInterStoreLocationMapping.getShippedQty();
                }
                if (Math.abs(delqty+shipqty)>0.0000) {
                    isship = false;
                    break;
                }

            }
            /**
             * If isShip = true then update status
             */
            if (isship) {
                map.put("deliveryOrder", deliveryOrder);
                map.put("companyid", deliveryOrder.getCompany().getCompanyID());
                Map<String, Object> paramMap = new HashMap<>();
                List<Packing> packingObjects = new ArrayList();
                for (DeliveryOrderDetail deliveryOrderDetail : deliveryOrderDetails) {
                    paramMap.put("dodetailid", deliveryOrderDetail);
                    /**
                     * Single DO Detail can have multiple Packing Objects
                     */
                    List<Packing> tempPackingObjects = kwlCommonTablesDAOObj.getRequestedObjectFieldsInCollection(PackingDetail.class, new String[]{"packing"}, paramMap);
                    packingObjects.addAll(tempPackingObjects);
                }
                /**
                 * packingObjects will contain Null, if DO is Shipped Directly.
                 */
                if (packingObjects != null) {
                    map.put(Constants.packRecord, packingObjects);
                }
                accInvoiceDAOobj.updateDeliveryOrderStatus(map);
            }
        }

    }
  
  @Override  
  @Transactional(propagation = Propagation.REQUIRED, rollbackFor = {ServiceException.class, SessionExpiredException.class, JSONException.class, AccountingException.class})
     public JSONObject  deleteTemporaryDeliveryOrders(JSONObject paramJobj) {
        JSONObject jobj = new JSONObject();
        String msg = "";
        boolean issuccess = false;
        boolean isConsignment = false;
        boolean isFixedAsset = false;
        boolean isMultiGroupCompanyFlag = false;
        boolean isCallFromSourceDomainFlag = false;//flag to recognize when po is deleted so will be deleted

      if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isMultiGroupCompanyFlag, null))) {
          isMultiGroupCompanyFlag = Boolean.parseBoolean(paramJobj.optString(Constants.isMultiGroupCompanyFlag));
          if (isMultiGroupCompanyFlag) {
              if (paramJobj.has("sourceTransactionId") && !StringUtil.isNullOrEmpty(paramJobj.optString("sourceTransactionId", null))) {
                  isCallFromSourceDomainFlag = true;
              }

              if (!isCallFromSourceDomainFlag) {
                  StringBuilder billidsBuilder = new StringBuilder();
                  try {
                      JSONArray jArr = new JSONArray(paramJobj.optString(Constants.RES_data));
                      for (int i = 0; i < jArr.length(); i++) {
                          JSONObject jo = jArr.getJSONObject(i);
                          billidsBuilder.append(jo.optString(Constants.billid) + ",");
                      }
                      String billids = billidsBuilder.toString().substring(0, billidsBuilder.toString().length() - 1);
                      JSONObject returnJObj = checklinkingofTransactions(paramJobj, billids);
                      isCallFromSourceDomainFlag = returnJObj.optBoolean(Constants.RES_success);
                      if (!isCallFromSourceDomainFlag) {
                          msg = messageSource.getMessage("acc.multiGroupDOCannotDeleteOperation", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));
                      }
                  } catch (JSONException ex) {
                      msg = ex.getMessage();
                      Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
                  }
              }
          }
      }
      List list = new ArrayList();
      StringBuffer productIds = new StringBuffer();
        try {
            //IF MULTIgroupCompany is not activated or if multigroupflag is activated and is call to delete grn
            if ((!isMultiGroupCompanyFlag) || (isCallFromSourceDomainFlag)) {
                if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment, null))) {
                    isConsignment = Boolean.parseBoolean(paramJobj.optString(Constants.isConsignment));
                }
                if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isFixedAsset, null))) {
                    isFixedAsset = Boolean.parseBoolean(paramJobj.optString(Constants.isFixedAsset));
                }

                String linkedTransaction = "";
                list = deleteDeliveryOrders(paramJobj);
                if (list != null && !list.isEmpty()) {
                    linkedTransaction = (String) list.get(0);
                }
                issuccess = true;
                if (StringUtil.isNullOrEmpty(linkedTransaction)) {
                    if (isConsignment) {
                        msg = messageSource.getMessage("acc.consignment.DO.del", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                    } else if (isFixedAsset) {
                        msg = messageSource.getMessage("acc.do.asset.del", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Asset Delivery Order has been deleted successfully";
                    } else {
                        msg = messageSource.getMessage("acc.do.del", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                    }
                } else {
                    if (isConsignment) {
                        msg = messageSource.getMessage("acc.consignment.DO.del", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                    } else {
                        msg = messageSource.getMessage("acc.field.DeliveryOrdersexcept", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))) + " " + linkedTransaction.substring(0, linkedTransaction.length() - 2) + " " + messageSource.getMessage("acc.field.hasbeendeletedsuccessfully", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                    }
                }

                if (list != null && list.size() > 0) {
                    productIds = (StringBuffer) list.get(1);
                }
            }
        } catch (Exception ex) {
            msg = "" + ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
                jobj.put("productIds", productIds);
            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return jobj;
    }  
  
    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = {ServiceException.class, SessionExpiredException.class, JSONException.class, AccountingException.class})
     public List deleteDeliveryOrders(JSONObject requestJobj) throws SessionExpiredException, AccountingException, ServiceException {
        String linkedTransaction = "";
        List resultList = new ArrayList();
        StringBuffer productIds = new StringBuffer();
        try {
            JSONArray jArr = new JSONArray(requestJobj.optString(Constants.RES_data));
            String companyid = requestJobj.optString(Constants.companyKey);
            KwlReturnObject capresult = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) capresult.getEntityList().get(0);
            KwlReturnObject extraresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extraresult.getEntityList().get(0);
            boolean isLeaseFixedAsset = false;

            if (!StringUtil.isNullOrEmpty(requestJobj.optString(Constants.isLeaseFixedAsset))) {
                isLeaseFixedAsset = Boolean.parseBoolean(requestJobj.optString(Constants.isLeaseFixedAsset));
            }

            JSONArray crmJsonArray = new JSONArray();
            HashSet<String> productReplacementIds = new HashSet<String>();

            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jobj = jArr.getJSONObject(i);
                if (!StringUtil.isNullOrEmpty(jobj.getString(Constants.billid))) {
                    List list = deleteDeliveryOrder(jobj, linkedTransaction, preferences, extraCompanyPreferences, productIds, requestJobj, productReplacementIds);
                    linkedTransaction = (String) list.get(0);
                    productIds = (StringBuffer) list.get(1);
                }
            }
            if (isLeaseFixedAsset) {
                if (!productReplacementIds.isEmpty()) {
                    createCRMJsonArrayForUpdatingCloseStatus(productReplacementIds, crmJsonArray, companyid);
                    if (crmJsonArray != null && crmJsonArray.length() > 0) {
                        sendRequestToCRMForUpdatingProductReplacementStatus(requestJobj, crmJsonArray);
                    }
                }
            }
            resultList.add(0, linkedTransaction);
            resultList.add(1, productIds);
        } catch (InventoryException ex) {
            throw new AccountingException(messageSource.getMessage("acc.common.excp1", null, Locale.forLanguageTag(requestJobj.optString(Constants.language))));
        } catch (JSONException ex) {
            throw new AccountingException(messageSource.getMessage("acc.common.excp1", null, Locale.forLanguageTag(requestJobj.optString(Constants.language))));
        }
        return resultList;
    }  
    
  @Override  
    public JSONObject deleteDeliveryOrdersJSON(JSONObject paramJobj) {
        JSONObject jobj = new JSONObject();
        String msg = "";
        boolean issuccess = false;
        boolean isConsignment = false;
        boolean isFixedAsset = false;
        boolean isMultiGroupCompanyFlag = false;
        boolean isCallFromSourceDomainFlag = false;//flag to recognize when po is deleted so will be deleted

      if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isMultiGroupCompanyFlag, null))) {
          isMultiGroupCompanyFlag = Boolean.parseBoolean(paramJobj.optString(Constants.isMultiGroupCompanyFlag));
          if (isMultiGroupCompanyFlag) {
              if (paramJobj.has("sourceTransactionId") && !StringUtil.isNullOrEmpty(paramJobj.optString("sourceTransactionId", null))) {
                  isCallFromSourceDomainFlag = true;
              }

              if (!isCallFromSourceDomainFlag) {
                  StringBuilder billidsBuilder = new StringBuilder();
                  try {
                      JSONArray jArr = new JSONArray(paramJobj.optString(Constants.RES_data));
                      for (int i = 0; i < jArr.length(); i++) {
                          JSONObject jo = jArr.getJSONObject(i);
                          billidsBuilder.append(jo.optString(Constants.billid) + ",");
                      }
                      String billids = billidsBuilder.toString().substring(0, billidsBuilder.toString().length() - 1);
                      JSONObject returnJObj = checklinkingofTransactions(paramJobj, billids);
                      isCallFromSourceDomainFlag = returnJObj.optBoolean(Constants.RES_success);
                      if (!isCallFromSourceDomainFlag) {
                          msg = messageSource.getMessage("acc.multiGroupDOCannotDeleteOperation", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));
                      }
                  } catch (JSONException ex) {
                      msg = ex.getMessage();
                      Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
                  }
              }
          }
      }

      List list = new ArrayList();
      StringBuffer productIds = new StringBuffer();
       try {
          //IF MULTIgroupCompany is not activated or if multigroupflag is activated and is call to delete grn
          if ((!isMultiGroupCompanyFlag) || (isCallFromSourceDomainFlag)) {

              if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment, null))) {
                  isConsignment = Boolean.parseBoolean(paramJobj.optString(Constants.isConsignment));
              }
              if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isFixedAsset, null))) {
                  isFixedAsset = Boolean.parseBoolean(paramJobj.optString(Constants.isFixedAsset));
              }

              String linkedTransaction = "";
              list = deleteDeliveryOrdersPermanent(paramJobj);
              if (list != null && !list.isEmpty()) {
                  linkedTransaction = (String) list.get(0);
              }
              issuccess = true;
              if (StringUtil.isNullOrEmpty(linkedTransaction)) {
                  if (isConsignment) {
                      msg = messageSource.getMessage("acc.consignment.DO.del", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                  } else if (isFixedAsset) {
                      msg = messageSource.getMessage("acc.do.asset.delp", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                  } else {
                      msg = messageSource.getMessage("acc.do.delp", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                  }
              } else {
                  if (isConsignment) {
                      msg = messageSource.getMessage("acc.consignment.DeliveryOrdersexcept", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))) + " " + linkedTransaction.substring(0, linkedTransaction.length() - 2) + " " + messageSource.getMessage("acc.field.hasbeendeletedsuccessfully", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                  } else {
                      msg = messageSource.getMessage("acc.field.DeliveryOrdersexcept", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))) + " " + linkedTransaction.substring(0, linkedTransaction.length() - 2) + " " + messageSource.getMessage("acc.field.hasbeendeletedsuccessfully", null, Locale.forLanguageTag(paramJobj.optString(Constants.language)));   //"Delivery Order has been deleted successfully";
                  }
              }
              if (list != null && list.size() > 0) {
                  productIds = (StringBuffer) list.get(1);
              }
          }
            
        } catch (JSONException ex) {
            msg = ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (AccountingException ex) {
            msg = ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (SessionExpiredException ex) {
            msg = ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            msg = "" + ex.getMessage();
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                jobj.put(Constants.RES_success, issuccess);
                jobj.put(Constants.RES_msg, msg);
                jobj.put("productIds", productIds);
            } catch (JSONException ex) {
                Logger.getLogger(accInvoiceController.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return jobj;
    }
    
  @Override  
    public List deleteDeliveryOrdersPermanent(JSONObject paramJobj) throws SessionExpiredException, AccountingException, ServiceException, JSONException {
        String linkedTransaction = "";
        List resultList = new ArrayList();
        StringBuffer productIds = new StringBuffer();
        try {
            JSONArray jArr = new JSONArray(paramJobj.optString(Constants.RES_data));
            String companyid = paramJobj.optString(Constants.companyKey);
            KwlReturnObject capresult = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) capresult.getEntityList().get(0);
            ExtraCompanyPreferences extraCompanyPreferences = null;
            KwlReturnObject extraprefresult = accountingHandlerDAOobj.getObject(ExtraCompanyPreferences.class.getName(), companyid);
            extraCompanyPreferences = extraprefresult != null ? (ExtraCompanyPreferences) extraprefresult.getEntityList().get(0) : null;

            /*
             * getting status for separate deletion of normal DO and DO with
             * pick,pack and ship
             */
            JSONObject statusobj;
            String status = "";
            if (jArr != null && jArr.length() > 0) {
                statusobj = jArr.getJSONObject(0);
                status = statusobj.optString(Constants.status);
            }
            boolean isLeaseFixedAsset = false;

            if (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isLeaseFixedAsset))) {
                isLeaseFixedAsset = Boolean.parseBoolean(paramJobj.optString(Constants.isLeaseFixedAsset));
            }

            JSONArray crmJsonArray = new JSONArray();
            HashSet<String> productReplacementIds = new HashSet<String>();

            String doid = "";
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jobj = jArr.getJSONObject(i);
                doid = StringUtil.DecodeText(jobj.optString(Constants.billid));
                List list = deleteDeliveryOrderPermanent(jobj, linkedTransaction, preferences, extraCompanyPreferences, status, productIds, paramJobj);
                if (isLeaseFixedAsset) {
                    makeProductReplacementIdsSetForUpdatingStatusOFProductReplacementRequest(productReplacementIds, doid, companyid);
                }
                linkedTransaction = (String) list.get(0);
                productIds = (StringBuffer) list.get(1);
            }
            if (isLeaseFixedAsset) {
                if (!productReplacementIds.isEmpty()) {
                    createCRMJsonArrayForUpdatingCloseStatus(productReplacementIds, crmJsonArray, companyid);
                    if (crmJsonArray != null && crmJsonArray.length() > 0) {
                        sendRequestToCRMForUpdatingProductReplacementStatus(paramJobj, crmJsonArray);
                    }
                }
            }
            resultList.add(0, linkedTransaction);
            resultList.add(1, productIds);
        } catch (InventoryException ex) {
            throw new AccountingException(messageSource.getMessage("acc.common.excp1", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))));
        } catch (JSONException ex) {
            throw new AccountingException(messageSource.getMessage("acc.common.excp1", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))));
        }
        return resultList;
    }

    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = {ServiceException.class, SessionExpiredException.class, JSONException.class, AccountingException.class})
    public List deleteDeliveryOrder(JSONObject jobj, String linkedTransaction, CompanyAccountPreferences preferences, ExtraCompanyPreferences extraCompanyPreferences, StringBuffer productIds, JSONObject requestJobj, HashSet<String> productReplacementIds) throws ServiceException, AccountingException, JSONException, SessionExpiredException {
        List resultList = new ArrayList();

        String companyid = requestJobj.optString(Constants.companyKey);
        boolean isConsignment = !StringUtil.isNullOrEmpty(requestJobj.optString(Constants.isConsignment)) ? Boolean.parseBoolean(requestJobj.optString(Constants.isConsignment)) : false;
        boolean isFixedAsset = !StringUtil.isNullOrEmpty(requestJobj.optString(Constants.isFixedAsset)) ? Boolean.parseBoolean(requestJobj.optString(Constants.isFixedAsset)) : false;
        boolean isLeaseFixedAsset = !StringUtil.isNullOrEmpty(requestJobj.optString(Constants.isLeaseFixedAsset)) ? Boolean.parseBoolean(requestJobj.optString(Constants.isLeaseFixedAsset)) : false;
        boolean isBatchSerial = preferences.isShowprodserial();
        boolean isnegativestockforlocwar = extraCompanyPreferences.isIsnegativestockforlocwar();
        String modulename = "";
        if (isConsignment) {
            modulename = " " + messageSource.getMessage("acc.Consignment.DO", null, Locale.forLanguageTag(requestJobj.optString(Constants.language))) + " ";
        } else if (isFixedAsset) {
            modulename = " " + messageSource.getMessage("acc.fixedAssetDeliveryOrder", null, Locale.forLanguageTag(requestJobj.optString(Constants.language))) + " ";
        } else {
            modulename = " " + messageSource.getMessage("acc.dimension.module.13", null, Locale.forLanguageTag(requestJobj.optString(Constants.language))) + " ";
        }

        String doid = StringUtil.DecodeText(jobj.optString(Constants.billid));
        String dono = StringUtil.DecodeText(jobj.getString(Constants.billno));
        KwlReturnObject result = accInvoiceDAOobj.getDOFromSR(doid, companyid);
        List list = result.getEntityList();
        if (!list.isEmpty()) {
//                        throw new AccountingException("Selected record(s) is currently used in the Sales Return(s). So it cannot be deleted.");
            linkedTransaction += dono + ", ";
            resultList.add(0, linkedTransaction);
            resultList.add(1, productIds);
            return resultList;
        }
        KwlReturnObject result1 = accInvoiceDAOobj.getDOFromInv(doid, companyid);
        List list1 = result1.getEntityList();
        if (!list1.isEmpty()) {
//                        throw new AccountingException("Selected record(s) is currently used in the Invoices(s). So it cannot be deleted.");
            linkedTransaction += dono + ", ";
            resultList.add(0, linkedTransaction);
            resultList.add(1, productIds);
            return resultList;
        }

        // check the pushed DO in Delivery Planner
        result = accInvoiceDAOobj.getDeliveryOrderFromDeliveryPlanner(doid, companyid);
        list = result.getEntityList();
        if (!list.isEmpty()) {
            linkedTransaction += dono + ", ";
            resultList.add(0, linkedTransaction);
            resultList.add(1, productIds);
            return resultList;
        }
        if (extraCompanyPreferences != null && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) { // delete JE temporary
            KwlReturnObject productsUsed = accInvoiceDAOobj.getProductsFromDeliveryOrderOrder(doid, companyid);
            if (productsUsed != null && productsUsed.getEntityList() != null && !productsUsed.getEntityList().isEmpty()) {
                List productList = productsUsed.getEntityList();
                if (productList != null && !productList.isEmpty()) {
                    for (Object object : productList) {
                        String productid = (String) object;
                        if (productIds.indexOf(productid) == -1) {
                            productIds.append(productid).append(",");
                        }
                    }
                }
            }
        }
        if (isLeaseFixedAsset) {
            makeProductReplacementIdsSetForUpdatingStatusOFProductReplacementRequest(productReplacementIds, doid, companyid);
        }

        KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);

        HashMap<String, Object> requestParams = new HashMap<String, Object>();
        requestParams.put("doid", doid);
        requestParams.put(Constants.companyKey, companyid);
        requestParams.put("dono", dono);
        requestParams.put(Constants.isFixedAsset, isFixedAsset);
        requestParams.put(Constants.isBatchSerial, isBatchSerial);
        requestParams.put(Constants.isLeaseFixedAsset, isLeaseFixedAsset);
        requestParams.put(Constants.isConsignment, isConsignment);
        requestParams.put("isnegativestockforlocwar", isnegativestockforlocwar);
        if (isFixedAsset || isLeaseFixedAsset) {
            accInvoiceDAOobj.deleteAssetDetailsLinkedWithDeliveryOrder(requestParams);
            if (isLeaseFixedAsset) {
                deleteDOContractMappings(doid, companyid);
            }
        }
        // update the salesorder order balance quantity
        
//        accInvoiceDAOobj.updateSOBalanceQtyAfterDO(doid, "", companyid);
        //ERP-40816:SDP-15767Line item unable to load when create invoice
        accInvoiceDAOobj.updateSOBalanceQtyAfterDOAfterDelete(doid, "", companyid);
        
        DeliveryOrder dOrders = (DeliveryOrder) rdresult.getEntityList().get(0);
        Set<DeliveryOrderDetail> doDetails = dOrders.getRows();
        Iterator it = doDetails.iterator();
        StringBuilder sodids = new StringBuilder();
        while (it.hasNext()) {
            DeliveryOrderDetail dodObj = (DeliveryOrderDetail) it.next();
            JSONObject json = new JSONObject();
            json.put("dodetailid", dodObj.getID());
//            if(!StringUtil.isNullObject(dodObj) && !StringUtil.isNullObject(dodObj.getSodetails())){  //ERP-38788
//                SalesOrderDetail sod = (SalesOrderDetail) dodObj.getSodetails();
//                if(sod!=null){
//                  sod.setLockquantity(0);  
//                  sod.getSalesOrder().setLockquantityflag(false);    
//                }                
//                sodids.append("'" + dodObj.getSodetails().getID() + "'" + ",");   
//            }else if(!StringUtil.isNullObject(dodObj) && !StringUtil.isNullObject(dodObj.getCidetails()) && !StringUtil.isNullObject(dodObj.getCidetails().getSalesorderdetail())){
//                SalesOrderDetail sod = (SalesOrderDetail) dodObj.getCidetails().getSalesorderdetail();
//                if(sod!=null){
//                  sod.setLockquantity(0);  
//                  sod.getSalesOrder().setLockquantityflag(false);    
//                }
//                sodids.append("'" + dodObj.getCidetails().getSalesorderdetail().getID() + "'" + ",");
//            }               
            KwlReturnObject kwlReturnObject = stockService.getDODetailISTMapping(json);
            List<DODQCISTMapping> dodISTMappings = kwlReturnObject.getEntityList();
            for (DODQCISTMapping dodqcistm : dodISTMappings) {
                /**
                 * Don't allow user to edit Delivery Order, if DO is
                 * approved/rejected from QC store.
                 */
                if (dodqcistm.getApprovedStockOuts() != null && !dodqcistm.getApprovedStockOuts().isEmpty()) {
                    throw new AccountingException(messageSource.getMessage("acc.deliveryOrder.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"delete", dOrders.getDeliveryOrderNumber(), "approved"}, Locale.forLanguageTag(requestJobj.optString(Constants.language))));
                }
                if (dodqcistm.getRejectedDODQCISTMappings() != null && !dodqcistm.getRejectedDODQCISTMappings().isEmpty()) {
                    throw new AccountingException(messageSource.getMessage("acc.goodsreceiptnote.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"delete", dOrders.getDeliveryOrderNumber(), "rejected"}, Locale.forLanguageTag(requestJobj.optString(Constants.language))));
                }
                if (dodqcistm.getPickedMapping() != null && !dodqcistm.getPickedMapping().isEmpty()) {
                    throw new AccountingException(messageSource.getMessage("acc.goodsreceiptnote.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"delete", dOrders.getDeliveryOrderNumber(), "picked"}, Locale.forLanguageTag(requestJobj.optString(Constants.language))));
                }
                if (dodqcistm.getQcInterStoreTransferRequest() != null) {
                    if (dodqcistm.getQcInterStoreTransferRequest().getStatus() != InterStoreTransferStatus.INTRANSIT) {
                        throw new AccountingException(messageSource.getMessage("acc.deliveryOrder.cannot.be.deleted.as.stockisaccepted.byQAstore", new Object[]{"delete", dOrders.getDeliveryOrderNumber()}, Locale.forLanguageTag(requestJobj.optString(Constants.language))));
                    } else {
                        istService.deleteISTRequest(dodqcistm.getQcInterStoreTransferRequest());
                    }
                }
            }
            accProductObj.deleteInventoryEntry(dodObj.getID(), companyid);
        }
        
        /* 
         Create JSON object to put required params used to below function
         */
        JSONObject paramJobj = new JSONObject();
        paramJobj.put(Constants.companyKey, requestJobj.optString(Constants.companyKey));
        paramJobj.put("isEdit", requestJobj.optString("isEdit"));
        paramJobj.put(Constants.userfullname, requestJobj.optString(Constants.userfullname));
        deleteExistingAutoBuildAssemblyEntriesOfDO(paramJobj, doid);

//            query = "update SalesOrder set deleted=true where ID in("+qMarks +") and company.companyID=?";
//            HibernateUtil.executeUpdate(session, query, params.toArray());
        if (extraCompanyPreferences != null && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) { // delete JE temporary
            if (dOrders != null && dOrders.getInventoryJE() != null) {
                result = accJournalEntryobj.deleteJournalEntry(dOrders.getInventoryJE().getID(), companyid);
            }
        }
        /*
         * Delete Free Gift JE if any
         */
        if (dOrders.isIsFreeGift() && dOrders.getFreeGiftJE() != null) {
            result = accJournalEntryobj.deleteJournalEntry(dOrders.getFreeGiftJE().getID(), companyid);
        }
//         if(!StringUtil.isNullOrEmpty(sodids.toString())){    //ERP-38788
//                String SOdids = sodids.substring(0, sodids.length() - 1).toString();
//                accInvoiceDAOobj.deleteSalesOrderSerialDetails(SOdids,companyid);
//        } 
        accInvoiceDAOobj.deleteDeliveryOrder(doid, companyid);
              
        if (preferences.isInventoryAccountingIntegration() && preferences.isWithInvUpdate()) {

            String action = "17";
            boolean isDirectUpdateInvFlag = false;
            if (preferences.isUpdateInvLevel()) {
                isDirectUpdateInvFlag = true;
                action = "19";//Direct Inventory Update action
            }

            JSONArray productArray = new JSONArray();

            KwlReturnObject res = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);
            DeliveryOrder DeliveryOrder = (DeliveryOrder) res.getEntityList().get(0);

            Set<DeliveryOrderDetail> deliveryOrderDetails = DeliveryOrder.getRows();
            for (DeliveryOrderDetail deliveryOrderDetail : deliveryOrderDetails) {
                JSONObject productObject = new JSONObject();
                productObject.put("itemUomId", deliveryOrderDetail.getInventory().getUom().getID());
                productObject.put("itemBaseUomRate", deliveryOrderDetail.getInventory().getBaseuomrate());
                productObject.put("itemQuantity", deliveryOrderDetail.getInventory().getBaseuomquantity());
                productObject.put(Constants.quantity, deliveryOrderDetail.getInventory().getQuantity());
                //productObject.put("itemQuantity", deliveryOrderDetail.getInventory().getQuantity());
                productObject.put("itemCode", deliveryOrderDetail.getInventory().getProduct().getProductid());
                if (isDirectUpdateInvFlag) {
                    productObject.put("storeid", deliveryOrderDetail.getInvstoreid());
                    productObject.put("locationid", deliveryOrderDetail.getInvlocid());
                }
                productArray.put(productObject);
            }
            if (productArray.length() > 0) {

                String sendDateFormat = Constants.yyyyMMdd;
                DateFormat dateformat = new SimpleDateFormat(sendDateFormat);
                Date date = DeliveryOrder.getOrderDate();
                String stringDate = dateformat.format(date);

                JSONObject jSONObject = new JSONObject();
                jSONObject.put("deliveryDate", stringDate);
                jSONObject.put("dateFormat", sendDateFormat);
                jSONObject.put("details", productArray);
                jSONObject.put("orderNumber", DeliveryOrder.getDeliveryOrderNumber());
                jSONObject.put("companyId", companyid);
                jSONObject.put("selling", true);

                ServletContext servletContext = (ServletContext) requestJobj.get("servletContext");
                String url = servletContext.getInitParameter("inventoryURL");
                CommonFnController cfc = new CommonFnController();
                cfc.updateInventoryLevel(requestJobj, jSONObject, url, action);
            }
        }
        stockMovementService.removeStockMovementByReferenceId(dOrders.getCompany(), dOrders.getID());
        accInvoiceDAOobj.deleteDeliveryOrdersBatchSerialDetails(requestParams);

        Map<String, Object> auditParamsMap = new HashMap();
        auditParamsMap.put(Constants.companyKey, requestJobj.optString(Constants.companyKey));
        auditParamsMap.put(Constants.useridKey, requestJobj.optString(Constants.useridKey));
        auditParamsMap.put(Constants.remoteIPAddress, requestJobj.optString(Constants.remoteIPAddress));
        auditParamsMap.put(Constants.reqHeader, requestJobj.optString(Constants.reqHeader));
        auditTrailObj.insertAuditLog(AuditAction.DELIVERY_ORDER, "User " + requestJobj.optString(Constants.userfullname) + " has deleted" + (isLeaseFixedAsset ? " a Lease " : "") + modulename + dono, auditParamsMap, doid);

        resultList.add(0, linkedTransaction);
        resultList.add(1, productIds);
        return resultList;
    }
    
    @Transactional(propagation = Propagation.REQUIRED, rollbackFor = {ServiceException.class, SessionExpiredException.class, JSONException.class, AccountingException.class})
    public List deleteDeliveryOrderPermanent(JSONObject jobj, String linkedTransaction, CompanyAccountPreferences preferences, ExtraCompanyPreferences extraCompanyPreferences, String status, StringBuffer productIds, JSONObject paramJobj) throws ServiceException, AccountingException, JSONException, SessionExpiredException {
        List resultList = new ArrayList();
        String doid = !StringUtil.isNullOrEmpty(jobj.optString(Constants.billid)) ? StringUtil.DecodeText(jobj.optString(Constants.billid)) : "";
        String dono = !StringUtil.isNullOrEmpty(jobj.optString(Constants.billno)) ? StringUtil.DecodeText(jobj.optString(Constants.billno)) : "";
        String companyid = paramJobj.optString(Constants.companyKey);
        boolean isConsignment = !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment)) ? Boolean.parseBoolean(paramJobj.optString(Constants.isConsignment)) : false;
        boolean isFixedAsset = !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isFixedAsset)) ? Boolean.parseBoolean(paramJobj.optString(Constants.isFixedAsset)) : false;
        boolean isLeaseFixedAsset = !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isLeaseFixedAsset)) ? Boolean.parseBoolean(paramJobj.optString(Constants.isLeaseFixedAsset)) : false;
        boolean auditcheck = !StringUtil.isNullOrEmpty(paramJobj.optString(Constants.auditcheck)) ? Boolean.parseBoolean(paramJobj.optString(Constants.auditcheck)) : true;
        boolean isBatchSerial = preferences.isShowprodserial();
        boolean isnegativestockforlocwar = extraCompanyPreferences.isIsnegativestockforlocwar();

        String modulename = "";
        if (isConsignment) {
            modulename = " " + messageSource.getMessage("acc.Consignment.DO", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))) + " ";
        } else if (isFixedAsset) {
            modulename = " " + messageSource.getMessage("acc.fixedAssetDeliveryOrder", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))) + " ";
        } else {
            modulename = " " + messageSource.getMessage("acc.dimension.module.13", null, Locale.forLanguageTag(paramJobj.optString(Constants.language))) + " ";
        }

        if (!StringUtil.isNullOrEmpty(doid)) {
            KwlReturnObject result = accInvoiceDAOobj.getDOFromSR(doid, companyid);
            List list = result.getEntityList();
            if (!list.isEmpty()) {
//                        throw new AccountingException("Selected record(s) is currently used in the Sales Return(s). So it cannot be deleted.");
                linkedTransaction += dono + ", ";
                resultList.add(0, linkedTransaction);
                resultList.add(1, productIds);
                return resultList;
            }
            KwlReturnObject result1 = accInvoiceDAOobj.getDOFromInv(doid, companyid);
            List list1 = result1.getEntityList();
            if (!list1.isEmpty()) {
//                        throw new AccountingException("Selected record(s) is currently used in the Invoices(s). So it cannot be deleted.");
                linkedTransaction += dono + ", ";
                resultList.add(0, linkedTransaction);
                resultList.add(1, productIds);
                return resultList;
            }
            if (isConsignment) {
                KwlReturnObject result2 = accInvoiceDAOobj.getSerialNoUsedinConsignmentInvoiceFromDO(doid, companyid);
                List list2 = result2.getEntityList();
                if (!list2.isEmpty()) {
                    linkedTransaction += dono + ", ";
                    resultList.add(0, linkedTransaction);
                    resultList.add(1, productIds);
                    return resultList;
//                            throw new AccountingException("Selected record(s) is currently used in the Some Transaction(s). So it cannot be edited.");
                }
                KwlReturnObject result3 = accInvoiceDAOobj.getbatchNoUsedinConsignmentInvoiceFromDO(doid, companyid);
                List list3 = result3.getEntityList();
                if (!list3.isEmpty()) {
                    linkedTransaction += dono + ", ";
                    resultList.add(0, linkedTransaction);
                    resultList.add(1, productIds);
                    return resultList;
//                            throw new AccountingException("Selected record(s) is currently used in the Some Transaction(s). So it cannot be edited.");
                }
            }

            // check the pushed DO in Delivery Planner
            result = accInvoiceDAOobj.getDeliveryOrderFromDeliveryPlanner(doid, companyid);
            list = result.getEntityList();
            if (!list.isEmpty()) {
                linkedTransaction += dono + ", ";
                resultList.add(0, linkedTransaction);
                resultList.add(1, productIds);
                return resultList;
            }
        }
        boolean isdeleted = !StringUtil.isNullOrEmpty(jobj.optString(Constants.deleted)) ? Boolean.parseBoolean(jobj.optString(Constants.deleted)) : false;
        // update the salesorder order balance quantity
        if(!isdeleted){
             //ERP-40816:SDP-15767Line item unable to load when create invoice
//        accInvoiceDAOobj.updateSOBalanceQtyAfterDO(doid, "", companyid);
        accInvoiceDAOobj.updateSOBalanceQtyAfterDOAfterDelete(doid, "", companyid);
        }
        KwlReturnObject res = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doid);
        DeliveryOrder DeliveryOrder = (DeliveryOrder) res.getEntityList().get(0);
        if (extraCompanyPreferences != null && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) { // delete JE temporary
            KwlReturnObject result = accInvoiceDAOobj.getProductsFromDeliveryOrderOrder(doid, companyid);
            if (result != null && result.getEntityList() != null && !result.getEntityList().isEmpty()) {
                List productList = result.getEntityList();
                if (productList != null && !productList.isEmpty()) {
                    for (Object object : productList) {
                        String productid = (String) object;
                        if (productIds.indexOf(productid) == -1) {
                            productIds.append(productid).append(",");
                        }
                    }
                }
            }
        }
        HashMap<String, Object> doRequestParams = new HashMap<String, Object>();
        ArrayList filter_names = new ArrayList(), filter_params = new ArrayList();
        filter_names.add("deliveryOrder.ID");
        filter_params.add(DeliveryOrder.getID());
        doRequestParams.put("filter_names", filter_names);
        doRequestParams.put("filter_params", filter_params);
        StringBuilder sodids = new StringBuilder();
        KwlReturnObject podresult = accInvoiceDAOobj.getDeliveryOrderDetails(doRequestParams);
        Iterator itr = podresult.getEntityList().iterator();
        while (itr.hasNext()) {
            DeliveryOrderDetail row = (DeliveryOrderDetail) itr.next();
            JSONObject json = new JSONObject();
            json.put("dodetailid", row.getID());
//            if(!StringUtil.isNullObject(row) && !StringUtil.isNullObject(row.getSodetails())){    //ERP-38788
//            SalesOrderDetail sod =row.getSodetails();
//            if(!StringUtil.isNullObject(sod)){
//               sod.setLockquantity(0); 
//               sod.getSalesOrder().setLockquantityflag(false);    
//            }            
//            sodids.append("'"+row.getSodetails().getID()+"'"+",");
//            }else if(!StringUtil.isNullObject(row.getCidetails()) && !StringUtil.isNullObject(row.getCidetails().getSalesorderdetail())){
//                SalesOrderDetail sod = (SalesOrderDetail) row.getCidetails().getSalesorderdetail();
//                if(!StringUtil.isNullObject(sod)){
//                    sod.setLockquantity(0);
//                    sod.getSalesOrder().setLockquantityflag(false);
//                }
//                sodids.append("'" + row.getCidetails().getSalesorderdetail().getID() + "'" + ",");
//            }
            KwlReturnObject kwlReturnObject = stockService.getDODetailISTMapping(json);
            List<DODQCISTMapping> dodISTMappings = kwlReturnObject.getEntityList();
            for (DODQCISTMapping dodqcistm : dodISTMappings) {
                /**
                 * Don't allow user to edit Delivery Order, if DO is
                 * approved/rejected from QC store.
                 */
                if (dodqcistm.getApprovedStockOuts() != null && !dodqcistm.getApprovedStockOuts().isEmpty()) {
                    throw new AccountingException(messageSource.getMessage("acc.deliveryOrder.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"edit", DeliveryOrder.getDeliveryOrderNumber(), "approved"}, Locale.forLanguageTag(paramJobj.optString(Constants.language))));
                }
                if (dodqcistm.getRejectedDODQCISTMappings() != null && !dodqcistm.getRejectedDODQCISTMappings().isEmpty()) {
                    throw new AccountingException(messageSource.getMessage("acc.goodsreceiptnote.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"edit", DeliveryOrder.getDeliveryOrderNumber(), "rejected"}, Locale.forLanguageTag(paramJobj.optString(Constants.language))));
                }
                if (dodqcistm.getPickedMapping() != null && !dodqcistm.getPickedMapping().isEmpty()) {
                    throw new AccountingException(messageSource.getMessage("acc.goodsreceiptnote.cannot.be.deleted.as.approvedOrRejected.byQAstore", new Object[]{"edit", DeliveryOrder.getDeliveryOrderNumber(), "picked"}, Locale.forLanguageTag(paramJobj.optString(Constants.language))));
                }

                if (dodqcistm.getQcInterStoreTransferRequest() != null) {
                    if (dodqcistm.getQcInterStoreTransferRequest().getStatus() != InterStoreTransferStatus.INTRANSIT) {
                        throw new AccountingException(messageSource.getMessage("acc.deliveryOrder.cannot.be.deleted.as.stockisaccepted.byQAstore", new Object[]{"edit", DeliveryOrder.getDeliveryOrderNumber()}, Locale.forLanguageTag(paramJobj.optString(Constants.language))));
                    } else {
                        istService.deleteISTRequest(dodqcistm.getQcInterStoreTransferRequest());
                    }
                }
            }
            if (row.getSodetails() != null) {
                String linkid = row.getSodetails().getSalesOrder().getID();
                if (!StringUtil.isNullOrEmpty(linkid)) {
                    KwlReturnObject rdresult = accountingHandlerDAOobj.getObject(SalesOrder.class.getName(), linkid);
                    SalesOrder salesOrder = (SalesOrder) rdresult.getEntityList().get(0);
                    HashMap hMap = new HashMap();
                    hMap.put("salesOrder", salesOrder);
                    hMap.put("value", "0");
                    hMap.put("isSOOpen", true);
                    accInvoiceDAOobj.updateSOLinkflag(hMap);
                }
            }
            if (row.getCidetails() != null) {
                Invoice invoice = (Invoice) row.getCidetails().getInvoice();
                if (invoice != null) {
                    HashMap hMap = new HashMap();
                    hMap.put("invoice", invoice);
                    hMap.put("isOpenDO", true);
                    accInvoiceDAOobj.updateInvoiceLinkflag(hMap);
                }
            }
        }
        
        if (extraCompanyPreferences.isAvalaraIntegration()) {
            deleteAvalaraTaxMappingForDO(new HashSet<DeliveryOrderDetail>(podresult.getEntityList()));
        }
        
        if (preferences.isInventoryAccountingIntegration() && preferences.isWithInvUpdate()) {

            String action = "17";
            boolean isDirectUpdateInvFlag = false;
            if (preferences.isUpdateInvLevel()) {
                isDirectUpdateInvFlag = true;
                action = "19";//Direct Inventory Update action
            }

            JSONArray productArray = new JSONArray();
            // DELETE ReceiptOrder Details  Term Map ... (deleteGRODetailsTermMap)

            Set<DeliveryOrderDetail> deliveryOrderDetails = DeliveryOrder.getRows();
            for (DeliveryOrderDetail deliveryOrderDetail : deliveryOrderDetails) {
                JSONObject productObject = new JSONObject();
                productObject.put("itemUomId", deliveryOrderDetail.getInventory().getUom().getID());
                productObject.put("itemBaseUomRate", deliveryOrderDetail.getInventory().getBaseuomrate());
                productObject.put("itemQuantity", deliveryOrderDetail.getInventory().getBaseuomquantity());
                productObject.put(Constants.quantity, deliveryOrderDetail.getInventory().getQuantity());
                //productObject.put("itemQuantity", deliveryOrderDetail.getInventory().getQuantity());
                productObject.put("itemCode", deliveryOrderDetail.getInventory().getProduct().getProductid());
                if (isDirectUpdateInvFlag) {
                    productObject.put("storeid", deliveryOrderDetail.getInvstoreid());
                    productObject.put("locationid", deliveryOrderDetail.getInvlocid());
                }
                productArray.put(productObject);
                /**
                 * DODetailsTermMap is not saved in database when Avalara Integration is enabled
                 * Therefore we delete DODetailsTermMap only when Avalara Integration is disabled
                 */
                if (extraCompanyPreferences.getLineLevelTermFlag() == 1 && !extraCompanyPreferences.isAvalaraIntegration()) {
                    accInvoiceDAOobj.deleteDODetailsTermMap(deliveryOrderDetail.getID());
                }
            }
            if (productArray.length() > 0) {

                String sendDateFormat = Constants.yyyyMMdd;
                DateFormat dateformat = new SimpleDateFormat(sendDateFormat);
                Date date = DeliveryOrder.getOrderDate();
                String stringDate = dateformat.format(date);

                JSONObject jSONObject = new JSONObject();
                jSONObject.put("deliveryDate", stringDate);
                jSONObject.put("dateFormat", sendDateFormat);
                jSONObject.put("details", productArray);
                jSONObject.put("orderNumber", DeliveryOrder.getDeliveryOrderNumber());
                jSONObject.put("companyId", companyid);
                jSONObject.put("selling", true);

                ServletContext servletContext = (ServletContext) paramJobj.get("servletContext");
                String url = servletContext.getInitParameter("inventoryURL");
                CommonFnController cfc = new CommonFnController();
                cfc.updateInventoryLevel(paramJobj, jSONObject, url, action);
            }
        }
        if (!extraCompanyPreferences.isPickpackship()) {
            stockMovementService.removeStockMovementByReferenceId(DeliveryOrder.getCompany(), DeliveryOrder.getID());
        }

        HashMap<String, Object> requestParams = new HashMap<String, Object>();
        requestParams.put("doid", doid);
        requestParams.put("dono", dono);
        requestParams.put(Constants.companyKey, companyid);
        requestParams.put(Constants.isConsignment, isConsignment);
        requestParams.put(Constants.isFixedAsset, isFixedAsset);
        requestParams.put(Constants.isLeaseFixedAsset, isLeaseFixedAsset);
        requestParams.put(Constants.auditcheck, auditcheck);
        requestParams.put(Constants.isBatchSerial, isBatchSerial);
        requestParams.put("isnegativestockforlocwar", isnegativestockforlocwar);
        requestParams.put("isPickPackShipOn", extraCompanyPreferences.isPickpackship());
        requestParams.put(Constants.status, status);
//        if(!StringUtil.isNullOrEmpty(sodids.toString())){   //ERP-38788
//                String SOdids = sodids.substring(0, sodids.length() - 1).toString();
//             //   accInvoiceDAOobj.deleteSalesOrderSerialDetails(SOdids,companyid);
//        }
        accInvoiceDAOobj.deleteDeliveryOrdersBatchSerialDetails(requestParams);
        accInvoiceDAOobj.deleteLinkingInformationOfDO(requestParams);

        Set<DeliveryOrderDetail> orderDetail = DeliveryOrder.getRows();
        for (DeliveryOrderDetail dodetail : orderDetail) {
            if (dodetail.getSodetails() != null) {
                dodetail.getSodetails().setIsLineItemClosed(false);
                dodetail.getSodetails().getSalesOrder().setIsSOClosed(false);
            } else if (dodetail.getCidetails() != null && dodetail.getCidetails().getSalesorderdetail() != null) {
                dodetail.getCidetails().getSalesorderdetail().setIsLineItemClosed(false);
                dodetail.getCidetails().getSalesorderdetail().getSalesOrder().setIsSOClosed(false);
            }
        }

        requestParams.put("isMRPModuleActivated", extraCompanyPreferences.isActivateMRPModule());
        requestParams.put("isPerpetualValuationActivated", (preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD));
        if (extraCompanyPreferences != null && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) {
            if (DeliveryOrder.getInventoryJE() != null) { // delete inventory JE
                JournalEntry inventoryJE = DeliveryOrder.getInventoryJE();
                requestParams.put("inventoryjeid", inventoryJE.getID());
            }
        }
        accInvoiceDAOobj.deleteDeliveryOrdersPermanent(requestParams);
        if (auditcheck) {
            Map<String, Object> map = new HashMap();
            map.put(Constants.companyKey, paramJobj.optString(Constants.companyKey));
            map.put(Constants.useridKey, paramJobj.optString(Constants.useridKey));
            map.put(Constants.remoteIPAddress, paramJobj.optString(Constants.remoteIPAddress));
            map.put(Constants.reqHeader, paramJobj.optString(Constants.reqHeader));
            auditTrailObj.insertAuditLog(AuditAction.DELIVERY_ORDER, "User " + paramJobj.optString(Constants.userfullname) + " has deleted" + (isLeaseFixedAsset ? " a Lease " : "") + modulename + "Permanently " + dono, map, doid);
        }

        resultList.add(0, linkedTransaction);
        resultList.add(1, productIds);
        return resultList;
    }
    
    public void makeProductReplacementIdsSetForUpdatingStatusOFProductReplacementRequest(HashSet<String> productReplacementIds, String doId, String companyid) throws ServiceException, JSONException {
        KwlReturnObject doObj = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), doId);
        DeliveryOrder deliveryOrder = (DeliveryOrder) doObj.getEntityList().get(0);

        Set<DeliveryOrderDetail> deliveryOrderDetails = deliveryOrder.getRows();
        for (DeliveryOrderDetail deliveryOrderDetail : deliveryOrderDetails) {
            ProductReplacementDetail productReplacementDetail = null;
            if (deliveryOrderDetail != null && deliveryOrderDetail.getSodetails() != null && deliveryOrderDetail.getSodetails().getProductReplacementDetail() != null) {
                productReplacementDetail = deliveryOrderDetail.getSodetails().getProductReplacementDetail();

            } else if (deliveryOrderDetail != null && deliveryOrderDetail.getSodetails() != null && deliveryOrderDetail.getSodetails().getQuotationDetail() != null && deliveryOrderDetail.getSodetails().getQuotationDetail().getProductReplacementDetail() != null) {
                productReplacementDetail = deliveryOrderDetail.getSodetails().getQuotationDetail().getProductReplacementDetail();
            }

            if (productReplacementDetail != null) {
                double deliveryOrderQuantity = deliveryOrderDetail.getDeliveredQuantity() * (-1);// need to reduce delivered quantity

                makeProductReplacementIdsSetAndupdateProductReplacementDetails(productReplacementDetail, productReplacementIds, companyid, deliveryOrderQuantity);
            }
        }
    }
        
    /**
     * @param : paramJobj 
     * @Desc : Method create rounding JE after calculating
     * total PI knocked off amount in base and other stuff
     * @throws : JSONException, ServiceException, SessionExpiredException,
     * AccountingException
     * @return : JournalEntry if Rounding JE Created otherwise it returns null
     */
    @Override
    public JournalEntry createRoundingOffJE(JSONObject paramJobj) throws JSONException, ServiceException, SessionExpiredException, AccountingException {
        //Global variable Section
        JournalEntry journalEntry = null;
        DefaultTransactionDefinition def = new DefaultTransactionDefinition();
        def.setName("RJE_Tx");
        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
        TransactionStatus status = null;
        try {
            Invoice invoice = (Invoice) paramJobj.get("salesInvoiceObj");
            Date amountDueDate = invoice.getAmountDueDate();
            String companyid = paramJobj.getString(Constants.companyKey);
            String gcurrenyid = paramJobj.getString(Constants.globalCurrencyKey);
            boolean isEdit = paramJobj.optBoolean("isEdit", false);
            boolean dontCheckYearLock = paramJobj.optBoolean("DontCheckYearLock", false);//When call come from Rounding JE Script,No need to check Year Lock and this flag comes true 
            String invoiceid = invoice.getID();
            String invoiceAccountID = invoice.getAccount() != null ? invoice.getAccount().getID() : invoice.getCustomer().getAccount().getID();
            KwlReturnObject extraPref = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), companyid);
            CompanyAccountPreferences compAccPref = (CompanyAccountPreferences) extraPref.getEntityList().get(0);
            String roundingAccID = compAccPref.getRoundingDifferenceAccount().getID();
            double totalKnockedOffAmtInBase = getInvoiceAmountUtilizedInRPandCN(paramJobj);
            double gramountInBase = invoice.isIsOpeningBalenceInvoice() ? invoice.getOriginalOpeningBalanceBaseAmount() : invoice.getInvoiceamountinbase();
            gramountInBase = authHandler.round(gramountInBase , companyid);
            double amtDiff = authHandler.round((gramountInBase - totalKnockedOffAmtInBase), companyid);
            if (amtDiff != 0 && Math.abs(amtDiff)<=0.05) {//Generating Rounding JE is amtdiff is non zero and it is assumed that rounding JE will not generate more than 0.05
                status = txnManager.getTransaction(def);
                Map<String, Object> jeDataMap = getJournalEntryMapWithEntryNumberDetail(paramJobj, amountDueDate);
                jeDataMap.put("entrydate", amountDueDate);
                jeDataMap.put("companyid", companyid);
                jeDataMap.put("memo", "Rounding Journal Entry for Sales Invoice " + invoice.getInvoiceNumber());
                jeDataMap.put("currencyid", gcurrenyid);
                jeDataMap.put("typevalue", 4);//type Value 4 for Rounding JE
                jeDataMap.put("transactionId", invoiceid);//type Value 4 for Rounding JE
                if (dontCheckYearLock) {
                    jeDataMap.put("DontCheckYearLock", true);
                }
                KwlReturnObject jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Create Journal entry without JEdetails
                journalEntry = (JournalEntry) jeresult.getEntityList().get(0);

                Set<JournalEntryDetail> jeDetails = new HashSet<>();
                JSONObject jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put("companyid", companyid);
                jedjson.put("accountid", (amtDiff < 0) ? roundingAccID : invoiceAccountID);
                jedjson.put("amount", Math.abs(amtDiff));
                jedjson.put("amountinbase", Math.abs(amtDiff));
                jedjson.put("debit", false);
                jedjson.put("jeid", journalEntry.getID());
                KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                JournalEntryDetail jeDetailRoundingAccount = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jeDetailRoundingAccount);

                jedjson = new JSONObject();
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put("companyid", companyid);
                jedjson.put("accountid", (amtDiff < 0) ? invoiceAccountID : roundingAccID);
                jedjson.put("amount", Math.abs(amtDiff));
                jedjson.put("amountinbase", Math.abs(amtDiff));
                jedjson.put("debit", true);
                jedjson.put("jeid", journalEntry.getID());
                jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                JournalEntryDetail jeDetailGRAccount = (JournalEntryDetail) jedresult.getEntityList().get(0);
                jeDetails.add(jeDetailGRAccount);

                jeDataMap.put("jeid", journalEntry.getID());
                jeDataMap.put("jedetails", jeDetails);
                jeresult = accJournalEntryobj.saveJournalEntry(jeDataMap);//Add Journal entry details
                journalEntry = (JournalEntry) jeresult.getEntityList().get(0);
                txnManager.commit(status);
            } else if (isEdit) {//In Edit case of MP and DN if PI amount due becomes zero and there is no rounding difference Now then we need to delete existing Rounding JE
                status = txnManager.getTransaction(def);
                KwlReturnObject jeResult = accJournalEntryobj.getRoundingJournalEntryByGRIds(invoice.getID(), companyid);
                List<JournalEntry> jeList = jeResult.getEntityList();
                for (JournalEntry roundingJE : jeList) {
                    KwlReturnObject jedResult = accJournalEntryobj.getJournalEntryDetail(roundingJE.getID(), companyid);
                    List<JournalEntryDetail> jedList = jedResult.getEntityList();
                    for (JournalEntryDetail jed : jedList) {
                        accJournalEntryobj.deleteJournalEntryDetailRow(jed.getID(), companyid);
                    }
                    accJournalEntryobj.permanentDeleteJournalEntry(roundingJE.getID(), companyid);
                }
                txnManager.commit(status);
            }
        } catch (Exception ex) {
            txnManager.rollback(status);
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw new AccountingException(ex.getMessage(), ex);
        }
        return journalEntry;
    }

    /**
     * @param : paramJobj 
     * @Desc : This method used to calculate total amount of
     * PI in base used in Payment and DN
     * @throws : JSONException, ServiceException, SessionExpiredException
     * @return : GR utilized Amount in base
     */
    @Override
    public double getInvoiceAmountUtilizedInRPandCN(JSONObject paramJobj) throws JSONException, ServiceException, SessionExpiredException {
        Map<String, Object> requestMap = AccountingManager.getGlobalParamsJson(paramJobj);
        String companyid = paramJobj.getString(Constants.companyKey);
        String gcurrenyid = paramJobj.getString(Constants.globalCurrencyKey);
        Invoice invoice = (Invoice) paramJobj.get("salesInvoiceObj");
        String invid = invoice.getID();
        double grExternalCurrencyRate = 0d;
        Date grCreationDate = null;
        String grCurrencyID = invoice.getCurrency() != null ? invoice.getCurrency().getCurrencyID() : gcurrenyid;
        grCreationDate = invoice.getCreationDate();
        if (invoice.isIsOpeningBalenceInvoice() && !invoice.isNormalInvoice()) {
            grExternalCurrencyRate = invoice.getExchangeRateForOpeningTransaction();
        } else {
//            grCreationDate = invoice.getJournalEntry().getEntryDate();
//            grExternalCurrencyRate = invoice.getJournalEntry().getExternalCurrencyRate();

            //code to avoid Lazy Initialization Error while executing PostRoundingJE Script
            KwlReturnObject result = accInvoiceDAOobj.getExternalCurrencyRateForInvoice(invid, companyid);
            if (result != null && result.getEntityList() != null && !result.getEntityList().isEmpty() && result.getEntityList().get(0) != null) {
                grExternalCurrencyRate = (Double) result.getEntityList().get(0);
            }
        }
        //#1.Receipt with SI, information saved in ReceiptDetail 
        double totalKnockedOffAmtInBase = 0;
        KwlReturnObject result = accInvoiceDAOobj.getReceiptDetailsOfSI(invid);
        if (result != null && result.getEntityList() != null && !result.getEntityList().isEmpty() && result.getEntityList().get(0) != null) {
            totalKnockedOffAmtInBase += (Double) result.getEntityList().get(0);
        }

        //#2.Case when Invoice linked in opening/advance receipt, information saved in LinkedReceiptDetails
        result = accInvoiceDAOobj.getLinkedReceiptDetailsOfSI(invid);
        if (result != null && result.getEntityList() != null && !result.getEntityList().isEmpty() && result.getEntityList().get(0) != null) {
            List list = result.getEntityList();
            for (int i = 0; i < list.size(); i++) {
                Object[] details = (Object[]) list.get(i);
                double enteredamount = (Double) details[0];
                double forexjeamountinbase = (Double) details[1];
                double reciptexchangerate = (Double) details[2];
                int isopeningbalencereceipt = (Integer) details[3];
                int isconversionratefromcurrencytobase = (Integer) details[4];
                boolean isdebit = false;
                if (details.length >= 5 && details[5] != null) {
                    isdebit = Boolean.parseBoolean(details[5].toString());
                }

                double enteredAmtInBase = 0;
                if (isopeningbalencereceipt == 1 && isconversionratefromcurrencytobase == 1) {//Opening Receipt
                    enteredAmtInBase = authHandler.round((enteredamount * reciptexchangerate), companyid);
                } else {
                    enteredAmtInBase = authHandler.round((enteredamount / reciptexchangerate), companyid);
                }

                if (isdebit) { //Adjust Frx Amount According to Debit or Credit
                    totalKnockedOffAmtInBase += authHandler.round(enteredAmtInBase + forexjeamountinbase, companyid);
                } else {
                    totalKnockedOffAmtInBase += authHandler.round(enteredAmtInBase - forexjeamountinbase, companyid);
                }

            }
        }

        //#3.DN with PI, linked Opening/otherwise DN SI, information saved in CreditNoteDetails
        result = accInvoiceDAOobj.getLinkedCreditNoteDetailsOfSI(invid);
        if (result != null && result.getEntityList() != null && !result.getEntityList().isEmpty() && result.getEntityList().get(0) != null) {
            List list = result.getEntityList();
            for (int i = 0; i < list.size(); i++) {
                Object[] details = (Object[]) list.get(i);
                double enteredamount = (Double) details[0];
                double forexjeamountinbase = (Double) details[1];
                double cnchangerate = (Double) details[2];
                int isopeningbalencecn = (Integer) details[3];
                int isconversionratefromcurrencytobase = (Integer) details[4];
                boolean isdebit = false;
                if (details.length >= 5 && details[5] != null) {
                    isdebit = Boolean.parseBoolean(details[5].toString());
                }

                double enteredAmtInBase = 0;
                if (isopeningbalencecn == 1 && isconversionratefromcurrencytobase == 1) {//Opening Receipt
                    enteredAmtInBase = authHandler.round((enteredamount * cnchangerate), companyid);
                } else {
                    enteredAmtInBase = authHandler.round((enteredamount / cnchangerate), companyid);
                }
                if (isdebit) { //Adjust Frx Amount According to Debit or Credit
                    totalKnockedOffAmtInBase += authHandler.round(enteredAmtInBase + forexjeamountinbase, companyid);
                } else {
                    totalKnockedOffAmtInBase += authHandler.round(enteredAmtInBase - forexjeamountinbase, companyid);
                }
            }
        }
        return totalKnockedOffAmtInBase;
    }

    /**
     * @param : paramJobj,jeEntryDate = It is JE creation Date @Desc : This
     * method used get JE Number Details like SEQFORMAT, SEQNUMBER etc
     * @throws : JSONException, ServiceException, SessionExpiredException,
     * AccountingException
     * @return : Map<String, Object> having JE number info
     */
    public Map<String, Object> getJournalEntryMapWithEntryNumberDetail(JSONObject paramJobj, Date jeEntryDate) throws JSONException, ServiceException, SessionExpiredException, AccountingException {
        Map<String, Object> jeDataMap = AccountingManager.getGlobalParamsJson(paramJobj);
        boolean isEdit = paramJobj.optBoolean("isEdit", false);
        String companyid = paramJobj.getString(Constants.companyKey);
        JournalEntry roundingJE = null;
        if (isEdit) {//In Edit case of Rounding JE we need to preserve number and delete existing rounding JE
            Invoice invoice = (Invoice) paramJobj.get("salesInvoiceObj");
            if (invoice != null) {
                KwlReturnObject jeResult = accJournalEntryobj.getRoundingJournalEntryByGRIds(invoice.getID(), companyid);
                if (jeResult != null && !jeResult.getEntityList().isEmpty() && jeResult.getEntityList().get(0) != null) {
                    roundingJE = (JournalEntry) jeResult.getEntityList().get(0);
                }
            }
        }

        if (roundingJE != null) {
            jeDataMap.put("entrynumber", roundingJE.getEntryNumber());
            jeDataMap.put("autogenerated", roundingJE.isAutoGenerated());
            jeDataMap.put(Constants.SEQFORMAT, roundingJE.getSeqformat().getID());
            jeDataMap.put(Constants.SEQNUMBER, roundingJE.getSeqnumber());
            jeDataMap.put(Constants.DATEPREFIX, roundingJE.getDatePreffixValue());
            jeDataMap.put(Constants.DATEAFTERPREFIX, roundingJE.getDateAfterPreffixValue());
            jeDataMap.put(Constants.DATESUFFIX, roundingJE.getDateSuffixValue());

            //Delete rounding JE
            KwlReturnObject jedResult = accJournalEntryobj.getJournalEntryDetail(roundingJE.getID(), companyid);
            List<JournalEntryDetail> jedList = jedResult.getEntityList();
            for (JournalEntryDetail jed : jedList) {
                accJournalEntryobj.deleteJournalEntryDetailRow(jed.getID(), companyid);
            }
            accJournalEntryobj.permanentDeleteJournalEntry(roundingJE.getID(), companyid);
        } else {
            HashMap<String, Object> JEFormatParams = new HashMap();
            JEFormatParams.put("moduleid", Constants.Acc_GENERAL_LEDGER_ModuleId);
            JEFormatParams.put("modulename", "autojournalentry");
            JEFormatParams.put("companyid", companyid);
            JEFormatParams.put("isdefaultFormat", true);

            KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
            SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);
            Map<String, Object> seqNumberMap = new HashMap();
            seqNumberMap = accCompanyPreferencesObj.getNextAutoNumber_Modified(companyid, StaticValues.AUTONUM_JOURNALENTRY, format.getID(), false, jeEntryDate);

            String jeentryNumber = (String) seqNumberMap.get(Constants.AUTO_ENTRYNUMBER);  //next auto generated number
            int jeIntegerPart = Integer.parseInt((String) seqNumberMap.get(Constants.SEQNUMBER));
            String jeDatePrefix = (String) seqNumberMap.get(Constants.DATEPREFIX);//Date Prefix Part
            String jeDateAfterPrefix = (String) seqNumberMap.get(Constants.DATEAFTERPREFIX);  //Date After Prefix Part
            String jeDateSuffix = (String) seqNumberMap.get(Constants.DATESUFFIX);//Date Suffix Part

            jeDataMap.put("entrynumber", jeentryNumber);
            jeDataMap.put("autogenerated", true);
            jeDataMap.put(Constants.SEQFORMAT, format.getID());
            jeDataMap.put(Constants.SEQNUMBER, jeIntegerPart);
            jeDataMap.put(Constants.DATEPREFIX, jeDatePrefix);
            jeDataMap.put(Constants.DATEAFTERPREFIX, jeDateAfterPrefix);
            jeDataMap.put(Constants.DATESUFFIX, jeDateSuffix);
        }
        return jeDataMap;
    }

    private void saveLinelevelCustomFieldData(JSONObject jobj, Map param, JSONObject paramJobj) throws Exception {

        boolean isFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isFixedAsset", null))) ? Boolean.parseBoolean(paramJobj.optString("isFixedAsset")) : false;
        boolean isConsignment = (!StringUtil.isNullOrEmpty(paramJobj.optString(Constants.isConsignment, null))) ? Boolean.parseBoolean(paramJobj.optString(Constants.isConsignment)) : false;
        boolean isLeaseFixedAsset = (!StringUtil.isNullOrEmpty(paramJobj.optString("isLeaseFixedAsset", null))) ? Boolean.parseBoolean(paramJobj.optString("isLeaseFixedAsset")) : false;
        String companyid = paramJobj.getString(Constants.companyKey);
        
        String inventoryID = param.containsKey("inventoryID") ? (String) param.get("inventoryID") : null;
        JSONArray jedForCustomFields = param.containsKey("jedForCustomFields") ? (JSONArray) param.get("jedForCustomFields") : null;


        if (!StringUtil.isNullOrEmpty(jobj.optString(Constants.customfield, null))) {
            /*
             * Tagging dimension value to jedetails added in jedForCustomFields
             * array
             */
            JSONArray jcustomarray = new JSONArray(jobj.optString(Constants.customfield, "[]"));
            HashMap<String, Object> customrequestParams = new HashMap<String, Object>();
            customrequestParams.put("customarray", jcustomarray);
            customrequestParams.put("modulename", Constants.Acc_JEDetail_modulename);
            customrequestParams.put("moduleprimarykey", Constants.Acc_JEDetailId);// Constants.Acc_JEDetail_recdetailId
            customrequestParams.put("recdetailId", inventoryID);
            customrequestParams.put(Constants.moduleid, isFixedAsset ? Constants.Acc_FixedAssets_DisposalInvoice_ModuleId : isConsignment ? Constants.Acc_ConsignmentInvoice_ModuleId : isLeaseFixedAsset ? Constants.LEASE_INVOICE_MODULEID : Constants.Acc_Invoice_ModuleId);
            customrequestParams.put(Constants.companyKey, companyid);
            customrequestParams.put("customdataclasspath", Constants.Acc_BillInvDetail_custom_data_classpath);

            for (int custCount = 0; custCount < jedForCustomFields.length(); custCount++) {
                String jedForCust = jedForCustomFields.getString(custCount);
                customrequestParams.put("modulerecid", jedForCust);

                KwlReturnObject customDataresult = fieldDataManagercntrl.setCustomData(customrequestParams);
                if (customDataresult != null && customDataresult.getEntityList().size() > 0) {
                    JSONObject jedjson = new JSONObject();
                    jedjson.put("accjedetailcustomdata", jedForCust);
                    jedjson.put("jedid", jedForCust);
                    accJournalEntryobj.updateJournalEntryDetails(jedjson);
                }
            }
        }
    }

    
    
    public List approveRelevantDocumentAttachedToCustomerInvoice(HashMap approveJeMap) throws ServiceException, AccountingException, JSONException, SessionExpiredException, ParseException {//also think should be thrown or catch

        List approveJeMapList = new ArrayList();
        Invoice salesInvoice = null;
        Company companyObj = null;
        String postingDateStr = "";
        ExtraCompanyPreferences extraCompanyPreferences = null;

        Map<String, Object> jeDataMap = new HashMap<String, Object>();
        boolean isEditedPendingDocument = false;

        if (approveJeMap.containsKey("salesInvoice") && approveJeMap.get("salesInvoice") != null) {
            salesInvoice = (Invoice) approveJeMap.get("salesInvoice");
        }

        if (approveJeMap.containsKey("company") && approveJeMap.get("company") != null) {
            companyObj = (Company) approveJeMap.get("company");
        }

        if (approveJeMap.containsKey("extraCompanyPreferences") && approveJeMap.get("extraCompanyPreferences") != null) {
            extraCompanyPreferences = (ExtraCompanyPreferences) approveJeMap.get("extraCompanyPreferences");
        }

        if (approveJeMap.containsKey("postingDateStr") && approveJeMap.get("postingDateStr") != null) {
            postingDateStr = (String) approveJeMap.get("postingDateStr");
        }

        if (approveJeMap.containsKey("isEditedPendingDocument") && approveJeMap.get("isEditedPendingDocument") != null) {
            isEditedPendingDocument = (Boolean) approveJeMap.get("isEditedPendingDocument");
        }

        if (approveJeMap.containsKey("jeDataMap") && approveJeMap.get("jeDataMap") != null) {
            jeDataMap = (Map<String, Object>) approveJeMap.get("jeDataMap");
        }

        String companyid = companyObj.getCompanyID();
        String jeID = salesInvoice.getJournalEntry().getID();
        String jeCompany = salesInvoice.getJournalEntry().getCompany().getCompanyID();
        String JENumber = "";
        String JEMsg = "";

        DateFormat df = authHandler.getDateOnlyFormat();
        Date postingDate = null;
        if (!StringUtil.isNullOrEmpty(postingDateStr)) {
            postingDate = df.parse(postingDateStr);
        }

        if (StringUtil.isNullOrEmpty(salesInvoice.getJournalEntry().getEntryNumber())) {
            int isApproved = 0;
            HashMap<String, Object> JEFormatParams = new HashMap<String, Object>();
            JEFormatParams.put("moduleid", Constants.Acc_GENERAL_LEDGER_ModuleId);
            JEFormatParams.put("modulename", CompanyPreferencesConstants.AUTOJOURNALENTRY);
            JEFormatParams.put("companyid", companyid);
            JEFormatParams.put("isdefaultFormat", true);
            KwlReturnObject kwlObj = accCompanyPreferencesObj.getSequenceFormat(JEFormatParams);
            SequenceFormat format = (SequenceFormat) kwlObj.getEntityList().get(0);

            jeDataMap.put("postingDate", postingDateStr);
            jeDataMap.put("isEditedPendingDocument", isEditedPendingDocument);

            String JENumBer = updateJEEntryNumberForNewJE(jeDataMap, salesInvoice.getJournalEntry(), companyid, format.getID(), isApproved);
        } else {
            JSONObject jeJobj = new JSONObject();
            HashSet<JournalEntryDetail> details = new HashSet<JournalEntryDetail>();
            jeJobj.put("jeid", jeID);
            jeJobj.put(JournalEntryConstants.COMPANYID, jeCompany);
            jeJobj.put("pendingapproval", 0);
            Map<String, Object> paramMap = new HashMap<>();
            paramMap.put("id", companyid);
            Object exPrefObject = kwlCommonTablesDAOObj.getRequestedObjectFields(ExtraCompanyPreferences.class, new String[]{"columnPref"}, paramMap);
            JSONObject jObj = StringUtil.isNullObject(exPrefObject) ? new JSONObject() : new JSONObject(exPrefObject.toString());
            boolean isPostingDateCheck = false;
            if (!StringUtil.isNullObject(jObj) && jObj.has(Constants.IS_POSTING_DATE_CHECK) && jObj.get(Constants.IS_POSTING_DATE_CHECK) != null && jObj.optBoolean(Constants.IS_POSTING_DATE_CHECK, false)) {
                isPostingDateCheck = true;
            }
            if (isPostingDateCheck) {
                jeJobj.put("entrydate", postingDate);
            }
            accJournalEntryobj.updateJournalEntry(jeJobj, details);
        }
        JENumber = " with JE No. " + salesInvoice.getJournalEntry().getEntryNumber();
        JEMsg = " JE No : <b>" + salesInvoice.getJournalEntry().getEntryNumber() + "</b>";
        // Approve Auto Generated DO if respective SI approved
        KwlReturnObject InvoiceDo = accInvoiceDAOobj.getAutogeneratedDOFromInvoices(salesInvoice.getID(), companyid);
        if (InvoiceDo.getEntityList() != null && InvoiceDo.getEntityList().size() > 0) {
            Object[] oj = (Object[]) InvoiceDo.getEntityList().get(0);
            String DeliveryOrderID = oj[1].toString();
            KwlReturnObject dores = accountingHandlerDAOobj.getObject(DeliveryOrder.class.getName(), DeliveryOrderID);
            DeliveryOrder doObj = (DeliveryOrder) dores.getEntityList().get(0);
            if (doObj.getApprovestatuslevel() != 11) {
                accInvoiceDAOobj.approvePendingDO(DeliveryOrderID, companyid, 11);
                Set<DeliveryOrderDetail> doDetails = doObj.getRows();
                List<StockMovement> stockMovementsList = new ArrayList<>();
                for (DeliveryOrderDetail doDetail : doDetails) {
                    Product product = doDetail.getProduct();
                    if ((product != null && !doObj.isIsconsignment()) && extraCompanyPreferences.isActivateInventoryTab() && (product.isIsBatchForProduct() || product.isIslocationforproduct() || product.isIswarehouseforproduct() || product.isIsrowforproduct() || product.isIsrackforproduct() || product.isIsbinforproduct() || product.isIsSerialForProduct())) {
                        newStockMovementDeliveryOrder(doDetail, stockMovementsList);
                    }
                    Inventory inventory = doDetail.getInventory();
                    if (inventory.isInvrecord()) {
                        inventory.setBaseuomquantity(inventory.getActquantity());
                        inventory.getProduct().setAvailableQuantity(inventory.getProduct().getAvailableQuantity() - inventory.getBaseuomquantity());
                        inventory.setActquantity(0.0);
                    }
                }
                if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateInventoryTab() && !stockMovementsList.isEmpty()) {
                    stockMovementService.addOrUpdateBulkStockMovement(doObj.getCompany(), doObj.getID(), stockMovementsList);
                }
            }
        }
        
        approveJeMapList.add(JENumber);
        approveJeMapList.add(JEMsg);

        return approveJeMapList;

    }
    
    
    
    /*----------Call from used places , search usage-----------*/
    public void newStockMovementDeliveryOrder(DeliveryOrderDetail doDetail,List<StockMovement> stockMovementsList) throws ServiceException{
        try {
            String documentid=doDetail.getID();
            Product product=doDetail.getProduct();
            KwlReturnObject kmsg = null;
            List<Object[]> batchserialdetails = null;
            if (!product.isIsSerialForProduct()) {
                kmsg = accCommonTablesDAO.getBatchSerialDetails(documentid, true, false,  Integer.toString(Constants.Acc_Delivery_Order_ModuleId), false, true, "");
                batchserialdetails = kmsg.getEntityList();
            } else {
                kmsg = accCommonTablesDAO.getBatchSerialDetails(documentid, !product.isIsSerialForProduct(), false, Integer.toString(Constants.Acc_Delivery_Order_ModuleId), false, true, "");
                batchserialdetails = kmsg.getEntityList();
            }

            double ActbatchQty = 1;
            double batchQty = 0;
            if (batchserialdetails != null) {
                // Save Batch detail for both  option for serial no and batch also as if batch option is off then also we are generating batch in backend
                StockMovementDetail smd = null;
                StockMovement stockMovement = null;
                Map<Store, StockMovement> storeWiseStockMovement = new HashMap<>();
                for (Object[] objArr : batchserialdetails) {
                    String locationid = "";
                    String warehouseid = "";
                    String batchid = (String) objArr[0];
                    if (objArr[2] != null) {
                        locationid = (String) objArr[2];
                    }
                    if (objArr[3] != null) {
                        warehouseid = (String) objArr[3];
                    }
                    //double quantity = getNewBatchRemainingQuantity(locationid, warehouseid, companyid, product.getID(), batchid, moduleID, isEdit, documentid);
//                    obj.put("avlquantity", quantity);
                    if ((product.isIsBatchForProduct() || product.isIslocationforproduct() || product.isIswarehouseforproduct() || product.isIsrowforproduct() || product.isIsrackforproduct() || product.isIsbinforproduct())) {
                        ActbatchQty = accCommonTablesDAO.getBatchQuantity(documentid, (String) objArr[0]);
                        if (batchQty == 0) {
                            batchQty = ActbatchQty;

                            KwlReturnObject warehouseObj = accountingHandlerDAOobj.getObject(Store.class.getName(), warehouseid);
                            Store store = (Store) warehouseObj.getEntityList().get(0);
                            if (product.isIswarehouseforproduct() && product.isIslocationforproduct()) {
                                if (storeWiseStockMovement.containsKey(store)) {
                                    stockMovement = storeWiseStockMovement.get(store);
                                    stockMovement.setQuantity(stockMovement.getQuantity() + batchQty);
                                } else {
                                    stockMovement = new StockMovement();
                                    if (store != null) {
                                        stockMovement.setStore(store);
                                    }
                                    stockMovement.setCompany(product.getCompany());
                                    stockMovement.setProduct(product);
                                    stockMovement.setStockUoM(product.getUnitOfMeasure());
                                    stockMovement.setPricePerUnit(doDetail.getBaseuomrate() < 1 ? (doDetail.getRate() * (1 / doDetail.getBaseuomrate())) : doDetail.getRate() / doDetail.getBaseuomrate());
                                    stockMovement.setQuantity(batchQty);
                                    stockMovement.setTransactionDate(doDetail.getDeliveryOrder().getOrderDate());
                                    stockMovement.setModuleRefId(doDetail.getDeliveryOrder().getID());
                                    stockMovement.setModuleRefDetailId(doDetail.getID());
                                    stockMovement.setCustomer(doDetail.getDeliveryOrder().getCustomer());
                                    stockMovement.setCostCenter(doDetail.getDeliveryOrder().getCostcenter());
                                    stockMovement.setTransactionNo(doDetail.getDeliveryOrder().getDeliveryOrderNumber());
                                    if (doDetail.getDeliveryOrder().isIsconsignment()) {
                                        stockMovement.setTransactionModule(TransactionModule.ERP_Consignment_DO);
                                        stockMovement.setRemark("Consignment Delivery Order Created");
                                    } else {
                                        stockMovement.setTransactionModule(TransactionModule.ERP_DO);
                                        stockMovement.setRemark("Delivery Order Created");
                                    }                                    
                                    stockMovement.setTransactionType(TransactionType.OUT);
                                    stockMovement.setMemo(doDetail.getDeliveryOrder().getMemo());
                                    storeWiseStockMovement.put(store, stockMovement);
                                }
                            }
                        }
                        if ((product.isIslocationforproduct() || product.isIswarehouseforproduct() || product.isIsBatchForProduct() || product.isIsrowforproduct() || product.isIsrackforproduct() || product.isIsbinforproduct()) && (batchQty == ActbatchQty)) {
                            KwlReturnObject locationUpdate = accountingHandlerDAOobj.getObject(Location.class.getName(), locationid);
                            Location locationObj = (Location) locationUpdate.getEntityList().get(0);
                            if (product.isIswarehouseforproduct() && product.isIslocationforproduct()) {
                                smd = new StockMovementDetail();
                                if (locationObj != null) {
                                    smd.setLocation(locationObj);
                                }
                                if (product.isIsrowforproduct()) {
                                    KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), (String) objArr[15]);
                                    StoreMaster row = (StoreMaster) krObject.getEntityList().get(0);
                                    smd.setRow(row);
                                }
                                if (product.isIsrackforproduct()) {
                                    KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), (String) objArr[16]);
                                    StoreMaster rack = (StoreMaster) krObject.getEntityList().get(0);
                                    smd.setRack(rack);
                                }
                                if (product.isIsbinforproduct()) {
                                    KwlReturnObject krObject = accountingHandlerDAOobj.getObject(StoreMaster.class.getName(), (String) objArr[17]);
                                    StoreMaster bin = (StoreMaster) krObject.getEntityList().get(0);
                                    smd.setBin(bin);
                                }

                                if (product.isIsBatchForProduct() && objArr[0] != null) {
                                    KwlReturnObject result1 = accountingHandlerDAOobj.getObject(NewProductBatch.class.getName(), objArr[0].toString());
                                    NewProductBatch newProductBatch = (NewProductBatch) result1.getEntityList().get(0);
                                    if (newProductBatch != null) {
                                        smd.setBatchName(newProductBatch.getBatchname());
                                    }
                                }
                                smd.setQuantity(batchQty);
                                smd.setStockMovement(stockMovement);

                                stockMovement.getStockMovementDetails().add(smd);
                            }

                        }
                    }
                    batchQty--;

                    if (product.isIsSerialForProduct() && objArr[7] != null) {
                        KwlReturnObject result1 = accountingHandlerDAOobj.getObject(NewBatchSerial.class.getName(), objArr[7].toString());
                        NewBatchSerial newBatchSerial = (NewBatchSerial) result1.getEntityList().get(0);
                        if (newBatchSerial != null && product.isIswarehouseforproduct() && product.isIslocationforproduct()) {
                            smd.addSerialName(newBatchSerial.getSerialname());
                        }
                    } else {
                        batchQty = 0;
                    }

                }
                if (product.isIswarehouseforproduct() && product.isIslocationforproduct()) {
                    for (Map.Entry<Store, StockMovement> entry : storeWiseStockMovement.entrySet()) {
                        stockMovementsList.add(entry.getValue());
                    }
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(accInvoiceController.class.getName()).log(Level.INFO, ex.getMessage());
        }
        
    }
    
      /*-------Function to send approval mail if check "Allow Sending Approval Mail" is activated from system preferences---------*/
    public void sendApprovalMailIfAllowedFromSystemPreferences(HashMap emailMap) throws ServiceException {

        String userName = "";
        Company company = null;
        Invoice salesInvoice = null;
        String baseUrl = "";
        CompanyAccountPreferences preferences = null;
        HashMap<String, Object> ApproveMap =null;

        if (emailMap.containsKey("userName") && emailMap.get("userName") != null) {
            userName = (String) emailMap.get("userName");
        }
        if (emailMap.containsKey("company") && emailMap.get("company") != null) {
            company = (Company) emailMap.get("company");
        }

        if (emailMap.containsKey("salesInvoice") && emailMap.get("salesInvoice") != null) {
            salesInvoice = (Invoice) emailMap.get("salesInvoice");
        }

        if (emailMap.containsKey("baseUrl") && emailMap.get("baseUrl") != null) {
            baseUrl = (String) emailMap.get("baseUrl");
        }

        if (emailMap.containsKey("preferences") && emailMap.get("preferences") != null) {
            preferences = (CompanyAccountPreferences) emailMap.get("preferences");
        }
        if (emailMap.containsKey("ApproveMap") && emailMap.get("ApproveMap") != null) {
            ApproveMap = (HashMap<String, Object>) emailMap.get("ApproveMap");
        }
        String sendorInfo = (!company.isEmailFromCompanyCreator()) ? Constants.ADMIN_EMAILID : authHandlerDAOObj.getSysEmailIdByCompanyID(company.getCompanyID());
        String creatormail = company.getCreator().getEmailID();
        ArrayList<String> emailArray = new ArrayList<>();
        String fname = company.getCreator().getFirstName() == null ? "" : company.getCreator().getFirstName();
        String lname = company.getCreator().getLastName() == null ? "" : company.getCreator().getLastName();
        String ruleId = "";
        String documentcreatoremail = (salesInvoice != null && salesInvoice.getCreatedby() != null) ? salesInvoice.getCreatedby().getEmailID() : "";
        String creatorname = fname + " " + lname;
        String approvalpendingStatusmsg = "";
        HashMap<String, Object> qdDataMap = new HashMap<String, Object>();
        qdDataMap.put(Constants.companyKey, company.getCompanyID());
        qdDataMap.put("level", salesInvoice.getApprovestatuslevel());
        qdDataMap.put(Constants.moduleid, Constants.Acc_Invoice_ModuleId);
//        emailArray = commonFnControllerService.getUserApprovalEmail(qdDataMap);
        emailArray.add(creatormail);
        String[] emails = {};
        if (!StringUtil.isNullOrEmpty(documentcreatoremail) && !creatormail.equalsIgnoreCase(documentcreatoremail)) {
            emailArray.add(documentcreatoremail);
        }
        emails = emailArray.toArray(emails);

        if (!StringUtil.isNullOrEmpty(preferences.getApprovalEmails())) {
            String[] compPrefMailIds = preferences.getApprovalEmails().split(",");
            emails = AccountingManager.getMergedMailIds(emails, compPrefMailIds);
        }
        if (salesInvoice.getApprovestatuslevel() < 11) {
            qdDataMap.put("ApproveMap", ApproveMap);
            approvalpendingStatusmsg = commonFnControllerService.getApprovalstatusmsg(qdDataMap);
        }
        Map<String, Object> mailParameters = new HashMap();
        mailParameters.put("Number", salesInvoice.getInvoiceNumber());
        mailParameters.put("userName", userName);
        mailParameters.put("emails", emails);
        mailParameters.put("sendorInfo", sendorInfo);
        mailParameters.put("moduleName", Constants.CUSTOMER_INVOICE);
        mailParameters.put("addresseeName", "All");
        mailParameters.put("companyid", company.getCompanyID());
        mailParameters.put("baseUrl", baseUrl);
        mailParameters.put("approvalstatuslevel", salesInvoice.getApprovestatuslevel());
        mailParameters.put("approvalpendingStatusmsg", approvalpendingStatusmsg);
        if (emails.length > 0) {
            accountingHandlerDAOobj.sendApprovedEmails(mailParameters);
        }

    }
    
    
    
    
    
    /*---Function to save approval history , If any document is approved at some level------   */
    public List saveApprovalHistory(HashMap approvalHistoryMap) throws ServiceException {

        List approvalHistoryList = new ArrayList();

        Invoice salesInvoice = null;
        Company companyObj = null;
        String userid = "";

        if (approvalHistoryMap.containsKey("salesInvoice") && approvalHistoryMap.get("salesInvoice") != null) {
            salesInvoice = (Invoice) approvalHistoryMap.get("salesInvoice");
        }

        if (approvalHistoryMap.containsKey("company") && approvalHistoryMap.get("company") != null) {
            companyObj = (Company) approvalHistoryMap.get("company");
        }

        if (approvalHistoryMap.containsKey("userid") && approvalHistoryMap.get("userid") != null) {
            userid = (String) approvalHistoryMap.get("userid");
        }

        HashMap<String, Object> hashMap = new HashMap<String, Object>();
        hashMap.put("transtype", Constants.Invoice_APPROVAL);
        hashMap.put("transid", salesInvoice.getID());
        hashMap.put("approvallevel", salesInvoice.getApprovestatuslevel());//  If approvedLevel = 11 then its final Approval
        hashMap.put("remark", "");
        hashMap.put("userid", userid);
        hashMap.put("companyid", companyObj.getCompanyID());
        accountingHandlerDAOobj.updateApprovalHistory(hashMap);

        KwlReturnObject kmsg = null;
        String roleName = "Company User";
        kmsg = permissionHandlerDAOObj.getRoleofUser(userid);
        Iterator ite2 = kmsg.getEntityList().iterator();
        while (ite2.hasNext()) {
            Object[] row = (Object[]) ite2.next();
            roleName = row[1].toString();
        }

        approvalHistoryList.add(roleName);

        return approvalHistoryList;

    }
    
    
        
    public JSONObject checklinkingofTransactions(JSONObject paramJobj, String billids) throws JSONException {
        JSONObject returnJObj = new JSONObject();
        boolean issuccess = true;
        try {
            KwlReturnObject bankresult = accInvoiceDAOobj.checklinkingofTransactions(String.valueOf(Constants.Acc_Goods_Receipt_ModuleId), billids);
            if (bankresult != null && bankresult.getRecordTotalCount() > 0) {
                issuccess = false;
            }
        } catch (Exception ex) {
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            try {
                returnJObj.put(Constants.RES_success, issuccess);
            } catch (JSONException ex) {
                Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        return returnJObj;
    }
    
    
   /*-------Function to send approval mail if check "Allow Sending Approval Mail" is activated from system preferences---------*/
    public void sendApprovalMailForDOIfAllowedFromSystemPreferences(HashMap emailMap) throws ServiceException {

        String userName = "";
        Company company = null;
        DeliveryOrder deliveryOrderObj = null;
        String baseUrl = "";    
        CompanyAccountPreferences preferences =null;

        if (emailMap.containsKey("userName") && emailMap.get("userName") != null) {
            userName = (String)emailMap.get("userName");
        }
        if (emailMap.containsKey("company") && emailMap.get("company") != null) {
             company = (Company)emailMap.get("company");
        }

        if (emailMap.containsKey("deliveryOrder") && emailMap.get("deliveryOrder") != null) {
            deliveryOrderObj = (DeliveryOrder)emailMap.get("deliveryOrder");
        }

        if (emailMap.containsKey("baseUrl") && emailMap.get("baseUrl") != null) {
            baseUrl = (String)emailMap.get("baseUrl");
        }
        
         if (emailMap.containsKey("preferences") && emailMap.get("preferences") != null) {
            preferences = (CompanyAccountPreferences)emailMap.get("preferences");
        }
         
                String sendorInfo = (!company.isEmailFromCompanyCreator())?Constants.ADMIN_EMAILID:authHandlerDAOObj.getSysEmailIdByCompanyID(company.getCompanyID());
                String creatormail = company.getCreator().getEmailID();
                String fname = company.getCreator().getFirstName() == null ? "" : company.getCreator().getFirstName();
                String lname = company.getCreator().getLastName() == null ? "" : company.getCreator().getLastName();
                String creatorname = fname + " " + lname;
                String documentcreatoremail = (deliveryOrderObj != null && deliveryOrderObj.getCreatedby() != null) ? deliveryOrderObj.getCreatedby().getEmailID() : "";
                String approvalpendingStatusmsg = "";
                HashMap<String, Object> qdDataMap = new HashMap<String, Object>();
                ArrayList<String> emailArray = new ArrayList<>();
                qdDataMap.put(Constants.companyKey, company.getCompanyID());
                qdDataMap.put("level", deliveryOrderObj.getApprovestatuslevel());
                qdDataMap.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
//                emailArray = commonFnControllerService.getUserApprovalEmail(qdDataMap);
                emailArray.add(creatormail);
                if (!StringUtil.isNullOrEmpty(documentcreatoremail) && !creatormail.equalsIgnoreCase(documentcreatoremail)) {
                     emailArray.add(documentcreatoremail);
                }
                String[] emails = {};
                emails = emailArray.toArray(emails);
//                String[] emails = {creatormail};                
                if (!StringUtil.isNullOrEmpty(preferences.getApprovalEmails())) {
                    String[] compPrefMailIds = preferences.getApprovalEmails().split(",");
                    emails = AccountingManager.getMergedMailIds(emails, compPrefMailIds);
                }
                if (deliveryOrderObj.getApprovestatuslevel() < 11) {
                approvalpendingStatusmsg = commonFnControllerService.getApprovalstatusmsg(qdDataMap);
                }
                Map<String, Object> mailParameters = new HashMap();
                mailParameters.put("Number", deliveryOrderObj.getDeliveryOrderNumber());
                mailParameters.put("userName", userName);
                mailParameters.put("emails", emails);
                mailParameters.put("sendorInfo", sendorInfo);
                mailParameters.put("moduleName",  Constants.Delivery_Order);
                mailParameters.put("addresseeName", "All");
                mailParameters.put("companyid", company.getCompanyID());
                mailParameters.put("baseUrl", baseUrl);
                mailParameters.put("approvalstatuslevel", deliveryOrderObj.getApprovestatuslevel());
                mailParameters.put("approvalpendingStatusmsg", approvalpendingStatusmsg);
                if (emails.length > 0) {
                    accountingHandlerDAOobj.sendApprovedEmails(mailParameters);
                }
    }
    
    
    /*---Function to save approval history , If any document is approved at some level------   */
    public List saveApprovalHistoryForDeliveryOrder(HashMap approvalHistoryMap) throws ServiceException {

        List approvalHistoryList = new ArrayList();

        DeliveryOrder deliveryOrderObj = null;
        Company companyObj = null;
        String userid = "";

        if (approvalHistoryMap.containsKey("deliveryOrder") && approvalHistoryMap.get("deliveryOrder") != null) {
            deliveryOrderObj = (DeliveryOrder) approvalHistoryMap.get("deliveryOrder");
        }

        if (approvalHistoryMap.containsKey("company") && approvalHistoryMap.get("company") != null) {
            companyObj = (Company) approvalHistoryMap.get("company");
        }

        if (approvalHistoryMap.containsKey("userid") && approvalHistoryMap.get("userid") != null) {
            userid = (String) approvalHistoryMap.get("userid");
        }

        HashMap<String, Object> hashMap = new HashMap<String, Object>();
        hashMap.put("transtype", Constants.DELIVERY_ORDER_APPROVAL);
        hashMap.put("transid", deliveryOrderObj.getID());
        hashMap.put("approvallevel", deliveryOrderObj.getApprovestatuslevel());//  If approvedLevel = 11 then its final Approval
        hashMap.put("remark", "");
        hashMap.put("userid", userid);
        hashMap.put("companyid", companyObj.getCompanyID());
        accountingHandlerDAOobj.updateApprovalHistory(hashMap);

        KwlReturnObject kmsg = null;
        String roleName = "Company User";
        kmsg = permissionHandlerDAOObj.getRoleofUser(userid);
        Iterator userRoleIterator = kmsg.getEntityList().iterator();
        while (userRoleIterator.hasNext()) {
            Object[] row = (Object[]) userRoleIterator.next();
            roleName = row[1].toString();
        }

        approvalHistoryList.add(roleName);

        return approvalHistoryList;

    }
    
    /*-------Fucntion to build Json for Sales Report Master Data ----------- */
    @Override
    public JSONArray getSalesReportMasterDataJson(JSONObject requestParams, List<Object[]> list, JSONArray jArr, HashMap<String, Object> params) throws ServiceException, JSONException, SessionExpiredException {

        String companyid = requestParams.optString("companyid", "");
        JSONArray productCustomDataIndexJsonArray = new JSONArray();
        JSONArray customerCustomDataIndexJsonArray = new JSONArray();
        
        JSONArray productCustomDataTypeJsonArray = new JSONArray();

        JSONArray customerCustomDataTypeJsonArray = new JSONArray();

        boolean isExport = false;

        String productCustomDataIndexArray = requestParams.has("productCustomDataIndexArray") && requestParams.get("productCustomDataIndexArray") != null ? requestParams.getString("productCustomDataIndexArray") : "";

        if (!StringUtil.isNullOrEmpty(productCustomDataIndexArray) && !productCustomDataIndexArray.equals("[]")) {
            productCustomDataIndexJsonArray = new JSONArray(productCustomDataIndexArray);
        }

        String customerCustomDataIndexArray = requestParams.has("customerCustomDataIndexArray") && requestParams.get("customerCustomDataIndexArray") != null ? requestParams.getString("customerCustomDataIndexArray") : "";

        if (!StringUtil.isNullOrEmpty(customerCustomDataIndexArray) && !customerCustomDataIndexArray.equals("[]")) {
            customerCustomDataIndexJsonArray = new JSONArray(customerCustomDataIndexArray);
        }
        
        
          String productCustomDataTypeArray = requestParams.has("productCustomDataTypeArray") && requestParams.get("productCustomDataTypeArray") != null ? requestParams.getString("productCustomDataTypeArray") : "";

        if (!StringUtil.isNullOrEmpty(productCustomDataTypeArray) && !productCustomDataTypeArray.equals("[]")) {
            productCustomDataTypeJsonArray = new JSONArray(productCustomDataTypeArray);
        }

        String customerCustomDataTypeArray = requestParams.has("customerCustomDataTypeArray") && requestParams.get("customerCustomDataTypeArray") != null ? requestParams.getString("customerCustomDataTypeArray") : "";

        if (!StringUtil.isNullOrEmpty(customerCustomDataTypeArray) && !customerCustomDataTypeArray.equals("[]")) {
            customerCustomDataTypeJsonArray = new JSONArray(customerCustomDataTypeArray);
        }
        
        if(requestParams.has("isExport") && requestParams.get("isExport") != null) {
            isExport = Boolean.parseBoolean(requestParams.get("isExport").toString());
        }
        DateFormat df = authHandler.getUserDateFormatterWithoutTimeZone(requestParams);
//        Iterator itr = list.iterator();
        double totalAmountInBase = 0, totalQty = 0;
        List<String> invoiceNumbers = new ArrayList<String>();
//        String oldInvId = "";
        for (int ind = 0; ind < list.size(); ind++) {

            JSONObject paramJobj = new JSONObject();
            
            Object[] obj = (Object[]) list.get(ind);
            double costofSales = 0;
            paramJobj.put("documenttype", "Invoice");
            paramJobj.put("documentno", obj[0]);
            paramJobj.put("billid", obj[1]);
            paramJobj.put("documentdate", df.format(obj[2]));
            paramJobj.put("documentdatelong", ((Date) obj[2]).getTime());
            paramJobj.put("invoiceamount", obj[3]);
            paramJobj.put("invoiceamountinbase", obj[4]);

            paramJobj.put("invoicedono", obj[5]);
            paramJobj.put("invoicedodate", obj[7]);
            paramJobj.put("invoicesono", obj[8]);
            paramJobj.put("invoicesodate", obj[10]);

            /*----------Customer Column Data ---------------  */
            paramJobj.put("customername", obj[11]);
            paramJobj.put("customercode", obj[12]);
            paramJobj.put("customeraliasname", obj[13]);
            paramJobj.put("customercategory", obj[14]);
            paramJobj.put("customercurrency", obj[15]);
            paramJobj.put("customercountry", obj[16]);
            paramJobj.put("salesmancode", obj[17] != null ? obj[17] : "");

            /*------Product Column Data --------------- */
            paramJobj.put("productname", obj[18]);
            paramJobj.put("productid", obj[19]);
            paramJobj.put("productdescription", obj[20] != null ? obj[20] : "");
            paramJobj.put("invoicesalesqty", obj[21]);
            paramJobj.put("unitsellingprice", obj[22]);
            paramJobj.put("productuom", obj[23]);
            paramJobj.put("productbatch", obj[24] != null ? obj[24] : "");
            paramJobj.put("productserial", obj[25] != null ? obj[25] : "");
            paramJobj.put("salesgl", obj[26]);
            paramJobj.put("producvendor", obj[27] != null ? obj[27] : "");
            paramJobj.put("currencysymboltransaction", obj[28] != null ? obj[28] : "");
            paramJobj.put("customercategory", obj[29] != null ? obj[29] : "");
            paramJobj.put("pid", obj[30] != null ? obj[30] : "");
            paramJobj.put("doid", obj[31] != null ? obj[31] : "");
            paramJobj.put("soid", obj[32] != null ? obj[32] : "");
            paramJobj.put("excludinggstamount", obj[33] != null ? obj[33] : "");
            paramJobj.put("excludinggstamountinbase", obj[34] != null ? obj[34] : "");
            paramJobj.put("salesrevenueinbasecurrency", obj[35] != null ? obj[35] : "");
            paramJobj.put("salesrevenue", obj[36] != null ? obj[36] : "");
            if(isExport){
                String linkedNo = "";
                linkedNo += obj[5] != null ? obj[5] + " / " : "";
                linkedNo += obj[39] != null ? obj[39] + " / " : "";
                linkedNo += obj[42] != null ? obj[42] + "" : "";
                linkedNo = linkedNo.endsWith(" / ") ? linkedNo.substring(0, linkedNo.length()-3) : linkedNo;
                
                paramJobj.put("linkedid", obj[31] + " / " + obj[38] + " / " + obj[41]);
                paramJobj.put("linkedno", linkedNo);
            } else{
                paramJobj.put("linkedid", obj[31] + "!##" + obj[38] + "!##" + obj[41]);
                paramJobj.put("linkedno", obj[5] + "!##" + obj[39] + "!##" + obj[42]);
            }
            String linkedDateStr = "";
            linkedDateStr = obj[7] == null ? "" : df.format((Date) obj[7]) + " / ";
            linkedDateStr += obj[40] == null ? "" : df.format((Date) obj[40]) + " / ";
            linkedDateStr += obj[43] == null ? "" : df.format((Date) obj[43]) + "";
            linkedDateStr = linkedDateStr.endsWith(" / ") ? linkedDateStr.substring(0, linkedDateStr.length()-3) : linkedDateStr;

            paramJobj.put("linkeddate", linkedDateStr);

            if (params.containsKey(obj[37]) && params.get(obj[37]) != null) {
                costofSales = Double.parseDouble(params.get(obj[37]).toString());
            }
            paramJobj.put("invoiceproductcost", authHandler.round(costofSales,companyid));
            paramJobj.put("totalinvoiceproductcost", authHandler.round((Double.parseDouble(obj[21].toString()) * costofSales), companyid));
//            KwlReturnObject invoiceResult = accountingHandlerDAOobj.getObject(Invoice.class.getName(), (String) obj[1]);
//            Invoice inv = (Invoice) invoiceResult.getEntityList().get(0);
//            KwlReturnObject pricingObj = accProductObj.getProductPrice((String) obj[30], true, (Date) obj[2], inv.getCreatedby().getUserID(), inv.getCurrency().getCurrencyID(), "", true);
//            List list2 = pricingObj != null ? pricingObj.getEntityList() : new ArrayList();
//            Iterator itr2 = list2.iterator();
//            if (itr2.hasNext()) {
//                Object row = itr2.next();
//                if (row != null) {
//                    paramJobj.put("invoiceproductcost", row);
//                    paramJobj.put("totalinvoiceproductcost", authHandler.round(Double.parseDouble(obj[21].toString()) * Double.parseDouble(row.toString()), companyid));
//                } else{
//                    paramJobj.put("invoiceproductcost", "");
//                    paramJobj.put("totalinvoiceproductcost", "");
//                }
//            }

            /*--------Putting Custom Field in Json Object -------------- */
            int j = 0;
            int k = 0;
            int m = 43;
            int count = 0;
            String values ="";
            
            for (j = 0; j < productCustomDataIndexJsonArray.length(); j++) {

                if (productCustomDataTypeJsonArray.get(j).equals(new Integer(4)) || productCustomDataTypeJsonArray.get(j).equals(new Integer(7))) {//4-Combo , 7-MultiSelect
                    if (obj[m + (j + 1)] != null) {
                        values = fieldManagerDAOobj.getFieldComboDtaValueUsingId(obj[m + (j + 1)].toString(), companyid);
                        paramJobj.put(productCustomDataIndexJsonArray.getString(j) + "_product", values);
                    }

                }else{
                     paramJobj.put(productCustomDataIndexJsonArray.getString(j) + "_product", obj[m + (j + 1)] != null ? obj[m + (j + 1)] : ""); 
                }
                count++;
            }

            m += count;

            for (k = 0; k < customerCustomDataIndexJsonArray.length(); k++) {

                if (customerCustomDataTypeJsonArray.get(k).equals(new Integer(4)) || customerCustomDataTypeJsonArray.get(k).equals(new Integer(7))) {//4-Combo , 7-MultiSelect
                    if (obj[m + (k + 1)] != null) {
                        values = fieldManagerDAOobj.getFieldComboDtaValueUsingId(obj[m + (k + 1)].toString(), companyid);
                        paramJobj.put(customerCustomDataIndexJsonArray.getString(k) + "_customer", values);
                    }

                } else {
                    paramJobj.put(customerCustomDataIndexJsonArray.getString(k) + "_customer", obj[m + (k + 1)] != null ? obj[m + (k + 1)] : "");
                }
            }
            if(!invoiceNumbers.contains(obj[0].toString())) {
                totalAmountInBase += Double.parseDouble(obj[4].toString());
            }
            invoiceNumbers.add(obj[0].toString());
            if(obj[21] != null){
                totalQty += Double.parseDouble(obj[21].toString());
            }
            
            jArr.put(paramJobj);
            
        }
        /**
         * get Credit Note details
         */
        KwlReturnObject result = null;
        List<Object[]> cnList = new ArrayList();
        List<String> cnNumbers = new ArrayList<String>();
        int totalCount = 0;
        result = accInvoiceDAOobj.getCreditNoteDetailsForSalesReport(requestParams);
        if (result != null && result.getEntityList() != null && result.getEntityList().size() > 0) {
            cnList = result.getEntityList();
            totalCount = result.getRecordTotalCount();
        }
        for (Object[] cnObj : cnList) {
            JSONObject cnDetailsJobj = new JSONObject();
            cnDetailsJobj.put("documenttype", "Credit Note");
            cnDetailsJobj.put("documentno", cnObj[0]);
            cnDetailsJobj.put("billid", cnObj[1]);
            cnDetailsJobj.put("documentdate", df.format(cnObj[2]));
            cnDetailsJobj.put("documentdatelong", ((Date) cnObj[2]).getTime());
            cnDetailsJobj.put("invoiceamount", ((Double) cnObj[3]) * -1);
            cnDetailsJobj.put("invoiceamountinbase", ((Double) cnObj[4]) * -1);
            double taxAmount = 0.0;
            taxAmount = null != cnObj[11] ? (Double) cnObj[11] : 0.0;
            cnDetailsJobj.put("excludinggstamount", (((Double) cnObj[3]) - taxAmount) * -1);
            double exRate = cnObj[13] != null ? ((Double) cnObj[13]) == 0 ? 1 : (Double) cnObj[13] : 1;
            cnDetailsJobj.put("excludinggstamountinbase", (((Double) cnObj[4]) - (taxAmount / exRate)) * -1);
            /*----------Customer Column Data ---------------  */
            cnDetailsJobj.put("customercode", cnObj[5]);
            cnDetailsJobj.put("customername", cnObj[6]);
            cnDetailsJobj.put("customeraliasname", cnObj[7]);
            cnDetailsJobj.put("customercategory", cnObj[8]);
            cnDetailsJobj.put("customercurrency", cnObj[9]);
            cnDetailsJobj.put("salesmancode", cnObj[10] != null ? cnObj[10] : "");
            cnDetailsJobj.put("currencysymboltransaction", cnObj[12] != null ? cnObj[12] : "");
            cnDetailsJobj.put("linkedid", cnObj[14] != null ? cnObj[14] : "");
            cnDetailsJobj.put("linkedno", cnObj[15] != null ? cnObj[15] : "");
            cnDetailsJobj.put("linkeddate", cnObj[16] != null ? df.format((Date) cnObj[16]) : "");
            
            //Product details
            cnDetailsJobj.put("productid", cnObj[17] != null ? cnObj[17] : "");
            cnDetailsJobj.put("productname", cnObj[18] != null ? cnObj[18] : "");
            cnDetailsJobj.put("pid", cnObj[19] != null ? cnObj[19] : "");
            cnDetailsJobj.put("productdescription", cnObj[20] != null ? cnObj[20] : "");
            cnDetailsJobj.put("invoicesalesqty", cnObj[21] != null ? cnObj[21] : "");
            cnDetailsJobj.put("unitsellingprice", cnObj[22] != null ? cnObj[22] : "");
            cnDetailsJobj.put("productuom", cnObj[23] != null ? cnObj[23] : "");
            cnDetailsJobj.put("salesrevenueinbasecurrency", cnObj[24] != null ? ((Double) cnObj[24] * -1) : "");
            cnDetailsJobj.put("salesrevenue", cnObj[25] != null ? ((Double) cnObj[25] * -1) : "");
            cnDetailsJobj.put("salesgl", cnObj[26] != null ? cnObj[26] : "");
            
            double costofSales = 0.0;
            if (params.containsKey(cnObj[27]) && params.get(cnObj[27]) != null) {
                costofSales = Double.parseDouble(params.get(cnObj[27]).toString());
            }
            cnDetailsJobj.put("invoiceproductcost", authHandler.round(costofSales * -1, companyid));
            if(cnObj[21] != null && !cnObj[21].equals("")){
                cnDetailsJobj.put("totalinvoiceproductcost", authHandler.round((Double.parseDouble(cnObj[21].toString()) * costofSales) * -1, companyid));
            }

            /*--------Putting Custom Field in Json Object -------------- */
            int j = 0;
            int k = 0;
            int m = 27;
            int count = 0;
            String values ="";
            
            for (j = 0; j < productCustomDataIndexJsonArray.length(); j++) {

                if (productCustomDataTypeJsonArray.get(j).equals(new Integer(4)) || productCustomDataTypeJsonArray.get(j).equals(new Integer(7))) {//4-Combo , 7-MultiSelect
                    if (cnObj[m + (j + 1)] != null) {
                        values = fieldManagerDAOobj.getFieldComboDtaValueUsingId(cnObj[m + (j + 1)].toString(), companyid);
                        cnDetailsJobj.put(productCustomDataIndexJsonArray.getString(j) + "_product", values);
                    }

                }else{
                     cnDetailsJobj.put(productCustomDataIndexJsonArray.getString(j) + "_product", cnObj[m + (j + 1)] != null ? cnObj[m + (j + 1)] : ""); 
                }
                count++;
            }

            m += count;

            for (k = 0; k < customerCustomDataIndexJsonArray.length(); k++) {

                if (customerCustomDataTypeJsonArray.get(k).equals(new Integer(4)) || customerCustomDataTypeJsonArray.get(k).equals(new Integer(7))) {//4-Combo , 7-MultiSelect
                    if (cnObj[m + (k + 1)] != null) {
                        values = fieldManagerDAOobj.getFieldComboDtaValueUsingId(cnObj[m + (k + 1)].toString(), companyid);
                        cnDetailsJobj.put(customerCustomDataIndexJsonArray.getString(k) + "_customer", values);
                    }

                } else {
                    cnDetailsJobj.put(customerCustomDataIndexJsonArray.getString(k) + "_customer", cnObj[m + (k + 1)] != null ? cnObj[m + (k + 1)] : "");
                }
            }
            
            jArr.put(cnDetailsJobj);

            if(!cnNumbers.contains(cnObj[0].toString())) {
                totalAmountInBase += (Double.parseDouble(cnObj[4].toString()) * -1);
            }
            cnNumbers.add(cnObj[0].toString());
        }
        cnList = new ArrayList();
        result = accInvoiceDAOobj.getCreditNoteAccountDetailsForSalesReport(requestParams);
        if (result != null && result.getEntityList() != null && result.getEntityList().size() > 0) {
            cnList = result.getEntityList();
            totalCount += result.getRecordTotalCount();
        }
        for (Object[] cnObj : cnList) {
            JSONObject cnDetailsJobj = new JSONObject();
            cnDetailsJobj.put("documenttype", "Credit Note");
            cnDetailsJobj.put("documentno", cnObj[0]);
            cnDetailsJobj.put("billid", cnObj[1]);
            cnDetailsJobj.put("documentdate", df.format(cnObj[2]));
            cnDetailsJobj.put("documentdatelong", ((Date) cnObj[2]).getTime());
            cnDetailsJobj.put("invoiceamount", ((Double) cnObj[3]) * -1);
            cnDetailsJobj.put("invoiceamountinbase", ((Double) cnObj[4]) * -1);
            double taxAmount = 0.0;
            taxAmount = null != cnObj[12] ? (Double) cnObj[12] : 0.0;
            cnDetailsJobj.put("excludinggstamount", (((Double) cnObj[3]) - taxAmount) * -1);
            double exRate = cnObj[13] != null ? ((Double) cnObj[13]) == 0 ? 1 : (Double) cnObj[13] : 1;
            cnDetailsJobj.put("excludinggstamountinbase", (((Double) cnObj[4]) - (taxAmount / exRate)) * -1);
            /*----------Customer Column Data ---------------  */
            cnDetailsJobj.put("customercode", cnObj[5]);
            cnDetailsJobj.put("customername", cnObj[6]);
            cnDetailsJobj.put("customeraliasname", cnObj[7]);
            cnDetailsJobj.put("customercategory", cnObj[8]);
            cnDetailsJobj.put("customercurrency", cnObj[9]);
            cnDetailsJobj.put("salesmancode", cnObj[10] != null ? cnObj[10] : "");
            cnDetailsJobj.put("currencysymboltransaction", cnObj[11] != null ? cnObj[11] : "");
            //Account details
            cnDetailsJobj.put("productid", cnObj[14] != null ? cnObj[14] : "");
            cnDetailsJobj.put("productname", cnObj[15] != null ? cnObj[15] : "");
            cnDetailsJobj.put("salesrevenueinbasecurrency", cnObj[16] != null ? ((Double) cnObj[16] * -1) : "");
            cnDetailsJobj.put("salesrevenue", cnObj[17] != null ? ((Double) cnObj[17] * -1) : "");
            cnDetailsJobj.put("salesgl", cnObj[15] != null ? cnObj[15] : "");
            
            /*--------Putting Custom Field in Json Object -------------- */
            int j = 0;
            int k = 0;
            int m = 17;
            String values ="";

            for (k = 0; k < customerCustomDataIndexJsonArray.length(); k++) {

                if (customerCustomDataTypeJsonArray.get(k).equals(new Integer(4)) || customerCustomDataTypeJsonArray.get(k).equals(new Integer(7))) {//4-Combo , 7-MultiSelect
                    if (cnObj[m + (k + 1)] != null) {
                        values = fieldManagerDAOobj.getFieldComboDtaValueUsingId(cnObj[m + (k + 1)].toString(), companyid);
                        cnDetailsJobj.put(customerCustomDataIndexJsonArray.getString(k) + "_customer", values);
                    }

                } else {
                    cnDetailsJobj.put(customerCustomDataIndexJsonArray.getString(k) + "_customer", cnObj[m + (k + 1)] != null ? cnObj[m + (k + 1)] : "");
                }
            }
            
            jArr.put(cnDetailsJobj);

            if(!cnNumbers.contains(cnObj[0].toString())) {
                totalAmountInBase += (Double.parseDouble(cnObj[4].toString()) * -1);
            }
            cnNumbers.add(cnObj[0].toString());
        }
        
        jArr = StringUtil.sortJsonArray(jArr, "documentdatelong", false, true);
        
        JSONArray returnJArr = new JSONArray();
        returnJArr.put(jArr);
        returnJArr.put(totalCount);
        return returnJArr;
    }
     @Override
    public JSONObject isPackingStoreUsedBefore(JSONObject requestParams) throws ServiceException, JSONException {
        JSONObject returnObject = new JSONObject();
        Map<String, Object> params = new HashMap();
        if (!StringUtil.isNullOrEmpty(requestParams.optString(Constants.companyid))) {
            params.put(Constants.companyid, requestParams.optString(Constants.companyid));
        }
        if (!StringUtil.isNullOrEmpty(requestParams.optString("store"))) {
            params.put("warehouse", requestParams.optString("store"));
        }
        KwlReturnObject res = accInvoiceDAOobj.isPackingStoreUsedBefore(params);
        if (res != null) {
            returnObject.put(Constants.RES_success, res.isSuccessFlag());           
        }
        return returnObject;
    }
    
    @Override
    public boolean isStoreUsedInTransaction(JSONObject requestParams) throws ServiceException, JSONException {

        String warehouseid = "";
        String companyID = "";
        try {
            warehouseid = requestParams.optString("storeid");
            companyID = requestParams.optString(Constants.companyid);
            KwlReturnObject result = accMasterItemsDAOobj.getdefault_warehouse(warehouseid, companyID); //Is default warehouse of company
            List list1 = result.getEntityList();
            int count1 = list1.size();

            result = accMasterItemsDAOobj.getProductsusedinWarehouses(warehouseid, companyID);  // Is warehouse used in product ?
            List list2 = result.getEntityList();
            int count2 = list2.size();

            result = accMasterItemsDAOobj.getBatches_warehouses(warehouseid, companyID); // Is Used in newproductBatch?
            List list3 = result.getEntityList();
            int count3 = list3.size();
            
            boolean isForStockRequest=true;
            List<Object> list4 = storeService.getTransactionCountForStoreId(warehouseid, companyID,isForStockRequest);
            int count4 = list4.size();
            
            isForStockRequest=false;
            List<Object> list5 = storeService.getTransactionCountForStoreId(warehouseid, companyID,isForStockRequest);
            int count5 = list5.size();

            result = accMasterItemsDAOobj.getSO_warehouses(warehouseid, companyID); // Is used in consignment Reuest
            List list7 = result.getEntityList();
            int count7 = list7.size();

            result = accMasterItemsDAOobj.getDO_warehouses(warehouseid, companyID); //Is used in  consignmentDelivery Order?
            List list8 = result.getEntityList();
            int count8 = list8.size();

            result = accMasterItemsDAOobj.getSR_warehouses(warehouseid, companyID); //Is used in consignment Sales return
            List list9 = result.getEntityList();
            int count9 = list9.size();

            result = accMasterItemsDAOobj.getcustomer_warehouses(warehouseid, companyID); //Is used in Purchase Requisition?
            List list10 = result.getEntityList();
            int count10 = list10.size();

            if (count1 > 0 || count2 > 0 || count3 > 0 || count4 > 0 || count5 > 0 || count7 > 0 || count8 > 0 || count9 > 0 || count10 > 0) {
                return true;
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return false;
    }
    /**
     * Get Additional memo details in JSON 
     * @param requestParams
     * @return
     * @throws ServiceException
     * @throws JSONException 
     */
    @Override
    public JSONObject getAdditionalMemo(JSONObject requestParams) throws ServiceException, JSONException {
        JSONObject detailsJSON = new JSONObject();
        try {
            JSONArray additionalMemoArray = new JSONArray();
            List<AdditionalMemo> additionalMemoList = accInvoiceDAOobj.getAdditionalMemo(requestParams);
            for (AdditionalMemo additionalMemoObject : additionalMemoList) {
                JSONObject additionalMemoJSON = new JSONObject();
                additionalMemoJSON.put("id", additionalMemoObject.getId());
                additionalMemoJSON.put("name", additionalMemoObject.getName());
                additionalMemoJSON.put("code", additionalMemoObject.getCode());
                additionalMemoArray.put(additionalMemoJSON);
            }
            detailsJSON.put("data", additionalMemoArray);
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return detailsJSON;
    }
    /**
     * Description: build default Batch Serial JSON for warehouse and location -Mobile Apps (POS and Android)
     * @param paramJobj
     * @return JSONObject
     */
     public JSONObject buildBatchSerialJson(JSONObject paramJObj, JSONObject detailObj,Product prodObj) throws ServiceException, ParseException, SessionExpiredException {
        JSONObject detailsJSON = detailObj;
        JSONArray jArray = new JSONArray();
        try {
             
            if (prodObj!=null &&  paramJObj.has("storeid") && !StringUtil.isNullOrEmpty(paramJObj.optString("storeid"))) {
                JSONObject jObj = new JSONObject();
                jObj.put("location",prodObj.getLocation()!=null?prodObj.getLocation().getId():"" );
                jObj.put("warehouse", paramJObj.optString("storeid"));
                jObj.put("productid",prodObj.getID());
                jObj.put("documentid", "");
                jObj.put("purchasebatchid", "");
                jObj.put("quantity",detailObj.optString("quantity"));
                jArray.put(jObj);
            }
            detailsJSON.put("batchdetails",jArray.toString());
        } catch (JSONException e) {
            throw ServiceException.FAILURE("Exception occurred while populating masters information", "erp23", false);
        }
        return detailsJSON;
    }
     
     /**
     * Save temporary saved attachment files mapping in permanent table
     * @param jsonObj
     * @return
     * @throws ServiceException 
     */
    public KwlReturnObject saveDocuments(JSONObject jsonObj) throws ServiceException{
        List list = new ArrayList();
        try{
           KwlReturnObject result= accSalesOrderServiceobj.saveDocuments(jsonObj);
           list = result.getEntityList();
        } catch(Exception ex){
            Logger.getLogger(AccInvoiceModuleServiceImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("AccInvoiceModuleServiceImpl.saveDocuments:" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list!=null?list.size():0);
    }
    
}
