/*
 * Copyright (C) 2012  Krawler Information Systems Pvt Ltd
 * All rights reserved.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
package com.krawler.spring.accounting.product;

import com.krawler.common.admin.*;
import com.krawler.common.dao.BaseDAO;
import com.krawler.common.service.ServiceException;
import com.krawler.common.session.SessionExpiredException;
import com.krawler.common.util.*; //INV_ACC_MERGE
import com.krawler.hql.accounting.*;
import com.krawler.inventory.model.frequency.Frequency;
import com.krawler.inventory.model.inspection.InspectionTemplate;
import com.krawler.inventory.model.location.Location;
import com.krawler.inventory.model.packaging.Packaging;
import com.krawler.inventory.model.store.Store;
import com.krawler.spring.accounting.account.accAccountDAO;
import com.krawler.spring.accounting.assemblyQA.AssemblyProductApprovalDetails;
import com.krawler.spring.accounting.assemblyQA.AssemblyQAStatus;
import com.krawler.spring.accounting.currency.accCurrencyDAO;
import com.krawler.spring.accounting.customDesign.CustomDesignerConstants;
import com.krawler.spring.accounting.handler.AccountingHandlerDAO;
import com.krawler.spring.accounting.handler.AccountingManager;
import com.krawler.spring.accounting.journalentry.accJournalEntryDAO;
import com.krawler.spring.authHandler.authHandler;
import com.krawler.spring.authHandler.authHandlerDAO;
import com.krawler.spring.common.KwlReturnObject;
import com.krawler.spring.common.fieldManagerDAO;
import com.krawler.spring.common.kwlCommonTablesDAO;
import com.krawler.spring.storageHandler.storageHandlerImpl;
import com.krawler.spring.sessionHandler.sessionHandlerImpl;
import com.krawler.utils.json.base.JSONArray;
import com.krawler.utils.json.base.JSONException;
import com.krawler.utils.json.base.JSONObject;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.sql.SQLException;
import java.text.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.joda.time.DateTime;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import com.krawler.spring.accounting.companypreferances.accCompanyPreferencesDAO;
import org.springframework.web.servlet.support.RequestContextUtils;
import org.springframework.context.MessageSource;
/**
 *
 * @author krawler
 */
public class accProductImpl extends BaseDAO implements accProductDAO {
    private accJournalEntryDAO accJournalEntryobj;
    private accAccountDAO accAccountDAOobj;
    private fieldManagerDAO fieldManagerDAOobj;
    private AccountingHandlerDAO accountingHandlerDAOobj;
    private kwlCommonTablesDAO kwlCommonTablesDAOObj;
    private accCurrencyDAO accCurrencyDAOobj;
    private accCompanyPreferencesDAO accCompanyPreferencesObj;
    private MessageSource messageSource;

    
    public void setaccCompanyPreferencesDAO(accCompanyPreferencesDAO accCompanyPreferencesObj) {
        this.accCompanyPreferencesObj = accCompanyPreferencesObj;
    }
    public void setMessageSource(MessageSource msg) {
        this.messageSource = msg;
    }

    public void setAccJournalEntryDAO(accJournalEntryDAO accJournalEntryobj) {
        this.accJournalEntryobj = accJournalEntryobj;
    }
    public void setaccAccountDAO(accAccountDAO accAccountDAOobj) {
        this.accAccountDAOobj = accAccountDAOobj;
    }

    public void setFieldManagerDAO(fieldManagerDAO fieldManagerDAOobj) {
        this.fieldManagerDAOobj = fieldManagerDAOobj;
    }
    
    public void setaccountingHandlerDAO(AccountingHandlerDAO AccountingHandlerDAOobj) {
        this.accountingHandlerDAOobj = AccountingHandlerDAOobj;
    }
    
    public void setkwlCommonTablesDAO(kwlCommonTablesDAO kwlCommonTablesDAOObj) {
        this.kwlCommonTablesDAOObj = kwlCommonTablesDAOObj;
    }
    
     public void setaccCurrencyDAO(accCurrencyDAO accCurrencyDAOobj) {
        this.accCurrencyDAOobj = accCurrencyDAOobj;
    }
    @Override
    public KwlReturnObject getReportSchema(Map<String, Object> requestParams) throws ServiceException {
        KwlReturnObject results;
        try{
            String sql = "SELECT * FROM reportschema";
            String condition = "";
            
            List params = new ArrayList();
            if(requestParams.containsKey("reportId")) {
                String id = (String) requestParams.get("reportId");
                condition += (StringUtil.isNullOrEmpty(condition)? " where " : " and ") + " id = ?";
                params.add(id);
            }
            
            sql += condition;
            List list = executeSQLQuery(sql, params.toArray());
            results = new KwlReturnObject(true, null, null, list, list.size());
        } catch (Exception ex) {
            results = new KwlReturnObject(false, "accProductImpl.getProducts:" + ex.getMessage(), null, null, 0);
        }
        return results;
    }
    public KwlReturnObject getObject(String classpath, String id) throws ServiceException {
        List list = new ArrayList();
        try {
            Class cls = Class.forName(classpath);
            Object obj = get(cls, id);
            list.add(obj);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    public KwlReturnObject getObject(String classpath, int id) throws ServiceException {
        List list = new ArrayList();
        try {
            Class cls = Class.forName(classpath);
            Object obj = get(cls, id);
            list.add(obj);
        } catch (ClassNotFoundException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject getInventoryWOdetails(HashMap<String, Object> requestParams) throws ServiceException {
        String ss = (String) requestParams.get("ss");
        ArrayList params = new ArrayList();
        params.add((String) requestParams.get("productid"));
        params.add((String) requestParams.get("companyid"));
        String condition = " and inven.deleted=false and inven.company.companyID=? and (inven.invrecord = true and inven.quantity > 0) ";
        if (StringUtil.isNullOrEmpty(ss) == false) {
            params.add(ss + "%");
            condition += " and inven.product.name like ?";
        }
        String query = "select inven from "
                + "Inventory inven "
                + "where "
                + "    inven not in (select inventory from InvoiceDetail invd) "
                + "and inven not in (select inventory from CreditNoteDetail cnd)"
                + "and inven not in (select inventory from GoodsReceiptDetail cnd)"
                + "and inven not in (select inventory from DebitNoteDetail cnd)"
                + " and inven.product.ID = ? " + condition
                + " group by inven.ID";
        List list = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getInventoryWithDetails(HashMap<String, Object> requestParams) throws ServiceException {
        String start = (String) requestParams.get("start");
        String limit = (String) requestParams.get("limit");
        String ss = (String) requestParams.get("ss");
        ArrayList params = new ArrayList();
        params.add((String) requestParams.get("productid"));
        params.add((String) requestParams.get("companyid"));
        String condition = " and inven.deleted=false and inven.company.companyID=?  and (inven.invrecord = true and inven.quantity > 0) ";
        if (StringUtil.isNullOrEmpty(ss) == false) {
            params.add(ss + "%");
            condition += " and inven.product.name like ?";
        }
        String query = "select inven, je from "
                + "Inventory inven, JournalEntry je "
                + "where ("
                + "    inven.ID in (select ID from InvoiceDetail where invoice.journalEntry=je)"
                + " or inven.ID in (select inventory.ID from CreditNoteDetail where creditNote.journalEntry=je)"
                + " or inven.ID in (select ID from GoodsReceiptDetail where goodsReceipt.journalEntry=je)"
                + " or inven.ID in (select inventory.ID from DebitNoteDetail where debitNote.journalEntry=je)"
                + ") and je.deleted=false and inven.product.ID = ? " + condition
                + " order by je.entryNumber ASC";
        List list = executeQuery( query, params.toArray());
        int count = list.size();
//        if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
//            list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
//        }
        return new KwlReturnObject(true, "", null, list, count);
    }

    public KwlReturnObject getProductsForCombo(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        String condition = "";
        int moduleID = 0;
        ArrayList params = new ArrayList();
        boolean ismultiselectProductids = false;

        /**
         * ismultiselectProductids : check true when getting selected products
         * 
         */
        if (requestParams.containsKey("ismultiselectProductids") && requestParams.get("ismultiselectProductids") != null) {
            ismultiselectProductids = Boolean.parseBoolean(requestParams.get("ismultiselectProductids").toString());
        }
        String productid = (String) requestParams.get("productid");
        String companyid = (String) requestParams.get("companyid");
        String ids[] = (String[]) requestParams.get("ids");
        if (requestParams.containsKey("moduleid") && requestParams.get("moduleid") != null) {
            moduleID = Integer.parseInt(requestParams.get("moduleid").toString());
        }
        int start = 0;
        int limit = 15;
        boolean pagingFlag = false;
        boolean quickSearchFlag = false;

        boolean isFixedAsset = false;
        if (requestParams.containsKey("isFixedAsset")) {
            isFixedAsset = (Boolean) requestParams.get("isFixedAsset");
        }
        boolean isSalesPrice = false;
        if (requestParams.containsKey("isSalesPrice")) {
            isSalesPrice = (Boolean) requestParams.get("isSalesPrice");
        }
       
        boolean includeBothFixedAssetAndProductFlag = false;
        if (requestParams.containsKey("includeBothFixedAssetAndProductFlag")) {
            includeBothFixedAssetAndProductFlag = (Boolean) requestParams.get("includeBothFixedAssetAndProductFlag");
        }

        boolean excludeParent = false;
        if (requestParams.containsKey("excludeParent") && !StringUtil.isNullOrEmpty(requestParams.get("excludeParent").toString())) {
            excludeParent = Boolean.parseBoolean(requestParams.get("excludeParent").toString());
        }
        // For Inventory -Product use in inventory only when werehouse and location enable for that.
        boolean isStoreLocationEnable = false;
        if (requestParams.containsKey("isStoreLocationEnable") && !StringUtil.isNullOrEmpty(requestParams.get("isStoreLocationEnable").toString())) {
            isStoreLocationEnable = Boolean.parseBoolean(requestParams.get("isStoreLocationEnable").toString());
        }
        // For Inventory -Product use in inventory only when werehouse and location is set for that.
        boolean isWarehouseLocationSet = false;
        if (requestParams.containsKey("isWarehouseLocationSet") && !StringUtil.isNullOrEmpty(requestParams.get("isWarehouseLocationSet").toString())) {
            isWarehouseLocationSet = Boolean.parseBoolean(requestParams.get("isWarehouseLocationSet").toString());
        }
        
        boolean isInventoryForm=false;
        if (requestParams.containsKey("isInventoryForm") && !StringUtil.isNullOrEmpty( (String) requestParams.get("isInventoryForm"))) {
            isInventoryForm = Boolean.parseBoolean( (String) requestParams.get("isInventoryForm"));
        }
        
        boolean isWastageApplicable = false;
        if (requestParams.containsKey("isWastageApplicable")) {
            isWastageApplicable = (Boolean) requestParams.get("isWastageApplicable");
        }
        boolean isForBarcode = false;
        if (requestParams.containsKey("isForBarcode")) {
            isForBarcode = (Boolean) requestParams.get("isForBarcode");
        }
        
        String productStore = "";
        if (requestParams.containsKey("productStore")) {
            productStore =  requestParams.get("productStore").toString();
        }
        
        String affecteduser = (String) requestParams.get("affecteduser");
        if (requestParams.containsKey("start") && requestParams.containsKey("limit") && !StringUtil.isNullOrEmpty(requestParams.get("start").toString())) {
            start = Integer.parseInt(requestParams.get("start").toString());
            limit = Integer.parseInt(requestParams.get("limit").toString());
            pagingFlag = true;
        }

        String date = (String) requestParams.get("transactiondate");
        String producttype = (String) requestParams.get("type");
        DateFormat df = (DateFormat) requestParams.get("df");

        Date transactionDate = null;
        try {
            transactionDate = (date == null ? null : df.parse(date));
        } catch (ParseException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("getProducts : " + ex.getMessage(), ex);
        }
        params.add(companyid);
        if (ids != null) {
            condition += " and p.ID in(? ";
            params.add(null);
            for (int i = 0; i < ids.length; i++) {
                if (!StringUtil.isNullOrEmpty(ids[i])) {
                    condition += " ,?";
                    params.add(ids[i]);
                }
            }
            condition += " )";
        }
        if (!StringUtil.isNullOrEmpty(producttype)) {
            condition += " and p.producttype.ID=? ";
            params.add(producttype);
        }

        if (!includeBothFixedAssetAndProductFlag) {
            condition += " and p.asset=? ";
            params.add(isFixedAsset);
        }
        
        if (requestParams.containsKey("natureOfStockItem") && requestParams.get("natureOfStockItem")!=null) {
            condition += " and p.natureofStockItem=? ";
            params.add(requestParams.get("natureOfStockItem").toString());
        }

        if (isStoreLocationEnable) {
            condition += " and p.iswarehouseforproduct = 'T' and p.islocationforproduct = 'T' ";
//            params.add(isStoreLocationEnable);
//            params.add(isStoreLocationEnable);
        }
        
        if (isWastageApplicable) {
            condition += " and p.wastageApplicable = true ";
        }
        
        if (!StringUtil.isNullOrEmpty(productStore)) {
            condition += " and p.warehouse.id = ? ";
            params.add(productStore);
        }
        
        if (storageHandlerImpl.GetSATSCompanyId().contains(companyid)) {  //This is sats specific code 
            if(moduleID == Constants.Acc_Vendor_Invoice_ModuleId || moduleID == Constants.Acc_Purchase_Order_ModuleId || moduleID == Constants.Acc_Vendor_Quotation_ModuleId ){
                condition+=" and p.producttype.ID <>? ";
                params.add(Producttype.ASSEMBLY);
            }
        }else{
            if (moduleID == Constants.Acc_Invoice_ModuleId || moduleID == Constants.Acc_ConsignmentRequest_ModuleId || moduleID == Constants.Acc_Customer_Quotation_ModuleId || moduleID == Constants.Acc_Sales_Order_ModuleId || moduleID == Constants.Acc_Delivery_Order_ModuleId || moduleID == Constants.Acc_Sales_Return_ModuleId || isSalesPrice
                    || moduleID == Constants.Acc_Cash_Sales_ModuleId) {
                    condition += " and p.producttype.ID <>? ";
                    params.add(Producttype.Inventory_Non_Sales);
            }else if(moduleID == Constants.VENDOR_JOB_WORKORDER_MODULEID ){
                condition += " and p.producttype.ID = ? ";
                params.add(Producttype.CUSTOMER_ASSEMBLY);
            }
        }
        /*
          *If product is selected 
          */
        if (requestParams.containsKey("selectedProductIds") && requestParams.get("selectedProductIds") != null) {
            String selectedProductIds = requestParams.get("selectedProductIds").toString();
            selectedProductIds = AccountingManager.getFilterInString(selectedProductIds);
            if (ismultiselectProductids) {
                condition += " and p.id IN " + selectedProductIds;
            } else {
                condition += " and p.id NOT IN " + selectedProductIds;
            }
        }
        if(isInventoryForm){ 
            condition += " and p.producttype.ID IN (?,?,?)";
            params.add(Producttype.ASSEMBLY );    
            params.add(Producttype.INVENTORY_PART);    
            params.add(Producttype.Inventory_Non_Sales);
        }
        int productsearchingflag = 1;
        if (requestParams.containsKey(Constants.PRODUCT_SEARCH_FLAG) && requestParams.get(Constants.PRODUCT_SEARCH_FLAG) != null) {
            productsearchingflag = Integer.parseInt(requestParams.get(Constants.PRODUCT_SEARCH_FLAG).toString());
        }
        if (requestParams.containsKey("ss") && requestParams.get("ss") != null && !ismultiselectProductids) {
            String ss = requestParams.get("ss").toString();
            String searchQuery = "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                if (isForBarcode) { // This flag is used to get exact match of product id for barcode reader.
                    searchQuery = " and ( p.productid = ? or p.barcode = ? )";
                    params.add(ss);
                    params.add(ss);
                } else {
                    String[] searchcol = new String[]{"p.name", "p.productid"};
                    try {
                        Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                        map.put(Constants.PRODUCT_SEARCH_FLAG, productsearchingflag);
                        StringUtil.insertParamSearchString(map);
                        
                    } catch (SQLException ex) {
                        Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                }
                condition += searchQuery;
                quickSearchFlag = true;
            }
        }
        
         //search alphabetically on product name for android 
        if (requestParams.containsKey(Constants.sortstring) && requestParams.get(Constants.sortstring) != null) {
            String mobilesearch = requestParams.get(Constants.sortstring).toString().toUpperCase();
            if (!StringUtil.isNullOrEmpty(mobilesearch)) {
                if (!mobilesearch.equalsIgnoreCase(Constants.NON_ALPHANUMERIC)) {
                    String[] searchArray = mobilesearch.split(",");
                    String[] searchcol = new String[searchArray.length];

                    for (int i = 0; i < searchArray.length; i++) {
                        searchcol[i] = "p.name";
                        params.add(searchArray[i].trim() + "%");
                        params.add(searchArray[i].trim() + "%");
                    }

                    String searchQuery = StringUtil.getSearchString(mobilesearch, "and", searchcol);
                    condition += searchQuery;
                    quickSearchFlag = true;
                } else {
                    /**
                     * sort string key is non alphanumeric for Product Name
                     * starts with any Special Characters.
                     */
                    condition += "and ( (p.name NOT BETWEEN 'a' and 'z') and (p.name NOT BETWEEN 'A' and 'Z') and (p.name NOT BETWEEN '0' and '9'))";
                    condition += "and p.name NOT LIKE 'z%' and p.name NOT LIKE 'Z%' and p.name NOT LIKE '9%'";//for excluding EndPoint from Between Condition
                }
            }
        }
            
        if (!quickSearchFlag && !excludeParent) {
            condition += " and p.parent is null ";
        }

        if (requestParams.containsKey("searchProductString") && requestParams.get("searchProductString") != null) {
            String searchProductString = requestParams.get("searchProductString").toString();
            if (!StringUtil.isNullOrEmpty(searchProductString)) {
                    condition += "  and ( p.productid = ? or p.barcode = ? )";
                    params.add(searchProductString.trim());
                    params.add(searchProductString.trim());
                }
                
            }

        if (requestParams.containsKey("customervendorcategory") && !StringUtil.isNullOrEmpty(requestParams.get("customervendorcategory").toString())) {
            condition += " and ( p.customerCategory like ? )";
            params.add("%" + requestParams.get("customervendorcategory")+ "%");
        }
        /*
         * Product search by Start with 'Product Name' and Any Match together (ERP-32842)
         */
        String ss = "",locateCondition="";
        if (requestParams.containsKey(Constants.ss) && !StringUtil.isNullOrEmpty((String) requestParams.get(Constants.ss))) {
            ss = requestParams.get("ss").toString().trim();
            locateCondition = "LOCATE('"+ ss +"', p.name),";
        }
        //Query changed for Ticket No : ERP-19352
        String orderBy = " order by "+ locateCondition +" length(p.productid),p.productid,p.producttype,p.name ";
        
        if (requestParams.containsKey("productsortingflag") && requestParams.get("productsortingflag") != null) {
             int productSortingFlag = Integer.parseInt(requestParams.get("productsortingflag").toString());
            if (productSortingFlag==0) {
                orderBy = " order by "+ locateCondition +" p.name,length(p.productid),p.producttype,p.productid ";
            } else if (productSortingFlag==1) {
                orderBy = " order by "+ locateCondition +" length(p.productid),p.productid,p.producttype, p.name ";
            }

        }
        /**
         * If Users Visibility is Enable then Append user condition
         */
        String customdatajoin = "";
        String usercondition = "";
        if (requestParams.containsKey("isUserVisibilityFlow") && requestParams.get("isUserVisibilityFlow") != null) {
            usercondition = (String) requestParams.get("appendusercondtion");
            customdatajoin = " inner join p.productCustomData pcd ";
        }
        String query = "select p from Product p "+customdatajoin+" where p.deleted=false and p.company.companyID=? " + condition +usercondition + orderBy;
        List list = executeQuery( query, params.toArray());
        int totalCount = list.size();
        
        if(pagingFlag && !ismultiselectProductids) {
            query = "select p from Product p "+customdatajoin+" where p.deleted=false and p.company.companyID=? " + condition +usercondition + orderBy;
            list = executeQueryPaging( query, params.toArray(), new Integer[]{start, limit});
        }
        
        return new KwlReturnObject(true, "", null, list, totalCount);
    }
    
    
    /* 
    
    This method is written for purposly because dependency in these controller 
    This method provides list of products with status - Tagged or Not tagged in Work Order   
    */
    public KwlReturnObject getWorkOrderProductsCombo(Map<String, Object> requestParams) throws ServiceException {
        ArrayList params = new ArrayList();
        String companyid = "";
        String workcenterid = "";
        String query = "";
        if (requestParams.containsKey("companyid")) {
            companyid = requestParams.get("companyid").toString();
            params.add(companyid);
        }
        if (requestParams.containsKey("workcenterid")) {
            workcenterid = requestParams.get("workcenterid").toString();
            params.add(workcenterid);
        }
            /* Query returns product ids which are used in workorder and mapped with product_workcentre_mapping table on the basis of work centre id and company id*/
            query = "SELECT distinct wo.productid "+
                    " FROM workorder wo "+
                    " INNER JOIN  product_workcentre_mapping wwm ON wwm.productid = wo.productid "+
                    " INNER JOIN workcenter wc ON wc.id = wwm.workcentreid "+
                    " WHERE wo.company =? AND wwm.workcentreid = ?";
                    
        List list = executeSQLQuery(query, params.toArray());
        int count = list.size();
        return new KwlReturnObject(true, "", null, list, count);
    }
    
    public KwlReturnObject getProductsForSelectionGrid(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        String condition = "";
        int moduleID = 0;
        String query = "", joinCondition = "";
        ArrayList params = new ArrayList();

        String productid = (String) requestParams.get("productid");
        String companyid = (String) requestParams.get("companyid");
        String ids[] = (String[]) requestParams.get("ids");
        String categoryid = (String) requestParams.get("categoryid");
        if (requestParams.containsKey("moduleid") && requestParams.get("moduleid") != null) {
            moduleID = Integer.parseInt(requestParams.get("moduleid").toString());
        }
        int start = 0;
        int limit = 15;
        boolean pagingFlag = false;
        boolean quickSearchFlag = false;

        boolean isFixedAsset = false;
        if (requestParams.containsKey("isFixedAsset")) {
            isFixedAsset = (Boolean) requestParams.get("isFixedAsset");
        }

        boolean includeBothFixedAssetAndProductFlag = false;
        if (requestParams.containsKey("includeBothFixedAssetAndProductFlag")) {
            includeBothFixedAssetAndProductFlag = (Boolean) requestParams.get("includeBothFixedAssetAndProductFlag");
        }

        boolean excludeParent = false;
        if (requestParams.containsKey("excludeParent") && !StringUtil.isNullOrEmpty(requestParams.get("excludeParent").toString())) {
            excludeParent = Boolean.parseBoolean(requestParams.get("excludeParent").toString());
        }
        // For Inventory -Product use in inventory only when werehouse and location enable for that.
        boolean isStoreLocationEnable = false;
        if (requestParams.containsKey("isStoreLocationEnable") && !StringUtil.isNullOrEmpty(requestParams.get("isStoreLocationEnable").toString())) {
            isStoreLocationEnable = Boolean.parseBoolean(requestParams.get("isStoreLocationEnable").toString());
        }
        // For Inventory -Product use in inventory only when werehouse and location is set for that.
        boolean isWarehouseLocationSet = false;
        if (requestParams.containsKey("isWarehouseLocationSet") && !StringUtil.isNullOrEmpty(requestParams.get("isWarehouseLocationSet").toString())) {
            isWarehouseLocationSet = Boolean.parseBoolean(requestParams.get("isWarehouseLocationSet").toString());
        }
        
        boolean isWastageApplicable = false;
        if (requestParams.containsKey("isWastageApplicable")) {
            isWastageApplicable = (Boolean) requestParams.get("isWastageApplicable");
        }

        if (isWastageApplicable) {
            condition += " and p.iswastageapplicable ='T' ";
        }
        String affecteduser = (String) requestParams.get("affecteduser");
        if (requestParams.containsKey("start") && requestParams.containsKey("limit") && !StringUtil.isNullOrEmpty(requestParams.get("start").toString())) {
            start = Integer.parseInt(requestParams.get("start").toString());
            limit = Integer.parseInt(requestParams.get("limit").toString());
            pagingFlag = true;
        }

        String date = (String) requestParams.get("transactiondate");
        String producttype = (String) requestParams.get("type");
        DateFormat df = (DateFormat) requestParams.get("df");

        Date transactionDate = null;
        try {
            transactionDate = (date == null ? null : df.parse(date));
        } catch (ParseException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("getProducts : " + ex.getMessage(), ex);
        }
        params.add(companyid);
        if (ids != null) {
            if (ids.length > 0 && !StringUtil.isNullOrEmpty(ids[0])) {
                condition += " and p.id in(? ";
                params.add(null);
                for (int i = 0; i < ids.length; i++) {
                    if (!StringUtil.isNullOrEmpty(ids[i])) {
                        condition += " ,?";
                        params.add(ids[i]);
                    }
                }
                condition += " )";
            }
        }
        if (!StringUtil.isNullOrEmpty(producttype)) {
            condition += " and p.producttype=? ";
            params.add(producttype);
        }

        if (!includeBothFixedAssetAndProductFlag) {
            condition += " and p.isasset=? ";
            params.add(isFixedAsset);
        }
        if (!StringUtil.isNullOrEmpty(categoryid)) {

            if (!StringUtil.isNullOrEmpty(categoryid) && !StringUtil.equal(categoryid, "All")) {
                condition += " and  pm.productcategory = ? ";
                joinCondition  += "inner join productcategorymapping pm on p.id=pm.productid ";
                params.add(categoryid);
            }
            if (StringUtil.equal(categoryid, "All")) {
                joinCondition = "left join productcategorymapping pm on p.id=pm.productid ";
            }
            joinCondition += "left join masteritem mi on mi.id=pm.productcategory and mi.masterGroup='19'";
        } else {
            joinCondition += "left join productcategorymapping pm on p.id=pm.productid ";
            joinCondition += "left join masteritem mi on mi.id=pm.productcategory and mi.masterGroup='19'";
        }

        if (isStoreLocationEnable) {
            condition += " and p.iswarehouseforproduct = 'T' and p.islocationforproduct = 'T' ";
        }

        if (moduleID == Constants.Acc_Invoice_ModuleId || moduleID == Constants.Acc_ConsignmentRequest_ModuleId || moduleID == Constants.Acc_Customer_Quotation_ModuleId || moduleID == Constants.Acc_Sales_Order_ModuleId || moduleID == Constants.Acc_Delivery_Order_ModuleId || moduleID == Constants.Acc_Sales_Return_ModuleId
                || moduleID == Constants.Acc_Cash_Sales_ModuleId) {
            condition += " and p.producttype <>? ";
            params.add(Producttype.Inventory_Non_Sales);
        }else if(moduleID == Constants.Acc_Stock_Adjustment_ModuleId || moduleID == Constants.Acc_Stock_Request_ModuleId || moduleID == Constants.Acc_InterStore_ModuleId || moduleID == Constants.Acc_InterLocation_ModuleId){
            condition += " and p.producttype IN (?,?,?)";
            params.add(Producttype.ASSEMBLY );    
            params.add(Producttype.INVENTORY_PART);    
            params.add(Producttype.Inventory_Non_Sales);
        }


        if (requestParams.containsKey("ss") && requestParams.get("ss") != null) {
            String ss = requestParams.get("ss").toString();
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"p.name", "p.productid"};
                try {
                    Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                    StringUtil.insertParamSearchString(map);
                } catch (SQLException ex) {
                    Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
                quickSearchFlag = true;
            }
        }
        if (!quickSearchFlag && !excludeParent) {
            condition += " and p.parent is null ";
        }

        if (requestParams.containsKey("searchProductString") && requestParams.get("searchProductString") != null) {
            String searchProductString = requestParams.get("searchProductString").toString();
            if (!StringUtil.isNullOrEmpty(searchProductString)) {
                condition += " and p.productid= ? ";
                params.add(searchProductString.trim());
            }

        }
        //Query changed for Ticket No : ERP-19352
        String orderBy = " order by length(p.productid),p.productid,p.producttype,p.name ";
        
        if (requestParams.containsKey("productsortingflag") && requestParams.get("productsortingflag") != null) {
            int productSortingFlag = Integer.parseInt(requestParams.get("productsortingflag").toString());
            if (productSortingFlag==0) {
                orderBy = " order by  mi.value,p.name,length(p.productid),p.producttype,p.productid ";
            } else if (productSortingFlag==1) {
                orderBy = " order by  mi.value,length(p.productid),p.productid,p.producttype,p.name ";
            }

        }
        
        if (requestParams.containsKey("customervendorcategory") && !StringUtil.isNullOrEmpty(requestParams.get("customervendorcategory").toString())) {
            condition += " and ( p.customerCategory like ? )";
            params.add("%" + requestParams.get("customervendorcategory") + "%");
        }
        List list = null;
        int totalCount = 0;
        /*
            To include only active products in product select window isactive='T' is added (SDP-3953)
        */
        /**
         * if Users visibility enable and current user is not admin
         */
        String customdatajoin = "";
        String usercondition = "";
        if (requestParams.containsKey("isUserVisibilityFlow") && requestParams.get("isUserVisibilityFlow") != null) {
            usercondition = (String) requestParams.get("appendusercondtion");
            customdatajoin = " inner join accproductcustomdata pcd on pcd.productId=p.id  ";
//            usercondition = " and (" + appendusercondtion + ")";
        }
        query = "select p.id,pm.productcategory from product p " + customdatajoin+joinCondition + " where  p.deleteflag = 'F' and p.isactive='T' and p.company=?  " + condition+usercondition +" group by p.id "+ orderBy ;
        list = executeSQLQuery( query, params.toArray());
        totalCount = list.size();

        if (pagingFlag) {
            query = "select p.id,pm.productcategory from product p " + customdatajoin +joinCondition + " where p.deleteflag = 'F' and p.isactive='T' and p.company=? " + condition+usercondition +" group by p.id "+ orderBy;
            list = executeSQLQueryPaging( query, params.toArray(), new Integer[]{start, limit});
        }

        return new KwlReturnObject(true, "", null, list, totalCount);
    }
    
    public KwlReturnObject getUserMappedProducts(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        String condition = "";
//        int moduleID = 0 ;
        ArrayList params = new ArrayList();

//        String productid = (String) requestParams.get("productid");
        String companyid = (String) requestParams.get("companyid");
        String affecteduser = (String) requestParams.get("affecteduser");
        Boolean isCustomer = Boolean.parseBoolean((String) requestParams.get("isCustomer"));
        DateFormat df = (DateFormat) requestParams.get("df");

        params.add(companyid);

        String query = "";
        if (!StringUtil.isNullOrEmpty(affecteduser) && !isCustomer) {
            condition += "and vpm.vendor.ID=?";
            params.add(affecteduser);
            query = "select vpm.products,vpm.jsonstring from VendorProductMapping vpm inner join vpm.products p where  p.deleted=false  and p.isActive='T' and p.company.companyID=? " + condition + " order by p.producttype, p.name ";
        } else {
            condition += "and cpm.customer.ID=?";
            params.add(affecteduser);
            query = "select cpm.products,cpm.jsonstring from CustomerProductMapping cpm inner join cpm.products p where  p.deleted=false and  p.isActive='T' and p.company.companyID=? " + condition + " order by p.producttype, p.name ";
        }

//        query="select vpm.products from VendorProductMapping vpm inner join vpm.products p where  p.deleted=false and p.company.companyID=? "+condition+" order by p.producttype, p.name ";
        List list = executeQuery( query, params.toArray());
        int totalCount = list.size();
        return new KwlReturnObject(true, "", null, list, totalCount);
    }

    @Override
    public KwlReturnObject getProductsIds(HashMap<String, Object> requestParams) throws ServiceException {
        KwlReturnObject results;
        try{
            Long totalCount =0l;
            List returnList = new ArrayList();
            String condition = "";
            ArrayList params = new ArrayList();

            String companyid = (String) requestParams.get("companyid");
            int showallproduct = 1;
            if (requestParams.containsKey("showallproduct")) {
                showallproduct = (Integer) requestParams.get("showallproduct");
            }

            params.add(companyid);

            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (requestParams.containsKey("filterConjuctionCriteria") && requestParams.get("filterConjuctionCriteria") != null) {
                if (requestParams.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            String searchJoin = "";
            String searchDefaultFieldSQL = "";
            if (requestParams.containsKey("searchJson") && requestParams.get("searchJson") != null) {
                Searchjson = requestParams.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    JSONObject serachJobj = new JSONObject(Searchjson);
                    JSONArray customSearchFieldArray = new JSONArray();
                    JSONArray defaultSearchFieldArray = new JSONArray();
                    StringUtil.seperateCostomAndDefaultSerachJson(serachJobj, customSearchFieldArray, defaultSearchFieldArray);
                    if (defaultSearchFieldArray.length() > 0) {
                        /*
                         Advance Search For Default Form fields
                         */
                        ArrayList tableArray = new ArrayList();
                        tableArray.add("customer"); //this table array used to identified wheather join exists on table or not                         
                        Map<String, Object> map = buildSqlDefaultFieldAdvSearch(defaultSearchFieldArray, params, ""+Constants.Acc_Product_Master_ModuleId, tableArray, filterConjuctionCriteria);
                        searchJoin += map.containsKey("searchjoin") ? map.get("searchjoin") : "";
                        searchDefaultFieldSQL = (String) (map.containsKey("condition") ? map.get("condition") : "");
                        searchDefaultFieldSQL = searchDefaultFieldSQL.replaceAll("productRef", "p");
                    }
                    if (customSearchFieldArray.length() > 0) {   //Advance search case for Custome field
                        requestParams.put(Constants.Searchjson, Searchjson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "p.productCustomData");
                        mySearchFilterString = mySearchFilterString.replaceAll("accproductcustomdata", "p.productCustomData");
                        StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                    }
                    mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(searchDefaultFieldSQL, mySearchFilterString, filterConjuctionCriteria);
                }
            }

            
            String query = "select p.ID from Product p where p.company.companyID=? " + condition + mySearchFilterString ;
            String countQuery = "select count(p.ID) as count from Product p where p.company.companyID=? " + condition + mySearchFilterString;
            List cntlist = executeQuery( countQuery, params.toArray());
            if (cntlist != null && !cntlist.isEmpty()){
                totalCount = (Long) cntlist.get(0);
            }
            List<Product> list = executeQuery( query, params.toArray());
            
            results=new KwlReturnObject(true, "", null, list, totalCount.intValue());
        } catch (Exception ex) {
            results = new KwlReturnObject(false, "accProductImpl.getProducts:" + ex.getMessage(), null, null, 0);
        }
        return results;
    }
        
    @Override
    public KwlReturnObject getProducts(HashMap<String, Object> requestParams) throws ServiceException {
        KwlReturnObject results;
        try{
            Long totalCount =0l;
            List returnList = new ArrayList();
            String condition = "";
            String joinCondition = "";
            ArrayList params = new ArrayList();

            String productid = (String) requestParams.get("productid");
            String companyid = (String) requestParams.get("companyid");
            String ids[] = (String[]) requestParams.get("ids");
            int start = 0;
            int limit = 15;
            boolean pagingFlag = false;
            boolean quickSearchFlag = false;
            boolean isFixedAsset = false, isFixedAssetSummaryReport = false;
            int showallproduct = 1;
            if (requestParams.containsKey("showallproduct")) {
                showallproduct = (Integer) requestParams.get("showallproduct");
            }
            if (requestParams.containsKey("isFixedAsset")) {
                isFixedAsset = (Boolean) requestParams.get("isFixedAsset");
            }
            if (requestParams.containsKey("isFixedAssetSummaryReport")) {
                isFixedAssetSummaryReport = (Boolean) requestParams.get("isFixedAssetSummaryReport");
            }
            String affecteduser = (String) requestParams.get("affecteduser");
            if (requestParams.containsKey("start") && requestParams.containsKey("limit") && !StringUtil.isNullOrEmpty(requestParams.get("start").toString())) {
                start = Integer.parseInt(requestParams.get("start").toString());
                limit = Integer.parseInt(requestParams.get("limit").toString());
                pagingFlag = true;
            }

            String date = (String) requestParams.get("transactiondate");
            String producttype = (String) requestParams.get("type");
            DateFormat df = (DateFormat) requestParams.get("df");

            Date transactionDate = null;
            try {
                transactionDate = (date == null ? null : df.parse(date));
            } catch (ParseException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                throw ServiceException.FAILURE("getProducts : " + ex.getMessage(), ex);
            }
            params.add(companyid);
            if (ids != null) {
                condition += " and p.ID in(? ";
                params.add(null);
                for (int i = 0; i < ids.length; i++) {
                    if (!StringUtil.isNullOrEmpty(ids[i])) {
                        condition += " ,?";
                        params.add(ids[i]);
                    }
                }
                condition += " )";
            }
            if (!StringUtil.isNullOrEmpty(producttype)) {
                condition += " and p.producttype.ID=? ";
                params.add(producttype);
            }
            
            String productTypeFilter = "";

            if (requestParams.containsKey("productTypeFilter") && !StringUtil.isNullOrEmpty((String) requestParams.get("productTypeFilter"))) {
                productTypeFilter = (String) requestParams.get("productTypeFilter");

                if (!productTypeFilter.equalsIgnoreCase("All") && !StringUtil.isNullOrEmpty(productTypeFilter)) {
                    productTypeFilter = (String) requestParams.get("productTypeFilter");
//                    productType = (requestParams.get("productType").toString());
                    productTypeFilter = AccountingManager.getFilterInString(productTypeFilter);
                }
            }

            
            if (!productTypeFilter.equalsIgnoreCase("All") && !StringUtil.isNullOrEmpty(productTypeFilter)) {
                condition += " and  p.producttype.ID in " + productTypeFilter;
               
            }
            boolean includeParent = false; // used in product view case
            if (requestParams.containsKey("includeParent") && !StringUtil.isNullOrEmpty(requestParams.get("includeParent").toString())) {
                includeParent = Boolean.parseBoolean(requestParams.get("includeParent").toString());
            }
            if (requestParams.containsKey("ss") && requestParams.get("ss") != null) {
                String ss = requestParams.get("ss").toString().toUpperCase();
                if (!StringUtil.isNullOrEmpty(ss)) {
                    String[] searchcol = new String[]{"p.name", "p.productid", "p.producttype.name", "p.description"};
                    try {
                        Map map = StringUtil.insertParamSearchStringMap(params, ss, 4);
                        StringUtil.insertParamSearchString(map);
                    } catch (SQLException ex) {
                        Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                    condition += searchQuery;
                    quickSearchFlag = true;
                }
            }
            
            //search alphabetically on product name for android 
            if (requestParams.containsKey(Constants.sortstring) && requestParams.get(Constants.sortstring) != null) {
                String mobilesearch = requestParams.get(Constants.sortstring).toString().toUpperCase();
                if (!StringUtil.isNullOrEmpty(mobilesearch)) {
                    if (!mobilesearch.equalsIgnoreCase(Constants.NON_ALPHANUMERIC)) {
                        String[] searchArray = mobilesearch.split(",");
                        String[] searchcol = new String[searchArray.length];

                        for (int i = 0; i < searchArray.length; i++) {
                            searchcol[i] = "p.name";
                            params.add(searchArray[i].trim() + "%");
                            params.add(searchArray[i].trim() + "%");
                        }

                        String searchQuery = StringUtil.getSearchString(mobilesearch, "and", searchcol);
                        condition += searchQuery;
                        quickSearchFlag = true;
                    } else {
                        /**
                         * sort string key is non alphanumeric for Product Name
                         * starts with any Special Characters.
                         */
                        condition += "and ( (p.name NOT BETWEEN 'a' and 'z') and (p.name NOT BETWEEN 'A' and 'Z') and (p.name NOT BETWEEN '0' and '9'))";
                        condition += "and p.name NOT LIKE 'z%' and p.name NOT LIKE 'Z%' and p.name NOT LIKE '9%'";//for excluding EndPoint from Between Condition
                    }
                }
            }
            
            if (requestParams.containsKey("searchProductString") && requestParams.get("searchProductString") != null) {
                String searchProductString = requestParams.get("searchProductString").toString();
                if (!StringUtil.isNullOrEmpty(searchProductString)) {
                    condition += " and p.productid= ? ";
                    params.add(searchProductString.trim());
                }

            }
            if (!quickSearchFlag && !includeParent && showallproduct != 4) {
                condition += " and p.parent is null ";
            }
            condition += " and p.asset=? ";
            params.add(isFixedAsset);
            
            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (requestParams.containsKey("filterConjuctionCriteria") && requestParams.get("filterConjuctionCriteria") != null) {
                if (requestParams.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            String searchJoin = "";
            String searchDefaultFieldSQL = "";
            if (requestParams.containsKey("searchJson") && requestParams.get("searchJson") != null && !isFixedAssetSummaryReport) {
                Searchjson = requestParams.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    JSONObject serachJobj = new JSONObject(Searchjson);
                    JSONArray customSearchFieldArray = new JSONArray();
                    JSONArray defaultSearchFieldArray = new JSONArray();
                    StringUtil.seperateCostomAndDefaultSerachJson(serachJobj, customSearchFieldArray, defaultSearchFieldArray);
                    if (defaultSearchFieldArray.length() > 0) {
                        /*
                         Advance Search For Default Form fields
                         */
                        ArrayList tableArray = new ArrayList();
                        tableArray.add("customer"); //this table array used to identified wheather join exists on table or not                         
                        Map<String, Object> map = buildSqlDefaultFieldAdvSearch(defaultSearchFieldArray, params, ""+Constants.Acc_Product_Master_ModuleId, tableArray, filterConjuctionCriteria);
                        searchJoin += map.containsKey("searchjoin") ? map.get("searchjoin") : "";
//                        searchJoin += " left join solinking on solinking.docid=salesorder.id and solinking.sourceflag = 1 ";
                        searchDefaultFieldSQL = (String) (map.containsKey("condition") ? map.get("condition") : "");
                        searchDefaultFieldSQL = searchDefaultFieldSQL.replaceAll("productRef", "p");
                    }
                    if (customSearchFieldArray.length() > 0) {   //Advance search case for Custome field
                        requestParams.put(Constants.Searchjson, Searchjson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "p.productCustomData");
                        mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "p.productCustomData");
                        mySearchFilterString = mySearchFilterString.replaceAll("accproductcustomdata", "p.productCustomData");
                        StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                    }
                    mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(searchDefaultFieldSQL, mySearchFilterString, filterConjuctionCriteria);
                }
            }

            String orderBy = "";
            if (requestParams.containsKey("dir") && requestParams.containsKey("sort")) {
                String Col_Name = requestParams.get("sort").toString();
                String Col_Dir = requestParams.get("dir").toString();
                orderBy = sortColumnProduct(Col_Name, Col_Dir);
            } else {
                orderBy = " order by p.producttype.name, p.name ";
            }
            if (showallproduct == 1) {
                condition += " ";
            } else if (showallproduct == 2) {
                condition += " and p.deleted=false ";
            } else if (showallproduct == 4) {
                condition += " and p.availableQuantity > 0 ";
            } else if (showallproduct == 5) {
                condition += " and p.isActive=true ";
            } else if (showallproduct == 6) {
                condition += " and p.isActive=false ";
            } else {
                condition += " and p.deleted=true ";
            }
            
            if (requestParams.containsKey("wcid")) {
                List list = new ArrayList();
                ArrayList param = new ArrayList();
                String query1 = "select productid from product_workcentre_mapping where workcentreid = ?";
                param.add((String) requestParams.get("wcid"));
                list = executeSQLQuery(query1, param.toArray());
                String productIdStr = "";
                for (int i = 0; i<list.size(); i++) {
                    if (i == 0) {
                        productIdStr += "'" + list.get(i) + "'";
                    } else {
                        productIdStr += ",'" + list.get(i) + "'";
                    }
                }
                if (list.size() >  0) {
                    condition += " and p.ID in (" + productIdStr + ") ";
                } else {
                    condition += " and p.ID is NULL";
                }
            }
            /**
             * if Users visibility enable and current user is not admin
             */
            String customdatajoin = "";
            String usercondition = "";
            if (requestParams.containsKey("isUserVisibilityFlow") && requestParams.get("isUserVisibilityFlow") != null) {
                usercondition = (String) requestParams.get("appendusercondtion");
                customdatajoin = " inner join p.productCustomData pcd ";
            }
            String query = "select p from Product p "+customdatajoin+" where p.company.companyID=? " + condition +usercondition+ mySearchFilterString + orderBy;
            String countQuery = "select count(p.ID) as count from Product p "+customdatajoin+" where p.company.companyID=? " + condition+usercondition + mySearchFilterString + orderBy;
            List cntlist = executeQuery( countQuery, params.toArray());
            if (cntlist != null && !cntlist.isEmpty()){
                totalCount = (Long) cntlist.get(0);
            }
            List<Product> list = null;
            if (pagingFlag) {
                list = executeQueryPaging( query, params.toArray(), new Integer[]{start, limit});
            } else {
                list = executeQuery( query, params.toArray());
            }
            int level = 0;
            boolean isProductQuantityFromColumn=false;
            if (list != null && list.size() > 0) {
           isProductQuantityFromColumn = isProductQuantityFromColumn(companyid);
            }
            if(totalCount > 0){
                boolean namedQueryFlag = false;
                if (list.size() <= 1000 || pagingFlag) {
                    namedQueryFlag = true;
                }
                List<HashMap<String, Double>> purchaseSalesPriceList = getProductPurchaseAndSalesPriceMap(companyid, list, namedQueryFlag);
                HashMap<String, Double> productPurchasePriceMap = purchaseSalesPriceList.get(0);
                HashMap<String, Double> productSalesPriceMap = purchaseSalesPriceList.get(1);
                
                purchaseSalesPriceList = getProductInitialPurchaseAndSalesPriceMap(companyid, list, namedQueryFlag);
                HashMap<String, Double> productInitialPurchasePriceMap = purchaseSalesPriceList.get(0);
                HashMap<String, Double> productInitialSalesPriceMap = purchaseSalesPriceList.get(1);
                
                purchaseSalesPriceList = getProductInitialPurchaseAndSalesPriceDateWiseMap(companyid, list, namedQueryFlag, affecteduser, transactionDate);
                HashMap<String, Double> productPurchasePriceDateWiseMap = purchaseSalesPriceList.get(0);
                HashMap<String, Double> productSalesPriceDateWiseMap = purchaseSalesPriceList.get(1);
                
                Map<String, Double> availableQuantityMap = getAvailableQuantityMap(companyid, list, namedQueryFlag);
                Map<String, Double> initialQuantityMap = getInitialQuantityMap(companyid, list, namedQueryFlag);;
                Map<String, Object> proCreationDateMap = getProCreationDateMap(companyid, list, namedQueryFlag);;
                Map<String, Double> assemblyLockQuantityMap = getAssemblyLockQuantityMap(companyid, list, namedQueryFlag);;
                Map<String, Double> soLockQuantityMap = getSOLockQuantityMap(companyid, list, namedQueryFlag);;
                Map<String, Double> woLockQuantityMap = getWOLockQuantityMap(companyid, list, namedQueryFlag);;
                Map<String, Double> leasedQuantityMap = getLeasedQuantityMap(companyid, list, namedQueryFlag);;
                Map<String, Double> consignedQuantityMap = getConsignedQuantityMap(companyid, list, namedQueryFlag);;
                Map<String, Double> vendorConsignedQuantityMap = getVendorConsignedQuantityMap(companyid, list, namedQueryFlag);;
                Map<String, String> productCategoriesMap = getProductCategoriesMap(companyid, list, namedQueryFlag);;
                
                for (Product product : list) {
                    if (product.getID().equals(productid)) {
                        continue;
                    }
                    Object tmplist[] = new Object[18]; //0:Product, 1:level, 2:leaf
                    tmplist[0] = product;
                    tmplist[1] = level;
                    returnList.add(tmplist);
                    if (!quickSearchFlag && !includeParent && showallproduct != 4) {
                        tmplist[2] = getChildProducts(product, returnList, level, productid, transactionDate, affecteduser,isProductQuantityFromColumn);
                    } else {
                        tmplist[2] = true;
                    }

                    tmplist[3] = productPurchasePriceMap.get(product.getID());
                    tmplist[4] = productSalesPriceMap.get(product.getID());
                    if (isProductQuantityFromColumn) {
                        tmplist[5] = product.getAvailableQuantity(); // availableQuantity
                    } else {
                        tmplist[5] = availableQuantityMap.get(product.getID()); // availableQuantity
                    }

                    tmplist[6] = initialQuantityMap.get(product.getID());

                    tmplist[7] = productInitialPurchasePriceMap.get(product.getID());
                    tmplist[9] = productSalesPriceDateWiseMap.get(product.getID());
                    tmplist[10] = productPurchasePriceDateWiseMap.get(product.getID());
                    tmplist[11] = productInitialSalesPriceMap.get(product.getID());

                    tmplist[12] = proCreationDateMap.get(product.getID());
                    Double assmblyLockQuantity = 0.0;
                    Double SoLockQuantity = 0.0;
                    Double WOLockQuantity = 0.0;
                    if(assemblyLockQuantityMap.containsKey(product.getID()) && assemblyLockQuantityMap.get(product.getID()) != null){
                        assmblyLockQuantity = assemblyLockQuantityMap.get(product.getID());
                    }
                    if(soLockQuantityMap.containsKey(product.getID()) && soLockQuantityMap.get(product.getID()) != null){
                        SoLockQuantity = soLockQuantityMap.get(product.getID());
                    }
                    if(woLockQuantityMap.containsKey(product.getID()) && woLockQuantityMap.get(product.getID()) != null){
                        WOLockQuantity = woLockQuantityMap.get(product.getID());
                    }
                    tmplist[13] = assmblyLockQuantity + SoLockQuantity + WOLockQuantity; // lockquantity
                    tmplist[14] = leasedQuantityMap.get(product.getID());
                    tmplist[15] = consignedQuantityMap.get(product.getID());
                    tmplist[16] = vendorConsignedQuantityMap.get(product.getID());
                    if(productCategoriesMap.containsKey(product.getID()) && productCategoriesMap.get(product.getID()) != null){
                        tmplist[17] = productCategoriesMap.get(product.getID());
                    }
                }
            }
            results=new KwlReturnObject(true, "", null, returnList, totalCount.intValue());
        } catch (Exception ex) {
            results = new KwlReturnObject(false, "accProductImpl.getProducts:" + ex.getMessage(), null, null, 0);
        }
        return results;
    }
    
    private List<HashMap<String, Double>> getProductPurchaseAndSalesPriceMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(companyid);
        params.add("-1");
        
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }
        HashMap<String, Double> productPurchasePriceMap = new HashMap<String, Double>();
        HashMap<String, Double> productSalesPriceMap = new HashMap<String, Double>();
        String getProductPurchaseAndSalesPriceQuery = "select pl1.product.ID, pl1.price, pl1.carryIn from PriceList pl1 where company.companyID=? "
                + " and (pl1.product.unitOfMeasure is not null AND pl1.uomid.ID = pl1.product.unitOfMeasure.ID) and affecteduser = ? "
                + " and ((pl1.product.currency is not null and pl1.currency.currencyID=pl1.product.currency.currencyID) OR (pl1.product.currency is null and pl1.currency.currencyID=pl1.company.currency.currencyID)) "
                + " and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = pl1.affecteduser and product.ID=pl1.product.ID "
                + " and currency.currencyID = pl1.currency.currencyID and uomid.ID=pl1.uomid.ID and carryIn=pl1.carryIn group by product)"+ productInSubQuery;
        List productPurchaseAndSalesPriceList = null;
        if (namedQueryFlag) {
            productPurchaseAndSalesPriceList = executeQuery(getProductPurchaseAndSalesPriceQuery, params.toArray(), namedParams);
        } else {
            productPurchaseAndSalesPriceList = executeQuery(getProductPurchaseAndSalesPriceQuery, params.toArray());
        }
        for(int i=0; i<productPurchaseAndSalesPriceList.size(); i++){
            Object[] obj = (Object[]) productPurchaseAndSalesPriceList.get(i);
            if((Boolean) obj[2]){
                productPurchasePriceMap.put((String) obj[0], (Double) obj[1]);
            } else {
                productSalesPriceMap.put((String) obj[0], (Double) obj[1]);
            }
        }
        /*
        getProductPurchaseAndSalesPriceQuery = "select pl1.product.ID, pl1.price, pl1.carryIn from PriceList pl1 where company.companyID=? "
                + " and pl1.uomid is null and affecteduser = ? "
                + " and ((pl1.product.currency is not null and pl1.currency.currencyID=pl1.product.currency.currencyID) OR (pl1.product.currency is null and pl1.currency.currencyID=pl1.company.currency.currencyID)) "
                + " and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = pl1.affecteduser and product.ID=pl1.product.ID "
                + " and currency.currencyID = pl1.currency.currencyID and uomid.ID is null and carryIn=pl1.carryIn group by product)"+ productInSubQuery;
        productPurchaseAndSalesPriceList = null;
        if (namedQueryFlag) {
            productPurchaseAndSalesPriceList = executeQuery(getProductPurchaseAndSalesPriceQuery, params.toArray(), namedParams);
        } else {
            productPurchaseAndSalesPriceList = executeQuery(getProductPurchaseAndSalesPriceQuery, params.toArray());
        }
        for(int i=0; i<productPurchaseAndSalesPriceList.size(); i++){
            Object[] obj = (Object[]) productPurchaseAndSalesPriceList.get(i);
            if((Boolean) obj[2]){
                if(!productPurchasePriceMap.containsKey((String) obj[0]) || productPurchasePriceMap.get((String) obj[0]) == null){
                    productPurchasePriceMap.put((String) obj[0], (Double) obj[1]);
                }
            } else {
                if(!productSalesPriceMap.containsKey((String) obj[0]) || productSalesPriceMap.get((String) obj[0]) == null){
                    productSalesPriceMap.put((String) obj[0], (Double) obj[1]);
                }
            }
        }
        */

        List<HashMap<String, Double>> list = new ArrayList<HashMap<String, Double>>();
        list.add(productPurchasePriceMap);
        list.add(productSalesPriceMap);
        return list;
    }
    
    /**
     * Method is used to get initial purchase & sales price to show product
     * master. We have kept initialPrice to distinguish initial purchase price
     * and other purchase price.
     */
    private List<HashMap<String, Double>> getProductInitialPurchaseAndSalesPriceMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(companyid);
        params.add("-1");
        
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }
        HashMap<String, Double> productInitialPurchasePriceMap = new HashMap<String, Double>();
        HashMap<String, Double> productInitialSalesPriceMap = new HashMap<String, Double>();
        String getProductInitialPurchaseAndSalesPriceQuery = "select pl1.product.ID, pl1.price, pl1.carryIn from PriceList pl1 where company.companyID=? "
                + " and (pl1.product.unitOfMeasure is not null AND pl1.uomid.ID = pl1.product.unitOfMeasure.ID) and affecteduser = ? and (carryIn = false or (carryIn=true and initialPrice = true)) "
                + " and ((pl1.product.currency is not null and pl1.currency.currencyID=pl1.product.currency.currencyID) OR (pl1.product.currency is null and pl1.currency.currencyID=pl1.company.currency.currencyID)) "
                + " and applyDate = (select min(applyDate) as ld from PriceList where affecteduser = pl1.affecteduser and product.ID=pl1.product.ID "
                + " and currency.currencyID = pl1.currency.currencyID and uomid.ID = pl1.product.unitOfMeasure.ID and carryIn=pl1.carryIn  and (carryIn = false or (carryIn=true and initialPrice = true)) group by product)"+ productInSubQuery;
        List productPurchaseAndSalesPriceDateWiseList = null;
        if (namedQueryFlag) {
            productPurchaseAndSalesPriceDateWiseList = executeQuery(getProductInitialPurchaseAndSalesPriceQuery, params.toArray(), namedParams);
        } else {
            productPurchaseAndSalesPriceDateWiseList = executeQuery(getProductInitialPurchaseAndSalesPriceQuery, params.toArray());
        }
        for(int i=0; i<productPurchaseAndSalesPriceDateWiseList.size(); i++){
            Object[] obj = (Object[]) productPurchaseAndSalesPriceDateWiseList.get(i);
            if((Boolean) obj[2]){
                productInitialPurchasePriceMap.put((String) obj[0], (Double) obj[1]);
            } else {
                productInitialSalesPriceMap.put((String) obj[0], (Double) obj[1]);
            }
        }

        List<HashMap<String, Double>> list = new ArrayList<HashMap<String, Double>>();
        list.add(productInitialPurchasePriceMap);
        list.add(productInitialSalesPriceMap);
        return list;
    }
    
    private List<HashMap<String, Double>> getProductInitialPurchaseAndSalesPriceDateWiseMap(String companyid, List<Product> productList, boolean namedQueryFlag, String affecteduser, Date transactionDate) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(companyid);
        params.add(affecteduser);
        
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }
        String transactionDateInQuery = "";
        if(transactionDate != null){
            transactionDateInQuery = " and applyDate<=? ";
            params.add(transactionDate);
        }

        HashMap<String, Double> productPurchasePriceDateWiseMap = new HashMap<String, Double>();
        HashMap<String, Double> productSalesPriceDateWiseMap = new HashMap<String, Double>();
        String getProductPurchaseAndSalesPriceDateWiseQuery = "select pl1.product.ID, pl1.price, pl1.carryIn from PriceList pl1 where company.companyID=? "
                + " and (pl1.product.unitOfMeasure is not null AND pl1.uomid.ID = pl1.product.unitOfMeasure.ID) and affecteduser = ? "
                + " and ((pl1.product.currency is not null and pl1.currency.currencyID=pl1.product.currency.currencyID) OR (pl1.product.currency is null and pl1.currency.currencyID=pl1.company.currency.currencyID)) "
                + " and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = pl1.affecteduser and product.ID=pl1.product.ID "
                + " and currency.currencyID = pl1.currency.currencyID and uomid.ID = pl1.product.unitOfMeasure.ID and carryIn=pl1.carryIn "+ transactionDateInQuery +" group by product)"+ productInSubQuery;
        List productInitialPurchaseAndSalesPriceList = null;
        if (namedQueryFlag) {
            productInitialPurchaseAndSalesPriceList = executeQuery(getProductPurchaseAndSalesPriceDateWiseQuery, params.toArray(), namedParams);
        } else {
            productInitialPurchaseAndSalesPriceList = executeQuery(getProductPurchaseAndSalesPriceDateWiseQuery, params.toArray());
        }
        for(int i=0; i<productInitialPurchaseAndSalesPriceList.size(); i++){
            Object[] obj = (Object[]) productInitialPurchaseAndSalesPriceList.get(i);
            if((Boolean) obj[2]){
                productPurchasePriceDateWiseMap.put((String) obj[0], (Double) obj[1]);
            } else {
                productSalesPriceDateWiseMap.put((String) obj[0], (Double) obj[1]);
            }
        }

        params.set(1, "-1");
        productInitialPurchaseAndSalesPriceList = null;
        if (namedQueryFlag) {
            productInitialPurchaseAndSalesPriceList = executeQuery(getProductPurchaseAndSalesPriceDateWiseQuery, params.toArray(), namedParams);
        } else {
            productInitialPurchaseAndSalesPriceList = executeQuery(getProductPurchaseAndSalesPriceDateWiseQuery, params.toArray());
        }
        for(int i=0; i<productInitialPurchaseAndSalesPriceList.size(); i++){
            Object[] obj = (Object[]) productInitialPurchaseAndSalesPriceList.get(i);
            if((Boolean) obj[2]){
                if(!productPurchasePriceDateWiseMap.containsKey((String) obj[0]) || productPurchasePriceDateWiseMap.get((String) obj[0]) == null){
                    productPurchasePriceDateWiseMap.put((String) obj[0], (Double) obj[1]);
                }
            } else {
                if(!productSalesPriceDateWiseMap.containsKey((String) obj[0]) || productSalesPriceDateWiseMap.get((String) obj[0]) == null){
                    productSalesPriceDateWiseMap.put((String) obj[0], (Double) obj[1]);
                }
            }
        }

        List<HashMap<String, Double>> list = new ArrayList<HashMap<String, Double>>();
        list.add(productPurchasePriceDateWiseMap);
        list.add(productSalesPriceDateWiseMap);
        return list;
    }
    
    private Map<String, Double> getAvailableQuantityMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(Producttype.SERVICE);
        params.add(companyid);
        
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }
        Map<String, Double> availableQuantityMap = new HashMap<String, Double>();
        String getAvailableQuantityQuery = "select product.ID, sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory "
                + " where deleted=false and product.producttype.ID <> ? and company.companyID=? "+ productInSubQuery +" group by product.ID";
        List availableQuantityList = null;
        if (namedQueryFlag) {
            availableQuantityList = executeQuery(getAvailableQuantityQuery, params.toArray(), namedParams);
        } else {
            availableQuantityList = executeQuery(getAvailableQuantityQuery, params.toArray());
        }
        for(int i=0; i<availableQuantityList.size(); i++){
            Object[] obj = (Object[]) availableQuantityList.get(i);
            availableQuantityMap.put((String) obj[0], (Double) obj[1]);
        }
        return availableQuantityMap;
    }
    
    private Map<String, Double> getInitialQuantityMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(Producttype.SERVICE);
        params.add(companyid);
        
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }
        HashMap<String, Double> initialQuantityMap = new HashMap<String, Double>();
//            String getInitialQuantityQuery = "select product, baseuomquantity from inventory inner join product on product.id=inventory.product "
//                    + " where inventory.deleteflag=false  and product.producttype <> ? and inventory.company=? and newinv='T' group by product";
        String getInitialQuantityQuery = "select product.ID, baseuomquantity from Inventory where deleted=false  and product.producttype.ID <> ? "
                + " and company.companyID=? and newinv='T' "+ productInSubQuery +" group by product.ID";
        List initialQuantityList = null;
        if (namedQueryFlag) {
            initialQuantityList = executeQuery(getInitialQuantityQuery, params.toArray(), namedParams);
        } else {
            initialQuantityList = executeQuery(getInitialQuantityQuery, params.toArray());
        }
        for(int i=0; i<initialQuantityList.size(); i++){
            Object[] obj = (Object[]) initialQuantityList.get(i);
            initialQuantityMap.put((String) obj[0], (Double) obj[1]);
        }
        return initialQuantityMap;
    }
    
    private Map<String, Object> getProCreationDateMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }
        HashMap<String, Object> proCreationDateMap = new HashMap<String, Object>();
//            String getProCreationDateQuery = "select product, min(updatedate) from inventory where company=? group by product";
        String getProCreationDateQuery = "select product.ID, min(updateDate) from Inventory where deleted=false and company.companyID=?"+ productInSubQuery;
        List proCreationDateList = null;
        if (namedQueryFlag) {
            proCreationDateList = executeQuery(getProCreationDateQuery, companyid, namedParams);
        } else {
            proCreationDateList = executeQuery(getProCreationDateQuery, companyid);
        }
        for(int i=0; i<proCreationDateList.size(); i++){
            Object[] obj = (Object[]) proCreationDateList.get(i);
            proCreationDateMap.put((String) obj[0], (Object) obj[1]);
        }
        return proCreationDateMap;
    }
    
    private Map<String, Double> getAssemblyLockQuantityMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and subproducts IN (:productids)";
        }

        HashMap<String, Double> assemblyLockQuantityMap = new HashMap<String, Double>();
//            String getAssemblyLockQuantityQuery = "select subproducts, sum(quantity) from lockassemblyquantitymapping "
//                    + " inner join product on product.id=subproducts where product.company=? group by subproducts";
        String getAssemblyLockQuantityQuery = "select subproducts.ID, sum(quantity) from AssemblySubProductMapping "
                + " where subproducts.company.companyID=? "+ productInSubQuery +" group by subproducts.ID";
        List assemblyLockQuantityList = null;
        if (namedQueryFlag) {
            assemblyLockQuantityList = executeQuery(getAssemblyLockQuantityQuery, companyid, namedParams);
        } else {
            assemblyLockQuantityList = executeQuery(getAssemblyLockQuantityQuery, companyid);
        }
        for(int i=0; i<assemblyLockQuantityList.size(); i++){
            Object[] obj = (Object[]) assemblyLockQuantityList.get(i);
            assemblyLockQuantityMap.put((String) obj[0], (Double) obj[1]);
        }
        return assemblyLockQuantityMap;
    }
    
    private Map<String, Double> getSOLockQuantityMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }

        HashMap<String, Double> soLockQuantityMap = new HashMap<String, Double>();
//            String getSOLockQuantityQuery = "select product, sum(lockquantity) from sodetails where company=? group by product";
        String getSOLockQuantityQuery = "select product.ID, sum(lockquantity) from SalesOrderDetail where company.companyID=? "+ productInSubQuery +" and salesOrder.deleted='F' group by product.ID";
        List soLockQuantityList = null;
        if (namedQueryFlag) {
            soLockQuantityList = executeQuery(getSOLockQuantityQuery, companyid, namedParams);
        } else {
            soLockQuantityList = executeQuery(getSOLockQuantityQuery, companyid);
        }
        for(int i=0; i<soLockQuantityList.size(); i++){
            Object[] obj = (Object[]) soLockQuantityList.get(i);
            soLockQuantityMap.put((String) obj[0], (Double) obj[1]);
        }
        return soLockQuantityMap;
    }
    
    private Map<String, Double> getWOLockQuantityMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        
        /** productType check is added in query 
         *  currently in MRP, quantity is not block for Assembly product
         *  when assembly product get produce WOCD table update block quantity
         *  But newproductbatch table not updated for lockquantity
         *  for Assembly product don't return block quantity.
         */
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids) and product.producttype!='"+Constants.ASSEMBLY+"'";
        }

        HashMap<String, Double> woLockQuantityMap = new HashMap<String, Double>();
//            String getWOLockQuantityQuery = "select product, sum(case when isblockqtyused='T' then "
//                    + " (blockquantity-(blockquantityused+rejectedquantity+returnquantity)) else blockquantity end) from workordercomponentdetail "
//                    + " inner join product on product.id=product where product.company=? group by product";
        String getWOLockQuantityQuery = "select product.ID, sum(case when blockQtyUsed='T' then "
                + " (blockQuantity-(blockQuantityUsed+rejectedQuantity+returnQuantity)) else blockQuantity end) from WorkOrderComponentDetails "
                + " where product.company.companyID=? "+ productInSubQuery +" group by product.ID";
        List woLockQuantityList = null;
        if (namedQueryFlag) {
            woLockQuantityList = executeQuery(getWOLockQuantityQuery, companyid, namedParams);
        } else {
            woLockQuantityList = executeQuery(getWOLockQuantityQuery, companyid);
        }
        for(int i=0; i<woLockQuantityList.size(); i++){
            Object[] obj = (Object[]) woLockQuantityList.get(i);
            woLockQuantityMap.put((String) obj[0], (Double) obj[1]);
        }
        return woLockQuantityMap;
    }
    
    private Map<String, Double> getLeasedQuantityMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(Producttype.SERVICE);
        params.add(companyid);
        
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }
        HashMap<String, Double> leasedQuantityMap = new HashMap<String, Double>();
//            String getLeasedQuantityQuery = "select product, sum((case when carryin=true then -baseuomquantity else baseuomquantity end)) from inventory "
//                    + " inner join product on product.id=inventory.product where inventory.deleteflag=false "
//                    + " and product.producttype <> ? and inventory.company=? and leaseFlag=true group by product";
        String getLeasedQuantityQuery = "select product.ID, sum((case when carryIn=true then -baseuomquantity else baseuomquantity end)) from Inventory "
                + " where deleted=false and product.producttype.ID <> ? and company.companyID=? and leaseFlag=true "+ productInSubQuery +" group by product.ID";
        List leasedQuantityQuantityList = null;
        if (namedQueryFlag) {
            leasedQuantityQuantityList = executeQuery(getLeasedQuantityQuery, params.toArray(), namedParams);
        } else {
            leasedQuantityQuantityList = executeQuery(getLeasedQuantityQuery, params.toArray());
        }
        for(int i=0; i<leasedQuantityQuantityList.size(); i++){
            Object[] obj = (Object[]) leasedQuantityQuantityList.get(i);
            leasedQuantityMap.put((String) obj[0], (Double) obj[1]);
        }
        return leasedQuantityMap;
    }
    
    private Map<String, Double> getConsignedQuantityMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(Producttype.SERVICE);
        params.add(companyid);
        
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }
        HashMap<String, Double> consignedQuantityMap = new HashMap<String, Double>();
//            String getConsignedQuantityQuery = "select product, sum(consignuomquantity) from inventory "
//                    + " inner join product on product.id=inventory.product where inventory.deleteflag=false "
//                    + " and product.producttype <> ? and inventory.company=? and isconsignment='T' and invrecord='T' group by product";
        String getConsignedQuantityQuery = "select product.ID, sum(consignuomquantity) from Inventory where deleted=false and product.producttype.ID <> ? "
                + " and company.companyID=? and isconsignment='T' and invrecord='T' "+ productInSubQuery +" group by product.ID";
        List consignedQuantityQuantityList = null;
        if (namedQueryFlag) {
            consignedQuantityQuantityList = executeQuery(getConsignedQuantityQuery, params.toArray(), namedParams);
        } else {
            consignedQuantityQuantityList = executeQuery(getConsignedQuantityQuery, params.toArray());
        }
        for(int i=0; i<consignedQuantityQuantityList.size(); i++){
            Object[] obj = (Object[]) consignedQuantityQuantityList.get(i);
            consignedQuantityMap.put((String) obj[0], (Double) obj[1]);
        }

        return consignedQuantityMap;
    }
    
    private Map<String, Double> getVendorConsignedQuantityMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(Producttype.SERVICE);
        params.add(companyid);
        
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and product IN (:productids)";
        }

        HashMap<String, Double> vendorConsignedQuantityMap = new HashMap<String, Double>();
//            String getVendorConsignedQuantityQuery = "select product, sum(venconsignuomquantity) from inventory "
//                    + " inner join product on product.id=inventory.product where inventory.deleteflag=false "
//                    + " and product.producttype <> ? and inventory.company=? group by product";
        String getVendorConsignedQuantityQuery = "select product.ID, sum(venconsignuomquantity) from Inventory where deleted=false "
                + " and product.producttype.ID <> ? and company.companyID=? "+ productInSubQuery +" group by product.ID";
        List vendorConsignedQuantityQuantityList = null;
        if (namedQueryFlag) {
            vendorConsignedQuantityQuantityList = executeQuery(getVendorConsignedQuantityQuery, params.toArray(), namedParams);
        } else {
            vendorConsignedQuantityQuantityList = executeQuery(getVendorConsignedQuantityQuery, params.toArray());
        }
        for(int i=0; i<vendorConsignedQuantityQuantityList.size(); i++){
            Object[] obj = (Object[]) vendorConsignedQuantityQuantityList.get(i);
            vendorConsignedQuantityMap.put((String) obj[0], (Double) obj[1]);
        }

        return vendorConsignedQuantityMap;
    }
    
    private Map<String, String> getProductCategoriesMap(String companyid, List<Product> productList, boolean namedQueryFlag) throws ServiceException {
        Map<String, Object> namedParams = null;
        String productInSubQuery = "";
        if (namedQueryFlag) {
            namedParams = new HashMap<String, Object>();
            namedParams.put("productids", productList);
            productInSubQuery = " and productID IN (:productids)";
        }

        HashMap<String, String> productCategoriesMap = new HashMap<String, String>();
        String getProductCategoriesQuery = "select productID.ID, productCategory.ID from ProductCategoryMapping where productID.asset='F' "
                + " and productID.deleted = 'F' and productID.company.companyID=? and productCategory is not null "+ productInSubQuery +" order by productCategory.ID desc";
        List productCategoriesList = null;
        if (namedQueryFlag) {
            productCategoriesList = executeQuery(getProductCategoriesQuery, companyid, namedParams);
        } else {
            productCategoriesList = executeQuery(getProductCategoriesQuery, companyid);
        }
        for(int i=0; i<productCategoriesList.size(); i++){
            Object[] obj = (Object[]) productCategoriesList.get(i);
            if(productCategoriesMap.containsKey((String) obj[0])){
                productCategoriesMap.put((String) obj[0], productCategoriesMap.get((String) obj[0]) +","+ (String) obj[1]);
            } else {
                productCategoriesMap.put((String) obj[0], (String) obj[1]);
            }
        }
        return productCategoriesMap;
    }
    
    @Override
    public KwlReturnObject getAssemblyProducts(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        String condition = "";
        ArrayList params = new ArrayList();
        boolean exportflag=false;
        String isBuild = "true";
        String productid = (String) requestParams.get("productid");
        String companyid = (String) requestParams.get("companyid");
        String buildid = (String) requestParams.get("buildid");
        if (requestParams.get("exportfalg")!=null) {
        exportflag = Boolean.parseBoolean(requestParams.get("exportfalg").toString());
        }
        if (requestParams.get("isBuild")!=null) {
            isBuild = (String)requestParams.get("isBuild");
        }
        params.add(companyid);
        boolean quickSearchFlag = false;
        int start = 0;
        int limit = 15;
        String affecteduser = (String) requestParams.get("affecteduser");
        if (requestParams.containsKey("start") && requestParams.containsKey("limit") && !StringUtil.isNullOrEmpty(requestParams.get("start").toString())) {
            start = Integer.parseInt(requestParams.get("start").toString());
            limit = Integer.parseInt(requestParams.get("limit").toString());
        }

        if (requestParams.containsKey("ss") && requestParams.get("ss") != null) {
            String ss = requestParams.get("ss").toString();
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"p.product.name", "p.product.productid", "p.description"};
                try {
                    Map map = StringUtil.insertParamSearchStringMap(params, ss, 3);
                    StringUtil.insertParamSearchString(map);
                } catch (SQLException ex) {
                    Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
                quickSearchFlag = true;
            }
        } else if (requestParams.containsKey("search") && requestParams.get("search") != null) {
            String ss = requestParams.get("search").toString();
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"p.product.name", "p.product.productid", "p.description"};
                try {
                    Map map = StringUtil.insertParamSearchStringMap(params, ss, 3);
                    StringUtil.insertParamSearchString(map);
                } catch (SQLException ex) {
                    Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
                quickSearchFlag = true;
            }
        }

        if (!StringUtil.isNullOrEmpty(productid)) {
            String productidArray[] = productid.split(",");
            for (int i = 0; i < productidArray.length; i++) {
                if (i == 0) {
                    condition += " and (";
                } else {
                    condition += " or ";
                }
                condition += " p.product.id=?";
                params.add(productidArray[i]);
                if (i == productidArray.length - 1) {
                    condition += " ) ";
                }
            }
        }
        if (requestParams.containsKey(Constants.REQ_startdate)){
            Date startDate = (Date) requestParams.get(Constants.REQ_startdate);
            Date endDate = (Date) requestParams.get(Constants.REQ_enddate);
            if (startDate!=null && endDate!=null) {
                condition += " and (p.entryDate >=? and p.entryDate <=?)";
                params.add(startDate);
                params.add(endDate);
            }
        }
        if (!StringUtil.isNullOrEmpty(buildid)) {
            condition += " and p.ID = ? ";
            params.add(buildid);
        }
        String query = "select p from ProductBuild p where p.company.companyID=? and p.isBuild="+isBuild+" and p.product.deleted=false " + condition;
        List list = executeQuery( query, params.toArray());
        int totalCount = list.size();
        if(!exportflag){
        list = executeQueryPaging( query, params.toArray(), new Integer[]{start, limit});
        }
        return new KwlReturnObject(true, "", null, list, totalCount);
    }
    @Override
    public KwlReturnObject getBuildAssemblyDetails(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        String condition = "";
        ArrayList params = new ArrayList();
        String productid = (String) requestParams.get("productid");
        String companyid = (String) requestParams.get("companyid");
        params.add(companyid);
        boolean quickSearchFlag = false;
        int start = 0;
        int limit = 15;
        if (requestParams.containsKey("start") && requestParams.containsKey("limit") && !StringUtil.isNullOrEmpty(requestParams.get("start").toString())) {
            start = Integer.parseInt(requestParams.get("start").toString());
            limit = Integer.parseInt(requestParams.get("limit").toString());
        }
        if (requestParams.containsKey("ss") && requestParams.get("ss") != null) {
            String ss = requestParams.get("ss").toString();
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"pbd.build.product.name", "pbd.build.product.productid", "pbd.build.description"};
                try {
                    Map map = StringUtil.insertParamSearchStringMap(params, ss, 3);
                    StringUtil.insertParamSearchString(map);
                } catch (SQLException ex) {
                    Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
                quickSearchFlag = true;
            }
        } else if (requestParams.containsKey("search") && requestParams.get("search") != null) {
            String ss = requestParams.get("search").toString();
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"pbd.build.product.name", "pbd.build.product.productid", "pbd.build.description"};
                try {
                    Map map = StringUtil.insertParamSearchStringMap(params, ss, 3);
                    StringUtil.insertParamSearchString(map);
                } catch (SQLException ex) {
                    Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
                quickSearchFlag = true;
            }
        }
        if (!StringUtil.isNullOrEmpty(productid)) {
            String productidArray[] = productid.split(",");
            for (int i = 0; i < productidArray.length; i++) {
                if (i == 0) {
                    condition += " and (";
                } else {
                    condition += " or ";
                }
                condition += " pbd.build.product.ID=?";
                params.add(productidArray[i]);
                if (i == productidArray.length - 1) {
                    condition += " ) ";
                }
            }
        }
        if (requestParams.containsKey(Constants.REQ_startdate)) {
            Date startDate = (Date) requestParams.get(Constants.REQ_startdate);
            Date endDate = (Date) requestParams.get(Constants.REQ_enddate);
            if (startDate != null && endDate != null) {
                condition += " and (pbd.build.entryDate >=? and pbd.build.entryDate <=?)";
                params.add(startDate);
                params.add(endDate);
            }
        }
        String query = "from ProductBuildDetails pbd where pbd.build.company.companyID=? and pbd.build.product.deleted=false " + condition;
        List list = executeQuery( query, params.toArray());
        int totalCount = list.size();
        list = executeQueryPaging( query, params.toArray(), new Integer[]{start, limit});
        return new KwlReturnObject(true, "", null, list, totalCount);
    }
    public String sortColumnProduct(String Col_Name, String Col_Dir) throws ServiceException {
        String String_Sort = "";
        if (Col_Name.equals("productname")) {
            String_Sort = " order by p.name " + Col_Dir;
        } else if (Col_Name.equals("pid")) {
            String_Sort = " order by p.productid " + Col_Dir;
        } else if (Col_Name.equals("desc")) {
            String_Sort = " order by p.description " + Col_Dir;
        } else if (Col_Name.equals("type")) {
            String_Sort = " order by p.producttype.name " + Col_Dir;
        } else if (Col_Name.equals("reorderquantity")) {
            String_Sort = " order by p.reorderQuantity " + Col_Dir;
        } else if (Col_Name.equals("reorderlevel")) {
            String_Sort = " order by p.reorderLevel " + Col_Dir;
        } else if (Col_Name.equals("leadtime")) {
            String_Sort = " order by p.leadTimeInDays " + Col_Dir;
        } else if (Col_Name.equals("warranty")) {
            String_Sort = " order by p.warrantyperiod " + Col_Dir;
        } else if (Col_Name.equals("quantity")) {
            String_Sort = " order by p.availableQuantity " + Col_Dir;
        } else if (Col_Name.equals("isActiveItem")) {
            String_Sort = " order by p.isActive " + Col_Dir;
        }
        return String_Sort;
    }

    @Override
    public KwlReturnObject getProductByName(HashMap<String, Object> requestParams) throws ServiceException {
        String condition = "";
        ArrayList params = new ArrayList();
        String companyid = (String) requestParams.get("companyid");
        params.add(companyid);

        if (requestParams.containsKey("productName") && requestParams.get("productName") != null) {
            String productName = (String) requestParams.get("productName");
            condition += " and p.name=? ";
            params.add(productName);
        }

        if (requestParams.containsKey("isForAsset") && requestParams.get("isForAsset") != null) {
            boolean isForAsset = (Boolean) requestParams.get("isForAsset");
            condition += " and p.asset=? ";
            params.add(isForAsset);
        }

        if (requestParams.containsKey("productIDText") && requestParams.get("productIDText") != null) {// Product ID entered in Product Form
            String productIDText = (String) requestParams.get("productIDText");
            condition += " and p.productid=? ";
            params.add(productIDText);
        }

        String query = "From Product p where p.company.companyID=?" + condition;

        List list = executeQuery( query, params.toArray());
        int totalCount = list.size();
        return new KwlReturnObject(true, "", null, list, totalCount);

    }

    public KwlReturnObject getProductByID(String productid, String companyid) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(productid);
        params.add(companyid);
        List returnList = new ArrayList();
        String query = "from Product p where p.ID=? and p.company.companyID=? ";
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getProductByProdID(String productid, String companyid,boolean isFixedAsset) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(productid);
        params.add(isFixedAsset);
        params.add(companyid);
        List returnList = new ArrayList();
        String query = "from Product p where p.productid=? and p.asset=? and p.company.companyID=? ";
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Transactional(propagation= Propagation.REQUIRED)
    private Object getChildProducts(Product product, List returnList, int level, String productid, Date transactionDate, String affecteduser,boolean isProductQuantityFromColumn) throws ServiceException {
        boolean leaf = true;
        level++;
        Set<Product> children= new TreeSet(product.getChildren());
        for (Product child : children) {
//            if (child.getID().equals(productid) || child.isDeleted()) {
            if (child.getID().equals(productid)) {
                continue;
            }
            leaf = false;
            Object tmplist[] = new Object[18]; //0:Product, 1:level, 2:leaf
            tmplist[0] = child;
            tmplist[1] = level;
            returnList.add(tmplist);
            tmplist[2] = getChildProducts(child, returnList, level, productid, transactionDate, affecteduser,isProductQuantityFromColumn);
            tmplist = getProductsDetails(tmplist, child, transactionDate, affecteduser,isProductQuantityFromColumn);            
        }
        return leaf;
    }

    private Object[] getProductsDetails(Object[] detailsArray, Product product, Date transactionDate, String affecteduser,boolean isProductQuantityFromColumn) throws ServiceException {
        String currencyId="";
        if(product.getCurrency()!=null){
            currencyId=product.getCurrency().getCurrencyID();
        }
        String stockUomID = product.getUnitOfMeasure() != null ? product.getUnitOfMeasure().getID() : "";
        boolean excludeInitialPrice = true;
        KwlReturnObject result = getProductPrice(product.getID(), true, null, "", currencyId, stockUomID, excludeInitialPrice); // purchasePrice

//        if(result.getEntityList().get(0)==null){
//           result = getProductPrice(product.getID(), true, null, "", currencyId); // purchasePrice
//       }
        detailsArray[3] = result.getEntityList().get(0);
//            obj.put("saleprice",row[2]);
        result = getProductPrice(product.getID(), false, null, "", currencyId, stockUomID, excludeInitialPrice); // salesPrice
//        if(result.getEntityList().get(0)==null){
//           result = getProductPrice(product.getID(), false, null, "", currencyId); // salesPrice
//       }
        detailsArray[4] = result.getEntityList().get(0);
//            obj.put("quantity",(row[3]==null?0:row[3]));
        if (isProductQuantityFromColumn) {
            detailsArray[5] = product.getAvailableQuantity(); // availableQuantity
        } else {
            result = getQuantity(product.getID());
            detailsArray[5] = (result.getEntityList().get(0)); // availableQuantity
        }
//            obj.put("initialquantity",(row[4]==null?0:row[4]));
        result = getInitialQuantity(product.getID());
        detailsArray[6] = (result.getEntityList().get(0)); // initialquantity
//            obj.put("initialprice",(row[5]==null?0:row[5]));
        result = getInitialPrice(product.getID(), true); 
        detailsArray[7] = result.getEntityList().get(0); // initialprice

        //Cycle count Object
//        HashMap<String, Object> ccfilterParams = new HashMap<String, Object>();
//        ccfilterParams.put("productid", product.getID());
//        detailsArray[8] = getCycleCountEntryObject(ccfilterParams);

        //salespricedatewise
        result = getProductPrice(product.getID(), false, transactionDate, affecteduser, "");
        detailsArray[9] = result.getEntityList().get(0); // salespricedatewise    
           
        //purchasepricedatewise
        result = getProductPrice(product.getID(), true, transactionDate, affecteduser, "");
        detailsArray[10] = result.getEntityList().get(0);// purchasepricedatewise

        //initialsalesprice
        result = getInitialPrice(product.getID(), false);
        detailsArray[11] = result.getEntityList().get(0); // initialsalesprice

        result = getProCreationDate(product.getID(), product.getCompany().getCompanyID());
        detailsArray[12] = result.getEntityList().get(0);

        KwlReturnObject result2 = getAssemblyLockQuantity(product.getID());
        Double assmblyLockQuantity = (Double) (result2.getEntityList().get(0) == null ? 0.0 : result2.getEntityList().get(0));

        KwlReturnObject result1 = getLockQuantity(product.getID());
        Double SoLockQuantity = (Double) (result1.getEntityList().get(0) == null ? 0.0 : result1.getEntityList().get(0));
        
        KwlReturnObject woresult = getWOLockQuantity(product.getID());
        Double WOLockQuantity = (Double) (woresult.getEntityList().get(0) == null ? 0.0 : woresult.getEntityList().get(0));

        detailsArray[13] = assmblyLockQuantity + SoLockQuantity + WOLockQuantity; // lockquantity

        result = getLeasedQuantity(product.getID());
        detailsArray[14] = (result.getEntityList().get(0));
        //Consignment Quntity
        result = getConsignedQuantity(product.getID());
        detailsArray[15] = (result.getEntityList().get(0));

        //Vendor Consignment Quntity
        result = getVendorConsignedQuantity(product.getID());
        detailsArray[16] = (result.getEntityList().get(0));
        
        return detailsArray;

    }

    public KwlReturnObject getSuggestedReorderProducts(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        String condition = "";
        ArrayList params = new ArrayList();

        String productid = (String) requestParams.get("productid");
        String companyid = (String) requestParams.get("companyid");
        String start = (String) requestParams.get("start");
        String limit = (String) requestParams.get("limit");
        String date = (String) requestParams.get("transactiondate");
        String producttype = (String) requestParams.get("type");
        DateFormat df = (DateFormat) requestParams.get("df");
        boolean isFromDashBoard = requestParams.get(Constants.isFromDashBoard)!=null?(boolean)requestParams.get(Constants.isFromDashBoard):false;
        
        Date transactionDate = null;
        try {
            transactionDate = (date == null ? null : df.parse(date));
        } catch (ParseException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("getSuggestedReorderProducts : " + ex.getMessage(), ex);
        }
        params.add(Producttype.SERVICE);
        params.add(companyid);
        if (!StringUtil.isNullOrEmpty(producttype)) {
            condition = " and p.producttype.ID=? ";
            params.add(producttype);
        }
        if (requestParams.containsKey("ss") && requestParams.get("ss") != null) {
            String ss = requestParams.get("ss").toString().toUpperCase();
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"p.name", "p.productid"};
                try {
                    Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                    StringUtil.insertParamSearchString(map);
                } catch (SQLException ex) {
                    Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                }
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
            }
        }
//        String query = "select p, (select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory inv3  where product.ID=p.ID and inv3.deleted=false and inv3.company.companyID=? group by product.ID) from Product p"
//                + " where p.deleted=false and p.producttype.ID <> ?  and p.company.companyID=? " + condition
//                + " order by p.producttype, p.name ";
        //ERP-34654 - for optimization update the availablequantity in product from inventory table through query and fetch record from product table
        String query = "select p,p.availableQuantity from Product p"
                + " where p.deleted=false and p.producttype.ID <> ? and p.availableQuantity <= p.reorderLevel  and p.company.companyID=? " + condition
                + " order by p.producttype, p.name ";
        List<Object[]> list = executeQuery( query, params.toArray());
        int count = list.size();
        if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
            list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
        }
        int level = 0;
        Product product;
        double quantity;
        boolean isProductQuantityFromColumn = false;
        if (list != null && list.size() > 0) {
            isProductQuantityFromColumn = isProductQuantityFromColumn(companyid);
        }
        if (list != null && !list.isEmpty()) {
            for (Object[] result : list) {
                product = (Product) result[0];
                quantity = result[1] == null ? 0 : Double.parseDouble(result[1].toString());
                if (quantity > product.getReorderLevel()) {
                    continue;
                }
                if (product.getID().equals(productid)) {
                    continue;
                }
                Object tmplist[] = new Object[18]; //0:Product, 1:level, 2:leaf     //ERP-11935 : Increased the size of an array by one
                tmplist[0] = product;
                tmplist[1] = level;
                returnList.add(tmplist);
                tmplist[2] = true;//getChildProducts(product, returnList, level, productid, transactionDate);
                if(isFromDashBoard) {
                    tmplist[5] = result[1];
                }else {
                    tmplist = getProductsDetails(tmplist, product, transactionDate, "",isProductQuantityFromColumn);
                }
            }
        }
        return new KwlReturnObject(true, "", null, returnList, count);
    }

    public KwlReturnObject getProductfromAccount(String accountid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "from Product pr where (purchaseAccount.ID=? or salesAccount.ID=? or purchaseReturnAccount.ID=? or salesReturnAccount.ID=? or inventoryAccount.ID=?) and pr.company.companyID=?";
        list = executeQuery( q, new Object[]{accountid, accountid, accountid, accountid, accountid,companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    public KwlReturnObject getAssetGroupfromAccount(String accountid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "from Product pr where (sellAssetGLAccount.ID=? or writeOffAssetAccount.ID=?) and pr.company.companyID=?";
        list = executeQuery( q, new Object[]{accountid, accountid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

     public KwlReturnObject getInvoiceTermfromAccount(String accountid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "from InvoiceTermsSales ts where ts.account.ID=? and ts.company.companyID=?";
        list = executeQuery( q, new Object[]{accountid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    public KwlReturnObject getOpeningDepreciationForAccount(HashMap<String, Object> reqParams) throws ServiceException {
        List returnList = Collections.EMPTY_LIST;
        String accountid = "";
        String companyid = "";
        String Searchjson = "";
        String filterConjuctionCriteria = "";
        if (reqParams.containsKey("accountid")) {
            accountid = reqParams.get("accountid").toString();
        }
        if (reqParams.containsKey("companyid")) {
            companyid = reqParams.get("companyid").toString();
        }
        if (reqParams.containsKey("searchJson")) {
            Searchjson = reqParams.get("searchJson").toString();
        }
        if (reqParams.containsKey("filterConjuctionCriteria")) {
            filterConjuctionCriteria = reqParams.get("filterConjuctionCriteria").toString();
        }
 
        String mySearchFilterString = "";
        ArrayList params = new ArrayList();
        params.add(accountid);
        params.add(companyid);
        String joinString = "";
        if (!StringUtil.isNullOrEmpty(Searchjson)) {
            HashMap<String, Object> request = new HashMap<String, Object>();
            request.put(Constants.Searchjson, Searchjson);
            request.put(Constants.appendCase, "and");
            request.put(Constants.moduleid, Constants.Acc_FixedAssets_Details_ModuleId);
            request.put("filterConjuctionCriteria", filterConjuctionCriteria);
            try {
                mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "assetdetailcustomdata");
                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "assetdetailcustomdata");
                joinString = " inner join assetdetailcustomdata on assetdetail.id=assetdetailcustomdata.assetDetailsId ";
                StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
            } catch (JSONException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            } catch (ParseException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
        String q = "select COALESCE(sum(openingdepreciation),0) from assetdetail inner join product on assetdetail.product=product.id " + joinString + " where product.depreciationprovisionglaccount=? and product.company=?" + mySearchFilterString;
        returnList = executeSQLQuery( q, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    public int getOpeningDepreciationCountForAccount(String accountid, String companyid) throws ServiceException {
        List<BigInteger> returnList = Collections.EMPTY_LIST;
        String q = "select count(assetdetail.id) from assetdetail inner join product on assetdetail.product=product.id where product.depreciationprovisionglaccount=? and product.company=? and assetdetail.openingdepreciation > 0";
        returnList = executeSQLQuery( q, new Object[]{accountid, companyid});
        int count = 0;
        if (!returnList.isEmpty() && returnList.size() > 0) {
            count = (Integer) returnList.get(0).intValue();
        }
        return count;
    }    
    @Override
    public int getAssetPurchaseOpeningBalanceCountForAccount(HashMap<String, Object> requestMap) throws ServiceException {
        List<BigInteger> returnList = Collections.EMPTY_LIST;
        String accountid="";
        String companyid="";
        Date dateValue=null;
        if (requestMap.containsKey("accountid")) {
            accountid = requestMap.get("accountid").toString();
        }
        if (requestMap.containsKey("companyid")) {
            companyid = requestMap.get("companyid").toString();
        }

        String q = "select count(assetdetail.id) from assetdetail inner join product on assetdetail.product=product.id where assetdetail.iscreatedfromopeningform='1' and product.purchaseAccount=? and product.company=? ";
        returnList = executeSQLQuery( q, new Object[]{accountid, companyid});
        int count = 0;
        if (!returnList.isEmpty() && returnList.size() > 0) {
            count = (Integer) returnList.get(0).intValue();
        }
        return count;
    }
    
    @Override
    public KwlReturnObject getAssetPurchaseOpeningForAccount(HashMap<String, Object> reqParams) throws ServiceException {
        List returnList = Collections.EMPTY_LIST;
        String accountid = "";
        String companyid = "";
        String Searchjson = "";
        String filterConjuctionCriteria = "";
        if (reqParams.containsKey("accountid")) {
            accountid = reqParams.get("accountid").toString();
        }
        if (reqParams.containsKey("companyid")) {
            companyid = reqParams.get("companyid").toString();
        }
        if (reqParams.containsKey("searchJson")) {
            Searchjson = reqParams.get("searchJson").toString();
        }
        if (reqParams.containsKey("filterConjuctionCriteria")) {
            filterConjuctionCriteria = reqParams.get("filterConjuctionCriteria").toString();
        }
 
        String mySearchFilterString = "";
        ArrayList params = new ArrayList();
        params.add(accountid);
        params.add(companyid);
        String joinString = "";
        if (!StringUtil.isNullOrEmpty(Searchjson)) {
            HashMap<String, Object> request = new HashMap<String, Object>();
            request.put(Constants.Searchjson, Searchjson);
            request.put(Constants.appendCase, "and");
            request.put(Constants.moduleid, Constants.Acc_FixedAssets_Details_ModuleId);
            request.put("filterConjuctionCriteria", filterConjuctionCriteria);
            try {
                mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(request, true).get(Constants.myResult));
                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "assetdetailcustomdata");
                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "assetdetailcustomdata");
                joinString = " inner join assetdetailcustomdata on assetdetail.id=assetdetailcustomdata.assetDetailsId ";
                StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
            } catch (JSONException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            } catch (ParseException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            }

        }
        String q = "select COALESCE(sum(cost),0) from assetdetail inner join product on assetdetail.product=product.id " + joinString + " where assetdetail.iscreatedfromopeningform='1' and product.purchaseAccount=? and product.company=?" + mySearchFilterString;
        returnList = executeSQLQuery( q, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
//    @Override
//     public Date getAssetPurchaseAccountBalanceBasedOnDate(ExtraCompanyPreferences extra, CompanyAccountPreferences preferences) throws ServiceException{
//        Date finanDate = null;
//        if(extra != null && preferences != null){
//            if(extra.getAssetDepreciationCalculationBasedOn() == Constants.DEPRECIATION_BASED_ON_BOOK_BEGINNING_DATE){
//                finanDate = preferences.getBookBeginningFrom();
//            }else{
//                finanDate = preferences.getFirstFinancialYearFrom() != null ? preferences.getFirstFinancialYearFrom() : preferences.getFinancialYearFrom();
//            }
//        }
//        return finanDate;
//    }
    
    @Override
    public KwlReturnObject addProduct(HashMap<String, Object> productMap) throws ServiceException {
        List list = new ArrayList();
        try {
            Product product = new Product();
            product.setDeleted(false);
            product = buildProduct(product, productMap);
            save(product);
            list.add(product);
        } catch (Exception e) {
            throw ServiceException.FAILURE("addProduct : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product has been added successfully", null, list, list.size());
    }
    
    /**
     * Method to save or update mapping of Deskera product and corresponding item on AvaTax
     * @param paramsJobj
     * @return
     * @throws ServiceException 
     */
    @Override
    public KwlReturnObject saveOrUpdateProductAvalaraIdMapping(JSONObject paramsJobj) throws ServiceException {
        List list = new ArrayList();
        String productid = null;
        if (paramsJobj.has("productid")) {
            productid = paramsJobj.optString("productid");
        }
        if (!StringUtil.isNullOrEmpty(productid)) {
            ProductAvalaraIdMapping productAvalaraIdMapping = (ProductAvalaraIdMapping) get(ProductAvalaraIdMapping.class, productid);
            if (productAvalaraIdMapping == null) {
                productAvalaraIdMapping = new ProductAvalaraIdMapping();
                Product product = (Product) get(Product.class, productid);
                productAvalaraIdMapping.setProduct(product);
            }
            if (paramsJobj.has("avalaraItemId")) {
                productAvalaraIdMapping.setAvalaraItemId(paramsJobj.optString("avalaraItemId"));
            }
            saveOrUpdate(productAvalaraIdMapping);
            list.add(productAvalaraIdMapping);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    /**
     * Function to get amending price.it is user specific functionality.
     * in this sales should always be greater than latest purchase price.
     */
    @Override
    public JSONObject getamendingPurchaseprice(String Productid,String userid, Date transactionDate, String currency, String uomid,JSONObject obj) throws ServiceException, JSONException {
//       JSONObject obj = new JSONObject();
        KwlReturnObject amendingPriceresult = accountingHandlerDAOobj.getObject(AmendingPrice.class.getName(), userid !=null ? userid:"");
        AmendingPrice AmendingPriceObj = amendingPriceresult != null ? (AmendingPrice) amendingPriceresult.getEntityList().get(0) : null;
        boolean isamendpurchasepriceNotAvl = false;
        if (AmendingPriceObj != null && AmendingPriceObj.isBlockAmendingPrice() && !StringUtil.isNullOrEmpty(Productid)) {
            /**
             * Checking updated price is purchase price is present or not.
             */
            KwlReturnObject updatedPurchasePriceresult = getProductPrice(Productid, true, transactionDate, "", currency, uomid, true);                 //ERM-389 / ERP-35140
            double updatedPurchasePrice = updatedPurchasePriceresult != null ? (updatedPurchasePriceresult.getEntityList().isEmpty() ? 0 : (updatedPurchasePriceresult.getEntityList().get(0) == null ? 0 : (Double) updatedPurchasePriceresult.getEntityList().get(0))) : 0;
            /**
             * Checking initial price if updated price is not purchase price.
             */
            KwlReturnObject amendpurchasepriceObj = getProductPrice(Productid, true, transactionDate, "", currency, uomid, false);
            double amendpurchaseprice = amendpurchasepriceObj != null ? (amendpurchasepriceObj.getEntityList().isEmpty() ? 0 : (amendpurchasepriceObj.getEntityList().get(0) == null ? 0 : (Double) amendpurchasepriceObj.getEntityList().get(0))) : 0;
            if (updatedPurchasePrice <= 0 && amendpurchasepriceObj != null && amendpurchasepriceObj.getEntityList() != null && amendpurchasepriceObj.getEntityList().get(0) == null) {
                isamendpurchasepriceNotAvl = true;
            }
            obj.put("amendpurchaseprice", (updatedPurchasePrice > 0) ? updatedPurchasePrice : amendpurchaseprice);
            obj.put("isamendpurchasepricenotavail", isamendpurchasepriceNotAvl);
        }
        return obj;
    }
    
    /**
     * Method to delete mapping of Deskera product and corresponding item on AvaTax
     * @param paramsJobj
     * @return
     * @throws ServiceException 
     */
    @Override
    public KwlReturnObject deleteProductAvalaraIdMapping(JSONObject paramsJobj) throws ServiceException {
        List list = new ArrayList();
        String productid = null;
        if (paramsJobj.has("productid")) {
            productid = paramsJobj.optString("productid");
        }
        if (!StringUtil.isNullOrEmpty(productid)) {
            ProductAvalaraIdMapping productAvalaraIdMapping = (ProductAvalaraIdMapping) get(ProductAvalaraIdMapping.class, productid);
            if (productAvalaraIdMapping != null) {
                delete(productAvalaraIdMapping);
                list.add(productid);
            }
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    /*Getting Category of selected product that was selected to clone*/

    @Override
    public KwlReturnObject getProductCategory(String productid) throws ServiceException {
        List list = new ArrayList();
        try {
            String hqlQuery = "Select pcm.productCategory.ID from ProductCategoryMapping pcm where pcm.productID.ID=?";
            list = executeQuery(hqlQuery, new Object[]{productid});
        } catch (Exception e) {
            throw ServiceException.FAILURE("getProductCategory : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    public KwlReturnObject deleteProductBatchSerialDetails(HashMap<String, Object> requestParams) throws ServiceException {
        String delQuery = "", delQuery1 = "", delQuery2 = "", delQuerypb = "", delQueryBs = "";
        int numtotal = 0, numRows5 = 0;
        String serialmapids = "", docids = "",serialstringids="";
        String batchmapids = "";
        docids=(String)requestParams.get("productid");
        docids="'"+docids+"'";
        if (!StringUtil.isNullOrEmpty(docids)) {
            ArrayList params14 = new ArrayList();
            String myquery4 = " select batchmapid from locationbatchdocumentmapping where documentid in (" + docids + ") ";
            String myquery5 = " select serialid,id from serialdocumentmapping where documentid in (" + docids + ") ";
            List list4 = executeSQLQuery( myquery4, params14.toArray());
            Iterator itr4 = list4.iterator();
            while (itr4.hasNext()) {
                String docId = (String) itr4.next();
                if (docId != null) {
                    String batchstringids = docId;
                    batchmapids += "'" + batchstringids + "',";
                }
            }
            if (!StringUtil.isNullOrEmpty(batchmapids)) {
                batchmapids = batchmapids.substring(0, batchmapids.length() - 1);
            }
            List list5 = executeSQLQuery( myquery5, params14.toArray());
            Iterator itr5 = list5.iterator();
            while (itr5.hasNext()) {
                Object[] objArr = (Object[]) itr5.next();
//                String serialstringids = itr4.next().toString();
//                serialmapids += "'" + serialstringids + "',";
                serialmapids += "'" + objArr[0] + "',";
            }
            if (!StringUtil.isNullOrEmpty(serialmapids)) {
                serialstringids = serialmapids.substring(0, serialmapids.length() - 1);
            }
            String serialDocumentMappingId = getSerialDocumentIds(list5);
            if (!StringUtil.isNullOrEmpty(serialDocumentMappingId)) {
                serialDocumentMappingId = serialDocumentMappingId.substring(0, serialDocumentMappingId.length() - 1);
                ArrayList params1 = new ArrayList();
                delQuery1 = "delete  from serialcustomdata where serialdocumentmappingid in (" + serialDocumentMappingId + ")";
                int numRows1 = executeSQLUpdate( delQuery1, params1.toArray());
            }

        }
        ArrayList params15 = new ArrayList();
        delQuerypb = "delete  from locationbatchdocumentmapping where documentid in (" + docids + ") ";
        int numRows = executeSQLUpdate( delQuerypb, params15.toArray());

        delQuerypb = "delete  from serialdocumentmapping where documentid in (" + docids + ") ";
        numRows = executeSQLUpdate( delQuerypb, params15.toArray());

        if (!StringUtil.isNullOrEmpty(batchmapids)) {
            params15 = new ArrayList();
            delQuerypb = "delete  from newproductbatch where id in (" + batchmapids + ") ";
            int numRows8 = executeSQLUpdate( delQuerypb, params15.toArray());

        }

        if (!StringUtil.isNullOrEmpty(serialmapids)) {
            ArrayList paramsSerial = new ArrayList();
            delQueryBs = " delete from newbatchserial where id in(" + serialstringids + ") ";
            int numRowsSerial = executeSQLUpdate( delQueryBs, paramsSerial.toArray());
        }

        return new KwlReturnObject(true, "Product Batch Details has been deleted successfully.", null, null, numtotal);
    }
    public KwlReturnObject deleteProductCompostion(HashMap<String, Object> requestParams) throws ServiceException {
        int numRows1 = 0;
        String delQuery1 = "",proids = "", prodComids = "";
        proids = (String) requestParams.get("productid");
        if (!StringUtil.isNullOrEmpty(proids)) {
            String myquery4 = " select id from productcomposition where product = ?";
            List list4 = executeSQLQuery( myquery4,new Object[]{proids});
            Iterator itr4 = list4.iterator();
            while (itr4.hasNext()) {
                String prodId = (String) itr4.next();
                if (prodId != null) {
                    String batchstringids = prodId;
                    prodComids += "'" + batchstringids + "',";
                }
            }
            if (!StringUtil.isNullOrEmpty(prodComids)) { 
                prodComids = prodComids.substring(0, prodComids.length() - 1);
                delQuery1 = "delete from productcomposition where id in ("+prodComids+")";
                numRows1 = executeSQLUpdate( delQuery1);
            }
        }
        return new KwlReturnObject(true, "Product Composition Details has been deleted successfully.", null, null, numRows1);
    }
    /*
     * activateDeactivateProducts() used to activate/deactivate of product
     */
    public KwlReturnObject activateDeactivateProducts(HashMap request) throws ServiceException{
        List list = new ArrayList();
        try {
            JSONArray jArr = new JSONArray((String) request.get("data"));
            boolean productActivateDeactivateFlag = (Boolean) request.get("productActivateDeactivateFlag");
            for (int i = 0; i < jArr.length(); i++) {
                JSONObject jobj = jArr.getJSONObject(i);
                if (!StringUtil.isNullOrEmpty(jobj.getString("productid"))) {
                    Product productObj = (Product) get(Product.class, jobj.getString("productid"));
                    if (productObj != null) {
                        productObj.setIsActive(productActivateDeactivateFlag);
                        update(productObj);
                        list.add(productObj);
                    }
                }
            }
        }  catch (JSONException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }    
    public String getSerialDocumentIds(List list) {
        String serialDocument = "";
        String serialDocumentMappingId = "";
        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            Object[] objArr = (Object[]) itr.next();
            for (int i = 0; i < objArr.length; i++) {
                SerialDocumentMapping serialDocumentMapping = (SerialDocumentMapping) get(SerialDocumentMapping.class, (String) objArr[i]);
                if (serialDocumentMapping != null) {
                    serialDocument = serialDocumentMapping.getId().toString();
                    serialDocumentMappingId += "'" + serialDocument + "',";

                }
            }

        }
        return serialDocumentMappingId;
    }
    @Override
    public KwlReturnObject updateProduct(HashMap<String, Object> productMap) throws ServiceException {
        List list = new ArrayList();
        try {
            String productid = (String) productMap.get("id");
            Product product = (Product) get(Product.class, productid);
            if (product != null) {
                product = buildProduct(product, productMap);
                saveOrUpdate(product);
            }
            list.add(product);
        } catch (Exception e) {
            throw ServiceException.FAILURE("updateProduct : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product has been updated successfully", null, list, list.size());
    }

    public Product buildProduct(Product product, HashMap<String, Object> productMap) throws ServiceException {
        if (productMap.containsKey("producttype")) {
            Producttype ptype = productMap.get("producttype") == null ? null : (Producttype) get(Producttype.class, (String) productMap.get("producttype"));
            product.setProducttype(ptype);
        }
        if (productMap.containsKey(Constants.SEQFORMAT)) {
            product.setSeqformat((SequenceFormat) get(SequenceFormat.class, (String) productMap.get(Constants.SEQFORMAT)));
        }
        if (productMap.containsKey(Constants.SEQNUMBER)) {
            product.setSeqnumber(Integer.parseInt(productMap.get(Constants.SEQNUMBER).toString()));
        }
        if (productMap.containsKey(Constants.DATEPREFIX) && productMap.get(Constants.DATEPREFIX) != null) {
            product.setDatePreffixValue((String) productMap.get(Constants.DATEPREFIX));
        }
        if (productMap.containsKey(Constants.DATEAFTERPREFIX) && productMap.get(Constants.DATEAFTERPREFIX) != null) {
            product.setDateAfterPreffixValue((String) productMap.get(Constants.DATEAFTERPREFIX));
        }
        if (productMap.containsKey(Constants.DATESUFFIX) && productMap.get(Constants.DATESUFFIX) != null) {
            product.setDateSuffixValue((String) productMap.get(Constants.DATESUFFIX));
        }
        if (productMap.containsKey("createdon")) {
            product.setCreatedon((Long) productMap.get("createdon"));
        }
        if (productMap.containsKey("asOfDate")) {
            product.setAsOfDate((Date) productMap.get("asOfDate"));
        }
        if (productMap.containsKey("industryCodeId")) {
            product.setIndustryCodeId((String) productMap.get("industryCodeId"));
        }
        if (productMap.containsKey("parentid")) {
            Product pproduct = productMap.get("parentid") == null ? null : (Product) get(Product.class, (String) productMap.get("parentid"));
            product.setParent(pproduct);
        }
        if (productMap.containsKey("name")) {
            product.setName((String) productMap.get("name"));
        }
        if (productMap.containsKey("productid")) {
            product.setProductid((String) productMap.get("productid"));
        }
        if (productMap.containsKey("desc")) {
            product.setDescription((String) productMap.get("desc"));
        }
        if (productMap.containsKey("tariffname")) {
            product.setTariffName((String) productMap.get("tariffname"));
        }
        if (productMap.containsKey("hsCode")) {
            product.setHSNCode((String) productMap.get("hsCode"));
        }
        if (productMap.containsKey("reportinguom")) {
            product.setReportinguom((String) productMap.get("reportinguom"));
        }
        if (productMap.containsKey("reportingSchemaType")) {
            UOMschemaType uoms = productMap.get("reportingSchemaType") == null ? null : (UOMschemaType) get(UOMschemaType.class, (String) productMap.get("reportingSchemaType"));
            product.setReportingSchemaType(uoms);
        }
        if (productMap.containsKey("syncable")) {
            product.setSyncable((Boolean) productMap.get("syncable"));
        }
        if (productMap.containsKey("isrecyclable")) {
            product.setRecyclable((Boolean) productMap.get("isrecyclable"));
        }
        if (productMap.containsKey("isQAenable")) {
            product.setQaenable((Boolean) productMap.get("isQAenable"));
        }
        if (productMap.containsKey("multiuom")) {
            product.setMultiuom((Boolean) productMap.get("multiuom"));
        }
        if (productMap.containsKey("blockLooseSell")) {
            product.setblockLooseSell((Boolean) productMap.get("blockLooseSell"));
        }
        if (productMap.containsKey("autoAssembly")) {
            product.setAutoAssembly((Boolean) productMap.get("autoAssembly"));
        }
        if (productMap.containsKey("isBatchForProduct")) {
            product.setIsBatchForProduct((Boolean) productMap.get("isBatchForProduct"));
        }
        if (productMap.containsKey("isLocationForProduct")) {
            product.setIslocationforproduct((Boolean) productMap.get("isLocationForProduct"));
        }
        if (productMap.containsKey("activateProductComposition")) {
            product.setActivateProductComposition((Boolean) productMap.get("activateProductComposition"));
        }
        if (productMap.containsKey("isWarehouseForProduct")) {
            product.setIswarehouseforproduct((Boolean) productMap.get("isWarehouseForProduct"));
        }
        if (productMap.containsKey("isRowForProduct")) {
            product.setIsrowforproduct((Boolean) productMap.get("isRowForProduct"));
        }
        if (productMap.containsKey("isRackForProduct")) {
            product.setIsrackforproduct((Boolean) productMap.get("isRackForProduct"));
        }
        if (productMap.containsKey("isBinForProduct")) {
            product.setIsbinforproduct((Boolean) productMap.get("isBinForProduct"));
        }
        if (productMap.containsKey("isSerialForProduct")) {
            product.setIsSerialForProduct((Boolean) productMap.get("isSerialForProduct"));
        }
        if (productMap.containsKey("isSKUForProduct")) {
            product.setIsSKUForProduct((Boolean) productMap.get("isSKUForProduct"));
        }
        if (productMap.containsKey("uomid")) {
            UnitOfMeasure uom = productMap.get("uomid") == null ? null : (UnitOfMeasure) get(UnitOfMeasure.class, (String) productMap.get("uomid"));
            product.setUnitOfMeasure(uom);
        }
        if (productMap.containsKey("displayUoM")) {
            UnitOfMeasure displayUoM = productMap.get("displayUoM") == null ? null : (UnitOfMeasure) get(UnitOfMeasure.class, (String) productMap.get("displayUoM"));
            product.setDisplayUoM(displayUoM);
        }
        if (productMap.containsKey("purchaseaccountid")) {
            Account paccount = productMap.get("purchaseaccountid") == null ? null : (Account) get(Account.class, (String) productMap.get("purchaseaccountid"));
            if (product.getPurchaseAccount() != null && paccount != null) {
                if (!product.getPurchaseAccount().getID().equals(paccount.getID())) {
                    Account currentpaccount = product.getPurchaseAccount();
                    String CurrentUsedIn = currentpaccount.getUsedIn();
                    CurrentUsedIn = StringUtil.replaceUsedIn(CurrentUsedIn,Constants.Product_Purchase_Account);
                    currentpaccount.setUsedIn(CurrentUsedIn);
                    saveOrUpdate(currentpaccount);
                }
            }
            product.setPurchaseAccount(paccount);
            if(paccount != null){
                String usedin=paccount.getUsedIn();
                paccount.setUsedIn(StringUtil.getUsedInValue(usedin, Constants.Product_Purchase_Account));
            }
        }
        if (productMap.containsKey("salesaccountid")) {
            Account saccount = productMap.get("salesaccountid") == null ? null : (Account) get(Account.class, (String) productMap.get("salesaccountid"));
            if (product.getSalesAccount() != null && saccount != null) {
                if (!product.getSalesAccount().getID().equals(saccount.getID())) {
                    Account currentsaccount = product.getSalesAccount();
                    String CurrentUsedIn = currentsaccount.getUsedIn();
                    CurrentUsedIn = StringUtil.replaceUsedIn(CurrentUsedIn,"Product Sales Account");
                    currentsaccount.setUsedIn(CurrentUsedIn);
                    saveOrUpdate(currentsaccount);
                }
            }
            product.setSalesAccount(saccount);
            if(saccount != null){
                String usedin=saccount.getUsedIn();
                saccount.setUsedIn(StringUtil.getUsedInValue(usedin, "Product Sales Account"));
            }
        }
        if (productMap.containsKey("shelfLocationId") && productMap.get("shelfLocationId") != null) {
            String shelfLocationId = (String) productMap.get("shelfLocationId");
            ShelfLocation shelfLocation = (ShelfLocation) get(ShelfLocation.class, shelfLocationId);
            product.setShelfLocation(shelfLocation);
        }
        if (productMap.containsKey("purchaseretaccountid")) {
            Account praccount = productMap.get("purchaseretaccountid") == null ? null : (Account) get(Account.class, (String) productMap.get("purchaseretaccountid"));
            if (product.getPurchaseReturnAccount() != null && praccount != null) {
                if (!product.getPurchaseReturnAccount().getID().equals(praccount.getID())) {
                    Account currentpraccount = product.getPurchaseReturnAccount();
                    String CurrentUsedIn = currentpraccount.getUsedIn();
                    CurrentUsedIn = StringUtil.replaceUsedIn(CurrentUsedIn,Constants.Product_Purchase_Return_Account);
                    currentpraccount.setUsedIn(CurrentUsedIn);
                    saveOrUpdate(currentpraccount);
                }
            }
            product.setPurchaseReturnAccount(praccount);
            if(praccount != null){
                String usedin=praccount.getUsedIn();
                praccount.setUsedIn(StringUtil.getUsedInValue(usedin, Constants.Product_Purchase_Return_Account));
            }
        }

        if (productMap.containsKey("location")) {
            InventoryLocation location = new InventoryLocation();
            location = (InventoryLocation) get(InventoryLocation.class, (String) productMap.get("location"));
            if (location != null) {
                product.setLocation(location);
            }
        }
        if (productMap.containsKey("warehouse")) {
            InventoryWarehouse warehouse = new InventoryWarehouse();
            warehouse = (InventoryWarehouse) get(InventoryWarehouse.class, (String) productMap.get("warehouse"));
            if (warehouse != null) {
                product.setWarehouse(warehouse);
            }
        }

        if (productMap.containsKey("salesretaccountid")) {
            Account sraccount = productMap.get("salesretaccountid") == null ? null : (Account) get(Account.class, (String) productMap.get("salesretaccountid"));
            if (product.getSalesReturnAccount() != null && sraccount != null) {
                if (!product.getSalesReturnAccount().getID().equals(sraccount.getID())) {
                    Account currentsraccount = product.getSalesReturnAccount();
                    String CurrentUsedIn = currentsraccount.getUsedIn();
                    CurrentUsedIn = StringUtil.replaceUsedIn(CurrentUsedIn,Constants.Product_Sales_Return_Account);
                    currentsraccount.setUsedIn(CurrentUsedIn);
                    saveOrUpdate(currentsraccount);
                }
            }
            product.setSalesReturnAccount(sraccount);
            if(sraccount != null){
                String usedin=sraccount.getUsedIn();
                sraccount.setUsedIn(StringUtil.getUsedInValue(usedin, Constants.Product_Sales_Return_Account));
            }
        }
        if (productMap.containsKey("leadtime")) {
            product.setLeadTimeInDays((Integer) productMap.get("leadtime"));
        }
        if (productMap.containsKey("QAleadtime")) {
            product.setQALeadTimeInDays((Integer) productMap.get("QAleadtime"));
        }
        if (productMap.containsKey("hsCode")) {
            product.setHSCode((String) productMap.get("hsCode"));
        }
        if (productMap.containsKey("industryCodeId")) {
            product.setIndustryCodeId((String) productMap.get("industryCodeId"));
        }
        if (productMap.containsKey("warrantyperiod")) {
            product.setWarrantyperiod((Integer) productMap.get("warrantyperiod"));
        }
        if (productMap.containsKey("warrantyperiodsal")) {
            product.setWarrantyperiodsal((Integer) productMap.get("warrantyperiodsal"));
        }
        if (productMap.containsKey("supplier")) {
            product.setSupplier((String) productMap.get("supplier"));
        }

        if (productMap.containsKey("productweight") && productMap.get("productweight")!=null) {
            product.setProductweight((Double) productMap.get("productweight"));
        }
        
        if (productMap.containsKey("productweightperstockuom") && productMap.get("productweightperstockuom")!=null) {
            product.setProductWeightPerStockUom((Double) productMap.get("productweightperstockuom"));
        }
        
        if (productMap.containsKey("productweightincludingpakagingperstockuom") && productMap.get("productweightincludingpakagingperstockuom")!=null) {
            product.setProductWeightIncludingPakagingPerStockUom((Double) productMap.get("productweightincludingpakagingperstockuom"));
        }
        
        if (productMap.containsKey("productvolumeperstockuom") && productMap.get("productvolumeperstockuom")!=null) {
            product.setProductVolumePerStockUom((Double) productMap.get("productvolumeperstockuom"));
        }
        if (productMap.containsKey("productvolumeincludingpakagingperstockuom") && productMap.get("productvolumeincludingpakagingperstockuom")!=null) {
            product.setProductVolumeIncludingPakagingPerStockUom((Double) productMap.get("productvolumeincludingpakagingperstockuom"));
        }

        if (productMap.containsKey("coilcraft")) {
            product.setCoilcraft((String) productMap.get("coilcraft"));
        }
        if (productMap.containsKey("interplant")) {
            product.setInterplant((String) productMap.get("interplant"));
        }

        if (productMap.containsKey("reorderlevel")) {
            product.setReorderLevel((Double) productMap.get("reorderlevel"));
        }
        if (productMap.containsKey("reorderquantity")) {
            product.setReorderQuantity((Double) productMap.get("reorderquantity"));
        }

        if (productMap.containsKey("minorderingquantity")) {
            product.setMinOrderingQuantity((Double) productMap.get("minorderingquantity"));
        }

        if (productMap.containsKey("maxorderingquantity")) {
            product.setMaxOrderingQuantity((Double) productMap.get("maxorderingquantity"));
        }

        if (productMap.containsKey("deletedflag")) {
            product.setDeleted((Boolean) productMap.get("deletedflag"));
        }
        if (productMap.containsKey("companyid")) {
            Company company = productMap.get("companyid") == null ? null : (Company) get(Company.class, (String) productMap.get("companyid"));
            product.setCompany(company);
        }
        if (productMap.containsKey("vendorid")) {
            Vendor vendor = productMap.get("vendorid") == null ? null : (Vendor) get(Vendor.class, (String) productMap.get("vendorid"));
            product.setVendor(vendor);
        }

        if (productMap.containsKey("isFixedAsset")) {
            product.setAsset((Boolean) productMap.get("isFixedAsset"));
        }
        if (productMap.containsKey("isDepreciable")) {
            product.setDepreciable((Boolean) productMap.get("isDepreciable"));
        }
        if (productMap.containsKey("depreciationMethod")) {
            product.setDepreciationMethod((Integer) productMap.get("depreciationMethod"));
        }
        if (productMap.containsKey("depreciationRate")) {
            product.setDepreciationRate((Double) productMap.get("depreciationRate"));
        }
        if (productMap.containsKey("depreciationCostLimit")) {
            product.setDepreciationCostLimit((Integer) productMap.get("depreciationCostLimit"));
        }
        if (productMap.containsKey("depreciationGLAccountID")) {
            Account depaccount = productMap.get("depreciationGLAccountID") == null ? null : (Account) get(Account.class, (String) productMap.get("depreciationGLAccountID"));
            product.setDepreciationGLAccount(depaccount);
            if(depaccount != null){
                String usedin=depaccount.getUsedIn();
                depaccount.setUsedIn(StringUtil.getUsedInValue(usedin, Constants.Fixed_Asset_Depreciation_GL_Account));
            }
        }
        if (productMap.containsKey("location")) {
            InventoryLocation location = null;
            location = (InventoryLocation) get(InventoryLocation.class, (String) productMap.get("location"));
            if (location != null) {
                product.setLocation(location);
            }
        }
        if (productMap.containsKey("warehouse")) {
            InventoryWarehouse warehouse = null;
            warehouse = (InventoryWarehouse) get(InventoryWarehouse.class, (String) productMap.get("warehouse"));
            if (warehouse != null) {
                product.setWarehouse(warehouse);
            }
        }

        if (productMap.containsKey("depreciationProvisionGLAccountID")) {
            Account depaccount = productMap.get("depreciationProvisionGLAccountID") == null ? null : (Account) get(Account.class, (String) productMap.get("depreciationProvisionGLAccountID"));
            product.setDepreciationProvisionGLAccount(depaccount);
            if(depaccount != null){
                String usedin=depaccount.getUsedIn();
                depaccount.setUsedIn(StringUtil.getUsedInValue(usedin, Constants.Depreciation_Provision_GL_Account));
            }
        }
        if (productMap.containsKey("sellAssetGLAccountID")) {
            Account depaccount = productMap.get("sellAssetGLAccountID") == null ? null : (Account) get(Account.class, (String) productMap.get("sellAssetGLAccountID"));
            product.setSellAssetGLAccount(depaccount);
            if(depaccount != null){
                String usedin=depaccount.getUsedIn();
                depaccount.setUsedIn(StringUtil.getUsedInValue(usedin, Constants.Asset_Sales_Account));
            }
        }
        
        /*
         ERM-597:Fixed asset - Provision of Write-off account for FA
        */
        if (productMap.containsKey("writeoffassetaccount")) {
            Account writeoffAcc = productMap.get("writeoffassetaccount") == null ? null : (Account) get(Account.class, (String) productMap.get("writeoffassetaccount"));
            product.setWriteOffAssetAccount(writeoffAcc);
            if(writeoffAcc != null){
                String usedin=writeoffAcc.getUsedIn();
                writeoffAcc.setUsedIn(StringUtil.getUsedInValue(usedin, Constants.Asset_Write_Off_Account));
            }
        }

        if (productMap.containsKey("batch")) {
            ProductBatch productBatch = productMap.get("batch") == null ? null : (ProductBatch) get(ProductBatch.class, (String) productMap.get("batch"));
            product.setBatch(productBatch);
        }
        if (productMap.containsKey("dependentType")) {
            PriceType priceType = productMap.get("dependentType") == null ? null : (PriceType) get(PriceType.class, (String) productMap.get("dependentType"));
            product.setDependenttype(priceType);
        }
        if (productMap.containsKey("intervalField")) {
            product.setIntervalfield((Boolean) productMap.get("intervalField"));
        }
        if (productMap.containsKey("addshiplentheithqty")) {
            Boolean shipQty = false;
            if (productMap.get("addshiplentheithqty") != null) {
                product.setAddshiplentheithqty(Boolean.parseBoolean(productMap.get("addshiplentheithqty").toString()));
            } else {
                product.setAddshiplentheithqty(shipQty);
            }
        }
        if (productMap.containsKey("timeinterval") && productMap.get("timeinterval") != null) {
            if (!StringUtil.isNullOrEmpty((String) productMap.get("timeinterval"))) {
                product.setTimeinterval(Integer.parseInt((String) productMap.get("timeinterval")));
            }
        }
        if (productMap.containsKey("qtyUOM")) {
            product.setNoofqtyvalue((String) productMap.get("qtyUOM"));
        }
        if (productMap.containsKey("noofqty")) {
            String noOfQty = (String) productMap.get("noofqty");
            if (!StringUtil.isNullOrEmpty(noOfQty)) {
                product.setNoofquqntity(Integer.parseInt((String) productMap.get("noofqty")));
            } else {
                product.setNoofquqntity(0);
            }
        }
        if (productMap.containsKey("intervalField")) {
            product.setIntervalfield((Boolean) productMap.get("intervalField"));
        }
        if (productMap.containsKey("isImport")) {
            product.setIsImport((Integer) productMap.get("isImport"));
        }
        if (productMap.containsKey("revenueRecognitionProcess")) {
            product.setRevenueRecognitionProcess(productMap.get("revenueRecognitionProcess") != null ? (Boolean) productMap.get("revenueRecognitionProcess") : false);
        }
        if (productMap.containsKey("salesRevenueRecognitionAccountid")) {
            Account salesRevenueRecognitionAccount = productMap.get("salesRevenueRecognitionAccountid") == null ? null : (Account) get(Account.class, (String) productMap.get("salesRevenueRecognitionAccountid"));
            product.setSalesRevenueRecognitionAccount(salesRevenueRecognitionAccount);
            if(salesRevenueRecognitionAccount != null){
                String usedin=salesRevenueRecognitionAccount.getUsedIn();
                salesRevenueRecognitionAccount.setUsedIn(StringUtil.getUsedInValue(usedin,Constants.Sales_Revenue_Recognition_Account));
            }
        }
        if (productMap.containsKey("itcAccountId")) {
            Account account = productMap.get("itcAccountId") == null ? null : (Account) get(Account.class, (String) productMap.get("itcAccountId"));
            product.setItcAccount(account);
            if (account != null) {
                String usedin = account.getUsedIn();
                account.setUsedIn(StringUtil.getUsedInValue(usedin, Constants.BLOCKED_ITC_Account));
            }
        }
        if (productMap.containsKey("barcodeField")) {
            product.setBarcodefield((Integer)productMap.get("barcodeField"));
        }
        if (productMap.containsKey("itctype")) {
            product.setItcType((Integer) productMap.get("itctype"));
        }
        if (productMap.containsKey("uomschemaType"))  {
            product.setUomSchemaType((UOMschemaType) productMap.get("uomschemaType"));
        }
//        //INV_ACC_MERGE
//        // new Properties      
            if (productMap.containsKey("additionaldescription")){
            product.setAdditionalDesc((String) productMap.get("additionaldescription"));
        }
        if (productMap.containsKey("barcode")) {
            product.setBarcode((String) productMap.get("barcode"));
        }
        if (productMap.containsKey("foreigndescription")) {
            product.setDescInForeign((String) productMap.get("foreigndescription"));
        }
        if (productMap.containsKey("itemgroup")) {
            product.setItemGroup((String) productMap.get("itemgroup"));
        }
        if (productMap.containsKey("itempricelist")) {
            product.setPriceList((String) productMap.get("itempricelist"));
        }
        if (productMap.containsKey("shippingtype")) {
            product.setShippingType((String) productMap.get("shippingtype"));
        }
        if (productMap.containsKey("isActiveItem")) {
            product.setIsActive((Boolean) productMap.get("isActiveItem"));
        }
        if (productMap.containsKey("isKnittingItem")) {
            product.setIsKnittingItem((Boolean) productMap.get("isKnittingItem"));
        }

        if (productMap.containsKey("isreusable")) {
                product.setItemReusability((ItemReusability)productMap.get("isreusable")); 
        }

        if (productMap.containsKey("reusabilitycount")) {
            product.setReusabilityCount((Integer) productMap.get("reusabilitycount"));

        }
        if (productMap.containsKey("valuationmethod")) {
            product.setValuationMethod((ValuationMethod) productMap.get("valuationmethod"));
        }
        if (productMap.containsKey("licensetype")) {
            product.setLicenseType((LicenseType) productMap.get("licensetype"));
        }
        if (productMap.containsKey("licensecode")) {
            product.setLicenseCode((String) productMap.get("licensecode"));
        }

        if (productMap.containsKey("customercategory") && productMap.get("customercategory") != null ) {
            product.setCustomerCategory(productMap.get("customercategory").toString());
        }
        
        if (productMap.containsKey("servicetaxcode") && productMap.get("servicetaxcode") != null) {
            product.setServiceTaxCode(productMap.get("servicetaxcode").toString());
        }
//        if (productMap.containsKey("abatementrate")) {
//            product.setAbatementRate((Double) productMap.get("abatementrate"));
//        }
        if (productMap.containsKey("excisemethod")) {
            product.setExcisemethodmain(productMap.get("excisemethod").toString());
        }
        if (productMap.containsKey("natureOfStockItem")) {
            product.setNatureofStockItem(productMap.get("natureOfStockItem").toString());
        }
        if (productMap.containsKey("excisemethodsubtype")) {
            product.setExcisemethodsubtype(productMap.get("excisemethodsubtype").toString());
        }
        if (productMap.containsKey("exciserate")) {
            product.setExciserate((Double) productMap.get("exciserate"));
        }
        if (productMap.containsKey("vatcommoditycode")) {
            MasterItem masteritem = productMap.get("vatcommoditycode") == null ? null : (MasterItem) get(MasterItem.class, (String) productMap.get("vatcommoditycode"));
            product.setVatcommoditycode(masteritem);
        }
        if (productMap.containsKey("vatonmrp")) {
            product.setVatonmrp(Boolean.valueOf(productMap.get("vatonmrp").toString()));
        }
        if (productMap.containsKey("mrprate")) {
            if(productMap.get("mrprate")!=null &&productMap.get("mrprate")!="")
                product.setMrprate(Double.parseDouble(productMap.get("mrprate").toString()));
        }
        if (productMap.containsKey("sac")) {
            product.setSAC((String) productMap.get("sac"));
        }
        if (productMap.containsKey("vatMethodType")) {
            product.setVatMethodType(productMap.get("vatMethodType").toString());
        }
        if (productMap.containsKey("reportingUOMVAT")) {
            product.setReportinguomVAT((String) productMap.get("reportingUOMVAT"));
        }
        if (productMap.containsKey("reportingSchemaVAT")) {
            UOMschemaType uoms = productMap.get("reportingSchemaVAT") == null ? null : (UOMschemaType) get(UOMschemaType.class, (String) productMap.get("reportingSchemaVAT"));
            product.setReportingSchemaTypeVAT(uoms);
        }
        if (productMap.containsKey("vatabatementrate")) {
            product.setVatAbatementRate((Double) productMap.get("vatabatementrate"));
        }
        if (productMap.containsKey("vatAbatementPeriodFromDate")) {
            product.setVatAbatementPeriodFromDate((Date) productMap.get("vatAbatementPeriodFromDate"));
        }
        if (productMap.containsKey("vatAbatementPeriodToDate")) {
            product.setVatAbatementPeriodToDate((Date) productMap.get("vatAbatementPeriodToDate"));
        }
        // Purchase Tab fields

        if (productMap.containsKey("catalogNo")) {
            product.setCatalogNo((String) productMap.get("catalogNo"));
        }

        if (productMap.containsKey("purchaseuomid"))  {
            product.setPurchaseUOM((UnitOfMeasure) productMap.get("purchaseuomid"));
        }
            if(productMap.containsKey("itempurchaseheight"))  {
            product.setItemPurchaseHeight((Double) productMap.get("itempurchaseheight"));
        }
        if(productMap.containsKey("itempurchasewidth"))  {
            product.setItemPurchaseWidth((Double) productMap.get("itempurchasewidth"));
        }
        if (productMap.containsKey("itempurchaselength")) {
            product.setItemPurchaseLength((Double) productMap.get("itempurchaselength"));
        }
        if (productMap.containsKey("itempurchasevolume")) {
            product.setItemPurchaseVolume((Double) productMap.get("itempurchasevolume"));
        }
        if (productMap.containsKey("purchasemfg")) {
            product.setPurchaseMfg((String) productMap.get("purchasemfg"));
        }


        // Sales Tab fields

        if (productMap.containsKey("salesuomid")) {
            product.setSalesUOM((UnitOfMeasure) productMap.get("salesuomid"));
        }           
        if(productMap.containsKey("itemsalesheight")) {
            product.setItemSalesHeight((Double) productMap.get("itemsalesheight"));
        }
        if (productMap.containsKey("itemsaleswidth")) {
            product.setItemSalesWidth((Double) productMap.get("itemsaleswidth"));
        }
            if(productMap.containsKey("itemsaleslength")){
            product.setItemSalesLength((Double) productMap.get("itemsaleslength"));
        }
            if(productMap.containsKey("itemsalesvolume")) {
            product.setItemSalesVolume((Double) productMap.get("itemsalesvolume"));
        }

            if(productMap.containsKey("alternateproductid")) {
            product.setAlternateProduct((String) productMap.get("alternateproductid"));
        }

        //  Properties Tab fields

            if(productMap.containsKey("itemheight")) {
            product.setItemHeight((Double) productMap.get("itemheight"));
        }
            if(productMap.containsKey("itemwidth")){
            product.setItemWidth((Double) productMap.get("itemwidth"));
        }
            if(productMap.containsKey("itemlength")) {
            product.setItemLength((Double) productMap.get("itemlength"));
        }
            if(productMap.containsKey("itemvolume")) {
            product.setItemVolume((Double) productMap.get("itemvolume"));
        }
            if(productMap.containsKey("itemcolor")) {
            product.setItemColor((String) productMap.get("itemcolor"));
        }

        //  Remarks Tab fields         

            if(productMap.containsKey("additionalfreetext")) {
            product.setAdditionalFreeText((String) productMap.get("additionalfreetext"));
        }

        //  Inventory Data Tab fields

        if (productMap.containsKey("valuationmethod")) {
                product.setValuationMethod((ValuationMethod)productMap.get("valuationmethod")); 
        }

        if (productMap.containsKey("orderUoM")) {
            product.setOrderingUOM((UnitOfMeasure) productMap.get("orderUoM"));
        }

        if (productMap.containsKey("transferUoM")) {
            product.setTransferUOM((UnitOfMeasure) productMap.get("transferUoM"));
        }

            if(productMap.containsKey("packaging")) {
            product.setPackaging((Packaging) productMap.get("packaging"));
        }
            if(productMap.containsKey("inspectionTemplate")) {
            product.setInspectionTemplate((InspectionTemplate) productMap.get("inspectionTemplate"));
        }

//            if (productMap.containsKey("itemcost")) {
//                product.setItemCost((Double) productMap.get("itemcost"));
//            }

            if(productMap.containsKey("WIPoffset")){
            product.setWIPOffset((String) productMap.get("WIPoffset"));
        }
            if(productMap.containsKey("Inventoryoffset")) {
            product.setInventoryOffset((String) productMap.get("Inventoryoffset"));
        }
        if (productMap.containsKey("countable")) {
                product.setCountable((Boolean)productMap.get("countable")); 
        }
        if (productMap.containsKey("CCFrequency")) {
                product.setCycleCountFrequencies((Set)productMap.get("CCFrequency")); 
        }
        if (productMap.containsKey("currencyid") && productMap.get("currencyid")!=null) {
            KWLCurrency currency = productMap.get("currencyid") == null ? null : (KWLCurrency) get(KWLCurrency.class, (String) productMap.get("currencyid"));
            product.setCurrency(currency);
        }
        if (productMap.containsKey("accproductcustomdataref")) {
            AccProductCustomData cmp = (productMap.get("accproductcustomdataref") == null ? null : (AccProductCustomData) get(AccProductCustomData.class, (String) productMap.get("accproductcustomdataref")));
            product.setProductCustomData(cmp);
        }
        if (productMap.containsKey("parentCompanyProductID")) {
            Product prod = productMap.get("parentCompanyProductID") == null ? null : (Product) get(Product.class, (String) productMap.get("parentCompanyProductID"));
            if (prod != null) {
                product.setPropagatedProductID(prod);
            }
        }
        if (productMap.containsKey("isWastageApplicable")) {
            product.setWastageApplicable((Boolean) productMap.get("isWastageApplicable"));
        }
        if (productMap.containsKey("wastageAccount")) {
            Account wastageAccount = productMap.get("wastageAccount") == null ? null : (Account) get(Account.class, (String) productMap.get("wastageAccount"));
            product.setWastageAccount(wastageAccount);
            if (wastageAccount != null) {
                String usedIn = wastageAccount.getUsedIn();
                wastageAccount.setUsedIn(StringUtil.getUsedInValue(usedIn, Constants.Product_Wastage_Account));
            }
        }
        if (productMap.containsKey("substituteProductId") &&  productMap.get("substituteProductId") != null) {
            Product substituteProduct = (Product) get(Product.class, (String) productMap.get("substituteProductId"));
            product.setSubstituteProduct(substituteProduct);
        }
        if (productMap.containsKey("substituteQty") &&  productMap.get("substituteQty") != null) {
            product.setSubstituteQty((Double) productMap.get("substituteQty"));
        }
        if (productMap.containsKey("interStatePurAccID")) {
             Account ispa = productMap.get("interStatePurAccID") == null ? null : (Account) get(Account.class, (String) productMap.get("interStatePurAccID"));
             product.setInterStatePurchaseAccount(ispa);
        }
        if (productMap.containsKey("interStatePurAccCformID")) {
            Account ispacf = productMap.get("interStatePurAccCformID") == null ? null : (Account) get(Account.class, (String) productMap.get("interStatePurAccCformID"));
            product.setInterStatePurchaseAccountCForm(ispacf);
        }
        if (productMap.containsKey("interStatePurReturnAccID")) {
            Account ispra = productMap.get("interStatePurReturnAccID") == null ? null : (Account) get(Account.class, (String) productMap.get("interStatePurReturnAccID"));
            product.setInterStatePurchaseReturnAccount(ispra);
        }
        if (productMap.containsKey("interStatePurReturnAccCformID")) {
            Account ispracf = productMap.get("interStatePurReturnAccCformID") == null ? null : (Account) get(Account.class, (String) productMap.get("interStatePurReturnAccCformID"));
            product.setInterStatePurchaseReturnAccountCForm(ispracf);
        }
        if (productMap.containsKey("inputVAT")) {
            Account inputVAT = productMap.get("inputVAT") == null ? null : (Account) get(Account.class, (String) productMap.get("inputVAT"));
            product.setInputVAT(inputVAT);
        }
        if (productMap.containsKey("cstVAT")) {
            Account cstVAT = productMap.get("cstVAT") == null ? null : (Account) get(Account.class, (String) productMap.get("cstVAT"));
            product.setCstVAT(cstVAT);
        }
        if (productMap.containsKey("cstVATattwo")) {
            Account cstVATattwo = productMap.get("cstVATattwo") == null ? null : (Account) get(Account.class, (String) productMap.get("cstVATattwo"));
            product.setCstVATattwo(cstVATattwo);
        }
        if (productMap.containsKey("interStateSalesAccID")) {
             Account ispa = productMap.get("interStateSalesAccID") == null ? null : (Account) get(Account.class, (String) productMap.get("interStateSalesAccID"));
             product.setInterStateSalesAccount(ispa);
        }
        if (productMap.containsKey("interStateSalesAccCformID")) {
            Account ispacf = productMap.get("interStateSalesAccCformID") == null ? null : (Account) get(Account.class, (String) productMap.get("interStateSalesAccCformID"));
            product.setInterStateSalesAccountCForm(ispacf);
        }
        if (productMap.containsKey("interStateSalesReturnAccID")) {
            Account ispra = productMap.get("interStateSalesReturnAccID") == null ? null : (Account) get(Account.class, (String) productMap.get("interStateSalesReturnAccID"));
            product.setInterStateSalesReturnAccount(ispra);
        }
        if (productMap.containsKey("interStateSalesReturnAccCformID")) {
            Account ispracf = productMap.get("interStateSalesReturnAccCformID") == null ? null : (Account) get(Account.class, (String) productMap.get("interStateSalesReturnAccCformID"));
            product.setInterStateSalesReturnAccountCForm(ispracf);
        }
        if (productMap.containsKey("inputVATSales")) {
            Account inputVATSales = productMap.get("inputVATSales") == null ? null : (Account) get(Account.class, (String) productMap.get("inputVATSales"));
            product.setInputVATSales(inputVATSales);
        }
        if (productMap.containsKey("cstVATSales")) {
            Account cstVATSales = productMap.get("cstVATSales") == null ? null : (Account) get(Account.class, (String) productMap.get("cstVATSales"));
            product.setCstVATSales(cstVATSales);
        }
        if (productMap.containsKey("cstVATattwoSales")) {
            Account ispracf = productMap.get("cstVATattwoSales") == null ? null : (Account) get(Account.class, (String) productMap.get("cstVATattwoSales"));
            product.setCstVATattwoSales(ispracf);
        }
        if (productMap.containsKey("stockadjustmentaccountid")) {// Stock Adjustment Account
            Account stockAdjustmentAccount = productMap.get("stockadjustmentaccountid") == null ? null : (Account) get(Account.class, (String) productMap.get("stockadjustmentaccountid"));
            product.setStockAdjustmentAccount(stockAdjustmentAccount);
        }
        if (productMap.containsKey("inventoryaccountid")) { // Inventory Account
            Account inventoryAccount = productMap.get("inventoryaccountid") == null ? null : (Account) get(Account.class, (String) productMap.get("inventoryaccountid"));
            product.setInventoryAccount(inventoryAccount);
        }
        if (productMap.containsKey("cogsaccountid")) {// Cost of Goods Sold Account
            Account cogsAccount = productMap.get("cogsaccountid") == null ? null : (Account) get(Account.class, (String) productMap.get("cogsaccountid"));
            product.setCostOfGoodsSoldAccount(cogsAccount);
        }
        if (productMap.containsKey("productBrandId") && productMap.get("productBrandId") != null) {
            MasterItem productBrand = (MasterItem) get(MasterItem.class, (String) productMap.get("productBrandId"));
            product.setProductBrand(productBrand);
        }
        if (productMap.containsKey("openingbalanceamount")) {
            if (productMap.get("openingbalanceamount") != null && productMap.get("openingbalanceamount") != "") {
                product.setOpeningBalanceAmount(Double.parseDouble(productMap.get("openingbalanceamount").toString()));
            }
        }
        if (productMap.containsKey("openingbalanceamountinbase")) {
            if (productMap.get("openingbalanceamountinbase") != null && productMap.get("openingbalanceamountinbase") != "") {
                product.setOpeningBalanceAmountInBase(Double.parseDouble(productMap.get("openingbalanceamountinbase").toString()));
            }
        }
        if (productMap.containsKey("exchangerateforopeningbalanceamount")) {
            if (productMap.get("exchangerateforopeningbalanceamount") != null && productMap.get("exchangerateforopeningbalanceamount") != "") {
                product.setExchangerateforopeningbalanceamount(Double.parseDouble(productMap.get("exchangerateforopeningbalanceamount").toString()));
            }
        }
        if (productMap.containsKey("landingCostCategory")) {
            Set<LandingCostCategory> landingCostCategorySet=new HashSet<LandingCostCategory>();
            if (productMap.get("landingCostCategory") != null && productMap.get("landingCostCategory") != "") {
                 List list=Arrays.asList(productMap.get("landingCostCategory").toString().split(","));
                for(Object data:list){
                    LandingCostCategory lcc=(LandingCostCategory)get(LandingCostCategory.class, data.toString());
                    landingCostCategorySet.add(lcc);
                }
            }
                product.setLccategoryid(landingCostCategorySet);
            }
        if (productMap.containsKey("productCreatedOnAvalara")) {
            product.setProductCreatedOnAvalara((Boolean) productMap.get("productCreatedOnAvalara"));
        }
        if (productMap.containsKey("rcmapplicable")) {
            product.setRcmApplicable((Boolean) productMap.get("rcmapplicable"));
        }
        
        if (productMap.containsKey("purchasetaxId")) {
            product.setPurchasetaxid((String) productMap.get("purchasetaxId"));
        }

        if (productMap.containsKey("salestaxId")) {
            product.setSalestaxid((String) productMap.get("salestaxId"));
        }
//        
//            // end new properties
//            
        return product;
    }

    public KwlReturnObject getProductCompositionDetails(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from ProductComposition";
        return buildNExecuteQuery( query, requestParams);
    }

    public KwlReturnObject deleteProduct(String productid) throws ServiceException {
        List list = new ArrayList();
        Product product = (Product) get(Product.class, productid);
        product.setDeleted(true);
        save(product);
        list.add(product);
        return new KwlReturnObject(true, "Product has been deleted successfully", null, list, 1);
    }

    public KwlReturnObject deleteProductFrequency(String productid, String companyid) throws ServiceException {
        String delQuery = "delete from Product p where p.ID=? and p.company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "Product Frequency has been deleted successfully.", null, null, numRows);

    }
    public KwlReturnObject deleteProductPermanently(String productid, String companyid) throws ServiceException {
        String delQuery = "delete from Product p where p.ID=? and p.company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "Product Type has been deleted successfully.", null, null, numRows);

    }
    /**
     * Function to delete Tax class data
     * @param productid
     * @return
     * @throws ServiceException 
     */
    public KwlReturnObject deleteProductTaxClassHistoryPermanently(String productid) throws ServiceException {
        String delQuery = "delete from ProductCustomFieldHistory p where p.product.ID=? ";
        int numRows = executeUpdate( delQuery, new Object[]{productid});
        return new KwlReturnObject(true, "Product Tax class history has been deleted successfully.", null, null, numRows);

    }
    public KwlReturnObject deleteProductCycleCountPermanently(String productid, String companyid) throws ServiceException {
        String delQuery = "delete from ProductCyclecount p where p.product.ID=? ";
        int numRows = executeUpdate( delQuery, new Object[]{productid});
        return new KwlReturnObject(true, "Product Type has been deleted successfully.", null, null, numRows);

    }

    public KwlReturnObject deleteCyclecountPermanently(String productid, String companyid) throws ServiceException {
        String delQuery = "delete from Cyclecount c where c.product.ID=? ";
        int numRows = executeUpdate( delQuery, new Object[]{productid});
        return new KwlReturnObject(true, "Product Type has been deleted successfully.", null, null, numRows);

    }

    public KwlReturnObject deleteProPricePermanently(String productid, String companyid) throws ServiceException {
        String delQuery = "delete from PriceList p where p.product.ID=? and p.company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "Product Price has been deleted successfully.", null, null, numRows);
    }

    public KwlReturnObject saveProductTypes(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            Producttype ptype = new Producttype();
            if (dataMap.containsKey("id")) {
                ptype = dataMap.get("id") == null ? null : (Producttype) get(Producttype.class, (String) dataMap.get("id"));
            }
            if (dataMap.containsKey("name")) {
                ptype.setName((String) dataMap.get("name"));
            }
            save(ptype);
            list.add(ptype);
        } catch (Exception e) {
            throw ServiceException.FAILURE("saveProductTypes : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product Type has been added successfully", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject getIncidentCase(JSONObject dataObj) throws ServiceException, SessionExpiredException, ParseException {
        List list = new ArrayList();
        ArrayList params = new ArrayList();
        int totalCount =0;
        boolean fromIncidentCaseReport=false;
        String ss = dataObj.optString(Constants.ss, null);
        String start = dataObj.optString(Constants.start,null);
        String limit = dataObj.optString(Constants.limit,null);
        String joinQuery="";
        if(dataObj.has("fromIncidentCaseReport")){
           fromIncidentCaseReport= dataObj.optBoolean("fromIncidentCaseReport", false);
        }
        String selectQuery = " select incident from IncidentCases incident  ";
        if (!fromIncidentCaseReport) {
            joinQuery = "inner join incident.product ";
        }
        String conditionQuery = " where incident.company.companyID = ?";
        params.add(dataObj.optString(Constants.companyKey, ""));
        
        String orderBy = " order by incident.incidentDate desc ";

        if (!StringUtil.isNullOrEmpty(ss)) {
            try {
                String[] searchcol = new String[]{"incident.report", "incident.product.productid","incident.product.name", "incident.resolution","incident.customer.name", "incident.customer.acccode"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 6);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                conditionQuery += searchQuery;
            } catch (SQLException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            }

        }

        String sqlQuery = selectQuery + joinQuery + conditionQuery + orderBy;

        list = executeQuery(sqlQuery, params.toArray());
        totalCount = list.size();
        
        if (!StringUtil.isNullOrEmpty(start) && !StringUtil.isNullOrEmpty(limit)) {
            list = executeQueryPaging(sqlQuery, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
        }

        return new KwlReturnObject(true, null, null, list, totalCount);
    }
    
    @Override
    public KwlReturnObject getIncidentChart(JSONObject dataObj) throws ServiceException, SessionExpiredException, ParseException {
        List list = new ArrayList();
        ArrayList params = new ArrayList();
        int totalCount = 0;
        try {

            DateFormat df = authHandler.getDateFormatter(dataObj);

            String selectQuery = " select DATE_FORMAT(incident.incidentDate, '%M'), COUNT(incident.ID) from IncidentCases incident  ";
            
            String conditionQuery = " where incident.company.companyID = ? ";
            params.add(dataObj.optString(Constants.companyKey, ""));

            if (dataObj.has("startdate") && dataObj.has("enddate")) {
                conditionQuery += " and incident.incidentDate >= ? and incident.incidentDate <= ?";
                params.add(df.parse(dataObj.optString("startdate","")));
                params.add(df.parse(dataObj.optString("enddate","")));
            }

            String groupBy = " GROUP BY DATE_FORMAT(incident.incidentDate, '%Y%M') ";

            String orderBy = " order by  DATE_FORMAT(incident.incidentDate, '%m') asc ";

            String sqlQuery = selectQuery + conditionQuery + groupBy + orderBy;

            list = executeQuery(sqlQuery, params.toArray());
            totalCount = list.size();

        } catch (JSONException ex) {
            return new KwlReturnObject(false, null, null, list, totalCount);
        }
        return new KwlReturnObject(true, null, null, list, totalCount);
    }
    
    @Override
    public KwlReturnObject saveIncidentCase(JSONObject dataObj) throws ServiceException,SessionExpiredException,ParseException {
        List list = new ArrayList();
        try {
            IncidentCases incidentCase = new IncidentCases();
            String incidentId = dataObj.has("id") ? dataObj.optString("id",""):"";
            
            if (StringUtil.isNullOrEmpty(incidentId)) {
                if (dataObj.has(Constants.useridKey) && dataObj.get(Constants.useridKey)!=null ) {
                    User user = (User) get(User.class, dataObj.getString(Constants.useridKey));
                    incidentCase.setCreatedby(user);
                    incidentCase.setModifiedby(user);
                }

                if (dataObj.has("createdon")) {
                    incidentCase.setCreatedon(dataObj.getLong("createdon"));
                }
                if (dataObj.has("updatedon")) {
                    incidentCase.setUpdatedon(dataObj.getLong("updatedon"));
                }
            } else {
                incidentCase = dataObj.get("id") == null ? null : (IncidentCases) get(IncidentCases.class, dataObj.getString("id"));
                if (dataObj.has(Constants.useridKey) && dataObj.get(Constants.useridKey)!=null ) {
                    User user = (User) get(User.class,  dataObj.getString(Constants.useridKey));
                    incidentCase.setModifiedby(user);
                }
                if (dataObj.has("updatedon")) {
                    incidentCase.setUpdatedon(dataObj.getLong("updatedon"));
                }
            }
            
            incidentCase.setDeleted(false);


            if (dataObj.has("report")) {
                incidentCase.setReport(dataObj.getString("report"));
            }
            if (dataObj.has("incidentdate")) {
                SimpleDateFormat sdf = new SimpleDateFormat(Constants.yyyyMMdd);
                incidentCase.setIncidentDate(sdf.parse(dataObj.getString("incidentdate")));
            }
            if (dataObj.has("incidenttime")) {
                incidentCase.setIncidenttime(dataObj.getString("incidenttime"));
            }
            if (dataObj.has("description")) {
                incidentCase.setDescription(dataObj.getString("description"));
            }
            if (dataObj.has("attachment")) {
                incidentCase.setAttatchment(dataObj.getString("attachment"));
            }
            if (dataObj.has("resolution")) {
                incidentCase.setResolution(dataObj.getString("resolution"));
            }
            if (dataObj.has("location")) {
                incidentCase.setLocation(dataObj.getString("location"));
            }
            if (dataObj.has("latitude")) {
                incidentCase.setLatitude(dataObj.optString("latitude",""));
            }
            if (dataObj.has("longitude")) {
                incidentCase.setLongitude(dataObj.optString("longitude",""));
            }
            if (dataObj.has(Constants.productid) && dataObj.get(Constants.productid) != null) {
                Product product = (Product) get(Product.class, dataObj.getString(Constants.productid));
                if (product != null) {
                    incidentCase.setProduct(product);
                }
            }
            if (dataObj.has(Constants.companyKey) && dataObj.get(Constants.companyKey) != null) {
                Company company = (Company) get(Company.class, dataObj.getString(Constants.companyKey));
                if (company != null) {
                    incidentCase.setCompany(company);
                }
            }
            
            if (dataObj.has(Constants.customerid) && dataObj.get(Constants.customerid) != null) {
                Customer customer = (Customer) get(Customer.class, dataObj.getString(Constants.customerid));
                if (customer != null) {
                    incidentCase.setCustomer(customer);
                }
            }
            
            saveOrUpdate(incidentCase);
            list.add(incidentCase);
        } catch (Exception e) {
            throw ServiceException.FAILURE("saveIncidentCase : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Incident Case added successfully", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject deleteIncidentPermanent(String incidentid) throws ServiceException {
        String delQuery = "delete from IncidentCases ic where ic.ID=?";
        int numRows = executeUpdate( delQuery, new Object[]{incidentid});
        return new KwlReturnObject(true, "Incident Case has been deleted successfully.", null, null, numRows);
    }
    
    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public KwlReturnObject deleteIncidentTemporary(JSONObject dataObj) throws ServiceException, JSONException {
        List list = new ArrayList();

        IncidentCases incidentCase = dataObj.get("id") == null ? null : (IncidentCases) get(IncidentCases.class, dataObj.getString("id"));
        if (incidentCase != null) {
            incidentCase.setDeleted(true);

            if (dataObj.has(Constants.useridKey) && dataObj.get(Constants.useridKey) != null) {
                User user = (User) get(User.class, dataObj.getString(Constants.useridKey));
                incidentCase.setModifiedby(user);
            }
            if (dataObj.has("updatedon")) {
                incidentCase.setUpdatedon(dataObj.getLong("updatedon"));
            }
            saveOrUpdate(incidentCase);
            list.add(incidentCase);
        }
        return new KwlReturnObject(true, "Incident Case has been deleted successfully.", null, list, list.size());
    }
    
    public KwlReturnObject saveProductPackging(Packaging packaging) throws ServiceException {
        List list = new ArrayList();
        try {
            save(packaging);
            list.add(packaging);
        } catch (Exception e) {
            throw ServiceException.FAILURE("saveProductPakaging : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product Packaging has been saved successfully", null, list, list.size());
    }

    public KwlReturnObject getProductTypes(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        String query = "from Producttype";
        returnList = executeQuery( query);
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject deleteProductType(String typeid) throws ServiceException {
        String delQuery = "delete from Producttype u where u.ID=?";
        int numRows = executeUpdate( delQuery, new Object[]{typeid});
        return new KwlReturnObject(true, "Product Type has been deleted successfully.", null, null, numRows);
    }
    
    public KwlReturnObject getProductsByType(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        params.add(Producttype.SERVICE);
        params.add((String) requestParams.get("companyid"));
        String type = (String) requestParams.get("type");
        String ss = (String) requestParams.get("ss");
        String start = (String) requestParams.get("start");
        String limit = (String) requestParams.get("limit");
        boolean isMultiSelectProductidsFlag = false;
        int totalCount = 0;
        boolean isBuild = Boolean.parseBoolean(requestParams.get("isBuild").toString());
        String condition = "";
        
        if (isBuild) {
            if (!StringUtil.isNullOrEmpty(type)) {
                condition = " and p.producttype.ID in (" +type + ") " ;
//                params.add(type);
            }
        } else {
            if (!StringUtil.isNullOrEmpty(type)) {
                condition = " and p.producttype.ID=? ";
                params.add(type);
            }
        }
        
        if (requestParams.containsKey("isMultiSelectProductidsFlag")) {
            isMultiSelectProductidsFlag = (boolean) requestParams.get("isMultiSelectProductidsFlag");
        }
        
        if (requestParams.containsKey("selectedProductIds") && !StringUtil.isNullOrEmpty((String) requestParams.get("selectedProductIds")) && isMultiSelectProductidsFlag) {
            String productIdGroup = requestParams.get("selectedProductIds").toString();
            productIdGroup = AccountingManager.getFilterInString(productIdGroup);
            condition += " and p.ID IN " + productIdGroup;
        }
        
        if (!StringUtil.isNullOrEmpty(ss)) {
            String searchQuery = "";
            String[] searchcol = new String[]{"p.name", "p.productid"};
            try {
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                StringUtil.insertParamSearchString(map);
            } catch (SQLException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
            searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
            condition += searchQuery;
        }
        
        String query = "select p,"
                + "(select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory inv where product.ID=p.ID and inv.deleted=false  and product.producttype.ID <> ? group by product.ID) "
                + "from Product p where p.parent is null and p.deleted=false and p.company.companyID=? " + condition + " order by p.name ";
        returnList = executeQuery( query, params.toArray());
        totalCount = returnList.size();
        if (!StringUtil.isNullOrEmpty(start) && !StringUtil.isNullOrEmpty(limit) && !isMultiSelectProductidsFlag) {
            returnList = executeQueryPaging(query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }
    
    @Override
    public KwlReturnObject getProductsFoRemoteAPI(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        String companyid = (String) requestParams.get("companyid");
        String currencyid = (String) requestParams.get("currencyid");
        params.add(companyid);
        String query="select p," +
                    "(select pl1.price from PriceList pl1 where product.ID=p.ID and carryIn=true "+Constants.PRICELIST_UOM_CONDITION_PURCHASE+" and pl1.currency.currencyID='"+currencyid+"' and applyDate = (select max(applyDate) as ld from PriceList where product.ID=pl1.product.ID and carryIn=pl1.carryIn "+Constants.PRICELIST_UOM_CONDITION_PURCHASE_INNER+" and currency.currencyID='"+currencyid+"' group by product))," +
                    "(select pl2.price from PriceList pl2 where product.ID=p.ID and carryIn=false "+Constants.PRICELIST_UOM_CONDITION_SALES+" and pl2.currency.currencyID='"+currencyid+"' and applyDate = (select max(applyDate) as ld from PriceList where product.ID=pl2.product.ID and carryIn=pl2.carryIn "+Constants.PRICELIST_UOM_CONDITION_SALES_INNER+" and currency.currencyID='"+currencyid+"' group by product)), " +
                    "(select sum((case when carryIn=true then quantity else -quantity end)) from Inventory where product.ID=p.ID group by product.ID), " +
                    "(select quantity from Inventory where product.ID=p.ID and newinv='T' group by product.ID), " +
                    "(select pl1.price from PriceList pl1 where product.ID=p.ID and carryIn=true "+Constants.PRICELIST_UOM_CONDITION_PURCHASE+" and pl1.currency.currencyID='"+currencyid+"' and applyDate = (select min(applyDate) as ld from PriceList where product.ID=pl1.product.ID and carryIn=pl1.carryIn "+Constants.PRICELIST_UOM_CONDITION_PURCHASE_INNER+" and currency.currencyID='"+currencyid+"' group by product)) " +
                    "from Product p where p.parent is null and p.deleted=false and p.company.companyID=? order by p.name ";
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    @Override
    public KwlReturnObject getChildProductsFoRemoteAPI(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        String companyid = (String) requestParams.get("companyid");
        String currencyid = (String) requestParams.get("currencyid");
        params.add(companyid);
        String query="select (select pl1.price from PriceList pl1 where product.ID=p.ID and carryIn=true "+Constants.PRICELIST_UOM_CONDITION_PURCHASE+" and pl1.currency.currencyID='"+currencyid+"' and applyDate = (select max(applyDate) as ld from PriceList where product.ID=pl1.product.ID and carryIn=pl1.carryIn "+Constants.PRICELIST_UOM_CONDITION_PURCHASE_INNER+"and currency.currencyID='"+currencyid+"' group by product))," +
                    "(select pl2.price from PriceList pl2 where product.ID=p.ID and carryIn=false "+Constants.PRICELIST_UOM_CONDITION_SALES+" and pl2.currency.currencyID='"+currencyid+"'and applyDate = (select max(applyDate) as ld from PriceList where product.ID=pl2.product.ID and carryIn=pl2.carryIn  "+Constants.PRICELIST_UOM_CONDITION_SALES_INNER+"and currency.currencyID='"+currencyid+"' group by product))," +
                    "(select sum((case when carryIn=true then quantity else -quantity end)) from Inventory where product.ID=p.ID group by product.ID)" +
                    " from Product p where p.ID=?";
        returnList = executeQuery(query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    //Product Assembly
    public KwlReturnObject deleteProductAssembly(String parentProductId) throws ServiceException {
        String delQuery = "delete from ProductAssembly where product.ID = ?";
        int numRows = executeUpdate( delQuery, new Object[]{parentProductId});

        return new KwlReturnObject(true, "", null, null, numRows);
    }

    //Product Composition 
    public KwlReturnObject deleteProductComposition(String productid) throws ServiceException {
        String delQuery = "delete from ProductComposition where product.ID = ?";
        int numRows = executeUpdate( delQuery, new Object[]{productid});

        return new KwlReturnObject(true, "", null, null, numRows);
    }

    public KwlReturnObject deleteProductBuildDetails(String parentProductId, String companyid) throws ServiceException {
        String delQuery = "delete from ProductBuildDetails pbd where pbd.build.ID in(select pb.ID from ProductBuild pb where pb.product.ID= ? and pb.company.companyID=? )";
        int numRows = executeUpdate( delQuery, new Object[]{parentProductId,companyid});

        return new KwlReturnObject(true, "", null, null, numRows);
    }
    public KwlReturnObject deleteProductbBuild(String parentProductId, String companyid) throws ServiceException {
        String delQuery = "delete from ProductBuild where product.ID = ? and company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{parentProductId,companyid});

        return new KwlReturnObject(true, "", null, null, numRows);
    }
    @Override
    public KwlReturnObject deleteProductBuildDetailsByID(String parentProductId, String companyid) throws ServiceException {
        String delQuery = "delete from ProductBuildDetails pbd where pbd.build.ID in(select pb.ID from ProductBuild pb where pb.ID= ? and pb.company.companyID=? )";
        int numRows = executeUpdate( delQuery, new Object[]{parentProductId,companyid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    @Override
    public KwlReturnObject deleteProductBuildBatchDetailsByID(String documentId,boolean isAssemblyProduct, String companyid) throws ServiceException{
        String selQry = " SELECT batchmapid,id,quantity from locationbatchdocumentmapping WHERE documentid = ? ";
        List params=new ArrayList();
        params.add(documentId);
      
        List listRes = executeSQLQuery(selQry, params.toArray());
        Iterator itr = listRes.iterator();
        while (itr.hasNext()) {
            Object[] objs = (Object[]) itr.next();
            String batchmapId = objs[0] != null ? (String) objs[0] : null;
            String lbmId = objs[1] != null ? (String) objs[1] : null;
            double qty = objs[2] != null ? (double) objs[2] : null;
            if(!StringUtil.isNullOrEmpty(batchmapId) && !StringUtil.isNullOrEmpty(lbmId) ){
                NewProductBatch batch = (NewProductBatch) get(NewProductBatch.class, batchmapId);
                if(batch != null){
                    qty= isAssemblyProduct ? -qty : qty;
                    if(isAssemblyProduct){
                        batch.setQuantity(batch.getQuantity() + qty);
                    }
                    batch.setQuantitydue(authHandler.roundQuantity((batch.getQuantitydue() + qty),companyid));
                    save(batch);
                }
                String delQuery = "DELETE FROM locationbatchdocumentmapping WHERE id = ? ";
                int numRows = executeSQLUpdate( delQuery, new Object[]{lbmId});
            }
        }
        return new KwlReturnObject(true, "", null, null, 1);
    }
    @Override
    public KwlReturnObject deleteProductbBuildByID(String parentProductId, String companyid) throws ServiceException {
        String delQuery = "delete from ProductBuild where ID = ? and company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{parentProductId,companyid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    @Override
    public List getAssembyProducts(String buildProductid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "from ProductBuildDetails where build.ID=? ";
        list = executeQuery( q, new Object[]{buildProductid});
        return list;
    }
    public KwlReturnObject deleteSubProductFromAssembly(String subProductId) throws ServiceException {
        String delQuery = "delete from ProductAssembly where subproducts.ID = ?";
        int numRows = executeUpdate( delQuery, new Object[]{subProductId});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    public KwlReturnObject updateRecycleQuantityofSubProductFromAssembly(String subProductId,double recycleQuantity) throws ServiceException, AccountingException {
        List list = new ArrayList();
        try {
            Product product = (Product) get(Product.class, subProductId);
            if(product!=null){
                double quantity=product.getRecycleQuantity();//Checking avialable recycle quantity is grater than required recycle quantity.
                if((recycleQuantity < 0 && quantity >=(-recycleQuantity)) || (recycleQuantity > 0)){
                    recycleQuantity=quantity+recycleQuantity;
                    product.setRecycleQuantity(recycleQuantity);
                    save(product);
                    list.add(product);
                }else{
                    throw new AccountingException("Required Recycle quntity is not available for build assembly.");
                }
            }
        } catch (AccountingException ex){
            throw new AccountingException(ex.getMessage(),ex);
        } catch (Exception e) {
            throw ServiceException.FAILURE("updateProduct : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product has been updated successfully", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject updateProductBuild(ProductBuild productBuild) throws ServiceException {
        List list = new ArrayList();
        try {
            if (productBuild != null) {
                saveOrUpdate(productBuild);
                list.add(productBuild);
            }
        } catch (Exception e) {
            throw ServiceException.FAILURE("updateProductBuild : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product Build has been updated successfully", null, list, list.size());
    }
    
    public KwlReturnObject updateProductBuildDetails(ProductBuildDetails buildDetails) throws ServiceException {
        List list = new ArrayList();
        try {
            if(buildDetails!=null){
                saveOrUpdate(buildDetails);
                list.add(buildDetails);
            }
        } catch (Exception e) {
            throw ServiceException.FAILURE("updateProductBuildDetails : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product Build Details has been updated successfully", null, list, list.size());
    }

    public KwlReturnObject saveProductAssembly(HashMap<String, Object> assemblyMap) throws ServiceException {
        List list = new ArrayList();
        try {
            ProductAssembly assembly = new ProductAssembly();
            if (assemblyMap.containsKey("id")) {
                assembly = assemblyMap.get("id") == null ? null : (ProductAssembly) get(ProductAssembly.class, (String) assemblyMap.get("id"));
            }
            if (assemblyMap.containsKey("productid")) {
                Product Pproduct = assemblyMap.get("productid") == null ? null : (Product) get(Product.class, (String) assemblyMap.get("productid"));
                assembly.setProduct(Pproduct);
            }
            if (assemblyMap.containsKey("subproductid")) {
                Product Sproduct = assemblyMap.get("subproductid") == null ? null : (Product) get(Product.class, (String) assemblyMap.get("subproductid"));
                assembly.setSubproducts(Sproduct);
            }
            if (assemblyMap.containsKey("quantity")) {
                assembly.setQuantity((Double) assemblyMap.get("quantity"));
            }
            if (assemblyMap.containsKey("percentage")) {
                assembly.setPercentage((Double) assemblyMap.get("percentage"));
            }
            if (assemblyMap.containsKey("actualquantity")) {
                assembly.setActualQuantity((Double) assemblyMap.get("actualquantity"));
            }
            if (assemblyMap.containsKey("inventoryquantiy")) {
                assembly.setInventoryQuantity((Double) assemblyMap.get("inventoryquantiy"));
            }
            if (assemblyMap.containsKey("recylequantity")) {
                assembly.setRecycleQuantity((Double) assemblyMap.get("recylequantity"));
            }
            if (assemblyMap.containsKey("remainingquantity")) {
                assembly.setRemainingQuantity((Double) assemblyMap.get("remainingquantity"));
            }
            if (assemblyMap.containsKey("wastageInventoryQuantity")) {
                assembly.setWastageInventoryQuantity((Double) assemblyMap.get("wastageInventoryQuantity"));
            }
            if (assemblyMap.containsKey("wastageQuantityType")) {
                assembly.setWastageQuantityType((Integer) assemblyMap.get("wastageQuantityType"));
            }
            if (assemblyMap.containsKey("wastageQuantity")) {
                assembly.setWastageQuantity((Double) assemblyMap.get("wastageQuantity"));
            }
            if (assemblyMap.containsKey("bomdetailid")) {
                BOMDetail bomdetail = assemblyMap.get("bomdetailid") == null ? null : (BOMDetail) get(BOMDetail.class, (String) assemblyMap.get("bomdetailid"));
                assembly.setBomdetail(bomdetail);
            }
            if (assemblyMap.containsKey("subbomid")) {
                BOMDetail bomdetail = assemblyMap.get("subbomid") == null ? null : (BOMDetail) get(BOMDetail.class, (String) assemblyMap.get("subbomid"));
                assembly.setSubbom(bomdetail);
            }
            if (assemblyMap.containsKey("crate")) {
                assembly.setCrate((Double) assemblyMap.get("crate"));
            }
            /*
             componentType
              
             * 1  =  Component
             * 2  =  Co-Product 
             * 3  =  Scrap
             */
            if (assemblyMap.containsKey("componentType")) {
                assembly.setComponentType((Integer) assemblyMap.get("componentType"));
            }
            save(assembly);
            list.add(assembly);
        } catch (Exception e) {
            throw ServiceException.FAILURE("saveProductAssembly : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product Assembly has been added successfully", null, list, list.size());
    }

    public KwlReturnObject saveProductComposition(HashMap<String, Object> productCompositionMap) throws ServiceException {
        List list = new ArrayList();
        try {
            ProductComposition productComposition = new ProductComposition();
            if (productCompositionMap.containsKey("id")) {
                productComposition = productCompositionMap.get("id") == null ? null : (ProductComposition) get(ProductComposition.class, (String) productCompositionMap.get("id"));
            }
            if (productCompositionMap.containsKey("productid")) {
                Product Pproduct = productCompositionMap.get("productid") == null ? null : (Product) get(Product.class, (String) productCompositionMap.get("productid"));
                productComposition.setProduct(Pproduct);
            }
            if (productCompositionMap.containsKey("srno")) {
                productComposition.setSrno((Integer) productCompositionMap.get("srno"));
            }
            if (productCompositionMap.containsKey("ingredients")) {
                productComposition.setIngredients((String) productCompositionMap.get("ingredients"));
            }
            if (productCompositionMap.containsKey("strength")) {
                productComposition.setStrength((String) productCompositionMap.get("strength"));
            }
            if (productCompositionMap.containsKey("companyid") && productCompositionMap.get("companyid") != null) {
                Company company = productCompositionMap.get("companyid") == null ? null : (Company) get(Company.class, (String) productCompositionMap.get("companyid"));
                productComposition.setCompany(company);
            }
            save(productComposition);
            list.add(productComposition);
        } catch (Exception e) {
            throw ServiceException.FAILURE("saveProductAssembly : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Product Composition has been added successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject maintainCustomFieldHistoryForProduct(HashMap<String, Object> requestParams) throws ServiceException {
        List list = new ArrayList();
        try {
            ProductCustomFieldHistory customFieldHistory = null;
            if (requestParams.containsKey("id") && requestParams.get("id") != null) {
                customFieldHistory = (ProductCustomFieldHistory) get(ProductCustomFieldHistory.class, (String) requestParams.get("id"));
            }else{
                customFieldHistory=new ProductCustomFieldHistory();
            }
            if (requestParams.containsKey("applyDate") && requestParams.get("applyDate") != null) {
                customFieldHistory.setApplyDate((Date) requestParams.get("applyDate"));
            }
            if (requestParams.containsKey("creationDate") && requestParams.get("creationDate") != null) {
                customFieldHistory.setCreationDate((Date) requestParams.get("creationDate"));
            }
            if (requestParams.containsKey("value") && requestParams.get("value") != null) {
                customFieldHistory.setValue(requestParams.get("value").toString());
            }
            if (requestParams.containsKey("moduleId") && requestParams.get("moduleId") != null) {
                customFieldHistory.setModuleId((Integer) requestParams.get("moduleId"));
            }
            if (requestParams.containsKey("companyid") && requestParams.get("companyid") != null) {
                Company company = requestParams.get("companyid") == null ? null : (Company) get(Company.class, (String) requestParams.get("companyid"));
                customFieldHistory.setCompany(company);
            }
            if (requestParams.containsKey("productId") && requestParams.get("productId") != null) {
                Product product = requestParams.get("productId") == null ? null : (Product) get(Product.class, (String) requestParams.get("productId"));
                customFieldHistory.setProduct(product);
            }
            if (requestParams.containsKey("loginId") && requestParams.get("loginId") != null) {
                User user = requestParams.get("loginId") == null ? null : (User) get(User.class, (String) requestParams.get("loginId"));
                customFieldHistory.setUser(user);
            }
            if (requestParams.containsKey("fieldId") && requestParams.get("fieldId") != null) {
                FieldParams fieldParams = requestParams.get("fieldId") == null ? null : (FieldParams) get(FieldParams.class, (String) requestParams.get("fieldId"));
                customFieldHistory.setFieldParams(fieldParams);
            }
            saveOrUpdate(customFieldHistory);
            list.add(customFieldHistory);
        } catch (Exception e) {
            throw ServiceException.FAILURE("save customFieldDataForProduct : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Custom Field Data has been saved successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject deleteCustomFieldHistoryForProduct(HashMap<String, Object> requestParams) throws ServiceException {
        List list = new ArrayList();
        try {
            String ProductId = "";
            String fieldId = "";
            Date applyDate = null;
            String companyId = "";
            if (requestParams.containsKey("applyDate") && requestParams.get("applyDate") != null) {
                applyDate = (Date) requestParams.get("applyDate");
            }
            if (requestParams.containsKey("companyid") && requestParams.get("companyid") != null) {
                companyId = (String) requestParams.get("companyid");
            }
            if (requestParams.containsKey("productId") && requestParams.get("productId") != null) {
                ProductId = (String) requestParams.get("productId");
            }
            if (requestParams.containsKey("fieldId") && requestParams.get("fieldId") != null) {
                fieldId = (String) requestParams.get("fieldId");
            }

            String query = "Delete from productcustomfieldhistory where product=? and fieldparams=? and DATE(applydate)=DATE(?) and company=?";
            ArrayList params = new ArrayList();
            params.add(ProductId);
            params.add(fieldId);
            params.add(applyDate);
            params.add(companyId);
            executeSQLUpdate( query, params.toArray());
//            executeQuery( query, params.toArray());

        } catch (Exception e) {
            throw ServiceException.FAILURE("save customFieldDataForProduct : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Custom Field Data has been saved successfully", null, list, list.size());
    }

    public ProductBuildDetails updateAssemblyBuildDetails(HashMap<String, Object> requestParams, String jeid, HashSet jeDetails, List returnList) throws ServiceException, AccountingException {
        ProductBuild build = null;
        ProductBuildDetails pbd = null;
        double buildCost = 0;
        try {
            KwlReturnObject extraCompanyPreferencesObj = getObject(ExtraCompanyPreferences.class.getName(), (String) requestParams.get("companyid"));
            ExtraCompanyPreferences extraCompanyPreferences = (ExtraCompanyPreferences) extraCompanyPreferencesObj.getEntityList().get(0);
            KwlReturnObject capresult = accountingHandlerDAOobj.getObject(CompanyAccountPreferences.class.getName(), (String) requestParams.get("companyid"));
            CompanyAccountPreferences preferences = (CompanyAccountPreferences) capresult.getEntityList().get(0);
            double aquantity = 0, deductqty = 0;
            double rate = 0;
            double buildquantity = (Double) requestParams.get("quantity");
            boolean isUnbuildAssembly = false, isBuild=false,postJe=false;
            String companyid = (String) requestParams.get("companyid");
            String assemblyjson = (String) requestParams.get("assemblyjson");
            String buildproductid = (String) requestParams.get("buildproductid");
            if(requestParams.containsKey("isUnbuildAssembly") && requestParams.get("isUnbuildAssembly")!=null){
                isUnbuildAssembly = (Boolean)requestParams.get("isUnbuildAssembly");
            }
            if(requestParams.containsKey("isBuild") && requestParams.get("isBuild")!=null){
                isBuild = (Boolean)requestParams.get("isBuild");
            }
            if(requestParams.containsKey("postJe") && requestParams.get("postJe")!=null){
                postJe = (Boolean)requestParams.get("postJe");
            }
            build = (ProductBuild) get(ProductBuild.class, buildproductid);

            JSONObject jobj = new JSONObject(assemblyjson);
            pbd = new ProductBuildDetails();
            pbd.setBuild(build);
            rate = Double.parseDouble(jobj.get("rate").toString());
            pbd.setRate(rate);
            Product aproduct = (Product) get(Product.class, jobj.get("product").toString());
            pbd.setAproduct(aproduct);
            aquantity = Double.parseDouble(jobj.optString("actualquantity", "0"));
            if(isBuild || isUnbuildAssembly){
                deductqty =  aquantity;
                pbd.setInventoryQuantity(aquantity/buildquantity);  //We are getting updatedf data, so get the actual quantity by dividing buildquantity
                pbd.setAquantity(aquantity/buildquantity);          //We are getting updatedf data, so get the actual quantity by dividing buildquantity
            } else {
                deductqty = aquantity * buildquantity;
                pbd.setInventoryQuantity(aquantity);
                pbd.setAquantity(aquantity);
            }
            pbd.setPercentage(Double.parseDouble(jobj.optString("percentage", "0")));
            pbd.setActualQuantity(Double.parseDouble(jobj.optString("actualquantity", "0")));
            pbd.setRecycleQuantity(Double.parseDouble(jobj.optString("recylequantity", "0")));
            pbd.setRemainingQuantity(Double.parseDouble(jobj.optString("remainingquantity", "0")));            
            double recycleQuantity = Double.parseDouble(jobj.optString("remainingquantity", "0")) - Double.parseDouble(jobj.optString("recylequantity", "0"));
            if(recycleQuantity != 0){
                updateRecycleQuantityofSubProductFromAssembly(jobj.getString("product"), recycleQuantity * buildquantity);
            }
//                    makeInventory(session, request, aproduct, deductqty, "Build Product Assembly for "+buildproduct.getName(), false, false,null);
            JSONObject inventoryjson = new JSONObject();
            inventoryjson.put("productid", aproduct.getID());
            inventoryjson.put("quantity", deductqty);
            inventoryjson.put("baseuomquantity", deductqty);
            inventoryjson.put("baseuomrate", 1);
            if (aproduct.getUnitOfMeasure() != null) {
                inventoryjson.put("uomid", aproduct.getUnitOfMeasure().getID());
            }
            if(isUnbuildAssembly){
                inventoryjson.put("description", "Unbuild Product Assembly for " + build.getProduct().getName());
                inventoryjson.put("carryin", true);
            } else {
                inventoryjson.put("description", "Build Product Assembly for " + build.getProduct().getName());
                inventoryjson.put("carryin", false);
            }            
            inventoryjson.put("defective", false);
            inventoryjson.put("newinventory", false);
            inventoryjson.put("updatedate",(Date) requestParams.get("updatedate"));
            inventoryjson.put("companyid", build.getProduct().getCompany().getCompanyID());
            KwlReturnObject invresult = addInventory(inventoryjson);
            Inventory inventory = (Inventory) invresult.getEntityList().get(0);
            
            pbd.setInventory(inventory);
            
            double wastageInventoryQuantity = Double.parseDouble(jobj.optString("wastageInventoryQuantity", "0"));
            int wastageQuantityType = Integer.parseInt(jobj.optString("wastageQuantityType", "0"));
            double wastageQuantity = Double.parseDouble(jobj.optString("wastageQuantity", "0"));
            pbd.setWastageInventoryQuantity(wastageInventoryQuantity);
            pbd.setWastageQuantityType(wastageQuantityType);
            pbd.setWastageQuantity(wastageQuantity);
            
            save(pbd);
            double totalWastageAmount = 0;
            if (postJe) {
                JSONObject jedjson = new JSONObject();
                double exchangerate = 1;
                /**
                 * IF subproducts are created in Non-base currency then exchange is saved for below JE.
                 */
                 if (pbd.getAproduct()!=null && build.getProduct()!=null && pbd.getAproduct().getCurrency() != build.getProduct().getCurrency()) {
                    HashMap<String, Object> currencyParams = new HashMap<>();
                    String tocurrencyid = pbd.getAproduct().getCurrency().getCurrencyID();
                    currencyParams.put("fromcurrencyid", build.getProduct().getCurrency().getCurrencyID());
                    currencyParams.put("tocurrencyid", pbd.getAproduct().getCurrency().getCurrencyID());
                    currencyParams.put(Constants.companyid, companyid);
                    currencyParams.put("transactiondate", (Date) requestParams.get("updatedate"));
                    KwlReturnObject exchResult = accCurrencyDAOobj.getCurrencyExchange(currencyParams);
                    ExchangeRate er = (ExchangeRate) exchResult.getEntityList().get(0);
                    KwlReturnObject erdresult = accCurrencyDAOobj.getExcDetailID(currencyParams, tocurrencyid, (Date) requestParams.get("updatedate"), er.getID());
                    if (erdresult.getEntityList() != null && !erdresult.getEntityList().isEmpty() && erdresult.getEntityList().size() > 1) {
                        ExchangeRateDetails erd = (ExchangeRateDetails) erdresult.getEntityList().get(0);
                        if (erd != null) {
                            exchangerate = erd.getExchangeRate();
                        }
                    }
                }
                jedjson.put("srno", jeDetails.size() + 1);
                jedjson.put("companyid", (String) requestParams.get("companyid"));
                /*SDP-1599*/
                if (isBuild || isUnbuildAssembly) {
                    buildCost = authHandler.round((build.getQuantity() * pbd.getInventoryQuantity() * rate), companyid); // Actual quantity required to build the product * rate
                } else {
                    buildCost = authHandler.round((build.getQuantity() * rate), companyid); // Actual quantity required to build the product * rate
                }

                jedjson.put("amount", buildCost);
                  /* Use Product's Inventory Account for posting JE instead of Purchase Account when MRP flow is activated. */
//              if (extraCompanyPreferences != null && extraCompanyPreferences.isActivateMRPModule() && aproduct.getInventoryAccount() != null) {
                if (extraCompanyPreferences != null && preferences != null && aproduct.getInventoryAccount() != null && (extraCompanyPreferences.isActivateMRPModule() || preferences.getInventoryValuationType() == Constants.PERPETUAL_VALUATION_METHOD)) {
                    jedjson.put("accountid", aproduct.getInventoryAccount().getID());
                } else {
                    jedjson.put("accountid", aproduct.getPurchaseAccount().getID());
                }
                if (isUnbuildAssembly) {     //Unbuild Assembly
                    jedjson.put("debit", true);
                } else {
                    jedjson.put("debit", false);
                }
                jedjson.put("jeid", jeid);
                jedjson.put("exchangeratefortransaction", exchangerate);
                KwlReturnObject jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                JournalEntryDetail jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                pbd.setJedetail(jed);
                jeDetails.add(jed);

                // Wastage debit entry
                
                if (aproduct.isWastageApplicable() && aproduct.getWastageAccount() != null && wastageQuantity != 0 && extraCompanyPreferences != null && extraCompanyPreferences.isActivateWastageCalculation()) {
                    double amount = 0;
                    if (wastageQuantityType == 1) { // For Percentage
                        amount = authHandler.round(rate * ((wastageQuantity * wastageInventoryQuantity) / 100) * buildquantity, companyid);
                    } else {
                        amount = authHandler.round(rate * wastageQuantity * buildquantity, companyid);
                    }
                    jedjson = new JSONObject();
                    jedjson.put("srno", jeDetails.size() + 1);
                    jedjson.put("companyid", (String) requestParams.get("companyid"));
                    jedjson.put("amount", amount);
                    jedjson.put("accountid", aproduct.getWastageAccount().getID());
                    jedjson.put("exchangeratefortransaction", exchangerate);
                    if (!isUnbuildAssembly) {     //Unbuild Assembly
                        jedjson.put("debit", false);
                    } else {
                        jedjson.put("debit", true);
                    }
                    jedjson.put("jeid", jeid);
                    jedresult = accJournalEntryobj.addJournalEntryDetails(jedjson);
                    jed = (JournalEntryDetail) jedresult.getEntityList().get(0);
                    jeDetails.add(jed);
                    pbd.setWastagejedetail(jed);

                    totalWastageAmount += amount;
                }
            }
            returnList.add(0, totalWastageAmount);
            returnList.add(1, buildCost);
        } catch (AccountingException ex) {
            throw new AccountingException(ex.getMessage());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("updateAssemblyInventory : " + ex.getMessage(), ex);
        } 
         return pbd;

    }
    public ProductBuild updateAssemblyInventory(HashMap<String, Object> requestParams) throws ServiceException {
        ProductBuild build = null;
        Product buildproduct = null;
        try {
            double buildquantity = (Double) requestParams.get("quantity");
            String refno = (String) requestParams.get("refno");
            String buildproductid = (String) requestParams.get("buildproductid");
            String applydate = ""+ requestParams.get("applydate");
//            String createdon = (String) requestParams.get("createdon");
            String createdon = requestParams.get("createdon") == null? new Date().toString():(String) requestParams.get("createdon");
            Long isAutoBACreatedOn = requestParams.get("autoBAcreatedon") != null? (Long) requestParams.get("autoBAcreatedon"):null; // DO createdon in auto build assembly case
            String memo = (String) requestParams.get("memo");
            String description = requestParams.get("description") == null ? "" : (String) requestParams.get("description");
            String companyid = (String) requestParams.get("companyid");
            DateFormat df = (DateFormat) requestParams.get("df");
            String jsondata = (String) requestParams.get("assembly");
            String productbatch = (String) requestParams.get("productbatch");
            String bomdetailid = (String) requestParams.get("bomdetailid");
            double productCost = requestParams.containsKey("cost")?(Double) requestParams.get("cost"):0;
            
            String doid = "";
            if (requestParams.containsKey("doid") && requestParams.get("doid") != null) {
                doid = (String) requestParams.get("doid");
            }
            String jwoid = "";
            if (requestParams.containsKey("jobworkorderid") && requestParams.get("jobworkorderid") != null) {
                jwoid = (String) requestParams.get("jobworkorderid");
            }
            Inventory inventory = null;
            if (requestParams.containsKey("inventory") && requestParams.get("inventory") != null) {
                inventory = (Inventory) requestParams.get("inventory");
            }

            JSONArray jarr = new JSONArray("[" + jsondata + "]");
            if (jarr.length() > 0) { //Bug Fixed #16851
                JSONObject jObj=jarr.getJSONObject(0);
                Date appDate = null,createdonDate=null;
                try {
                    appDate = df.parse(applydate);
                } catch (Exception e) {
                    appDate = authHandler.getSimpleDateAndTimeFormat().parse(authHandler.getConstantDateFormatter().format(new Date()));
                }
                try {
                    createdonDate = df.parse(createdon);
                } catch (Exception e) {
                    createdonDate = authHandler.getSimpleDateAndTimeFormat().parse(authHandler.getConstantDateFormatter().format(new Date()));
                }
                buildproduct = (Product) get(Product.class, buildproductid);
                build = new ProductBuild();
                build.setQuantity(buildquantity);
                build.setRefno(refno);
                build.setMemo(memo);
                build.setEntryDate(appDate);
                long createdontime = System.currentTimeMillis();
                build.setCreatedon(createdontime);
                if(isAutoBACreatedOn !=null){                 //BA shown before DO in auto build assembly case i.e  minus 1 from DO creation date
                    build.setCreatedon(isAutoBACreatedOn-1);
                }
                build.setProduct(buildproduct);
                build.setDescription(description);
                build.setProductcost(productCost);
                build.setJobworkorderid(jwoid); // Saving Jobwororder id in Product Build (Build Assembly)
                build.setIsBuild(true);
                if (!StringUtil.isNullOrEmpty(productbatch)) {
                    ProductBatch productBatch = (ProductBatch) get(ProductBatch.class, productbatch);
                    build.setBatch(productBatch);
                }
                build.setCompany((Company) get(Company.class, companyid));
                if (!StringUtil.isNullOrEmpty(bomdetailid)) {
                    build.setBomdetail((BOMDetail) get(BOMDetail.class, bomdetailid));
                }
                if (!StringUtil.isNullOrEmpty(doid)) {
                    String entryNumber = (String) requestParams.get("entrynumber");
                    String formatID = (String) requestParams.get(Constants.SEQFORMAT);
                    boolean autogenerated = Boolean.parseBoolean(requestParams.get("autogenerated").toString());
                    int seqNumber = Integer.parseInt(requestParams.get(Constants.SEQNUMBER).toString());
                    String datePrefix="";
                    String dateafterPrefix="";
                    String dateSuffix="";
                    if (requestParams.containsKey(Constants.DATEPREFIX) && requestParams.get(Constants.DATEPREFIX) != null) {
                        datePrefix = (String) requestParams.get(Constants.DATEPREFIX);
                    }
                    if (requestParams.containsKey(Constants.DATEAFTERPREFIX) && requestParams.get(Constants.DATEAFTERPREFIX) != null) {
                        dateafterPrefix = (String) requestParams.get(Constants.DATEAFTERPREFIX);
                    }
                    if (requestParams.containsKey(Constants.DATESUFFIX) && requestParams.get(Constants.DATESUFFIX) != null) {
                        dateSuffix = (String) requestParams.get(Constants.DATESUFFIX);
                    }
                    
                    build.setRefno(entryNumber);
                    build.setSeqformat((SequenceFormat) get(SequenceFormat.class, formatID));
                    build.setSeqnumber(seqNumber);
                    build.setDatePreffixValue(datePrefix);
                    build.setDateAfterPreffixValue(dateafterPrefix);
                    build.setDateSuffixValue(dateSuffix);
                    build.setAutoGenerated(autogenerated);
                    build.setDeliveryOrder(doid);
                }
                if (inventory != null) {
                    build.setInventory(inventory);
                }
                
                saveOrUpdate(build);

            /*    double aquantity = 0, deductqty = 0;
                double rate = 0;
                for (int i = 0; i < jarr.length(); i++) {
                    JSONObject jobj = jarr.getJSONObject(i);
                    ProductBuildDetails pbd = new ProductBuildDetails();
                    pbd.setBuild(build);
                    rate = Double.parseDouble(jobj.get("rate").toString());
                    pbd.setRate(rate);
                    Product aproduct = (Product) get(Product.class, jobj.get("product").toString());
                    pbd.setAproduct(aproduct);
                    aquantity = Double.parseDouble(jobj.optString("inventoryquantiy","0"));
                    deductqty = aquantity * buildquantity;
                   
                    pbd.setPercentage(Double.parseDouble(jobj.optString("percentage","0")));
                    pbd.setActualQuantity(Double.parseDouble(jobj.optString("actualquantity","0")));
                    pbd.setInventoryQuantity(aquantity);
                    pbd.setRecycleQuantity(Double.parseDouble(jobj.optString("recylequantity","0")));
                    pbd.setRemainingQuantity(Double.parseDouble(jobj.optString("remainingquantity","0")));   
                    pbd.setAquantity(aquantity);
                    save(pbd);
                    double recycleQuantity=Double.parseDouble(jobj.optString("remainingquantity","0"))-Double.parseDouble(jobj.optString("recylequantity","0"));
                    updateRecycleQuantityofSubProductFromAssembly(jobj.getString("product"),recycleQuantity* buildquantity);
//                    makeInventory(session, request, aproduct, deductqty, "Build Product Assembly for "+buildproduct.getName(), false, false,null);
                    JSONObject inventoryjson = new JSONObject();
                    inventoryjson.put("productid", aproduct.getID());
                    inventoryjson.put("quantity", deductqty);
                    inventoryjson.put("baseuomquantity", deductqty);
                    inventoryjson.put("baseuomrate", 1);
                    if (aproduct.getUnitOfMeasure() != null) {
                        inventoryjson.put("uomid", aproduct.getUnitOfMeasure().getID());
                }
                    inventoryjson.put("description", "Build Product Assembly for " + buildproduct.getName());
                    inventoryjson.put("carryin", false);
                    inventoryjson.put("defective", false);
                    inventoryjson.put("newinventory", false);
                    inventoryjson.put("companyid", companyid);
                    KwlReturnObject invresult = addInventory(inventoryjson);
                    Inventory inventory = (Inventory) invresult.getEntityList().get(0);
                }*/
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("updateAssemblyInventory : " + ex.getMessage(), ex);
        } finally {
            return build;
        }
    }

    @Override
    public Product updateAssemblyInventoryForOther(HashMap<String, Object> requestParams) throws ServiceException {
        Product buildproduct = null;
        try {
            double buildquantity = (Double) requestParams.get("quantity");
            String entryNumber = (String) requestParams.get("entrynumber");
            String formatID = (String) requestParams.get(Constants.SEQFORMAT);
            boolean autogenerated = Boolean.parseBoolean(requestParams.get("autogenerated").toString());
            int seqNumber = Integer.parseInt(requestParams.get(Constants.SEQNUMBER).toString());
            String datePrefix = "";
            String dateafterPrefix = "";
            String dateSuffix = "";
            if (requestParams.containsKey(Constants.DATEPREFIX) && requestParams.get(Constants.DATEPREFIX) != null) {
                datePrefix = (String) requestParams.get(Constants.DATEPREFIX);
            }
            if (requestParams.containsKey(Constants.DATEAFTERPREFIX) && requestParams.get(Constants.DATEAFTERPREFIX) != null) {
                dateafterPrefix = (String) requestParams.get(Constants.DATEAFTERPREFIX);
            }
            if (requestParams.containsKey(Constants.DATESUFFIX) && requestParams.get(Constants.DATESUFFIX) != null) {
                dateSuffix = (String) requestParams.get(Constants.DATESUFFIX);
            }
            String buildproductid = (String) requestParams.get("buildproductid");
            String applydate = (String) requestParams.get("applydate");
            String memo = (String) requestParams.get("memo");
            String description = requestParams.get("description") == null ? "" : (String) requestParams.get("description");
            String companyid = (String) requestParams.get("companyid");
            DateFormat df = (DateFormat) requestParams.get("df");
            String jsondata = (String) requestParams.get("assembly");
            String productbatch = (String) requestParams.get("productbatch");
            String doid = (requestParams.get("doid") == null)? "" : (String) requestParams.get("doid");
            Inventory inventory = (requestParams.get("inventory") == null)? null : (Inventory) requestParams.get("inventory");

            JSONArray jarr = new JSONArray("[" + jsondata + "]");
            if (jarr.length() > 0) { //Bug Fixed #16851
                Date appDate = null;
                try {
                    appDate = df.parse(applydate);
                } catch (Exception e) {
                    appDate = new Date();
                }
                buildproduct = (Product) get(Product.class, buildproductid);
                ProductBuild build = new ProductBuild();
                build.setQuantity(buildquantity);
                build.setRefno(entryNumber);
                build.setSeqformat((SequenceFormat) get(SequenceFormat.class, formatID));
                build.setSeqnumber(seqNumber);
                build.setDatePreffixValue(datePrefix);
                build.setDateAfterPreffixValue(dateafterPrefix);
                build.setDateSuffixValue(dateSuffix);
                build.setAutoGenerated(autogenerated);
                build.setMemo(memo);
                long createdon = System.currentTimeMillis();
                build.setCreatedon(createdon);
                build.setEntryDate(appDate);
                build.setProduct(buildproduct);
                build.setDescription(description);
                if (!StringUtil.isNullOrEmpty(productbatch)) {
                    ProductBatch productBatch = (ProductBatch) get(ProductBatch.class, productbatch);
                    build.setBatch(productBatch);
                }

                if (!StringUtil.isNullOrEmpty(doid)) {
                    build.setDeliveryOrder(doid);
                }

                build.setCompany((Company) get(Company.class, companyid));
                build.setInventory(inventory);
                saveOrUpdate(build);

                double aquantity = 0, deductqty = 0;
                double rate = 0;
                for (int i = 0; i < jarr.length(); i++) {
                    JSONObject jobj = jarr.getJSONObject(i);
                    ProductBuildDetails pbd = new ProductBuildDetails();
                    pbd.setBuild(build);
                    rate = Double.parseDouble(jobj.get("rate").toString());
                    pbd.setRate(rate);
                    Product aproduct = (Product) get(Product.class, jobj.get("product").toString());
                    pbd.setAproduct(aproduct);
                    aquantity = Double.parseDouble(jobj.optString("inventoryquantiy","0"));
                    deductqty = aquantity * buildquantity;

                    pbd.setPercentage(Double.parseDouble(jobj.optString("percentage","0")));
                    pbd.setActualQuantity(Double.parseDouble(jobj.optString("actualquantity","0")));
                    pbd.setInventoryQuantity(aquantity);
                    pbd.setRecycleQuantity(Double.parseDouble(jobj.optString("recylequantity","0")));
                    pbd.setRemainingQuantity(Double.parseDouble(jobj.optString("remainingquantity","0")));   
                    pbd.setAquantity(aquantity);
                    
                    double recycleQuantity=Double.parseDouble(jobj.optString("remainingquantity","0"))-Double.parseDouble(jobj.optString("recylequantity","0"));
                    if(recycleQuantity != 0){
                        updateRecycleQuantityofSubProductFromAssembly(jobj.getString("product"),recycleQuantity* buildquantity);
                    }
//                    makeInventory(session, request, aproduct, deductqty, "Build Product Assembly for "+buildproduct.getName(), false, false,null);
                    JSONObject inventoryjson = new JSONObject();
                    inventoryjson.put("productid", aproduct.getID());
                    inventoryjson.put("quantity", deductqty);
                    inventoryjson.put("baseuomquantity", deductqty);
                    inventoryjson.put("baseuomrate", 1);
                    if (aproduct.getUnitOfMeasure() != null) {
                        inventoryjson.put("uomid", aproduct.getUnitOfMeasure().getID());
                    }
                    inventoryjson.put("description", "Build Product Assembly for " + buildproduct.getName());
                    inventoryjson.put("carryin", false);
                    inventoryjson.put("defective", false);
                    inventoryjson.put("newinventory", false);
                    inventoryjson.put("companyid", companyid);
                    KwlReturnObject invresult = addInventory(inventoryjson);
                    Inventory pbdInventory = (Inventory) invresult.getEntityList().get(0);
                    
                    pbd.setInventory(pbdInventory);
                    
                    double wastageInventoryQuantity = Double.parseDouble(jobj.optString("wastageInventoryQuantity", "0"));
                    int wastageQuantityType = Integer.parseInt(jobj.optString("wastageQuantityType", "0"));
                    double wastageQuantity = Double.parseDouble(jobj.optString("wastageQuantity", "0"));
                    pbd.setWastageInventoryQuantity(wastageInventoryQuantity);
                    pbd.setWastageQuantityType(wastageQuantityType);
                    pbd.setWastageQuantity(wastageQuantity);
                    
                    save(pbd);
                }
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("updateAssemblyInventory : " + ex.getMessage(), ex);
        } finally {
            return buildproduct;
        }
    }

    public KwlReturnObject getAssemblyItems(HashMap<String, Object> requestParams) throws ServiceException {
        String productid = (String) requestParams.get("productid");
        String bomdetailid = (String) requestParams.get("bomdetailid");
        String currencyid = (String) requestParams.get("currencyid");
        boolean isdefaultbom=false;
        if(requestParams.containsKey("isdefaultbom")){
            isdefaultbom=(Boolean)requestParams.get("isdefaultbom");
        }
        
        boolean isManageQuantity=false;   
        boolean displayInitialPrice=false;   
        if(requestParams.containsKey("isManageQuantity")){
            isManageQuantity = Boolean.parseBoolean((String)requestParams.get("isManageQuantity"));
        }
        /*
        Previously initialPrice column was not present then more than one row is returned by the inner query, so to handle it column was added. 
        */
        if(requestParams.containsKey("displayInitialPrice")){
            displayInitialPrice =  (Boolean)requestParams.get("displayInitialPrice");
        }
        String conditionQuery = "";
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        
        if(isManageQuantity){
            conditionQuery = " and pa.subproducts.producttype.ID != '" + Producttype.SERVICE + "' ";
        }
        
        params.add(productid);
        if (isdefaultbom) {
            params.add(isdefaultbom);
            String query = "select pa,"
                    + " (select pl1.price from PriceList pl1 where pl1.affecteduser = '-1' and product.ID=pa.subproducts.ID and carryIn=true "+Constants.PRICELIST_UOM_CONDITION_ASSEMBLY_PURCHASE+" and pl1.initialPrice = "+displayInitialPrice+" and pl1.currency.currencyID='" + currencyid + "' and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = '-1' and currency.currencyID='" + currencyid + "' and product.ID=pl1.product.ID "+Constants.PRICELIST_UOM_CONDITION_ASSEMBLY_PURCHASE_INNER+" and initialPrice = pl1.initialPrice and carryIn=pl1.carryIn group by product)),"
                    + " (select pl2.price from PriceList pl2 where pl2.affecteduser = '-1' and product.ID=pa.subproducts.ID and carryIn=false "+Constants.PRICELIST_UOM_CONDITION_ASSEMBLY_SALES+" and pl2.initialPrice = false  and pl2.currency.currencyID='" + currencyid + "' and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = '-1' and currency.currencyID='" + currencyid + "' and product.ID=pl2.product.ID "+Constants.PRICELIST_UOM_CONDITION_ASSEMBLY_SALES_INNER+" and initialPrice = pl2.initialPrice and carryIn=pl2.carryIn group by product)),"
                    + " (select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory inv  where product.ID=pa.subproducts.ID and inv.deleted=false group by product.ID) "
                    + " from ProductAssembly pa where pa.product.ID=? and pa.bomdetail.isDefaultBOM=? " + conditionQuery;
            returnList = executeQuery(query, params.toArray());
        } else {
            String query = "select pa,"
                    + " (select pl1.price from PriceList pl1 where pl1.affecteduser = '-1' and product.ID=pa.subproducts.ID and carryIn=true "+Constants.PRICELIST_UOM_CONDITION_ASSEMBLY_PURCHASE+" and pl1.initialPrice = "+displayInitialPrice+" and pl1.currency.currencyID='" + currencyid + "' and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = '-1' and currency.currencyID='" + currencyid + "' and product.ID=pl1.product.ID "+Constants.PRICELIST_UOM_CONDITION_ASSEMBLY_PURCHASE_INNER+" and initialPrice = pl1.initialPrice and carryIn=pl1.carryIn group by product)),"
                    + " (select pl2.price from PriceList pl2 where pl2.affecteduser = '-1' and product.ID=pa.subproducts.ID and carryIn=false "+Constants.PRICELIST_UOM_CONDITION_ASSEMBLY_SALES+" and pl2.initialPrice = false and pl2.currency.currencyID='" + currencyid + "' and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = '-1' and currency.currencyID='" + currencyid + "' and product.ID=pl2.product.ID "+Constants.PRICELIST_UOM_CONDITION_ASSEMBLY_SALES_INNER+" and initialPrice = pl2.initialPrice and carryIn=pl2.carryIn group by product)),"
                    + " (select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory inv  where product.ID=pa.subproducts.ID and inv.deleted=false group by product.ID) "
                    + " from ProductAssembly pa where pa.product.ID=? " + conditionQuery;
            if (!StringUtil.isNullOrEmpty(bomdetailid)) {
                query+=" and pa.bomdetail.ID=?";
                params.add(bomdetailid);
            }          
            returnList = executeQuery(query, params.toArray());
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    /*
    * Fetching Stock Adjustment Detail ids for a Job Work Order    
    */
    public KwlReturnObject getSADetailsForSO(HashMap<String, Object> requestParams) throws ServiceException {
        String soid = (String) requestParams.get("soid");
        boolean isdefaultbom=false;
        List returnList = new ArrayList();
        String query = "select id from in_sa_detail where jobworkorder = '" + soid + "'";
        returnList = executeSQLQuery(query);
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    /**
     * 
     * @param requestParams
     * @return
     * @desc : Get IST details for Job Order
     * @throws ServiceException 
     */
        public KwlReturnObject getISTDetailsForJobWorkOrder(HashMap<String, Object> requestParams) throws ServiceException {
        String podid = (String) requestParams.get("podid");
        List returnList = new ArrayList();
        String query = "select id from in_interstoretransfer where podetails = '" + podid + "'";
        returnList = executeSQLQuery(query);
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    
    public KwlReturnObject getDocumentBySerialId(HashMap<String, Object> requestParams) throws ServiceException {
        String serialId = (String) requestParams.get("serialId");
        List returnList = new ArrayList();
        String query = "select documentid from SerialDocumentMapping where transactiontype=28 and serialid.id=?";
        returnList = executeQuery( query, serialId);
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getDocumentByBatchId(HashMap<String, Object> requestParams) throws ServiceException {
        String serialId = (String) requestParams.get("batchId");
        List returnList = new ArrayList();
        String query = "select documentid from LocationBatchDocumentMapping where transactiontype=28 and batchmapid.id=?";
        returnList = executeQuery( query, serialId);
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
 @Override  
        public double getPriceByDocumentId(String documentId) throws ServiceException {
        double price = 0;
        String query = "select rate from GoodsReceiptOrderDetails where id=?";
        List list = executeQuery( query, documentId);
        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            price = (Double) itr.next();
        }
        return price;
    }

      @Override //This method used only in accProductControllerCMN.java
    public KwlReturnObject searchRefNo(String refNo, String companyId, boolean isBuild) throws ServiceException {
        try {
            List list = new ArrayList();
            int count = 0;
            String q = "from ProductBuild p where p.refno=? and p.company.companyID=? AND p.isBuild=?";
            list = executeQuery( q, new Object[]{refNo, companyId, isBuild});
            count = list.size();
            return new KwlReturnObject(true, "", null, list, count);

        } catch (Exception ex) {
            throw ServiceException.FAILURE("updateAssemblyInventory : " + ex.getMessage(), ex);
        }
    }
//PRICE LIST
    public KwlReturnObject addPriceList(HashMap<String, Object> priceMap) throws ServiceException {
        List list = new ArrayList();
        try {
            PriceList price = new PriceList();
            Product product = null;
            if (priceMap.containsKey("productid")) {
                product = priceMap.get("productid") == null ? null : (Product) get(Product.class, (String) priceMap.get("productid"));
                price.setProduct(product);
            }
            if (priceMap.containsKey("carryin")) {
                price.setCarryIn((Boolean) priceMap.get("carryin"));
            }
            if (priceMap.containsKey("applydate")) {
                price.setApplyDate((Date) priceMap.get("applydate"));
            }
            if (priceMap.containsKey("price")) {
                price.setPrice((Double) priceMap.get("price"));
            }
            if (priceMap.containsKey("currencyid")) {
                KWLCurrency currency = priceMap.get("currencyid") == null ? null : (KWLCurrency) get(KWLCurrency.class, (String) priceMap.get("currencyid"));
                price.setCurrency(currency);
            } else {
                KWLCurrency currency = product.getCompany().getCurrency();
                price.setCurrency(currency);
            }
            if (priceMap.containsKey("affecteduser")) {
                price.setAffecteduser((String) priceMap.get("affecteduser"));
            } else {
                price.setAffecteduser("-1");
            }

            if (priceMap.containsKey("companyid")) {
                Company company = priceMap.get("companyid") == null ? null : (Company) get(Company.class, (String) priceMap.get("companyid"));
                price.setCompany(company);
            }
            /**
             * Passing uomid to save it in db. ERM-389 / ERP-35140
             */
            if (priceMap.containsKey("uomid")) {
                UnitOfMeasure unitOfMeasure = priceMap.get("uomid") == null ? null : (UnitOfMeasure) get(UnitOfMeasure.class, (String) priceMap.get("uomid"));
                price.setUomid(unitOfMeasure);
            } else {
                if (product != null) {
                    price.setUomid(product.getUnitOfMeasure());
                }
            }
            if (priceMap.containsKey("initialPrice")) {
                price.setInitialPrice((Boolean) priceMap.get("initialPrice"));
            }
            save(price);
            list.add(price);
        } catch (Exception e) {
            throw ServiceException.FAILURE("addPriceList : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Price has been added successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject saveProducsPriceRule(HashMap<String, Object> itemmap) throws ServiceException {
        List list = new ArrayList();
        try {

            ProductPriceRule productPriceRule = new ProductPriceRule();

            if (itemmap.containsKey("lowerlimit")) {
                double lowerlimit = Double.parseDouble((String) itemmap.get("lowerlimit"));
                productPriceRule.setLowerlimit(lowerlimit);
            }
            if (itemmap.containsKey("upperlimit")) {
                double upperlimit = Double.parseDouble((String) itemmap.get("upperlimit"));
                productPriceRule.setUpperlimit(upperlimit);
            }
            if (itemmap.containsKey("percentage")) {
                int typeId = Integer.parseInt((String) itemmap.get("percentage"));
                productPriceRule.setPercentageType(typeId);
            }
            if (itemmap.containsKey("increamentordecreamentType")) {
                int increamentordecreamentType = Integer.parseInt((String) itemmap.get("increamentordecreamentType"));
                productPriceRule.setIncreamentordecreamentType(increamentordecreamentType);
            }
            if (itemmap.containsKey("priceType")) {
                int priceType = Integer.parseInt((String) itemmap.get("priceType"));
                productPriceRule.setPriceType(priceType);
            }
            if (itemmap.containsKey("ruleType")) {
                int ruleType = Integer.parseInt((String) itemmap.get("ruleType"));
                productPriceRule.setRuleType(ruleType);
            }
            if (itemmap.containsKey("category")) {
                MasterItem category = itemmap.get("category") == null ? null : (MasterItem) get(MasterItem.class, (String) itemmap.get("category"));
                productPriceRule.setCategory(category);
            }
            if (itemmap.containsKey("amount")) {
                double amount = Double.parseDouble((String) itemmap.get("amount"));
                productPriceRule.setAmount(amount);
            }
            if (itemmap.containsKey("companyid")) {
                Company company = itemmap.get("companyid") == null ? null : (Company) get(Company.class, (String) itemmap.get("companyid"));
                productPriceRule.setCompany(company);
            }
            if (itemmap.containsKey("currencyid")) {
                KWLCurrency Currency = itemmap.get("currencyid") == null ? null : (KWLCurrency) get(KWLCurrency.class, (String) itemmap.get("currencyid"));
                productPriceRule.setCurrency(Currency);
            }
            if (itemmap.containsKey("basedOn") && itemmap.get("basedOn") != null) {
                int basedOn = Integer.parseInt((String) itemmap.get("basedOn"));
                productPriceRule.setBasedOn(basedOn);
            }
            save(productPriceRule);
            list.add(productPriceRule);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accProductImpl:saveProducsPriceRule :" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Product Price Rule has been added successfully.", null, list, list.size());
    }

    @Override
    public KwlReturnObject getProducsPriceRule(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from ProductPriceRule";
        return buildNExecuteQuery( query, requestParams);
    }

    @Override
    public KwlReturnObject deleteProductPriceRule(String itemid) throws ServiceException {
        boolean successflag = false;
        try {
            ProductPriceRule productPriceRule = (ProductPriceRule) get(ProductPriceRule.class, itemid);
            if (productPriceRule != null) {
                delete(productPriceRule);
                successflag = true;
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accProductImpl:deleteProductPriceRule :" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(successflag, "Product Price Rule has been deleted successfully.", null, null, 1);
    }

    @Override
    public KwlReturnObject getProductByPrice(double lowerlimit, double upperlimit, String companyid, String catagoryid, int priceType, int ruleType, String catagoryIds, String currencyid) throws ServiceException {
        ArrayList params = new ArrayList();
        List returnList = Collections.EMPTY_LIST;
        String conditionSQL = "";
        String query = "";
        params.add(companyid);
        if (priceType == 1) {
            conditionSQL = "carryin='F'";
        } else {
            conditionSQL = "carryin='T'";
        }
        if (ruleType == 2) {
            params.add(companyid);
            params.add(lowerlimit);
            params.add(upperlimit);
            query = "select ps.* from pricelist  ps inner join product prod on prod.id = ps.product where ps.company=?  and ps.uomid = prod.unitOfMeasure and ps.currency='" + currencyid + "' and  ps.applydate =(select  max(p.applydate) from pricelist p where  p." + conditionSQL + " and p.company=? and p.uomid = ps.uomid and p.currency='" + currencyid + "' and p.product=ps.product ) and ps." + conditionSQL + "  and   ps.price >=? and ps.price <=? order by ps.product";
//             query="select * from pricelist  where company=?  and   price >=? and price <=?  and applydate in(select  max(p.applydate) from pricelist p where  p."+conditionSQL+" and p.company=?  and   p.price >=? and p.price <=? GROUP BY p.product ) and "+conditionSQL;
        } else if (!StringUtil.isNullOrEmpty(catagoryIds)) {
            catagoryIds = catagoryIds.substring(0, catagoryIds.length() - 1);
            params.add(companyid);
            query = "select ps.* from pricelist  ps inner join product prod on prod.id = ps.product where ps.company=? and ps.uomid = prod.unitOfMeasure and ps.currency='" + currencyid + "' and ps.product in (select  pcm.productid from productcategorymapping pcm   where pcm.productcategory in( " + catagoryIds + ") )  and applydate =(select  max(p.applydate) from pricelist p where  p." + conditionSQL + " and p.company=? and p.uomid = ps.uomid and p.currency='" + currencyid + "' and p.product=ps.product) and ps." + conditionSQL + "";
            
//            query = "select * from pricelist  ps inner join productcategorymapping pcm on ps.product=pcm.productid where pcm.productcategory in( " + catagoryIds + ") and ps.company=? and ps.currency='" + currencyid + "' and applydate =(select  max(p.applydate) from pricelist p where  p." + conditionSQL + " and p.company=?  and p.currency='" + currencyid + "' and p.product=ps.product) and ps." + conditionSQL + "";
//              query="select * from pricelist  where company=? and product in (select  productid from productcategorymapping pcm   where pcm.productcategory in( "+ catagoryIds+") )  and applydate in(select  max(p.applydate) from pricelist p inner JOIN productcategorymapping pcm on pcm.productid=p.product  where  pcm.productcategory in("+catagoryIds+") and p."+conditionSQL+" GROUP BY p.product) and " +conditionSQL;
        } else {
            params.add(catagoryid);
            params.add(companyid);
            query = "select ps.* from pricelist ps inner join product prod on prod.id = ps.product where ps.company=? and ps.uomid = prod.unitOfMeasure and ps.currency='" + currencyid + "' and ps.product in (select  pcm.productid from productcategorymapping pcm   where pcm.productcategory=? )  and ps.applydate =(select  max(p.applydate) from pricelist p where  p." + conditionSQL + " and p.company=? and p.uomid = ps.uomid and p.currency='" + currencyid + "' and p.product=ps.product ) and ps." + conditionSQL + "";
            
            
//            query = "select * from pricelist ps inner join productcategorymapping pcm on ps.product=pcm.productid where  ps.company=? and ps.currency='" + currencyid + "' and pcm.productcategory=?  and ps.applydate =(select  max(p.applydate) from pricelist p where  p." + conditionSQL + " and p.company=?  and p.currency='" + currencyid + "' and p.product=ps.product ) and ps." + conditionSQL + "";
//            query="select * from pricelist  where company=? and product in (select  productid from productcategorymapping pcm   where pcm.productcategory=?  )  and applydate in(select  max(p.applydate) from pricelist p inner JOIN productcategorymapping pcm on pcm.productid=p.product  where  pcm.productcategory=? and p."+conditionSQL+" GROUP BY p.product) and " +conditionSQL;

        }
        returnList = executeSQLQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject updatePriceList(HashMap<String, Object> priceMap) throws ServiceException {
        List list = new ArrayList();
        try {
            String priceid = (String) priceMap.get("priceid");
            PriceList price = (PriceList) get(PriceList.class, priceid);
            if (price != null) {
                if (priceMap.containsKey("productid")) {
                    Product product = priceMap.get("productid") == null ? null : (Product) get(Product.class, (String) priceMap.get("productid"));
                    price.setProduct(product);
                }
                if (priceMap.containsKey("carryin")) {
                    price.setCarryIn((Boolean) priceMap.get("carryin"));
                }
                if (priceMap.containsKey("applydate")) {
                    price.setApplyDate((Date) priceMap.get("applydate"));
                }
                if (priceMap.containsKey("price")) {
                    price.setPrice((Double) priceMap.get("price"));
                }
                if (priceMap.containsKey("currencyid")) {
                    KWLCurrency currency = priceMap.get("currencyid") == null ? null : (KWLCurrency) get(KWLCurrency.class, (String) priceMap.get("currencyid"));
                    price.setCurrency(currency);
                }
                if (priceMap.containsKey("companyid")) {
                    Company company = priceMap.get("companyid") == null ? null : (Company) get(Company.class, (String) priceMap.get("companyid"));
                    price.setCompany(company);
                }
                /**
                 * Passing uomid to save it in db while updating PriceList.
                 * ERM-389 / ERP-35140
                 */
                if (priceMap.containsKey("uomid")) {
                    UnitOfMeasure unitOfMeasure = priceMap.get("uomid") == null ? null : (UnitOfMeasure) get(UnitOfMeasure.class, (String) priceMap.get("uomid"));
                    price.setUomid(unitOfMeasure);
                }
                
                if (priceMap.containsKey("initialPrice")) {
                    price.setInitialPrice((Boolean) priceMap.get("initialPrice"));
                }
                save(price);
                list.add(price);
            }
        } catch (Exception e) {
            throw ServiceException.FAILURE("updatePriceList : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Price has been updated successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject getPrice(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        try {
            String query = "from PriceList";
            String productid = (String) request.get("productid");
            String companyid = (String) request.get("companyid");
            String start = (String) request.get("start");
            String limit = (String) request.get("limit");
            String ss = (String) request.get("ss");
            String condition = " where company.companyID=? and affecteduser = '-1' and product.deleted = false ";
            boolean productPriceinMultipleCurrency = (Boolean) request.get("productPriceinMultipleCurrency");

            if (!productPriceinMultipleCurrency) {
                condition += " and currency='" + request.get(Constants.globalCurrencyKey) + "' ";
            }
            ArrayList params = new ArrayList();
            params.add(companyid);
            
            if (!StringUtil.isNullOrEmpty(productid) && !productid.equalsIgnoreCase("All")) {
                productid = AccountingManager.getFilterInString(productid);
                condition += " and product.ID in " + productid + "  ";
            }
            
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"product.name", "product.productid"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
            }
            
            String orderBy = "";
            if (request.containsKey("dir") && request.containsKey("sort")) {
                String Col_Name = request.get("sort").toString();
                String Col_Dir = request.get("dir").toString();
                orderBy = sortColumnForPriceReport(Col_Name, Col_Dir);
            } else {
                orderBy = " order by product.productid, applyDate desc";
            }
            
            condition += orderBy;
            query += condition;
            list = executeQuery(query, params.toArray());
            count = list.size();
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                list = executeQueryPaging(query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (Exception e) {
            throw ServiceException.FAILURE("getPrice : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, count);
    }
    
    public String sortColumnForPriceReport(String Col_Name, String Col_Dir) throws ServiceException {
        String sort_String = "";
        switch (Col_Name) {
            case "productid":
                sort_String = " order by product.productid " + Col_Dir;
                break;
            case "carryin":
                sort_String = " order by carryIn " + Col_Dir;
                break;
            case "price":
                sort_String = " order by price " + Col_Dir;
                break;
            case "applydate":
                sort_String = " order by applyDate " + Col_Dir;
                break;
            case "productName":
                sort_String = " order by product.name " + Col_Dir;
                break;
            case "productDesc":
                sort_String = " order by product.description " + Col_Dir;
                break;
        }
        return sort_String;
    }
    
    public KwlReturnObject getProductBaseUOMRate(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        try {
            String query = "from UOMSchema";
            String uomschematypeid = (String) request.get("uomschematypeid");
            String currentuomid = (String) request.get("currentuomid");
            boolean carryin = request.containsKey("carryin")?(Boolean) request.get("carryin"):false;
            String companyid = (String) request.get("companyid");
            String condition = " where company.companyID=?  ";
            ArrayList params = new ArrayList();
            params.add(companyid);
            if(!StringUtil.isNullOrEmpty(currentuomid)){
                condition+=" and uomnature=? ";
                if(carryin){//for Purchas=ture ans Sales=Flase
                    params.add(UOMNature.Purchase);
                    condition+=" and purchaseuom.ID=? ";
                    params.add(currentuomid);
                }else{
                    params.add(UOMNature.Sales);
                    condition+=" and salesuom.ID=? ";
                    params.add(currentuomid);
                }
            }
            if(!StringUtil.isNullOrEmpty(uomschematypeid)){
                condition+=" and uomschematype.ID=? ";
                params.add(uomschematypeid);
            }
            query += condition;
            list = executeQuery( query, params.toArray());
            count = list.size();
        } catch (Exception e) {
            throw ServiceException.FAILURE("getPrice : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, count);
    }

    @Override
    public KwlReturnObject getPriceCustVen(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        List prcelistForAllAffectedUsers = new ArrayList();
        int count = 0;
        boolean isvaliditydate = false;
        try {
            String query = "from PriceList pl1 ";
            String productid = (String) request.get("productid");
            String companyid = (String) request.get("companyid");
            String start = (String) request.get("start");
            String limit = (String) request.get("limit");
            String ss = (String) request.get("ss");
            boolean carryin = (Boolean) request.get("carryin");
            if (request.containsKey("isvaliditydate") && request.get("isvaliditydate") != null) {
                isvaliditydate = (Boolean) request.get("isvaliditydate");
            }
            boolean productPriceinMultipleCurrency = (Boolean) request.get("productPriceinMultipleCurrency");
            boolean isExport = (request.containsKey("isExport") && request.get("isExport") != null) ? (Boolean) request.get("isExport") : false;
            String affectUserID = "";
            if (request.containsKey("affectuserid") && request.get("affectuserid") != null) {
                affectUserID = (String) request.get("affectuserid");
            }

            String condition = " where pl1.company.companyID=? and pl1.product.deleted = false ";//SDP-175
            if (storageHandlerImpl.GetSATSCompanyId().contains(companyid)) {  //This is sats specific code 
                condition += " and pl1.affecteduser != '-1' ";
            }

            condition += carryin ? " and pl1.carryIn=true " : " and pl1.carryIn=false ";
            if (!productPriceinMultipleCurrency) {
                condition += " and pl1.currency='" + request.get(Constants.globalCurrencyKey) + "' ";
            }
            ArrayList params = new ArrayList();
            params.add(companyid);

            if (!StringUtil.isNullOrEmpty(productid) && !productid.equalsIgnoreCase("All")) {
                productid = AccountingManager.getFilterInString(productid);
                condition += " and pl1.product.ID in " + productid + "  ";
            }

            if (!StringUtil.isNullOrEmpty(affectUserID) && !affectUserID.equalsIgnoreCase("All")) {
                affectUserID = AccountingManager.getFilterInString(affectUserID);
                condition += " and pl1.affecteduser in " + affectUserID + "  ";
            }

            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"pl1.product.name", "pl1.product.productid"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
            }

            String orderBy = "", groupByIsValidate = "", conditionForAllusers = "", groupByIsValidateForAllUsers = "";
            if (request.containsKey("dir") && request.containsKey("sort")) {
                String Col_Name = request.get("sort").toString();
                String Col_Dir = request.get("dir").toString();
                orderBy = sortColumnForPriceCustVenReport(Col_Name, Col_Dir);
            } else {
                orderBy = " order by pl1.affecteduser, pl1.product.productid, pl1.applyDate desc";
            }
            if (request.containsKey(Constants.df) && request.containsKey(Constants.REQ_startdate)) {
                DateFormat df = (DateFormat) request.get(Constants.df);
                String startDate = (String) request.get(Constants.REQ_startdate);
                String endDate = (String) request.get(Constants.REQ_enddate);
                if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                    /**
                     * query to get latest price of the products.
                     */
                    if (isvaliditydate) {
                        conditionForAllusers += condition + " and pl1.applyDate in (select MAX(pl2.applyDate) as ipl from PriceList pl2 where pl2.company.companyID= ? and pl1.currency=pl2.currency and  pl1.carryIn=pl2.carryIn  and pl2.applyDate <= ? and pl2.affecteduser = '-1' group by pl2.product, pl2.uomid, pl2.currency,pl2.applyDate ) ";
                        condition += " and pl1.applyDate in (select MAX(pl2.applyDate) as ipl from PriceList pl2 where pl2.company.companyID= ? and pl1.currency=pl2.currency  and  pl1.carryIn=pl2.carryIn and pl2.applyDate <= ?  group by pl2.product,pl2.affecteduser,pl2.uomid,pl2.currency ) ";
                        params.add(companyid);
                        params.add(df.parse(endDate));
                        groupByIsValidate = " group by pl1.product,pl1.uomid , pl1.affecteduser , pl1.uomid ,pl1.currency ";
                        groupByIsValidateForAllUsers = " group by pl1.product,pl1.uomid,pl1.currency,pl1.applyDate ";
                    } else {
                        condition += " and (pl1.applyDate >=? and pl1.applyDate <=?)";
                        params.add(df.parse(startDate));
                        params.add(df.parse(endDate));
                    }
                }
            }
            if (request.containsKey("producttype") && request.get("producttype") != null && !((String) request.get("producttype")).equalsIgnoreCase("All")) {
                String producttype = (String) request.get("producttype");
                condition += " and pl1.product.producttype.ID ='" + producttype + "' ";
            }
            /**
             * getting price list records for all users.
             */
            if (isvaliditydate) {
                String queryForAllusers = query;
                conditionForAllusers += groupByIsValidateForAllUsers + orderBy;
                queryForAllusers += conditionForAllusers;
                prcelistForAllAffectedUsers = executeQuery(queryForAllusers, params.toArray());
                list.addAll(prcelistForAllAffectedUsers);
            }
            condition += groupByIsValidate + orderBy;
            query += condition;
            list = executeQuery(query, params.toArray());
            count = list.size();
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false && !isExport) {
                list = executeQueryPaging(query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (Exception e) {
            throw ServiceException.FAILURE("getPrice : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, count);
    }
    
    public String sortColumnForPriceCustVenReport(String Col_Name, String Col_Dir) throws ServiceException {
        String sort_String = "";
        switch (Col_Name) {
            case "affecteduser":
                sort_String = " order by pl1.affecteduser, pl1.product.productid, pl1.applyDate " + Col_Dir;
                break;
            case "carryin":
                sort_String = " order by pl1.affecteduser, pl1.product.productid, pl1.carryIn " + Col_Dir;
                break;
            case "price":
                sort_String = " order by pl1.affecteduser, pl1.product.productid, pl1.price " + Col_Dir;
                break;
            case "applydate":
                sort_String = " order by pl1.affecteduser, pl1.product.productid, pl1.applyDate " + Col_Dir;
                break;
            case "productName":
                sort_String = " order by pl1.affecteduser, pl1.product.productid, pl1.product.name " + Col_Dir;
                break;
            case "productDesc":
                sort_String = " order by pl1.affecteduser, pl1.product.productid, pl1.product.description " + Col_Dir;
                break;
        }
        return sort_String;
    }

    public KwlReturnObject getSerialNoByDocumentid(String documentid,int transactiontype) throws ServiceException {
        List returnList = new ArrayList();
        try {
            String query=" select serialid.id from SerialDocumentMapping where documentid= ? and transactiontype = ?";
            returnList = executeQuery( query, new Object[]{documentid,transactiontype});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSerialNoByDocumentid : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getSerialNoByDocumentidAndSerialNames(String documentid,int transactiontype,String serialNames) throws ServiceException {
        List returnList = new ArrayList();
        try {
             serialNames = AccountingManager.getFilterInString(serialNames);
            String query=" select serialid.id from SerialDocumentMapping where documentid= ? and transactiontype = ? and serialid.serialname IN "+ serialNames + "";
            returnList = executeQuery( query, new Object[]{documentid,transactiontype});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSerialNoByDocumentid : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getBatchesByDocumentid(String documentid,int transactiontype) throws ServiceException {
        List returnList = new ArrayList();
        try {
            String query=" select batchmapid.id,quantity from LocationBatchDocumentMapping where documentid= ? and transactiontype = ?";
            returnList = executeQuery( query, new Object[]{documentid,transactiontype});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSerialNoByDocumentid : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getBatchesByDocumentidAndBatchNames(String documentid,int transactiontype,String batchName) throws ServiceException {
        List returnList = new ArrayList();
        try {
            String query=" select batchmapid.id,quantity from LocationBatchDocumentMapping where documentid= ? and transactiontype = ? and batchmapid.batchname=?";
            returnList = executeQuery( query, new Object[]{documentid,transactiontype,batchName});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSerialNoByDocumentid : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getProductPrice(String productid, boolean isPurchase, Date transactiondate, String affecteduser, String forCurrency) throws ServiceException {
        boolean excludeInitialPrice = true;
        return getProductPrice(productid, isPurchase, transactiondate, affecteduser, forCurrency, "", excludeInitialPrice);
    }
    
    public KwlReturnObject getProductPrice(String productid, boolean isPurchase, Date transactiondate, String affecteduser, String forCurrency,String uomid,boolean excludeInitialPrice) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            ArrayList paramsSubquery = new ArrayList();
            String initialPriceCondition = "";
            if (excludeInitialPrice) {
                /**
                 * Exclude initial price from transaction(s) ERP-33364.
                 */
                initialPriceCondition = " and initialPrice = false ";
            } else {
                /**
                 * this has been currently used from importproduct.java
                 */
                initialPriceCondition = " and initialPrice = true ";
            }
            params.add(productid);
            params.add(isPurchase);
            String condition = "";
            String conditionSubquery = "";
            Map<String, Object>  prefparams = new HashMap();
            prefparams.put("id", productid);
            Object stockUOM = kwlCommonTablesDAOObj.getRequestedObjectFields(Product.class, new String[]{"unitOfMeasure"}, prefparams);
            String stockUOMId = "";
            if (stockUOM != null && stockUOM instanceof UnitOfMeasure) {
                UnitOfMeasure unitOfMeasure = (UnitOfMeasure) stockUOM;
                stockUOMId = unitOfMeasure.getID();
            }
            if (transactiondate != null) {
                paramsSubquery.add(transactiondate);
                //condition += " and applyDate<=? ";
                conditionSubquery += " and applyDate<=? ";
            }
            if (StringUtil.isNullOrEmpty(forCurrency)) {
                Product product = (Product) get(Product.class, productid); // To avoid unnessesory call and improve performance
                Company cmp =product!=null? product.getCompany():null;
                if (cmp != null) {
                    forCurrency = cmp.getCurrency().getCurrencyID();
                }
            }
            condition += " and pl1.currency.currencyID = ? ";
            conditionSubquery += " and currency.currencyID = ? ";
            params.add(forCurrency);
            paramsSubquery.add(forCurrency);
            if (StringUtil.isNullOrEmpty(affecteduser)) {
                condition += " and pl1.affecteduser = '-1' ";
                conditionSubquery += " and affecteduser = '-1' ";
            } else {
                /**
                 * Checking if uomid is passed in params if yes the fetching the price mapped to particular uom if not then getting the default value.
                 * ERM-389 / ERP-35140
                 */
                String affectedUserCheck="";
                ArrayList affectedUserparams = new ArrayList();
                affectedUserparams.add(isPurchase);
                affectedUserparams.add(productid);
                affectedUserparams.add(affecteduser);
                affectedUserparams.add(transactiondate);
                affectedUserparams.add(forCurrency);
                affectedUserCheck += " and uomid.ID = ? ";
                if (!StringUtil.isNullOrEmpty(uomid)) {
//                    affectedUserCheck += " and uomid.ID = ? ";
                    affectedUserparams.add(uomid);
                }else{
//                    affectedUserCheck += " and uomid is null ";
                    affectedUserparams.add(stockUOMId);
                }
                List listCheck = executeQuery( "from PriceList where carryIn=? and product.ID=? and affecteduser = ? and applyDate<=? and currency.currencyID=? "+affectedUserCheck, affectedUserparams.toArray());
                if (listCheck.isEmpty()) {
                    condition += " and pl1.affecteduser = '-1' ";
                    conditionSubquery += " and affecteduser = '-1' ";
                } else {
                    condition += " and pl1.affecteduser = ? ";
                    conditionSubquery += " and affecteduser = ? ";
                    params.add(affecteduser);
                    paramsSubquery.add(affecteduser);
                    
                }
                
            }
            /**
             * Checking if uomid is passed in params if yes the fetching the
             * price mapped to particular uom if not then getting the default
             * value. ERM-389 / ERP-35140
             */
            condition += " and pl1.uomid.ID = ? ";
            conditionSubquery += " and uomid.ID = ? ";
            if (!StringUtil.isNullOrEmpty(uomid)) {
                params.add(uomid);
                paramsSubquery.add(uomid);
            } else {
//                condition += " and pl1.uomid is null ";
//                conditionSubquery += " and uomid is null ";
                params.add(stockUOMId);
                paramsSubquery.add(stockUOMId);
            }
            
            params.addAll(paramsSubquery);

            String query = "select pl1.price from PriceList pl1 where product.ID=? and carryIn=? " + condition + initialPriceCondition + " and applyDate = (select max(applyDate) as ld from PriceList where product.ID=pl1.product.ID and carryIn=pl1.carryIn " + conditionSubquery + initialPriceCondition + "  group by product)";
            
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add((Double) itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getProductPrice : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    public boolean checkIfPriceIsMappedToUOMInPriceList(String productid, boolean isPurchase, Date transactiondate, String affecteduser, String forCurrency, String uomid) throws ServiceException {
        boolean isUOMPresent = false;
        ArrayList params = new ArrayList();
        ArrayList subQueryParams = new ArrayList();
        String condition = "", conditionSubquery = "";
        Product product = (Product) get(Product.class, productid);
        Company cmp =product!=null? product.getCompany():null;
        if (StringUtil.isNullOrEmpty(forCurrency)) {
            if (cmp != null) {
                forCurrency = cmp.getCurrency().getCurrencyID();
            }
        }
        params.add(productid);
        params.add(isPurchase);
        params.add(uomid);
        params.add(forCurrency);

        if (StringUtil.isNullOrEmpty(affecteduser)) {
            condition += " and pl1.affecteduser = '-1' ";
            conditionSubquery += " and affecteduser = '-1' ";
        } else {
            /**
             * Checking if uomid is passed in params if yes the fetching the
             * price mapped to particular uom if not then getting the default
             * value. ERM-389 / ERP-35140
             */
            String affectedUserCheck = "";
            ArrayList affectedUserparams = new ArrayList();
            affectedUserparams.add(isPurchase);
            affectedUserparams.add(productid);
            affectedUserparams.add(affecteduser);
            affectedUserparams.add(transactiondate);
            affectedUserparams.add(forCurrency);
            affectedUserparams.add(uomid);
            List listCheck = executeQuery("select affecteduser from PriceList where carryIn=? and product.ID=? and affecteduser = ? and applyDate<=? and currency.currencyID=?  and uomid.ID = ? ", affectedUserparams.toArray());
            if (listCheck.isEmpty()) {
                condition += " and pl1.affecteduser = '-1' ";
                conditionSubquery += " and affecteduser = '-1' ";
            } else {
                condition += " and pl1.affecteduser = ? ";
                conditionSubquery += " and affecteduser = ? ";
                params.add(affecteduser);
                subQueryParams.add(affecteduser);
            }
        }
            params.add(transactiondate);
            params.add(uomid);
            params.add(forCurrency);
            params.addAll(subQueryParams);
        String query = "select pl1.uomid from PriceList pl1 where pl1.product.ID=? and pl1.carryIn=? and pl1.uomid.ID = ? "
                + " and pl1.currency.currencyID = ? " + condition + " and pl1.applyDate = (select max(applyDate) as ld from PriceList where product.ID=pl1.product.ID and carryIn=pl1.carryIn"
                + " and applyDate<=?  and uomid.ID = ? and currency.currencyID = ?" + conditionSubquery + " group by product)";

        List list = executeQuery(query, params.toArray());
        if (!list.isEmpty()) {
            isUOMPresent = true;
        }
        return isUOMPresent;
    }
    
    public KwlReturnObject getAllProductsMaxAppliedDatePriceDetails(String companyid, HashMap<String, Object> request) throws ServiceException {
        List list_PriceList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            ArrayList mainSubQryparams = new ArrayList();
            StringBuilder mainSubQuery = new StringBuilder("");
            String stockUOMId = "";
            StringBuilder innerJoinForStockUOM = new StringBuilder();
            StringBuilder subQueryFilter = new StringBuilder(" where pricelist.company=? and price > 0 ");
            params.add(companyid);
            /*
            Initial price should be displayed while creating the assembly product.
            */
            boolean displayInitialPrice = false;
            if (request.containsKey("displayInitialPrice") && request.get("displayInitialPrice") != null) {
                displayInitialPrice = (Boolean) request.get("displayInitialPrice");
            }
            
            if (request.containsKey("isPurchase") && request.get("isPurchase") != null) {
                boolean isPurchase = (Boolean) request.get("isPurchase");
                subQueryFilter.append(" and carryin = ? ");
                mainSubQuery.append(" and pt.carryin = ? ");
                if(isPurchase) {
                    params.add('T');
                    mainSubQryparams.add('T');
                } else {
                    params.add('F');
                    mainSubQryparams.add('F');
                }
            }
            if (request.containsKey("transactiondate") && request.get("transactiondate") != null) {
                Date transactiondate = (Date) request.get("transactiondate");
                subQueryFilter.append(" and applydate = ? ");
                params.add(transactiondate);
            }
            if (request.containsKey("affecteduser") && request.get("affecteduser") != null) {
                String affecteduser = request.get("affecteduser").toString();
                    subQueryFilter.append(" and affecteduser = ? ");
                    params.add(affecteduser);
                }
            if (request.containsKey("currency") && request.get("currency") != null) {
                String currency = request.get("currency").toString();
                subQueryFilter.append(" and currency = ? ");
                params.add(currency);
            } else {
                subQueryFilter.append(" and company.currency = pricelist.currency and affecteduser = '-1'");
            }
            if (request.containsKey("productid") && request.get("productid") != null) {
                String productid = request.get("productid").toString();
                subQueryFilter.append(" and product = ? ");
                params.add(productid);
            }
            if (request.containsKey("uomid") && request.get("uomid") != null) {
                subQueryFilter.append(" and uomid = ? ");
                params.add(request.get("uomid"));
            } else {
                innerJoinForStockUOM.append(" inner join product pdt on pdt.id = pricelist.product ");
                subQueryFilter.append(" and pricelist.uomid = pdt.unitOfMeasure ");
            }
            
            if (displayInitialPrice) {
                mainSubQuery.append(" and pt.initialprice = 'T' ");
                subQueryFilter.append(" and pricelist.initialprice = 'T' ");
            }
            
            params.addAll(mainSubQryparams);
            String query_PriceList = " SELECT pt.id, pt.price, pt.applydate, pt.product FROM pricelist pt "
                    + "INNER JOIN ( SELECT product, MAX(applydate) AS applydate,pricelist.currency FROM pricelist inner join company on company.companyid = pricelist.company "+innerJoinForStockUOM.toString()+" "
                    + subQueryFilter+" GROUP BY product ) maxpricelist "
                    + "ON pt.product = maxpricelist.product AND maxpricelist.currency=pt.currency AND pt.applydate = maxpricelist.applydate "+mainSubQuery+" order by pt.product;";
            
            list_PriceList = executeSQLQuery( query_PriceList, 
                    params.toArray());

        } catch (Exception ex) {
            throw ServiceException.FAILURE("getAllProductsMaxAppliedDatePriceDetails : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list_PriceList, list_PriceList.size());
    }
    
    @Override
    public KwlReturnObject getProductCustomFieldValue(HashMap<String, Object> request) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            String productid = "";
            Date transactiondate = null;
            String fieldId = "";
            String companyId = "";
            if (request.containsKey("productId")) {
                productid = (String) request.get("productId");

            }
            if (request.containsKey("fieldId")) {
                fieldId = (String) request.get("fieldId");

            }
            if (request.containsKey("companyId")) {
                companyId = (String) request.get("companyId");

            }
            if (request.containsKey("transactionDate")) {
                transactiondate = (Date) request.get("transactionDate");
            }

            params.add(productid);
            params.add(fieldId);
            params.add(productid);
            params.add(fieldId);
            params.add(transactiondate);
            params.add(companyId);
            params.add(companyId);

            String query = "Select pc.value from ProductCustomFieldHistory pc where pc.product.ID = ? and pc.fieldParams.id = ? and pc.applyDate =(select MAX(applyDate) from ProductCustomFieldHistory pcf where pcf.product.ID = ? and pcf.fieldParams.id = ? and pcf.applyDate<=? and pcf.company.companyID=?) and pc.company.companyID=?";
            List list = executeQuery( query, params.toArray());
            returnList = list;
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getProductPrice : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject getCustomFieldHistoryForProduct(HashMap<String, Object> request) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            String productid = "";
            String fieldId = "";
            String companyId = "";
            Date applyDate = null;
            String applyDateCondition = "";
            if (request.containsKey("productId") && request.get("productId") != null) {
                productid = (String) request.get("productId");

            }
            if (request.containsKey("fieldId") && request.get("fieldId") != null) {
                fieldId = (String) request.get("fieldId");

            }
            if (request.containsKey("companyid") && request.get("companyid") != null) {
                companyId = (String) request.get("companyid");
            }



            params.add(productid);
            params.add(fieldId);
            params.add(companyId);

            if (request.containsKey("applyDate") && request.get("applyDate") != null) {
                applyDate = (Date) request.get("applyDate");
                applyDateCondition = " and Date(pc.applyDate)=Date(?) ";
                params.add(applyDate);
            }

            String query = "Select pc.Id from ProductCustomFieldHistory pc where pc.product.ID = ? and pc.fieldParams.id = ? and pc.company.companyID=?" + applyDateCondition;
            List list = executeQuery( query, params.toArray());
            returnList = list;
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getProductPrice : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    /**
     * Function to get Product tax class history based on date
     *
     * @param reqMap
     * @return
     * @throws ServiceException
     */
    public List getGstProductHistory(Map<String, Object> reqMap) throws ServiceException {
        List params = new ArrayList();
        String selectcol = " select id from  ProductCustomFieldHistory ";
        String condition = "";
        if (reqMap.containsKey("isdetails")) {
            selectcol = " From ProductCustomFieldHistory ";
        }
        if (reqMap.containsKey("productId")) {
            params.add((String) reqMap.get("productId"));
            condition += " where product.ID=? ";
        }
        if (reqMap.containsKey("fieldname")) {
            params.add((String) reqMap.get("fieldname"));
            condition += " and fieldParams.fieldname=? ";
        }
        if (reqMap.containsKey("moduleid")) {
            params.add((int) reqMap.get("moduleid"));
            condition += " and fieldParams.moduleid=? ";
        }
        if (reqMap.containsKey("fieldId")) {
            params.add((String) reqMap.get("fieldId"));
            condition += " and fieldParams.id=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            condition += " and Date(applyDate)=Date(?) ";
            params.add(applyDate);
        }
        String query = selectcol + condition + " order by applyDate desc ";
        List list = executeQuery(query, params.toArray());
        return list;
    }
     public List getGstProductUsedHistory(Map<String, Object> reqMap) throws ServiceException {
        List params = new ArrayList();
        String SIselectcol = " select inv.id,MAX(inv.creationdate) as invmaxdate from gsttaxclasshistory gtch ";
        String SIjoinSql =  " inner join invoicedetails invd on invd.id=gtch.refdocid "
                + " inner join invoice inv on inv.id=invd.invoice  "
                + " inner join inventory ivt on ivt.id=invd.id  ";
        String SIcondition = "";
        if (reqMap.containsKey("productId")) {
            String productId = (String) reqMap.get("productId");
            params.add(productId);
            SIcondition += " where ivt.product=? ";
        }
        if (reqMap.containsKey("companyid")) {
            params.add((String) reqMap.get("companyid"));
            SIcondition += " and inv.company=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            SIcondition += " and Date(inv.creationdate)>=Date(?) ";
            params.add(applyDate);
        }
        String having = " having invmaxdate is not null ";
        String orderby=" order by invmaxdate DESC ";
        String SIquery = SIselectcol + SIjoinSql + SIcondition + having;
        String PIselectcol = " select gr.id,MAX(gr.creationdate) as invmaxdate from gsttaxclasshistory gtch ";
        String PIjoinSql =  " inner join grdetails grd on grd.id=gtch.refdocid "
                + " inner join goodsreceipt gr on gr.id=grd.goodsreceipt  "
                + " inner join inventory ivt on ivt.id=grd.id  ";
        String PIcondition = "";
        if (reqMap.containsKey("productId")) {
            String productId = (String) reqMap.get("productId");
            params.add(productId);
            PIcondition += " where ivt.product=? ";
        }
        if (reqMap.containsKey("companyid")) {
            params.add((String) reqMap.get("companyid"));
            PIcondition += " and gr.company=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            PIcondition += " and Date(gr.creationdate)>=Date(?) ";
            params.add(applyDate);
        }
        String PIquery = PIselectcol + PIjoinSql + PIcondition + having;
        String CNselectcol = " select cn.id,MAX(cn.creationdate) as invmaxdate from gsttaxclasshistory gtch ";
        String CNjoinSql =  " inner join cntaxentry cnt on cnt.id=gtch.refdocid "
                + " inner join creditnote cn on cn.id=cnt.creditnote ";
        String CNcondition = "";
        if (reqMap.containsKey("productId")) {
            String productId = (String) reqMap.get("productId");
            params.add(productId);
            CNcondition += " where cnt.productid=? ";
        }
        if (reqMap.containsKey("companyid")) {
            params.add((String) reqMap.get("companyid"));
            CNcondition += " and cn.company=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            CNcondition += " and Date(cn.creationdate)>=Date(?) ";
            params.add(applyDate);
        }
        String CNquery = CNselectcol + CNjoinSql + CNcondition + having;
        String DNselectcol = " select dn.id,MAX(dn.creationdate) as invmaxdate from gsttaxclasshistory gtch ";
        String DNjoinSql =  " inner join dntaxentry dnt on dnt.id=gtch.refdocid "
                + " inner join debitnote dn on dn.id=dnt.debitnote ";
        String DNcondition = "";
        if (reqMap.containsKey("productId")) {
            String productId = (String) reqMap.get("productId");
            params.add(productId);
            DNcondition += " where dnt.productid=? ";
        }
        if (reqMap.containsKey("companyid")) {
            params.add((String) reqMap.get("companyid"));
            DNcondition += " and dn.company=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            DNcondition += " and Date(dn.creationdate)>=Date(?) ";
            params.add(applyDate);
        }
        String DNquery = DNselectcol + DNjoinSql + DNcondition + having;
        String SRSelectcol=" select sr.id,MAX(sr.orderdate) as invmaxdate from gsttaxclasshistory gtch ";
        String SRjoinSql = " inner join srdetails srd on srd.id=gtch.refdocid "
                + " inner join salesreturn sr on sr.id=srd.salesreturn ";
        String SRcondition = "";
        if (reqMap.containsKey("productId")) {
            String productId = (String) reqMap.get("productId");
            params.add(productId);
            SRcondition += " where srd.product=? ";
        }
        if (reqMap.containsKey("companyid")) {
            params.add((String) reqMap.get("companyid"));
            SRcondition += " and sr.company=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            SRcondition += " and Date(sr.orderdate)>=Date(?) ";
            params.add(applyDate);
        }

        String SRquery = SRSelectcol + SRjoinSql + SRcondition + having;
        String PRSelectcol=" select pr.id,MAX(pr.orderdate) as invmaxdate from gsttaxclasshistory gtch ";
        String PRjoinSql = " inner join prdetails prd on prd.id=gtch.refdocid "
                + " inner join purchasereturn pr on pr.id=prd.purchasereturn ";
        String PRcondition = "";
        if (reqMap.containsKey("productId")) {
            String productId = (String) reqMap.get("productId");
            params.add(productId);
            PRcondition += " where prd.product=? ";
        }
        if (reqMap.containsKey("companyid")) {
            params.add((String) reqMap.get("companyid"));
            PRcondition += " and pr.company=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            PRcondition += " and Date(pr.orderdate)>=Date(?) ";
            params.add(applyDate);
        }
        String PRquery = PRSelectcol + PRjoinSql + PRcondition + having;
        String RPSelectcol=" select r.id,MAX(r.creationdate) as invmaxdate from gsttaxclasshistory gtch ";
        String RPjoinSql = " inner join receiptadvancedetail rad on rad.id=gtch.refdocid "
                + " inner join receipt r on r.id=rad.receipt ";
        String RPcondition = "";
        if (reqMap.containsKey("productId")) {
            String productId = (String) reqMap.get("productId");
            params.add(productId);
            RPcondition += " where rad.product=? ";
        }
        if (reqMap.containsKey("companyid")) {
            params.add((String) reqMap.get("companyid"));
            RPcondition += " and r.company=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            RPcondition += " and Date(r.creationdate)>=Date(?) ";
            params.add(applyDate);
        }
        String RPquery = RPSelectcol + RPjoinSql + RPcondition + having;
        String MPSelectcol=" select p.id,MAX(p.creationdate) as invmaxdate from gsttaxclasshistory gtch ";
        String MPjoinSql = " inner join advancedetail ad on ad.id=gtch.refdocid "
                + " inner join payment p on p.id=ad.payment ";
        String MPcondition = "";
        if (reqMap.containsKey("productId")) {
            String productId = (String) reqMap.get("productId");
            params.add(productId);
            MPcondition += " where ad.productid=? ";
        }
        if (reqMap.containsKey("companyid")) {
            params.add((String) reqMap.get("companyid"));
            MPcondition += " and p.company=? ";
        }
        if (reqMap.containsKey("applyDate") && reqMap.get("applyDate") != null) {
            Date applyDate = (Date) reqMap.get("applyDate");
            MPcondition += " and Date(p.creationdate)>=Date(?) ";
            params.add(applyDate);
        }
        String MPquery = MPSelectcol + MPjoinSql + MPcondition + having;
        String union=" union ";
        String allModuleQuery = SIquery + union + PIquery + union + CNquery + union + DNquery + union + SRquery + union + PRquery + union + RPquery + union + MPquery + orderby;
        List list = executeSQLQuery(allModuleQuery, params.toArray());
        return list;
    }
    public KwlReturnObject getInitialPrice(String productid, boolean isPurchase) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(productid);
            String stockUOMId = "";
            Product product = (Product) get(Product.class, productid);
            String currencyid = "";
            if(product.getCurrency()!=null){
                currencyid=product.getCurrency().getCurrencyID();
            }else{
                currencyid=product.getCompany().getCurrency().getCurrencyID();
            }
            if(product.getUnitOfMeasure()!=null){
                stockUOMId = product.getUnitOfMeasure().getID();
            }
            params.add(isPurchase);
            params.add(currencyid);
            params.add(stockUOMId);
            params.add(currencyid);
            /**
             * 
             */
            String query = "select pl1.price from PriceList pl1 where pl1.affecteduser = '-1' and product.ID=? and carryIn=? and pl1.currency.currencyID = ? "+Constants.PRICELIST_UOM_CONDITION+" and "
                    + " applyDate = (select min(applyDate) as ld from PriceList where affecteduser = '-1' and product.ID=pl1.product.ID and currency.currencyID = ? "+Constants.PRICELIST_UOM_INNER_CONDITION+" and carryIn=pl1.carryIn and (carryIn = false or (carryIn=true and initialPrice = true)) group by product)";            //ERM-389 / ERP-35140
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add((Double) itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getInitialPrice : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject getProCreationDate(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(companyid);
            params.add(productid);
            String query = "select min(updateDate) from Inventory where deleted=false and company.companyID=? and product.ID=? ";
            list = executeQuery( query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getInitialPrice : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getPriceListEntry(HashMap<String, Object> filterParams) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        String condition = "";
        String query = "from PriceList ";
        String stockUOMId="";

        if (filterParams.containsKey("priceid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "ID=?";
            params.add(filterParams.get("priceid"));
        }
        if (filterParams.containsKey("applydate")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "DATE_FORMAT(applyDate,'%m-%d-%Y') = DATE_FORMAT(?,'%m-%d-%Y')";
            params.add(filterParams.get("applydate"));
        }
        if (filterParams.containsKey("productid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "product.ID=?";
            params.add(filterParams.get("productid"));
            Map<String, Object> prefparams = new HashMap();
            prefparams.put("ID", filterParams.get("productid"));
            Object stockUOM = kwlCommonTablesDAOObj.getRequestedObjectFields(Product.class, new String[]{"unitOfMeasure"}, prefparams);
            if (stockUOM != null && stockUOM instanceof UnitOfMeasure) {
                UnitOfMeasure unitOfMeasure = (UnitOfMeasure) stockUOM;
                stockUOMId = unitOfMeasure.getID();
            }
        }
        if (filterParams.containsKey("carryin")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "carryIn=?";
            params.add(filterParams.get("carryin"));
        }
        if (filterParams.containsKey("companyid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "company.companyID=?";
            params.add(filterParams.get("companyid"));
        }
        if (filterParams.containsKey("currencyid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "currency.currencyID=?";
            params.add(filterParams.get("currencyid"));
        }
        condition += (condition.length() == 0 ? " where " : " and ") + "uomid.ID=?";
        if (filterParams.containsKey("uomid")) {            //ERM-389 / ERP-35140
            params.add(filterParams.get("uomid"));
        }else{
            params.add(stockUOMId);
//            condition += (condition.length() == 0 ? " where " : " and ") + "uomid is null";
        }
        if (filterParams.containsKey("initialPrice")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "initialPrice=?";
            params.add(filterParams.get("initialPrice"));
        }
        if (filterParams.containsKey("affecteduser")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "affecteduser=?";
            params.add(filterParams.get("affecteduser"));
        } else {
            condition += (condition.length() == 0 ? " where " : " and ") + "affecteduser=?";
            params.add("-1");
        }
        query += condition;
//        query="from PriceList where applyDate=? and product.ID=? and carryIn=? and company.companyID=?";
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

//Cycle Count
//    public KwlReturnObject getCycleCountForApproval(HashMap<String, Object> requestParams) throws ServiceException {
//        List returnList = new ArrayList();
//        try {
//            ArrayList params = new ArrayList();
//            String query = "";
//            java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd");
//            Date countDate = sdf.parse((String) requestParams.get("countdate"));
//
//            query = "from Cyclecount cc where cc.status = 1 and cc.countDate = ? and cc.product.company.companyID=?";
//            params.add(countDate);
//            params.add((String) requestParams.get("companyid"));
//            returnList = executeQuery( query, params.toArray());
//        } catch (Exception ex) {
//            throw ServiceException.FAILURE("getCycleCountForApproval : " + ex.getMessage(), ex);
//        }
//        return new KwlReturnObject(true, "", null, returnList, returnList.size());
//    }
//    public KwlReturnObject getCycleCountWorkSheet(HashMap<String, Object> requestParams, boolean isExpotrt) throws ServiceException {
//        List returnList = new ArrayList();
//        try {
//            ArrayList params = new ArrayList();
//            String query = "";
//            java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd");
//            Date fromDate = null;
//            Date toDate = null;
//            String companyID = (String) requestParams.get("companyid");
//            if (isExpotrt) {
//                fromDate = sdf.parse((String) requestParams.get("stdate"));
//                toDate = sdf.parse((String) requestParams.get("enddate"));
////                includeCycleCount = request.getParameter("config");
//            } else {
//                fromDate = sdf.parse((String) requestParams.get("ctdatefr"));
//                toDate = sdf.parse((String) requestParams.get("ctdateto"));
////                includeCycleCount = request.getParameter("includerecount");
//            }
//
//            String filter = "";
//            if (Integer.parseInt((String) requestParams.get("includerecount")) == 0) {
//                filter = "(cc.countDate >= ? and cc.countDate <= ?) and ";
//                query = "select cc,"
//                        + " (select cp from ProductCyclecount cp where cp.product=cc.product ),"
//                        + " (select sum((case when carryIn=true then quantity else -quantity end)) from Inventory where deleted=false and product.ID=cc.product.ID  and product.producttype.ID <> ? group by product.ID) "
//                        + " from Cyclecount cc where " + filter
//                        + " cc.status = 2 and cc.product.deleted=false and cc.product.company.companyID=? order by cc.product.name ";
////                
//                //query = "select cp, " +
////                        " (select sum((case when carryIn=true then quantity else -quantity end)) from Inventory where deleted=false and product.ID=cp.product.ID  and product.producttype.ID <> ? group by product.ID) " +
////                        " from ProductCyclecount cp where ((cp.prevDate >= ? and cp.prevDate <= ?)) and " +
////                        " cp.product.deleted=false and cp.product.company.companyID=? order by cp.product.name ";
//                params.add(Producttype.SERVICE);
//                params.add(fromDate);
//                params.add(toDate);
//                //params.add(new Date(0, 0, 1));
//                params.add(companyID);
//                returnList = executeQuery( query, params.toArray());
//            } else {
//                filter = "(cc.countDate >= ? and cc.countDate <= ?) and ";
//                query = "select cc,"
//                        + " (select cp from ProductCyclecount cp where cp.product=cc.product ),"
//                        + " (select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory where deleted=false and product.ID=cc.product.ID  and product.producttype.ID <> ? group by product.ID) "
//                        + " from Cyclecount cc where " + filter
//                        + " cc.status = 0 and cc.product.deleted=false and cc.product.company.companyID=? order by cc.product.name ";
//                params.add(Producttype.SERVICE);
//                params.add(fromDate);
//                params.add(toDate);
//                params.add(companyID);
//                returnList = executeQuery( query, params.toArray());
//            }
//        } catch (Exception ex) {
//            throw ServiceException.FAILURE("getCycleCountWorkSheet : " + ex.getMessage(), ex);
//        }
//        return new KwlReturnObject(true, "", null, returnList, returnList.size());
//    }

//    public KwlReturnObject getCycleCountProduct(HashMap<String, Object> filterParams) throws ServiceException {
//        List returnList = new ArrayList();
//        ArrayList params = new ArrayList();
//        params.add(Producttype.SERVICE);
//        String query = "";
//        if (Integer.parseInt((String) filterParams.get("type")) == 0) {//type = 0 include initialcount ; type =1 include recount items
//            params.add(new Date(new Date().getYear(), new Date().getMonth(), new Date().getDate()));
//            params.add(new Date(0, 0, 1));
//            params.add((String) filterParams.get("companyid"));
//
////              query="select cp.product,(select sum((case when carryIn=true then quantity else -quantity end)) from Inventory where deleted=false and product.ID=cp.product.ID and product.producttype.ID <> ? group by product.ID), cp, cc "
////                      + "from  ProductCyclecount cp , Cyclecount cc "
////                      + "where ((cp.nextDate <= ? or cp.nextDate = ? ) and  cp.product.deleted=false and cp.product.company.companyID=?) and "
////                      + " cc.product.ID=cp.product.ID";
//            query = "select cp.product, "
//                    + " (select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory where deleted=false and product.ID=cp.product.ID and product.producttype.ID <> ? group by product.ID), "
//                    + " cp from ProductCyclecount cp where (cp.nextDate <= ? or cp.nextDate = ? ) and "
//                    + " cp.product.deleted=false and cp.product.company.companyID=? order by cp.product.name ";
////                    + " UNION"
////                    + " select c.product, c.countedquantity, NULL from Cyclecount c where c.status = 0  and  (c.countdate <= ?) and c.product.deleted=false and cp.product.company.companyID=? order by cp.product.name ";
////            params.add(new Date(new Date().getYear(), new Date().getMonth(), new Date().getDate()));
////            params.add((String) filterParams.get("companyid"));
//        } else {
//            query = "select cp.product, "
//                    + " (select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory where deleted=false and product.ID=cp.product.ID and product.producttype.ID <> ? group by product.ID), "
//                    + " (select cp1 from ProductCyclecount cp1 where cp1.product = cp.product),cp.ID, cp "
//                    + " from Cyclecount cp where cp.status = 0  and "
//                    + " cp.product.deleted=false and cp.product.company.companyID=? and cp.countDate = (select max(cp1.countDate) from Cyclecount cp1 where cp1.ID = cp.ID) group by cp.product.name order by cp.product.name ";
//            params.add((String) filterParams.get("companyid"));
//        }
//
//        returnList = executeQuery( query, params.toArray());
//        return new KwlReturnObject(true, "", null, returnList, returnList.size());
//    }

//    public KwlReturnObject cycleCountReport(HashMap<String, Object> filterParams, boolean isExport) throws ServiceException {
//        List returnList = new ArrayList();
//        int count = 0;
//        try {
//            ArrayList params = new ArrayList();
//            String query = "";
//            String filter = "";
//            java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd");
//            Date countStDate = sdf.parse((String) filterParams.get("stdate"));
//            Date countEndDate = sdf.parse((String) filterParams.get("enddate"));
//            countStDate = AccountingManager.setFilterTime(countStDate, true);
//            countEndDate = AccountingManager.setFilterTime(countEndDate, false);
//            String start = (String) filterParams.get("start");
//            String limit = (String) filterParams.get("limit");
//            if (filterParams.get("val").equals("0")) {
//                filter = "";
//            } else if (filterParams.get("val").equals("1")) {
//                filter = "cc.status=0 and";
//            } else if (filterParams.get("val").equals("2")) {
//                filter = "cc.status=1 and";
//            } else {
//                filter = "cc.status=2 and";
//            }
//            query = "from Cyclecount cc where (cc.countDate >= ? and cc.countDate <= ? )and " + filter + " cc.product.company.companyID=?";
//            params.add(countStDate);
//            params.add(countEndDate);
//            params.add((String) filterParams.get("companyid"));
//            returnList = executeQuery( query, params.toArray());
//            count = returnList.size();
//            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false && !isExport) {
//                returnList = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
//            }
//        } catch (ParseException ex) {
//            throw ServiceException.FAILURE("cycleCountReport : " + ex.getMessage(), ex);
//        }
//        return new KwlReturnObject(true, "", null, returnList, count);
//    }

//    @Override
//    public KwlReturnObject saveCycleCount(HashMap<String, Object> dataMap) throws ServiceException {
//        List list = new ArrayList();
//        try {
//            Cyclecount cc = new Cyclecount();
//            if (dataMap.containsKey("id")) {
//                cc = (Cyclecount) get(Cyclecount.class, (String) dataMap.get("id"));
//            }
//            if (dataMap.containsKey("productid")) {
//                Product product = dataMap.get("productid") == null ? null : (Product) get(Product.class, (String) dataMap.get("productid"));
//                cc.setProduct(product);
//            }
//            if (dataMap.containsKey("initquantity")) {
//                cc.setIniquantity((Double) dataMap.get("initquantity"));
//            }
//            if (dataMap.containsKey("countquantity")) {
//                cc.setCountedquantity((Double) dataMap.get("countquantity"));
//            }
//            if (dataMap.containsKey("status")) {
//                cc.setStatus((Integer) dataMap.get("status"));
//            }
//            if (dataMap.containsKey("reason")) {
//                cc.setReason((String) dataMap.get("reason"));
//            }
//            if (dataMap.containsKey("countdate")) {
//                cc.setCountDate((Date) dataMap.get("countdate"));
//            }
//            save(cc);
//            list.add(cc);
//        } catch (Exception e) {
//            throw ServiceException.FAILURE("saveCycleCount : " + e.getMessage(), e);
//        }
//        return new KwlReturnObject(true, "Cycle count has been added successfully", null, list, list.size());
//    }

//    public KwlReturnObject getCycleCountEntry(HashMap<String, Object> filterParams) throws ServiceException {
//        List returnList = new ArrayList();
//        ArrayList params = new ArrayList();
//        String condition = "";
//        String query = "from ProductCyclecount ";
//
//        if (filterParams.containsKey("productid")) {
//            condition += (condition.length() == 0 ? " where " : " and ") + "product.ID=?";
//            params.add(filterParams.get("productid"));
//        }
//        query += condition;
////        "select pc from ProductCyclecount pc where pc.product = ? ?"
//        returnList = executeQuery( query, params.toArray());
//        return new KwlReturnObject(true, "", null, returnList, returnList.size());
//    }

//    public ProductCyclecount getCycleCountEntryObject(HashMap<String, Object> filterParams) throws ServiceException {
//        KwlReturnObject retObj = getCycleCountEntry(filterParams);
//        ProductCyclecount pc = null;
//        Iterator itr = retObj.getEntityList().iterator();
//        while (itr.hasNext()) {
//            pc = (ProductCyclecount) itr.next();
//        }
//        return pc;
//    }

//    public KwlReturnObject saveProductCycleCount(HashMap<String, Object> dataMap) throws ServiceException {
//        List list = new ArrayList();
//        try {
//            ProductCyclecount pc = null;
//            String productid = (String) dataMap.get("productid");
//
//            if (!StringUtil.isNullOrEmpty(productid)) {
//                HashMap<String, Object> ccfilterParams = new HashMap<String, Object>();
//                ccfilterParams.put("productid", productid);
//                pc = getCycleCountEntryObject(ccfilterParams);
//            }
//
//            if (dataMap.containsKey("id")) {
//                pc = (ProductCyclecount) get(ProductCyclecount.class, (String) dataMap.get("id"));
//            }
//
//            if (pc == null) {
//                pc = new ProductCyclecount();
//                pc.setStatus(0);
//            }
//
//            if (dataMap.containsKey("productid")) {
//                Product product = productid == null ? null : (Product) get(Product.class, productid);
//                pc.setProduct(product);
//            }
//            if (dataMap.containsKey("tolerance")) {
//                pc.setTolerance((Integer) dataMap.get("tolerance"));
//            }
//            if (dataMap.containsKey("interval")) {
//                pc.setCountInterval((Integer) dataMap.get("interval"));
//            }
//            if (dataMap.containsKey("prevdate")) {
//                pc.setPrevDate((Date) dataMap.get("prevdate"));
//            }
//            if (dataMap.containsKey("nextdate")) {
//                pc.setNextDate((Date) dataMap.get("nextdate"));
//            }
//            save(pc);
//            list.add(pc);
//        } catch (Exception e) {
//            throw ServiceException.FAILURE("saveProductCycleCount : " + e.getMessage(), e);
//        }
//        return new KwlReturnObject(true, "Product cycle count has been added successfully", null, list, list.size());
//    }

    @Override
    public int deleteShelfLacation(String companyId) throws ServiceException {
        String delQuery = "Delete from ShelfLocation sl where sl.company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{companyId});
        return numRows;
    }

    @Override
    public KwlReturnObject saveShelfLocationData(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            ShelfLocation shelfLocation = new ShelfLocation();
            String shelfLocationId = "";
            if (dataMap.containsKey("shelfLocationId") && dataMap.get("shelfLocationId") != null) {
                shelfLocationId = (String) dataMap.get("shelfLocationId");
            } else {
                shelfLocationId = UUID.randomUUID().toString();
            }

            if (!StringUtil.isNullOrEmpty(shelfLocationId)) {
                shelfLocation.setId(shelfLocationId);
            }
            if (dataMap.containsKey("shelfLocationValue") && dataMap.get("shelfLocationValue") != null) {
                String shelfLocationValue = (String) dataMap.get("shelfLocationValue");
                shelfLocation.setShelfLocationValue(shelfLocationValue);
            }
            if (dataMap.containsKey("companyId")) {
                Company company = dataMap.get("companyId") == null ? null : (Company) get(Company.class, (String) dataMap.get("companyId"));
                shelfLocation.setCompany(company);
            }
            saveOrUpdate(shelfLocation);
            list.add(shelfLocation);
        } catch (Exception e) {
            throw ServiceException.FAILURE("saveShelfLocation : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Shelf Location has been added successfully", null, list, list.size());
    }

//Inventory
    public KwlReturnObject deleteInventory(String inventoryid, String companyid) throws ServiceException {
        Inventory inventory = (Inventory) get(Inventory.class, inventoryid);
        if (inventory != null) {
              updateProductQuantityOnDelete(inventory);
        }
//        String delQuery = "delete from Inventory where ID=? and company.companyID=?";
//        int numRows = executeUpdate( delQuery, new Object[]{inventoryid, companyid});
        delete(inventory);
        return new KwlReturnObject(true, "Inventory entry has been deleted successfully.", null, null, 1);
    }
    
    public KwlReturnObject deleteLBDMOnDocumentID(Map<String, Object> params) throws ServiceException {
        String query = "delete from locationbatchdocumentmapping where ";
        String conditions = "";
        List qData = new ArrayList();
        if (params.containsKey(Constants.DOCUMENTID)) {
            conditions += " documentid=? ";
            qData.add((String) params.get(Constants.DOCUMENTID));
        }
        if (params.containsKey(Constants.MRP_TransactionType)) {
            conditions += " and transactiontype=?";
            qData.add((int) params.get(Constants.MRP_TransactionType));
        }
        query += conditions;
        int res = executeSQLUpdate(query, qData.toArray());
        return new KwlReturnObject(true, "LBDM entry has been deleted successfully.", null, null, res);
    }

    public KwlReturnObject deleteInventoryByProduct(String productid, String companyid) throws ServiceException {
        String selQuery = "select from Inventory i where i.product.ID=? and i.company.companyID=?";
        List resultList = executeQuery( selQuery, new Object[]{productid, companyid});
        Iterator itr = resultList.iterator();
        while (itr.hasNext()) {
            Inventory inventory = (Inventory) itr.next();
            if (inventory != null) {
                 updateProductQuantityOnDelete(inventory);
            }

        }
        deleteAll(resultList);
        
//        int numRows = executeUpdate( delQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "Inventory entry has been deleted successfully.", null, null, resultList.size());
    }

    public KwlReturnObject deleteInventoryEntry(String inventoryid, String companyid) throws ServiceException {
        Inventory inventory = (Inventory) get(Inventory.class, inventoryid);
        if (inventory != null) {
            updateProductQuantityOnDelete(inventory);
        }
        String query = "update Inventory inv set inv.deleted=true where inv.ID=? and inv.company.companyID=?";
        int numRows = executeUpdate( query, new Object[]{inventoryid, companyid});
        return new KwlReturnObject(true, "Inventory has been deleted successfully.", null, null, numRows);
    }
    
    //Writen for update product quanity on delete
    public void updateProductQuantityOnDelete(Inventory inventory){
        if (inventory != null && inventory.isDeleted() == false) {
            if (inventory.isCarryIn()) {
                inventory.getProduct().setAvailableQuantity(authHandler.roundQuantity(inventory.getProduct().getAvailableQuantity() - inventory.getBaseuomquantity(), inventory.getCompany().getCompanyID()));// minus Purchase and Plus Sales (for Reverse effect for quantity)
            } else {
                inventory.getProduct().setAvailableQuantity(authHandler.roundQuantity(inventory.getProduct().getAvailableQuantity() + inventory.getBaseuomquantity(), inventory.getCompany().getCompanyID()));
            }
        }
    }
    public KwlReturnObject addInventory(JSONObject json) throws ServiceException {
        KwlReturnObject result;
        List list = new ArrayList();
        Inventory invetory = new Inventory();
        try {
            invetory = buildInventory(invetory, json);
            list.add(invetory);
            result = new KwlReturnObject(true, null, null, list, list.size());
        } catch (Exception ex) {
//            result = new KwlReturnObject(true, "addInventory :"+ex.getMessage(), null, list, list.size());
            throw ServiceException.FAILURE("addInventory:" + ex.getMessage(), ex);
        }
        return result;
    }
    public KwlReturnObject updateJobWorkDetailsAsClose(String rowId,String companyId) throws ServiceException {
        String query = "update in_interstoretransfer set isjobworkclose=? where id=? and company=?";
        int numRows = executeSQLUpdate(query, new Object[]{'T',rowId,companyId});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    
    public KwlReturnObject updateInventory(JSONObject json) throws ServiceException {
        KwlReturnObject result;
        List list = new ArrayList();
        try {
            String inventoryid = json.getString("inventoryid");
            Inventory invetory = (Inventory) get(Inventory.class, inventoryid);
            if (invetory != null) {
                if (invetory != null) {
                    updateProductQuantityOnDelete(invetory);
                }
                invetory = buildInventory(invetory, json);
            }
            list.add(invetory);
            result = new KwlReturnObject(true, null, null, list, list.size());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("updateInventory:" + ex.getMessage(), ex);
        }
        return result;
    }

    public KwlReturnObject updateInitialInventory(JSONObject json) throws ServiceException {
        KwlReturnObject result;
        List list = new ArrayList();
        Inventory invetory;
        try {
            String productid = json.getString("productid");
            List Inventoryid = searchInventoryId(productid, true);
            if (Inventoryid.size() == 0) {
                invetory = new Inventory();
            } else {
                invetory = (Inventory) Inventoryid.get(0);
                if (invetory != null) {
                    updateProductQuantityOnDelete(invetory);
                }
            }
            invetory = buildInventory(invetory, json);

            list.add(invetory);
            result = new KwlReturnObject(true, null, null, list, list.size());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("updateInitialInventory:" + ex.getMessage(), ex);
        }
        return result;
    }
      public KwlReturnObject updateAssemblyProductsInventoryEntry(JSONObject json) throws ServiceException {
        KwlReturnObject result;
        List list = new ArrayList();
        try {
            String inventoryid = json.getString("inventoryid");
            Inventory invetory = (Inventory) get(Inventory.class, inventoryid);
            if (invetory != null) {
                if (json.has("quantity")) {
                    invetory.setQuantity(invetory.getQuantity() + json.optDouble("quantity",0));
                }
                if (json.has("baseuomquantity") && json.get("baseuomquantity") != null && json.get("baseuomquantity") != "") {
                    invetory.setBaseuomquantity(invetory.getBaseuomquantity() + json.optDouble("baseuomquantity",0));
                }
                if (json.getBoolean("carryin")) {
                    invetory.getProduct().setAvailableQuantity(invetory.getProduct().getAvailableQuantity() + json.optDouble("baseuomquantity", 0));
                }
                list.add(invetory);
            }
            result = new KwlReturnObject(true, null, null, list, list.size());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("updateAssemblyProductsInventoryEntry:" + ex.getMessage(), ex);
        }
        return result;
    }

    @Override//ERP-11730
    public KwlReturnObject updateQuantityDueOfSerailnumbers(JSONObject json) throws ServiceException {
        KwlReturnObject result;
        try {
            String productid = json.getString("productid");
            String productBuildID = json.optString("productBuildID", "");
            double productBuildQuantity = Double.parseDouble(json.optString("productBuildQuantity","0.0"));
            String companyid = json.getString("companyid");

            String query_Batch = "select npb.id,lbdm.quantity from newproductbatch npb "
                    + "INNER JOIN locationbatchdocumentmapping lbdm ON npb.id = lbdm.batchmapid "
                    + "INNER JOIN pbdetails pbd ON lbdm.documentid = pbd.id "
                    + "INNER JOIN productbuild pb ON pbd.build=pb.id "
                    + "where pb.product= ? and pb.refno <> \"\" and pb.company = ? ";
            List<Object[]> list_Batch = executeSQLQuery( query_Batch, new Object[]{productid, companyid});

            for (int i = 0; i < list_Batch.size(); i++) {
                Object[] list_BatchQuantity = list_Batch.get(i);
                String listObj_Batch = (String) list_BatchQuantity[0];
                Double componantquantity = (Double) list_BatchQuantity[1];
                if (!StringUtil.isNullOrEmpty(listObj_Batch)) {
                    NewProductBatch newproductbatch = (NewProductBatch) get(NewProductBatch.class, listObj_Batch);
                    if(newproductbatch != null){
                       newproductbatch.setQuantitydue(authHandler.roundQuantity((newproductbatch.getQuantitydue() + componantquantity),companyid));
                    }
                }
            }
            
            String query_MainBatch = "select npb.id from newproductbatch npb INNER JOIN locationbatchdocumentmapping lbdm ON npb.id = lbdm.batchmapid "
                    + "INNER JOIN productbuild pb ON lbdm.documentid = pb.id where pb.product= ? and pb.id=?  and pb.company =?";
            List list_MainBatch = executeSQLQuery( query_MainBatch, new Object[]{productid,productBuildID, companyid});

            for (int i = 0; i < list_MainBatch.size(); i++) {
                String listObj_MainBatch = (String) list_MainBatch.get(i);
                if (!StringUtil.isNullOrEmpty(listObj_MainBatch)) {
                    NewProductBatch newMainproductbatch = (NewProductBatch) get(NewProductBatch.class, listObj_MainBatch);
                    if(newMainproductbatch != null){
                       newMainproductbatch.setQuantitydue(authHandler.roundQuantity((newMainproductbatch.getQuantitydue() - productBuildQuantity),companyid));
                    }
                }
            }

            String query_Serial = "select nbs.id from newbatchserial nbs "
                    + "INNER JOIN serialdocumentmapping sdm ON nbs.id = sdm.serialid "
                    + "INNER JOIN pbdetails pbd ON sdm.documentid = pbd.id "
                    + "INNER JOIN productbuild pb ON pbd.build=pb.id  "
                    + "where pb.product= ? and pb.refno <> \"\" and pb.company = ? ";
            List list_Serial = executeSQLQuery( query_Serial, new Object[]{productid, companyid});

            for (int i = 0; i < list_Serial.size(); i++) {
                String listObj_Serial = (String) list_Serial.get(i);
                if (!StringUtil.isNullOrEmpty(listObj_Serial)) {
                    NewBatchSerial newbatchserial = (NewBatchSerial) get(NewBatchSerial.class, listObj_Serial);
                    newbatchserial.setQuantitydue(newbatchserial.getQuantitydue() + 1);
                }
            }
            
            String query_MainSerial = "select npb.id from newbatchserial npb INNER JOIN serialdocumentmapping lbdm ON npb.id = lbdm.serialid "
                    + "INNER JOIN productbuild pb ON lbdm.documentid = pb.id where pb.product= ? and pb.id=?  and pb.company =?";
            List list_MainSerial = executeSQLQuery( query_MainSerial, new Object[]{productid,productBuildID, companyid});

            for (int i = 0; i < list_MainSerial.size(); i++) {
                String listObj_MainSerial = (String) list_MainSerial.get(i);
                if (!StringUtil.isNullOrEmpty(listObj_MainSerial)) {
                    NewBatchSerial NewMainBatchSerial = (NewBatchSerial) get(NewBatchSerial.class, listObj_MainSerial);
                    if(NewMainBatchSerial != null){
                       NewMainBatchSerial.setQuantitydue(NewMainBatchSerial.getQuantitydue() - productBuildQuantity);
                    }
                }
            }

            List list = list_Batch;
            list.addAll(list_Serial);
            result = new KwlReturnObject(true, null, null, list, list.size());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("updateInitialInventory:" + ex.getMessage(), ex);
        }
        return result;
    }

    public List searchInventoryId(String productid, boolean flag) throws ServiceException {
        List resultList;
        try {
            String selQuery = "from Inventory i where i.product.ID=? and i.newInv=?";
            resultList = executeQuery( selQuery, new Object[]{productid, flag});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("searchInventoryId:" + ex.getMessage(), ex);
        }
        return resultList;
    }

    public Inventory buildInventory(Inventory invetory, JSONObject json) throws JSONException, UnsupportedEncodingException, ServiceException {
        Product product = (Product) get(Product.class, json.getString("productid"));
        // if(!product.getProducttype().getID().equals(Producttype.SERVICE)){//service products
        if (json.has("productid")) {
            invetory.setProduct((Product) get(Product.class, json.getString("productid")));
        }
        if (json.has("quantity")) {
            invetory.setQuantity(authHandler.roundQuantity(json.getDouble("quantity"), json.getString("companyid")));
        }
        if (json.has("actquantity")) {
            invetory.setActquantity(authHandler.roundQuantity(json.getDouble("actquantity"),json.getString("companyid")));
        }
        if (json.has("invrecord")) {
            invetory.setInvrecord(json.getBoolean("invrecord"));
        } else {
            invetory.setInvrecord(true);
        }
        if (json.has("isOpeningInventory")) {
            invetory.setOpeningInventory(json.getBoolean("isOpeningInventory"));
        }
        if (json.has("leaseFlag")) {
            invetory.setLeaseFlag(json.getBoolean("leaseFlag"));
        }

        if (json.has("description")) {
            invetory.setDescription(StringUtil.DecodeText(json.optString("description")));
        }
        if (json.has("carryin")) {
            invetory.setCarryIn(json.getBoolean("carryin"));
        }
        if (json.has("defective")) {
            invetory.setDefective(json.getBoolean("defective"));
        }
        if (json.has("newinventory")) {
            invetory.setNewInv(json.getBoolean("newinventory"));
        }
        if (json.has("companyid")) {
            invetory.setCompany((Company) get(Company.class, json.getString("companyid")));
        }
        if (json.has("uomid")) {
            invetory.setUom((UnitOfMeasure) get(UnitOfMeasure.class, json.getString("uomid")));
        }
        if (json.has("baseuomquantity") && json.get("baseuomquantity") != null && json.get("baseuomquantity") != "") {
            invetory.setBaseuomquantity(authHandler.roundQuantity(json.getDouble("baseuomquantity"), json.getString("companyid")));
        }
        if (json.has("consignuomquantity") && json.get("consignuomquantity") != null && json.get("consignuomquantity") != "") {
            invetory.setConsignuomquantity(authHandler.roundQuantity(json.getDouble("consignuomquantity"), json.getString("companyid")));
        }
        if (json.has("venconsignuomquantity") && json.get("venconsignuomquantity") != null && json.get("venconsignuomquantity") != "") {
            invetory.setVenconsignuomquantity(authHandler.roundQuantity(json.getDouble("venconsignuomquantity"), json.getString("companyid")));
        }
        if ((json.has("isConsignment") && json.get("isConsignment") != null)) {
            invetory.setIsconsignment(json.getBoolean("isConsignment"));
        }
        if (json.has("baseuomrate") && json.get("baseuomrate") != null && json.get("baseuomrate") != "") {
            invetory.setBaseuomrate(json.getDouble("baseuomrate"));
        }
        if (json.has("productweightperstockuom") && json.get("productweightperstockuom") != null && json.get("productweightperstockuom") != "") {
            invetory.setProductWeightPerStockUom(json.getDouble("productweightperstockuom"));
        }
        if (json.has("productweightincludingpakagingperstockuom") && json.get("productweightincludingpakagingperstockuom") != null && json.get("productweightincludingpakagingperstockuom") != "") {
            invetory.setProductWeightIncludingPakagingPerStockUom(json.getDouble("productweightincludingpakagingperstockuom"));
        }
        if (json.has("productvolumeperstockuom") && json.get("productvolumeperstockuom") != null && json.get("productvolumeperstockuom") != "") {
            invetory.setProductVolumePerStockUom(json.getDouble("productvolumeperstockuom"));
        }
        if (json.has("productvolumeincludingpakagingperstockuom") && json.get("productvolumeincludingpakagingperstockuom") != null && json.get("productvolumeincludingpakagingperstockuom") != "") {
            invetory.setProductVolumeIncludingPakagingPerStockUom(json.getDouble("productvolumeincludingpakagingperstockuom"));
        }
        Date updateDate = new Date();
        if (json.has("updatedate")) {
            updateDate = json.get("updatedate") != null ? (Date) json.get("updatedate") : updateDate;
        }
        if(json.getBoolean("carryin")){
            invetory.getProduct().setAvailableQuantity(authHandler.roundQuantity(invetory.getProduct().getAvailableQuantity()+json.optDouble("baseuomquantity",0), json.getString("companyid")));
        }else{
            invetory.getProduct().setAvailableQuantity(authHandler.roundQuantity(invetory.getProduct().getAvailableQuantity()-json.optDouble("baseuomquantity",0), json.getString("companyid")));
        }
        invetory.setUpdateDate(updateDate);
        saveOrUpdate(invetory);
        //  }
        return invetory;
    }

    public KwlReturnObject getInventoryEntry(HashMap<String, Object> filterParams) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        String condition = "";
        String query = "from Inventory ";

        if (filterParams.containsKey("newinv")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "newinv=?";
            params.add(filterParams.get("newinv"));
        }
        if (filterParams.containsKey("productid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "product.ID=?";
            params.add(filterParams.get("productid"));
        }
        if (filterParams.containsKey("companyid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "company.companyID=?";
            params.add(filterParams.get("companyid"));
        }
        query += condition;
//        "from Inventory   where product.ID =? and newinv='T' and company.companyID=?"
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject getQuantity(String productid) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            KwlReturnObject jeresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
            Product prod = (Product) jeresult.getEntityList().get(0);
            params.add(Producttype.SERVICE);
            params.add(productid);
            String query = "select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) "
                    + " from Inventory where deleted=false  and product.producttype.ID <> ? and product.ID=? group by product.ID";
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(authHandler.roundQuantity(((Double)itr.next()),prod.getCompany().getCompanyID()));
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    @Override
    public KwlReturnObject getAvailableQuantityInSelectedUOM(String productid, String uomId) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(Producttype.SERVICE);
            params.add(productid);
            params.add(uomId);
            KwlReturnObject jeresult = accountingHandlerDAOobj.getObject(Product.class.getName(), productid);
            Product prod = (Product) jeresult.getEntityList().get(0);
            String query = "select sum((case when carryIn=true then quantity else -quantity end)) from Inventory where deleted=false and invrecord=true and product.producttype.ID <> ? and product.ID=? and uom.ID=? group by product.ID";
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(authHandler.roundQuantity(((Double)itr.next()),prod.getCompany().getCompanyID()));
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getAvailableQuantityInSelectedUOM : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    @Deprecated
    @Override
    public KwlReturnObject getAvailableBaseQuantityExceptInSelectedUOM(String productid, String uomId) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(Producttype.SERVICE);
            params.add(productid);
            params.add(uomId);
            String query = "select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory where deleted=false and invrecord=true and product.producttype.ID <> ? and product.ID=? and uom.ID!=? group by product.ID";
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getAvailableBaseQuantityExceptInSelectedUOM : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    /*----Get reserve Quantity of Product tagged in Quotation----*/
    @Override
    public double getReserveQuantityTaggedInQuotation(String productid, String companyid) throws ServiceException {
        double quantity = 0d;
        try {
            ArrayList params = new ArrayList();
            params.add(productid);
            params.add(companyid);
//            String query = "select sum(quantity) from QuotationDetail qd where qd.product.ID=? and qd.company.companyID=? and qd.quotation.reserveStockQuantityFlag=1";
//            List returnList = executeQuery(query, params.toArray());
            
            String query = "select sum(qd.quantity) from quotationdetails qd inner join quotation q on q.id=qd.quotation where qd.product=? and qd.company=? and q.reservestockquantityflag=1";
            List returnList = executeSQLQuery(query, params.toArray());
            if (returnList.get(0) != null) {
                quantity += (double) returnList.get(0);
            }

        } catch (Exception ex) {
            throw ServiceException.FAILURE("getReserveQuantityTaggedInQuotation : " + ex.getMessage(), ex);
        }
        return authHandler.roundQuantity(quantity, companyid);

    }
    @Override
    public Map<String, Double> getReserveQuantityTaggedInQuotation(String companyid) throws ServiceException {
        Map<String, Double> reserveQuantityTaggedInQuotationMap = new HashMap<String, Double>();
        String query = "select qd.product, sum(qd.quantity) from quotationdetails qd inner join quotation q on q.id=qd.quotation "
                + " where qd.company=? and q.reservestockquantityflag=1 group by qd.product";
        List returnList = executeSQLQuery(query, companyid);
        for(int i=0; i<returnList.size(); i++){
            Object[] obj = (Object[]) returnList.get(i);
            reserveQuantityTaggedInQuotationMap.put((String) obj[0], authHandler.roundQuantity((Double) obj[1],companyid));
        }
        return reserveQuantityTaggedInQuotationMap;
    }
    @Override
    public Map<String, Double> getProductBlockedQuantity(Company company, Store store, Location location, String searchString) throws ServiceException {
        Map productStockDetailMap = new HashMap();
        List params = new ArrayList();
        String storeCondi = "";
        String locaCond = "";
        String searchCond = "";
        if (store != null) {
            storeCondi = "AND nb.warehouse='" + store.getId() + "'";
        }
        if (location != null) {
            locaCond = " AND nb.location='" + location.getId() + "'";
        }
        if (!StringUtil.isNullOrEmpty(searchString)) {
            searchCond = " AND (p.productid LIKE '%" + searchString + "%' OR p.name LIKE '%" + searchString + "%')";
        }
        StringBuilder hql = new StringBuilder(" SELECT tb.product,SUM(tb.lockquantity) FROM (SELECT p.id AS product,SUM(lockquantity) AS lockquantity,nb.warehouse,nb.location FROM newproductbatch nb "
                + " INNER JOIN product p ON nb.product=p.id AND p.isSerialForProduct='F'"
                + " WHERE p.company=? AND nb.warehouse IS NOT NULL AND nb.location IS NOT NULL AND nb.lockquantity>0 " + storeCondi + locaCond + searchCond
                + " GROUP BY nb.warehouse,nb.location,product "
                + " UNION ALL "
                + " SELECT p.id AS product,SUM(nsr.lockquantity) AS lockquantity,nb.warehouse,nb.location FROM newproductbatch nb "
                + " INNER JOIN newbatchserial nsr ON nsr.batch=nb.id AND nsr.product=nb.product"
                + " INNER JOIN product p ON nb.product=p.id AND p.isSerialForProduct='T'"
                + " WHERE p.company=? AND nb.warehouse IS NOT NULL AND nb.location IS NOT NULL AND nsr.lockquantity>0 " + storeCondi + locaCond + searchCond
                + " GROUP BY nb.warehouse,nb.location,product) AS tb GROUP BY tb.product");
        params.add(company.getCompanyID());
        params.add(company.getCompanyID());

        List list = executeSQLQuery(hql.toString(), params.toArray());

        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            Object[] objs = (Object[]) itr.next();
            String productId = objs[0] != null ? (String) objs[0] : null;
            double quantity = objs[1] != null ? (Double) objs[1] : 0;
            productStockDetailMap.put(productId, authHandler.roundQuantity(quantity, company.getCompanyID()));
        }
        return productStockDetailMap;
    }
    /**
     * Method to get block qty of each product id passed in productJson
     * @param jobj
     * @param store
     * @param location
     * @param startDate
     * @param endDate
     * @return
     * @throws ServiceException
     * @throws JSONException 
     */
    @Override
    public JSONObject getProductBlockedQuantitybyWarehouseLocation(JSONObject jobj, Store store, Location location, Date startDate, Date endDate) throws ServiceException, JSONException {
        JSONObject blockQtyJson = new JSONObject();
        String storeCondi = "";
        String locaCond = "";
        String searchCond = "", productid = "", companyid = "", startDatecond = "", endDatecond = "";
        boolean isFinancialReport=false;

        if (jobj.has("companyid")) {
            companyid = jobj.optString("companyid");
        }
        if (jobj.has("isFinancialReport")) {
            isFinancialReport = jobj.optBoolean("isFinancialReport",false);
        }
        if (jobj.has("productid")) {
            productid = jobj.optString("productid");
        }
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        if (!isFinancialReport && startDate != null) {
            startDatecond += " AND so.orderdate>= '" + df.format(startDate) + "' ";
        }
        if (endDate != null) {
            endDatecond += " AND so.orderdate<= '" + df.format(endDate) + "' ";
        }
        if (store != null) {
            storeCondi += "AND nb.warehouse='" + store.getId() + "'";
        }
        if (location != null) {
            locaCond = " AND nb.location='" + location.getId() + "'";
        }
        if (!StringUtil.isNullOrEmpty(productid)) {
            searchCond = " AND (p.id = '" + productid + "')";
        }
        StringBuilder hql = new StringBuilder(" SELECT tb.product,SUM(tb.lockquantity) , MIN(tb.orderdate) FROM (SELECT p.id AS product,nb.lockquantity AS lockquantity,nb.warehouse,nb.location,MIN(so.orderdate) AS orderdate FROM newproductbatch nb "
                + " INNER JOIN product p ON nb.product=p.id AND p.isSerialForProduct='F'"
                + " INNER JOIN sodetails sod ON nb.product = sod.product INNER JOIN salesorder so ON so.id=sod.salesorder "
                + " WHERE p.company= '" + companyid + "' AND nb.warehouse IS NOT NULL AND nb.location IS NOT NULL AND nb.lockquantity>0 " + startDatecond + endDatecond + storeCondi + locaCond + searchCond
                + " GROUP BY nb.warehouse,nb.location,product "
                + " UNION ALL "
                + " SELECT p.id AS product,SUM(nsr.lockquantity) AS lockquantity,nb.warehouse,nb.location,MIN(so.orderdate) AS orderdate FROM newproductbatch nb "
                + " INNER JOIN newbatchserial nsr ON nsr.batch=nb.id AND nsr.product=nb.product"
                + " INNER JOIN product p ON nb.product=p.id AND p.isSerialForProduct='T'"
                + " INNER JOIN sodetails sod ON nb.product = sod.product INNER JOIN salesorder so ON so.id=sod.salesorder "
                + " WHERE p.company= '" + companyid + "' AND nb.warehouse IS NOT NULL AND nb.location IS NOT NULL AND nsr.lockquantity>0 " + startDatecond + endDatecond + storeCondi + locaCond + searchCond
                + " GROUP BY nb.warehouse,nb.location,product) AS tb GROUP BY tb.product");

        List list = executeSQLQuery(hql.toString());

        if (list != null && !list.isEmpty()) {
            Iterator itr = list.iterator();
            while (itr.hasNext()) {
                Object[] objs = (Object[]) itr.next();
                String productId = objs[0] != null ? (String) objs[0] : null;
                double blockqty = objs[1] != null ? (Double) objs[1] : 0;
                Date orderdate = objs[2] != null ? (Date) objs[2] : null;
                blockQtyJson.put("productid", productId);
                blockQtyJson.put("blockqty", blockqty);
                blockQtyJson.put("orderdate", orderdate);
            }
        }
        return blockQtyJson;
    }
    public KwlReturnObject getLeasedQuantity(String productid) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(Producttype.SERVICE);
            params.add(productid);
            String query = "select sum((case when carryIn=true then -baseuomquantity else baseuomquantity end)) from Inventory where deleted=false  and product.producttype.ID <> ? and product.ID=? and leaseFlag=true group by product.ID";
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getConsignedQuantity(String productid) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(Producttype.SERVICE);
            params.add(productid);
            String query = "select sum(consignuomquantity) from Inventory where deleted=false  and product.producttype.ID <> ? and product.ID=? and isconsignment='T' and invrecord='T' group by product.ID";
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getVendorConsignedQuantity(String productid) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(Producttype.SERVICE);
            params.add(productid);
            String query = "select sum(venconsignuomquantity) from Inventory where deleted=false  and product.producttype.ID <> ? and product.ID=? group by product.ID";
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getVendorQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject getLockQuantity(String productid) throws ServiceException { //for selecting a locked quantity of inventory product used in salesorder
        List returnList = new ArrayList();
        try {
            String query = "select sum(lockquantity) from sodetails where product=?";
            List list = executeSQLQuery( query, new Object[]{productid});
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    /**
     * Description : This method is used to get the blocked qunatity of BOM product used in Assembly Product.
     * @param productid : Assembly Product ID, subproduct : BOM Product ID
     * @return KwlReturnObject (with Locked Quantity)
     * @throws ServiceException 
     */
    @Override
    public KwlReturnObject getBOMProductLockQuantity(String productid, String subproduct) throws ServiceException { 
        List returnList = new ArrayList();
        try {
            String query = "SELECT SUM(quantity) FROM lockassemblyquantitymapping WHERE product=? AND subproducts=?";
            List list = executeSQLQuery( query, new Object[]{productid, subproduct});
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accProductImpl : getBOMProductLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    @Override
    public KwlReturnObject getInvoiceQuantity(String productid,String comapnyId) throws ServiceException { //for selecting a locked quantity of inventory product used in salesorder
        List returnList = new ArrayList();
        try {
            int quantityDigit = Constants.QUANTITY_DIGIT_AFTER_DECIMAL;
            if (Constants.CompanyPreferencePrecisionMap.containsKey(comapnyId)) {
                quantityDigit = (Integer) Constants.CompanyPreferencePrecisionMap.get(comapnyId).get(Constants.quantitydecimalforcompany);
            }
            String query = "SELECT SUM(FORMAT(consignuomquantity,"+quantityDigit+")) AS quantity FROM inventory WHERE product=? AND isconsignment='T' AND deleteflag='F' AND company=? ";
            List list = executeSQLQuery( query, new Object[]{productid,comapnyId});
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    @Override
    public KwlReturnObject getDOtoReturnQtyByProductBatch(String documentId,String productid,String comapnyId) throws ServiceException { 
        List returnList = new ArrayList();
        try {
            int quantityDigit = Constants.QUANTITY_DIGIT_AFTER_DECIMAL;
            if (Constants.CompanyPreferencePrecisionMap.containsKey(comapnyId)) {
                quantityDigit = (Integer) Constants.CompanyPreferencePrecisionMap.get(comapnyId).get(Constants.quantitydecimalforcompany);
            }
            String query = " SELECT SUM(FORMAT(nw.quantitydue,"+quantityDigit+")) FROM newproductbatch nw  "
                    + " INNER JOIN locationbatchdocumentmapping lcm ON lcm.batchmapid=nw.id "
                    + " WHERE lcm.documentid=? AND lcm.transactiontype=28 AND lcm.isconsignment='T' AND product=? AND nw.company=?";
            List list = executeSQLQuery( query, new Object[]{documentId,productid,comapnyId});
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject getLockQuantityInSelectedUOM(String productid, String uomId) throws ServiceException { //for selecting a locked quantity of inventory product used in salesorder
        List returnList = new ArrayList();
        try {
            String query = "select sum(lockquantityinselecteduom) from sodetails where product=? and uom=?";
            List list = executeSQLQuery( query, new Object[]{productid, uomId});
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getLockQuantityInSelectedUOM : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject getAssemblyLockQuantity(String productid) throws ServiceException {  //for selecting a locked quantity of assmble product used in salesorder
        List returnList = new ArrayList();
        try {
            String query = "select sum(quantity) from lockassemblyquantitymapping where subproducts=?";
            List list = executeSQLQuery( query, new Object[]{productid});
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject getAssemblyLockQuantityForBuild(String mainProductid, String subProductid) throws ServiceException {    //function for selcting quantity which is used in aseembly  excluding this product 
        List returnList = new ArrayList();
        try {
            String query = "select sum(quantity) from lockassemblyquantitymapping where subproducts=? and product!=?";
            List list = executeSQLQuery( query, new Object[]{subProductid, mainProductid});
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject getInitialQuantity(String productid) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(Producttype.SERVICE);
            params.add(productid);
            String query = "select baseuomquantity from Inventory where deleted=false  and product.producttype.ID <> ? and product.ID=?  and newinv='T' group by product.ID";
            List list = executeQuery( query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getInitialQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject getProValuation(HashMap requestParam) throws ServiceException {
        ArrayList params = new ArrayList();
        List returnList = new ArrayList();
        String condition = "";
        String condition2 = "";
        String productCondition = "";
        String checkForInvNonSaleProduct = "";
        boolean isAssemblySubProduct = false;
        isAssemblySubProduct = requestParam.get("isAssemblySubProduct")!=null ? Boolean.parseBoolean(requestParam.get("isAssemblySubProduct").toString()):false;
//        Calendar endcal = Calendar.getInstance();
        
        String companyid = (String) requestParam.get("companyid");
        Company company = (Company) get(Company.class, companyid);
        String currencyid = company.getCurrency().getCurrencyID();
        Date stDate = (Date) requestParam.get("stDate");
        Date endDate = (Date) requestParam.get("endDate");
        String productId = "",ss="";
        boolean isOpening=false;
        boolean isStockLedgerReport=false;
        boolean isFromStockReport=false;
        boolean isForPeriodTransactions=false;
        boolean isForOpeningTransactions=false;
        if(requestParam.containsKey("productid")){
            productId = (String) requestParam.get("productid");
        }
        if(requestParam.containsKey("ss") && requestParam.get("ss")!=null){
            ss = (String) requestParam.get("ss");
        }
        boolean isprovalReport = (Boolean) requestParam.get("isprovalReport");
        if (requestParam.containsKey("isOpening")) {
            isOpening = (Boolean) requestParam.get("isOpening");
        }
        if (requestParam.containsKey("isStockLedgerReport")) {
            isStockLedgerReport = (Boolean) requestParam.get("isStockLedgerReport");
        }
        if (requestParam.containsKey("isFromStockReport")) {
            isFromStockReport = (Boolean) requestParam.get("isFromStockReport");
        }
        if (requestParam.containsKey("isForPeriodTransactions")) {
            isForPeriodTransactions = Boolean.parseBoolean(requestParam.get("isForPeriodTransactions").toString());
        }
        if (requestParam.containsKey("isForOpeningTransactions")) {
            isForOpeningTransactions = Boolean.parseBoolean(requestParam.get("isForOpeningTransactions").toString());
        }
        if (isOpening) {                                                //isOpening:= For the opening shown in stock ledger if stock avaiable before start date.
            if (stDate != null) {
                params.add(stDate);
                condition += " and updateDate<= ? ";
            }
        } else if (isStockLedgerReport) {                               //isStockLedgerReport:= Final Valuation of product in Stock Ledger Report appply only enddate as opening row is also shown in Stock ledger
            if (endDate != null) {
//                endcal.setTime(endDate);
//            endcal.add(Calendar.DAY_OF_MONTH, -1);
                params.add(endDate);
                condition += " and updateDate<= ? ";
            }
        } else {
                if (stDate != null && !isFromStockReport) { 
                    params.add(stDate);
                    condition += " and updateDate>= ? ";
                }
                if (endDate != null) {
//            endcal.setTime(endDate);
//            endcal.add(Calendar.DAY_OF_MONTH, -1);
                        params.add(endDate);
                        condition += " and updateDate<= ? ";
                    }
                }
        String productCategoryid = "";
        if (requestParam.get(Constants.productCategoryid) != null) {
            productCategoryid = (String) requestParam.get(Constants.productCategoryid);
        }

        params.add(companyid);
        params.add(Producttype.INVENTORY_PART);
        params.add(Producttype.ASSEMBLY);
        if(isAssemblySubProduct){
            checkForInvNonSaleProduct += " or p.producttype.ID=? ";
            params.add(Producttype.Inventory_Non_Sales);
        }
        if (!StringUtil.isNullOrEmpty(productCategoryid)) {
            params.add(productCategoryid);
            condition2 += " and p.ID in (select productID.ID from ProductCategoryMapping where productCategory.ID = ?) ";
        }
        if (!StringUtil.isNullOrEmpty(productId)) {
            params.add(productId);
            productCondition += " and p.ID= ? ";
        }
        String searchQuery = "";
        if (!StringUtil.isNullOrEmpty(ss)) {
            try {
                String[] searchcol = new String[]{"p.productid", "p.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                StringUtil.insertParamSearchString(map);
                searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
            } catch (Exception ex) {

            }
        }
        String query = "";
        if (isprovalReport) {
                query = "select p,"
                    + " (select pl1.price from PriceList pl1 where pl1.affecteduser = '-1' and product.ID=p.ID and carryIn=true " + Constants.PRICELIST_UOM_CONDITION_PURCHASE + " and pl1.currency.currencyID ='" + currencyid + "' and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = '-1' and product.ID=pl1.product.ID and carryIn=pl1.carryIn " + Constants.PRICELIST_UOM_CONDITION_PURCHASE_INNER + " and currency.currencyID ='" + currencyid + "'group by product)),"
                    + " (select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory where deleted=false and product.ID=p.ID" + condition + " group by product.ID) "
                    + " from Product p where p.deleted=false and p.asset=false and p.company.companyID=?" +//p.parent is null and
                    " and (p.producttype.ID=? or p.producttype.ID=? "+ checkForInvNonSaleProduct +")"  + condition2 + searchQuery + //Inventory Part or inventory assembly
                    " order by p.name ";
        } else {
                query = "select p,"
                    + " 0, " +//(select pl1.price from PriceList pl1 where pl1.affecteduser = '-1' and product.ID=p.ID and carryIn=true and applyDate in (select max(applyDate) as ld from PriceList where affecteduser = '-1' and product.ID=pl1.product.ID and carryIn=pl1.carryIn group by product))," +//Purchase Price - Need to calculate only in case of  pro valuation report
                    " (select sum(consignuomquantity)+sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory where deleted=false and product.ID=p.ID" + condition + " group by product.ID) "
                    + " from Product p where p.deleted=false and p.asset=false and p.company.companyID=?" +//p.parent is null and
                    " and (p.producttype.ID=? or p.producttype.ID=? "+ checkForInvNonSaleProduct +" )" +productCondition+//Inventory Part or inventory assembly
                    " order by p.name ";
            }
        
        returnList = executeQuery( query, params.toArray());
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    
    public KwlReturnObject getStockInOutOpeningCalculation(HashMap requestParam) throws ServiceException {
        ArrayList params = new ArrayList();
        List returnList = new ArrayList();
        String query= "",productId = "", companyid="" ;
        Date stDate = null;
        Date endDate = null;
        boolean isFromStockReport = false;
        if(requestParam.containsKey("stDate")){
            stDate = (Date) requestParam.get("stDate");
        }
        if(requestParam.containsKey("endDate")){
            endDate = (Date) requestParam.get("endDate");
        }
        if(requestParam.containsKey("isFromStockReport")){
            isFromStockReport = (boolean) requestParam.get("isFromStockReport");
        }
        if(requestParam.containsKey("productid")){
            productId = (String) requestParam.get("productid");
        }
        if(requestParam.containsKey("companyid")){
            companyid = (String) requestParam.get("companyid");
        }
        if (isFromStockReport) {
            params.add(productId);
            params.add(companyid);
            params.add(AccountingManager.setFilterTime(stDate, true));
            params.add(AccountingManager.setFilterTime(endDate, true));
            params.add(productId);
            params.add(companyid);
            params.add(AccountingManager.setFilterTime(stDate, true));
            params.add(AccountingManager.setFilterTime(endDate, true));
            params.add(productId);
            params.add(companyid);
            params.add(AccountingManager.setFilterTime(stDate, true));
            params.add(productId);
            params.add(companyid);
            query = "select "
                    + " (select sum((case when carryIn=true   then baseuomquantity else 0.0 end)) from Inventory where deleted=false and product.ID=? and company.companyID = ? and updateDate >= ? and updateDate <= ? group by product.ID) , "//Stock IN
                    + " (select sum((case when carryIn=false  then baseuomquantity else 0.0 end)) from Inventory where deleted=false and product.ID=? and company.companyID = ? and updateDate >= ? and updateDate <= ? group by product.ID) , "//Stock Out
                    + " (select sum((case when carryIn=true   then baseuomquantity else -baseuomquantity end)) from Inventory where deleted=false and product.ID=? and company.companyID = ? and updateDate < ? group by product.ID)" //Opening Qty                   
                    + "from Inventory where product.ID = ? and deleted=false and company.companyID = ? order by product.ID";
        }
        returnList = executeQuery( query, params.toArray());
        int count = returnList.size();
       return new KwlReturnObject(true, "", null, returnList, count); 
    }
    public KwlReturnObject getAvailableQuantityForSerial(HashMap requestParam) throws ServiceException {
        List returnList = new ArrayList();

        String productid = "", companyid="";
        if(requestParam.containsKey("productid")) {
            productid = (String) requestParam.get("productid");
        }
        if(requestParam.containsKey("companyid")) {
            companyid = (String) requestParam.get("companyid");
        }
        ArrayList params = new ArrayList();
        params.add(0);
        String condition="";
        if(!StringUtil.isNullOrEmpty(productid)) { 
            params.add(productid);
            condition += "  and inventory.product= ? ";
        }
        if(!StringUtil.isNullOrEmpty(companyid)) { 
            params.add(companyid);
            condition += "  and inventory.company= ? ";
        }
        
        Date startcal=(Date)requestParam.get("startcal");
        Date endcal=(Date)requestParam.get("endcal");
//        DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        boolean excluseDateFilters=false;
        boolean isOpening = false;
        boolean isStockLedgerReport = false;
        boolean isAssemblySubProduct=false;
        if(requestParam.containsKey("excluseDateFilters") && !StringUtil.isNullOrEmpty(requestParam.get("excluseDateFilters").toString())){
            excluseDateFilters=Boolean.parseBoolean(requestParam.get("excluseDateFilters").toString());
        } 
        if (requestParam.containsKey("isOpening")) {
            isOpening = (Boolean) requestParam.get("isOpening");
        }
        if (requestParam.containsKey("isStockLedgerReport")) {
            isStockLedgerReport = (Boolean) requestParam.get("isStockLedgerReport");
        }
        if (requestParam.containsKey("isAssemblySubProduct")) {
            isAssemblySubProduct = (Boolean) requestParam.get("isAssemblySubProduct");
        }
        String sDate = "";
        String eDate = "";
        if (!excluseDateFilters) {
            if (isOpening) {
                if (startcal != null) {
//                    eDate = sdf.format(startcal);
                    params.add(startcal);
                    condition += " and updateDate<= ? ";
                }
            } else if (isStockLedgerReport) {
                if (endcal != null) {
                    condition += " and updateDate<= ? ";
                    params.add(endcal);
                }
            } else {
                if (!isAssemblySubProduct) {
                    if (startcal != null) {
//                    sDate = sdf.format(startcal);
                        params.add(startcal);
                        condition += "  and inventory.updateDate>= ? ";
                    }
                    if (endcal != null) {
//                    eDate = sdf.format(endcal);
                        params.add(endcal);
                        condition += "  and inventory.updateDate<= ? ";
                    }
                }
            }
        }
        
        String condition1="";
        params.add(0);
        if(!StringUtil.isNullOrEmpty(productid)) { 
            params.add(productid);
            condition1 += "  and newbatchserial.product= ? ";
        }
        if(!StringUtil.isNullOrEmpty(companyid)) { 
            params.add(companyid);
            condition1 += "  and newbatchserial.company= ? ";
        }
//        params.add(productid);
        
        
        if (!excluseDateFilters) {
            if (isOpening) {
                if (startcal != null) {
//                    eDate = sdf.format(startcal);
                    params.add(startcal);
                    condition1 += " and updateDate<= ? ";
                }
            } else if (isStockLedgerReport) {
                if (endcal != null) {
                    condition1 += " and updateDate<= ? ";
                    params.add(endcal);
                }
            } else {
                if (!isAssemblySubProduct) {
                    if (startcal != null) {
//                    sDate = sdf.format(startcal);
                        params.add(startcal);
                        condition1 += "  and inventory.updateDate>= ? ";
                    }
                    if (endcal != null) {
//                    eDate = sdf.format(endcal);
                        params.add(endcal);
                        condition1 += "  and inventory.updateDate<= ? ";
                    }
                }
            }
        }
        String query = "select newbatchserial.id as nbsid,newbatchserial.isopening,documentid,serialdocumentmapping.id as mappingid, inventory.product, grodetails.id as grodid, grodetails.rate, grorder.id as groid,grorder.grorderdate as transactiondate from newbatchserial "
                + " inner join serialdocumentmapping on newbatchserial.id=serialdocumentmapping.serialid "
                + " left join inventory on serialdocumentmapping.documentid=inventory.id "
                + " left join grodetails on grodetails.id = serialdocumentmapping.documentid inner join grorder on grorder.id = grodetails.grorder "
                + " where quantitydue > ? and newbatchserial.isopening='F' and serialdocumentmapping.transactiontype=28 and inventory.newinv='F' and inventory.deleteflag = 'F' and inventory.carryin ='T'"+condition
                
                + " UNION"
                
                + " select newbatchserial.id as nbsid,newbatchserial.isopening,serialdocumentmapping.documentid,serialdocumentmapping.id "
                + " as mappingid,newbatchserial.product, grodetails.id as grodid, grodetails.rate, grorder.id as groid,inventory.updatedate as transactiondate from newbatchserial INNER JOIN serialdocumentmapping on newbatchserial.id=serialdocumentmapping.serialid"
                + " INNER JOIN inventory on inventory.product=newbatchserial.product "
                + " left join grodetails on grodetails.id = serialdocumentmapping.documentid left join grorder on grorder.id = grodetails.grorder "
                + " where quantitydue > ? and newbatchserial.isopening='T' and inventory.newinv='T' and inventory.deleteflag = 'F' "+condition1;
        returnList = executeSQLQuery( query, params.toArray());
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    public KwlReturnObject getAvailableQuantityForBatch(HashMap requestParam) throws ServiceException {
        List returnList = new ArrayList();

        String productid = "", companyid="";
        if(requestParam.containsKey("productid")) {
            productid = (String) requestParam.get("productid");
        }
        if(requestParam.containsKey("companyid")) {
            companyid = (String) requestParam.get("companyid");
        }
        ArrayList params = new ArrayList();
        params.add(0);
        String condition="";
        if(!StringUtil.isNullOrEmpty(productid)) { 
            params.add(productid);
            condition += "  and inventory.product= ? ";
        }
        if(!StringUtil.isNullOrEmpty(companyid)) { 
            params.add(companyid);
            condition += "  and inventory.company= ? ";
        }
        
        Date startcal=(Date)requestParam.get("startcal");
        Date endcal=(Date)requestParam.get("endcal");
//        DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        boolean excluseDateFilters=false;
        boolean isOpening = false;
        boolean isStockLedgerReport = false;
        if(requestParam.containsKey("excluseDateFilters") && !StringUtil.isNullOrEmpty(requestParam.get("excluseDateFilters").toString())){
            excluseDateFilters=Boolean.parseBoolean(requestParam.get("excluseDateFilters").toString());
        } 
        if (requestParam.containsKey("isOpening")) {
            isOpening = (Boolean) requestParam.get("isOpening");
        }
        if (requestParam.containsKey("isStockLedgerReport")) {
            isStockLedgerReport = (Boolean) requestParam.get("isStockLedgerReport");
        }
        String sDate = "";
        String eDate = "";
        if (!excluseDateFilters) {
            if (isOpening) {
                if (startcal != null) {
//                    eDate = sdf.format(startcal);
                    params.add(startcal);
                    condition += " and updateDate<= ? ";
                }
            } else if (isStockLedgerReport) {
                if (endcal != null) {
                    condition += " and updateDate<= ? ";
                    params.add(endcal);
                }
            } else {
                if (startcal != null) {
//                    sDate = sdf.format(startcal);
                    params.add(startcal);
                    condition += "  and inventory.updateDate>= ? ";
                }
                if (endcal != null) {
//                    eDate = sdf.format(endcal);
                    params.add(endcal);
                    condition += "  and inventory.updateDate<= ? ";
                }
            }
        }
        
        String condition1="";
        params.add(0);
        if(!StringUtil.isNullOrEmpty(productid)) { 
            params.add(productid);
            condition1 += "  and newproductbatch.product= ? ";
        }
        if(!StringUtil.isNullOrEmpty(companyid)) { 
            params.add(companyid);
            condition1 += "  and newproductbatch.company= ? ";
        }
//        params.add(productid);
        
        
        if (!excluseDateFilters) {
            if (isOpening) {
                if (startcal != null) {
//                    eDate = sdf.format(startcal);
                    params.add(startcal);
                    condition1 += " and updateDate<= ? ";
                }
            } else if (isStockLedgerReport) {
                if (endcal != null) {
                    condition1 += " and updateDate<= ? ";
                    params.add(endcal);
                }
            } else {
                if (startcal != null) {
//                    sDate = sdf.format(startcal);
                    params.add(startcal);
                    condition1 += "  and inventory.updateDate>= ? ";
                }
                if (endcal != null) {
//                    eDate = sdf.format(endcal);
                    params.add(endcal);
                    condition1 += "  and inventory.updateDate<= ? ";
                }
            }
        }
        String query = "select newproductbatch.id as npbid,newproductbatch.isopening,documentid,locationbatchdocumentmapping.id as mappingid, inventory.product, grodetails.id as grodid, grodetails.rate, grorder.id as groid,newproductbatch.quantitydue from newproductbatch "
                + " inner join locationbatchdocumentmapping on newproductbatch.id=locationbatchdocumentmapping.batchmapid "
                + " left join inventory on locationbatchdocumentmapping.documentid=inventory.id "
                + " left join grodetails on grodetails.id = locationbatchdocumentmapping.documentid inner join grorder on grorder.id = grodetails.grorder "
                + " where quantitydue > ? and newproductbatch.isopening='F' and locationbatchdocumentmapping.transactiontype=28 and inventory.newinv='F' and inventory.deleteflag = 'F' and inventory.carryin ='T'"+condition
                
                + " UNION"
                
                + " select newproductbatch.id as npbid,newproductbatch.isopening,locationbatchdocumentmapping.documentid,locationbatchdocumentmapping.id "
                + " as mappingid,newproductbatch.product, grodetails.id as grodid, grodetails.rate, grorder.id as groid,newproductbatch.quantitydue from newproductbatch INNER JOIN locationbatchdocumentmapping on newproductbatch.id=locationbatchdocumentmapping.batchmapid"
                + " INNER JOIN inventory on inventory.product=newproductbatch.product "
                + " left join grodetails on grodetails.id = locationbatchdocumentmapping.documentid left join grorder on grorder.id = grodetails.grorder "
                + " where quantitydue > ? and newproductbatch.isopening='T' and locationbatchdocumentmapping.transactiontype=28 and inventory.newinv='T' and inventory.deleteflag = 'F' "+condition1;
        returnList = executeSQLQuery( query, params.toArray());
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    public KwlReturnObject getAvailableStockForSerial(HashMap requestParam) throws ServiceException {
        List returnList = new ArrayList();
        String productid = (String) requestParam.get("productid");
        String companyId = (String) requestParam.get("companyid");
        ArrayList params = new ArrayList();
        params.add(productid);
        params.add(companyId);
        String query = "select id,serialnames,batchname,store from in_stock where product=? and company=? and (serialnames!='') and quantity > 0  order by createdon desc";
        returnList = executeSQLQuery( query, params.toArray());
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    
    public KwlReturnObject getAvailablequantityBatches(HashMap requestParam) throws ServiceException {
        List returnList = new ArrayList();
        String attachQuery = "";
        String gronlyBatchQuery = "";
        String pronlyBatchQuery = "";
        String companyId = (String) requestParam.get("companyid");
        ArrayList params = new ArrayList();
        params.add(companyId);
        params.add((String) requestParam.get("locationid"));
        String location = "";
        String batchname = (String) requestParam.get("batchname");
        String conditionSQL = "";
        if (!StringUtil.isNullOrEmpty(batchname)) {
            conditionSQL += " and st.batchname like '%" + batchname + "%'  ";
        }
        int type = (Integer) requestParam.get("type");
        switch (type) {
            case 1:
                location = " inner join inventorywarehouse invloc on invloc.id =st.store";
                break;
            case 2:
                location = " inner join inventorylocation invloc on invloc.id =st.location";
                break;
            case 3:
                location = " inner join storemaster invloc on invloc.id =st.row";
                break;
            case 4:
                location = " inner join storemaster invloc on invloc.id =st.rack";
                break;
            case 5:
                location = " inner join storemaster invloc on invloc.id =st.bin";
                break;
        }
        String query = "select st.id,st.batchname,st.location,st.store,st.product from in_stock st " + location + " where st.company=? and (batchname!='' && batchname is not NULL) and st.quantity > 0 and invloc.id = ? " + conditionSQL + " order by createdon desc";
        returnList = executeSQLQuery( query, params.toArray());
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }

    public KwlReturnObject getquantityAndRateOfProductForInventory(HashMap requestParam) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        String companyId = (String) requestParam.get("companyid");
        params.add(companyId);
        params.add((String) requestParam.get("locationid"));
        String location = "";
        String batchnames = (String) requestParam.get("batchnames");
        int type = (Integer) requestParam.get("type");
        switch (type) {
            case 1:
                location = " and in_stockmovement.store=? and in_sm_detail.location= ?";
                params.add((String) requestParam.get("location"));
                break;
            case 2:
                location = " and in_sm_detail.location=? and in_stockmovement.store= ?";
                params.add((String) requestParam.get("store"));
                break;
            case 3:
                location = "  and in_sm_detail.row=? and in_sm_detail.location=? and in_stockmovement.store= ?";
                params.add((String) requestParam.get("location"));
                params.add((String) requestParam.get("store"));
                break;
            case 4:
                location = " and in_sm_detail.rack=? and in_sm_detail.location=? and in_stockmovement.store= ?";
                params.add((String) requestParam.get("location"));
                params.add((String) requestParam.get("store"));
                break;
            case 5:
                location = " and in_sm_detail.bin=? and in_sm_detail.location=? and in_stockmovement.store= ?";
                params.add((String) requestParam.get("location"));
                params.add((String) requestParam.get("store"));
                break;
        }
        String query = "select in_stockmovement.priceperunit ,'" + batchnames + "' as batch, in_stockmovement.store, in_sm_detail.location,in_sm_detail.row,in_sm_detail.rack,in_sm_detail.bin, in_stockmovement.product "
                + " from in_stockmovement INNER JOIN in_sm_detail on in_sm_detail.stockmovement=in_stockmovement.id "
                + " where in_stockmovement.company=? and in_sm_detail.batchname like '%" + batchnames + "%' " + location + " and in_stockmovement.transaction_module IN (0,1,2,3,4,11) "
                + " and in_stockmovement.transaction_type=1 order by in_stockmovement.createdon desc";
        returnList = executeSQLQuery( query, params.toArray());
        List l1 = new ArrayList();
        if (returnList.size() > 0) {
            l1.add(returnList.get(0));
        }
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, l1, count);
    }

    public KwlReturnObject getERPProductBatch(String companyId, String product, String store, String location, String row, String rack, String bin, String batchName, double perUnitPrice) throws ServiceException {
        if (StringUtil.isNullOrEmpty(batchName)) {
            batchName = "";
        }
        String query = "";
        String condition = "";
        List params = new ArrayList();
        params.add(companyId);
        params.add(product);
        params.add(store);
        params.add(location);
        params.add(batchName);

        if (row != null) {
            condition += " AND pb.row = ? ";
            params.add(row);
        } else {
            condition += " AND pb.row IS NULL ";
        }
        if (rack != null) {
            condition += " AND pb.rack = ? ";
            params.add(rack);
        } else {
            condition += " AND pb.rack IS NULL ";
        }
        if (bin != null) {
            condition += " AND pb.bin = ? ";
            params.add(bin);
        } else {
            condition += " AND pb.bin IS NULL ";
        }
     query = "select " + perUnitPrice + " as rate , pb.quantity , '' as currency , '' as grorderdate ,'' as groid,mi.value, p.productid, pb.batchname as batchname,pb.quantity,"
                + " 'false' as isOpeningTransaction, pb.id,p.id as proid,1 from newproductbatch pb"
                + " inner join product p on p.id=pb.product"
                + " left join productcategorymapping pm on p.id=pm.productid"
                + " left join masteritem mi on mi.id = pm.productcategory"
                + " where pb.company=? AND pb.product = ? AND pb.warehouse=? AND pb.location = ? AND pb.batchname = ?"+condition;
        List returnList = executeSQLQuery( query, params.toArray());
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    
    public double getSerialNoStockValuation(String product, String companyId, String serialNames, String batchnames,String store) throws ServiceException {
        List returnList = new ArrayList();
        double valuation = 0;
        ArrayList params = new ArrayList();
        params.add(product);
        params.add(companyId);
        if (!StringUtil.isNullOrEmpty(serialNames)) {                                                                                                       //We are writing this function we are not able to fetch all the exact available serials because
            String[] serialNamesArr = serialNames.split(",");                                                                                               //on inventory side table we save the serial,batches in comma seprated format
            String[] batchnamesArr = batchnames.split(",");                                                                                                 //so need to execute this query in loop.
            int count = 0;
                for (String btch : batchnamesArr) {                                                                                                                                     
                    for (String st : serialNamesArr) {
                        String query = "select in_stockmovement.priceperunit from in_stockmovement "
                                + " INNER JOIN "
                                + " in_sm_detail ON in_stockmovement.id=in_sm_detail.stockmovement where in_stockmovement.product=? "
                                + " and in_stockmovement.company=? and in_stockmovement.transaction_module=3 and in_stockmovement.transaction_type=1  "
                                + " and in_sm_detail.serialnames like '%" + st + "%' and in_sm_detail.batchname like '%" + btch + "%' and store= '" +store + "' order by createdon desc";
                        returnList = executeSQLQuery( query, params.toArray());
                        if (returnList != null && returnList.size() > 0) {
                            valuation += (double) returnList.get(0);
                        }
                    }
                }
        }
        return valuation;
    }
    public KwlReturnObject getQuantityPurchaseOrSales(String productid, boolean isPurchase) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(isPurchase);
            params.add(productid);
            String query = "select sum((case when carryIn=? then baseuomquantity else  0 end)) from Inventory where product.ID= ? group by product.ID";
            returnList = executeQuery( query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getPurchaseOrSalesQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject getQuantityPurchaseOrSalesDetails(String productid, boolean isPurchase,boolean isSalesByItem) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add(productid);
            params.add(isPurchase);
            String conditionsql="";
            if(!isSalesByItem){
                conditionsql=" and invrecord=true";
            }
            String query = "from Inventory where product.ID= ? and carryIn=? and deleted = false"+conditionsql;
            returnList = executeQuery( query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getPurchaseOrSalesQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    /**
     * Used for Sales By Item Summary and Detail Report
     * @param productid
     * @param stDate
     * @param endDate
     * @param isPurchase - True  if Inventory In and False if Inventory out
     * @param isSalesByItem - True if from Sales by Item Report
     * @return
     * @throws ServiceException 
     */
   
    public KwlReturnObject getQuantityPurchaseOrSalesDetailsByItem(String productid, Date stDate, Date endDate,boolean isPurchase, boolean isSalesByItem ) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
           
            params.add(isPurchase);
            String conditionsql="";
            
            if(!isSalesByItem){
                conditionsql=" and invrecord=true";
            }
            if (stDate != null) {
                params.add(stDate);
                conditionsql += "  and updateDate>= ?";
            }
            if (endDate != null) {
                params.add(endDate);
                conditionsql += "  and updateDate<= ?";
            }
            if (!StringUtil.isNullOrEmpty(productid)) {
                params.add(productid);
                conditionsql += "  and product.ID= ? ";
            }else{
                conditionsql += "  and product is not Null ";
            }
             
            String query = "from Inventory where carryIn=? and deleted = false"+conditionsql;
            returnList = executeQuery( query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getPurchaseOrSalesQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getQuantityPurchaseDetails(String productid, boolean isPurchase,Date stDate, Date endDate,boolean isAssemblySubProduct) throws ServiceException {
        List returnList = new ArrayList();
        String condition="";
        try {
            ArrayList params = new ArrayList();
            params.add(productid);
            params.add(isPurchase);
            params.add(productid);
           if(!isAssemblySubProduct){
//            if (stDate != null) {
//                params.add(stDate);
//                condition += "  and updateDate>= ?";
//            }
            if (endDate != null) {
                params.add(endDate);
                condition += "  and updateDate<= ?";
            }
           }
            String query = "from Inventory where product.ID= ? and carryIn=? and deleted = false and invrecord=true and ID not in (select ID from SalesReturnDetail where product.ID= ?)"+condition;
            returnList = executeQuery( query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getPurchaseOrSalesQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject getInitialCost(String productid) throws ServiceException {
        Product product = (Product) get(Product.class, productid);
        String currencyid = product.getCompany().getCurrency().getCurrencyID();
        String stockUOMId="";
        UnitOfMeasure unitOfMeasure = product.getUnitOfMeasure();
        if (unitOfMeasure != null) {
            stockUOMId = unitOfMeasure.getID();
        }
        String query = "select price from PriceList where affecteduser = '-1' and carryin = 'T' and product.ID = ? and uomid.ID = ? and  currency.currencyID ='" + currencyid + "' and "
                + " applyDate = (select min(applyDate) as ld from PriceList  where affecteduser = '-1' and product.ID=? and carryIn='T'  and uomid.ID = ? and  currency.currencyID ='" + currencyid + "' ) ";

        List returnList = executeQuery(query, new Object[]{productid, stockUOMId, productid, stockUOMId});

        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject getAvgcostAssemblyProduct(String productid, Date stDate, Date endDate) throws ServiceException {
        double avgCost = 0;
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        params.add(productid);
        String condition = "";
        Product product = (Product) get(Product.class, productid);
        String currencyid = product.getCompany().getCurrency().getCurrencyID();
        if (stDate != null) {
            params.add(stDate);
            condition += "  and pb.entryDate>= ?";
        }
        if (endDate != null) {
            params.add(endDate);
            condition += "  and pb.entryDate<= ?";
        }

        String query = "select distinct pb.ID as buildid ,pb,pb.product.ID as productid,pb.quantity as quantity,pb.entryDate as entrydate,pb.productcost as cost from ProductBuild pb where pb.product.ID=? "+condition;

        List resultList = executeQuery( query, params.toArray());
        Iterator itr = resultList.iterator();
        double totalCost = 0;
        double totalQuantity = 0;
        while (itr.hasNext()) {
            Object[] row = (Object[]) itr.next();
            ProductBuild productBuild = (ProductBuild) row[1];
            double qua = productBuild.getQuantity();
            double amount = productBuild.getProductcost();;
            totalQuantity += qua;
            totalCost += (amount);
        }
        
       //Following code is used for the calculate the Opening product valuation
        returnList = new ArrayList();
        params = new ArrayList();
        params.add(productid);
        condition = "";

        if (stDate != null) {
            params.add(stDate);
            condition += "  and inv.updateDate>= ?";
        }
        if (endDate != null) {
            params.add(endDate);
            condition += "  and inv.updateDate<= ?";
        }
        query = "select inv, "
                + " (select pl1.price from PriceList pl1 where pl1.affecteduser = '-1' and product.ID=inv.product.ID and carryIn=true and pl1.uomid.ID = inv.product.unitOfMeasure.ID and pl1.currency.currencyID ='" + currencyid + "' and applyDate = (select max(applyDate) as ld from PriceList where affecteduser = '-1' and  product.ID=inv.product.ID and carryIn=true and uomid.ID = inv.product.unitOfMeasure.ID and date(applyDate)<=date(inv.updateDate) and  currency.currencyID ='" + currencyid + "' group by product))"
                + "from Inventory inv "
                + " where inv.deleted=false and inv.newInv=true and product.ID=? and carryIn = true " + condition + " group by product.ID";

        resultList = executeQuery( query, params.toArray());
        itr = resultList.iterator();
        while (itr.hasNext()) {
            Object[] row = (Object[]) itr.next();
            Inventory invObj = (Inventory) row[0];
            double qua = invObj.getBaseuomquantity();
            double amount = (row[1] == null ? 0.0 : (Double) row[1]);
            totalQuantity += qua;
            totalCost += (qua * amount);
        }
        
        
            if (totalQuantity != 0) {
                avgCost = (totalCost / totalQuantity);
            }

            returnList.add(avgCost);

            return new KwlReturnObject(true, "", null, returnList, returnList.size());
        }

    public KwlReturnObject getInventoryOpeningBalanceDate(String companyid) throws ServiceException {
        String query = "select min(updateDate) from Inventory where product.company.companyID = ?";
        List returnList = executeQuery( query, companyid);

        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public boolean isChild(String ParentID, String childID) throws ServiceException {
        String query = "select id from product where parent=? and id=?";
        List list = executeSQLQuery( query, new Object[]{ParentID, childID});
        return !list.isEmpty();
    }

    public KwlReturnObject getProductList(Map<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int count = 0;
        try {
            String companyId = (String) requestParams.get("companyid");
            String start = (String) requestParams.get("start");
            String limit = (String) requestParams.get("limit");
            String ss = (String) requestParams.get("ss");
            String condition = "";
            ArrayList params = new ArrayList();
            params.add(companyId);
            
            if (requestParams.containsKey("productTypeID") && requestParams.get("productTypeID") != null && requestParams.get("productTypeID") != "") {
                condition += " and p.producttype.ID = ? ";
                params.add((String) requestParams.get("productTypeID"));
            }
            
                if (!StringUtil.isNullOrEmpty(ss)) {
                condition += StringUtil.getSearchString(ss, "and", new String[]{"p.name"});
                params.add(ss);
                params.add("%" + ss + "%");
                    }
            String query = "select p from Product p where  p.deleted=false and p.asset=false and p.company.companyID=? " + condition;
            returnList = executeQuery( query, params.toArray());
            count = returnList.size();
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                returnList = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSalesByItem : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    
    public Integer getSyncableProductsCount(Map<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int count = 0;
        try {
            String companyId = (String) requestParams.get("companyid");
           
            ArrayList params = new ArrayList();
            params.add(companyId);
           
            String query = "select count(p.ID) from Product p where p.company.companyID=? "; //p.syncable=true and p.deleted=false and p.asset=false and
          
            returnList = executeQuery(query, params.toArray());        
            count = Integer.parseInt(returnList.get(0).toString());

        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSyncableProductsCount : " + ex.getMessage(), ex);
        }
        return count;
    }
    
    @Override
    public List getSyncableProductList(Map<String, Object> requestParams) throws ServiceException {
        List<Product> returnList = new ArrayList();
        int count = 0;
        try {
            String companyId = (String) requestParams.get("companyid");
            String condition = "";
            ArrayList params = new ArrayList();
            params.add(companyId);
            String ids[] = null;
            if(requestParams.get("ids") != null){
                ids = (String[]) requestParams.get("ids");
            }
            
            
            
            boolean isAllSync = false;
            if(requestParams.containsKey("isAllSync") && !StringUtil.isNullOrEmpty(requestParams.get("isAllSync").toString())){
                isAllSync = Boolean.parseBoolean(requestParams.get("isAllSync").toString());
            }
            
            int start = 0;
            int limit = 0;

            if (requestParams.containsKey("start") && requestParams.containsKey("limit") && !StringUtil.isNullOrEmpty(requestParams.get("start").toString())) {
                start = Integer.parseInt(requestParams.get("start").toString());
                limit = Integer.parseInt(requestParams.get("limit").toString());
                
            }
            
            if (ids != null && !isAllSync) {
                if(start != 0){
                    start = start -1;
                }
                limit = limit + start;
                condition += " and p.ID in(? ";
                params.add(""); //Coundition was null initially, beacuse of null query was not giving result.
                for (int i = start; i < limit; i++) {
                    if (!StringUtil.isNullOrEmpty(ids[i])) {
                        condition += " ,?";
                        params.add(ids[i]);
                    }
                }
                condition += " )";
            }

            
            String query = "select p from Product p where p.syncable=true and p.deleted=false and p.asset=false and p.company.companyID=? " + condition
                    + " order by p.productid";
            
            String syncAllQuery = "select p from Product p where p.syncable=true and p.deleted=false and p.asset=false and p.company.companyID=? "
                    + " order by p.productid";
            
            if (!isAllSync) {
                returnList = executeQuery( query, params.toArray());
            }else{
               returnList = executeQueryPaging(syncAllQuery, params.toArray(), new Integer[]{start, limit});
            }            
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSyncableProductList: " + ex.getMessage(), ex);
        }
        return returnList;
    }
    
    
    

    public MasterItem getProductsMasterItem(String companyid, String productid) {
        MasterItem masterItem = null;
        try {
            HashMap<String, Object> requestParams = new HashMap<String, Object>();
            requestParams.put("companyid", companyid);
            requestParams.put("productid", productid);
            KwlReturnObject result = getNewProductList(requestParams);
            if (result.getEntityList().size() > 0) {
                Iterator itr1 = result.getEntityList().iterator();
                while (itr1.hasNext()) {
                    Object[] row1 = (Object[]) itr1.next();
                    String CategoryId = row1[1] != null ? row1[1].toString() : "";
                    if (!StringUtil.isNullOrEmpty(CategoryId)) {
                        KwlReturnObject catresult = getObject(MasterItem.class.getName(), CategoryId);
                        masterItem = (MasterItem) catresult.getEntityList().get(0);
                    }
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(accProductController.class.getName()).log(Level.SEVERE, null, ex);
        }
        return masterItem;
    }

    @Override
    public KwlReturnObject getNewProductList(Map<String, Object> requestParams) throws ServiceException {
        List listSql = null;
        int totalCount = 0;
        try {
            boolean isConsolidationStockReport=false;
            boolean executeCountQuery = false;
            if (requestParams.containsKey("executeCountQuery")) {
                executeCountQuery = (boolean) requestParams.get("executeCountQuery");
                totalCount = (int) requestParams.get("totalPrdRecordCount");
            }
            ArrayList params = new ArrayList();
            String start = "";
            if (requestParams.containsKey(Constants.start)) {
                start = (String) requestParams.get(Constants.start);
            }
            String limit = "";
            if (requestParams.containsKey(Constants.limit)) {
                limit = (String) requestParams.get(Constants.limit);
            }
            String conditionSQL = "";
            
            if(requestParams.containsKey("isConsolidationStockReport") && requestParams.get("isConsolidationStockReport")!=null){
                isConsolidationStockReport=Boolean.parseBoolean(requestParams.get("isConsolidationStockReport").toString());
            }
            String productid = "";
            if (requestParams.containsKey("productid")) {
                productid = (String) requestParams.get("productid");
            }
            if (requestParams.containsKey("companyids") && requestParams.get("companyids") != null ) {// multiple companyids come when call came from getConsolidationStockReport
                String companyids = AccountingManager.getFilterInString(requestParams.get("companyids").toString());
                conditionSQL += " and p.company in" + companyids + " ";
            } else if (requestParams.containsKey("companyid") && requestParams.get("companyid") != null) {
                conditionSQL += " and p.company=? ";
                params.add((String) requestParams.get("companyid"));
            }
            
            if(requestParams.containsKey("categoryids") && requestParams.get("categoryids")!=null && !requestParams.get("categoryids").toString().equalsIgnoreCase("All")){// multiple categoryids come when call came from getConsolidationStockReport
                String categoryids = (String) requestParams.get("categoryids");
                if (!StringUtil.isNullOrEmpty(categoryids) && !categoryids.equalsIgnoreCase("All")) {
                    categoryids = AccountingManager.getFilterInString(categoryids);
                    conditionSQL += " and pm.productcategory in" + categoryids + " ";
                }
            } else if(requestParams.containsKey("categoryid") && requestParams.get("categoryid")!=null && !requestParams.get("categoryid").toString().equalsIgnoreCase("All")){// In all case does not require applying check
                String categoryid = (String) requestParams.get("categoryid");
                if (!StringUtil.isNullOrEmpty(categoryid) && !categoryid.equalsIgnoreCase("All")) {
                    params.add(categoryid);
                    conditionSQL += " and  pm.productcategory = ? ";
                }
            }
            if(requestParams.containsKey("producttypeids") && requestParams.get("producttypeids")!=null ){
                String producttypeids = (String) requestParams.get("producttypeids");
                if (!StringUtil.isNullOrEmpty(producttypeids)) {
                    producttypeids = AccountingManager.getFilterInString(producttypeids);
                    conditionSQL += " and p.producttype in" + producttypeids + " ";
                }
            }
            if (!StringUtil.isNullOrEmpty(productid)) {
                params.add(productid);
                conditionSQL += " and  pm.productid = ? ";
            }
            
            if (requestParams.containsKey("ss") && requestParams.get("ss") != null) {
                String ss = requestParams.get("ss").toString().toUpperCase();
                if (!StringUtil.isNullOrEmpty(ss)) {
                    String[] searchcol = new String[]{"p.name", "p.productid"};
                    try {
                        Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                        StringUtil.insertParamSearchString(map);
                    } catch (SQLException ex) {
                        Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                    conditionSQL += searchQuery;
                }
            }
            
            String orderBy = "";
            if (requestParams.containsKey("dir") && requestParams.containsKey("sort")) {
                String Col_Name = requestParams.get("sort").toString();
                String Col_Dir = requestParams.get("dir").toString();
                orderBy = sortColumnProduct(Col_Name, Col_Dir);
            } else {
                orderBy = " order by pm.productcategory desc";
            }
            /**
             * If Users visibility enable and current user is not admin
             */
            String customdatajoin = "";
            String usercondition = "";
            if (requestParams.containsKey("isUserVisibilityFlow") && requestParams.get("isUserVisibilityFlow") != null) {
                usercondition = (String) requestParams.get("appendusercondtion");
                customdatajoin = " inner join accproductcustomdata pcd on p.id=pcd.productId ";
            }
            
            String query="";
            String selectQuery="";
            if(isConsolidationStockReport){// in consolidation report need distinct products, So here is check 
                query = " select GROUP_CONCAT(p.company,'=',p.id SEPARATOR ',') as id from product p left join productcategorymapping pm on p.id=pm.productid where p.isasset=false and p.deleteflag = 'F' " + conditionSQL+ " group by p.productid "+orderBy  ;
                
                selectQuery = " select p.id from product p left join productcategorymapping pm on p.id=pm.productid where p.isasset=false and p.deleteflag = 'F' " + conditionSQL+ " group by p.productid "+orderBy  ;
            } else {
                query = " select p.id,pm.productcategory from product p left join productcategorymapping pm on p.id=pm.productid "+customdatajoin+" where p.isasset=false and p.deleteflag = 'F' " +usercondition+ conditionSQL+orderBy  ;
                selectQuery = query;
            }
            if(!executeCountQuery){
                listSql = executeSQLQuery( selectQuery, params.toArray());
                totalCount = listSql.size();
            }
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                listSql = executeSQLQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            } else if(requestParams.containsKey("exportConsolidationStockReport") && (Boolean)requestParams.get("exportConsolidationStockReport")){
                listSql = executeSQLQuery( query, params.toArray());
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return new KwlReturnObject(true, "", "", listSql, totalCount);
    }

    // Done by Neeraj    
    public KwlReturnObject selectInventoryByProduct(String productid, String companyid) throws ServiceException {
        String selectQuery = "from Inventory i where i.product.ID=? and i.company.companyID=?";
        List Records = executeQuery( selectQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, null, Records.size());
    }

    public KwlReturnObject selectSubProductFromAssembly(String subProductId) throws ServiceException {
        String selectQuery = "from ProductAssembly p where p.subproducts.ID = ?";
        List Records = executeQuery( selectQuery, new Object[]{subProductId});
        return new KwlReturnObject(true, "", null, Records, Records.size());
    }
    
    public KwlReturnObject selectSubProductFromAssemblyMRP(String subProductId, String bomDetailId) throws ServiceException {
        String selectQuery = "from ProductAssembly p where p.subproducts.ID = ? and p.bomdetail.ID = ?";
        List Records = executeQuery( selectQuery, new Object[]{subProductId, bomDetailId});
        return new KwlReturnObject(true, "", null, Records, Records.size());
    }
    
    //This method used to check whether the Product having BOM Products or not
    public List isAssemblyProductWithBOM(String productid) throws ServiceException {
        ArrayList listObj = new ArrayList();
        boolean isAssemblyProductWithBOM = false;
        try {
            String selectQuery = "FROM ProductAssembly p WHERE p.product.ID = ?";
            List Records = executeQuery(selectQuery, new Object[]{productid});
            if (Records.size()>0) {
                isAssemblyProductWithBOM = true;
            }
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        listObj.add(isAssemblyProductWithBOM);
        return listObj;
    }
    
    public KwlReturnObject selectSubProductFromBuildAssembly(String subProductId) throws ServiceException {
//        String selectQuery = "from ProductBuildDetails where aproduct.ID = ?";
        String selectQuery = "select count(id) from pbdetails where aproduct = ?";
        List Records = executeSQLQuery(selectQuery, new Object[]{subProductId});
        return new KwlReturnObject(true, "", null, Records, Records.size());
    }

    public KwlReturnObject selectProductCycleCountPermanently(String productid, String companyid) throws ServiceException {
        String selectQuery = "from ProductCyclecount p where p.product.ID=? ";
        List Records = executeQuery( selectQuery, new Object[]{productid});
        return new KwlReturnObject(true, "", null, null, Records.size());
    }

    public KwlReturnObject selectCyclecountPermanently(String productid, String companyid) throws ServiceException {
        String selectQuery = "from Cyclecount c where c.product.ID=? ";
        List Records = executeQuery( selectQuery, new Object[]{productid});
        return new KwlReturnObject(true, "", null, null, Records.size());
    }
    
    @Deprecated
    public KwlReturnObject selectProPricePermanently(String productid, String companyid) throws ServiceException {
        String selectQuery = "from PriceList p where p.affecteduser = '-1' and p.product.ID=? and p.company.companyID=?";
        List Records = executeQuery( selectQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, null, Records.size());
    }

    @Override
    public List isChildorGrandChild(String childID) throws ServiceException {
        String query = "from Product where ID=? and parent != null";
        List Result = executeQuery( query, new Object[]{childID});
        return Result;
    }

    public KwlReturnObject getQtyandUnitCost(String productid, Date endDate) throws ServiceException {
        try {
            String selQuery = "select baseuomquantity, updateDate from Inventory inv where inv.product.ID=? and inv.updateDate<=? and inv.carryIn=true and inv.newInv=false";
            List list = executeQuery( selQuery, new Object[]{productid, endDate});
            return new KwlReturnObject(true, "Rate and Quantity for the product", null, list, list.size());
        } catch (Exception ex) {
            System.out.print(ex);
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
    }

    @Override
    public KwlReturnObject getAssemblyProductBillofMaterials(String productid) throws ServiceException {
        try {
            String selectQuery = "from ProductAssembly ap where ap.product.ID=?";
            List Records = executeQuery( selectQuery, new Object[]{productid});
            return new KwlReturnObject(true, "Bill of Materials", null, Records, Records.size());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("getAssemblyProductBillofMaterials : " + ex.getMessage(), ex);
        }
    }
    @Override
    public KwlReturnObject getAssemblyProductDetails(String productid) throws ServiceException {
        try {
            String selectQuery = "from ProductBuildDetails pbd where pbd.build.product.ID=? and pbd.unbuild=false";
            List Records = executeQuery( selectQuery, new Object[]{productid});
            return new KwlReturnObject(true, "Bill of Materials", null, Records, Records.size());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("getAssemblyProductBillofMaterials : " + ex.getMessage(), ex);
        }
    }
    @Override
    public KwlReturnObject getAssemblyBuidDetails(String buidid) throws ServiceException {
        try {
            String selectQuery = "from ProductBuildDetails pbd where pbd.build.ID=?";
            List Records = executeQuery( selectQuery, new Object[]{buidid});
            return new KwlReturnObject(true, "Bill of Materials", null, Records, Records.size());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("getAssemblyProductBillofMaterials : " + ex.getMessage(), ex);
        }
    }

    public String getNextAutoProductIdNumber(String companyid) throws ServiceException {
        try {
            String autoNumber = "";
            CompanyAccountPreferences pref = (CompanyAccountPreferences) get(CompanyAccountPreferences.class, companyid);
            String table = "Product", field = "productid";

            String pattern = null;

            if (!StringUtil.isNullOrEmpty(pref.getProductidNumberFormat())) {
                pattern = pref.getProductidNumberFormat().split(",")[0];
            }

            if (pattern == null) {
                return autoNumber;
            }

            String query = "select max(" + field + ") from " + table + " where " + field + " like ? and company.companyID=?";
            List list = executeQuery( query, new Object[]{pattern.replace('0', '_'), companyid});
            if (list.isEmpty() == false) {
                autoNumber = (String) list.get(0);
            }

            while (!pattern.equals(autoNumber)) {
                autoNumber = AccountingManager.generateNextAutoNumber(pattern, autoNumber);
                query = "select " + field + " from " + table + " where " + field + " = ? and company.companyID=?";
                list = executeQuery( query, new Object[]{autoNumber, companyid});
                if (list.isEmpty()) {
                    return autoNumber;
                }
            }

            return autoNumber;
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getNextAutoProductIdNumber : " + ex.getMessage(), ex);
        }
    }

//    public KwlReturnObject getSoldorPurchaseQty(String productid, boolean sold) throws ServiceException {
//    	try{
//    		String query="from Inventory i where i.product.id=? and i.carryIn=? and i.deleted=false";
//    		List list=executeQuery( query, new Object[]{productid,sold});
//    		return new KwlReturnObject(true, "Sold or Purchased Quantity for the product", null, list, list.size());
//    	} catch(Exception ex){
//        	throw ServiceException.FAILURE("getSoldorPurchaseQty : "+ex.getMessage(), ex);
//        }
//    }
    public KwlReturnObject getRateandQtyfromInvoice(String productid) throws ServiceException {
        try {
            String query = "from GoodsReceiptDetail grd where grd.inventory.product.id=? and grd.goodsReceipt.deleted = false";
            List list = executeQuery( query, new Object[]{productid});
            return new KwlReturnObject(true, "Rate and qty of product from invoice", null, list, list.size());
        } catch (Exception ex) {
            ex.printStackTrace();
            throw ServiceException.FAILURE("getRateandQtyfromInvoice : " + ex.getMessage(), ex);
        }
    }

    public KwlReturnObject checkSubProductforAssembly(String productid) throws ServiceException {
        try {
//            String query = "from ProductAssembly p where p.subproducts.ID=? and p.product.deleted=false";
            String query = "select count(pa.id) from productassembly pa inner join product p on p.id=pa.product inner join productbuild pb on pa.product = pb.product where pa.subproducts=? and p.deleteflag=false";
            List list = executeSQLQuery( query, new Object[]{productid});
            return new KwlReturnObject(true, "", null, list, list.size());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("checkSubProductforAssembly : " + ex.getMessage(), ex);
        }
    }

    public KwlReturnObject checkIfParentProduct(String productid) throws ServiceException {
        try {
//            String query = "from Product p where p.parent.ID=?";
            String query = "select count(p.id) from product p where p.parent=?";
            List list = executeSQLQuery( query, new Object[]{productid});
            return new KwlReturnObject(true, "", null, list, list.size());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("checkIfParentProduct : " + ex.getMessage(), ex);
        }
    }
    
    public KwlReturnObject updateProductParent(String productid, String companyId) throws ServiceException {
        String query = "update product set parent=null where parent=? and company=?";
        int numRows = executeSQLUpdate( query, new Object[]{productid,companyId});
        return new KwlReturnObject(true, "", null, null, numRows);
    }

    @Override
    public DefaultsForProduct getDefaultAccountsForProduct(HashMap<String, Object> request) throws ServiceException {
        DefaultsForProduct defaultsForProduct = new DefaultsForProduct();
        try {
            String companyid = (String) request.get("companyid");
            if (!StringUtil.isNullOrEmpty(companyid)) {
                String productType = (String) request.get("productType");
                String hql = " from UnitOfMeasure where company.companyID=? and  name = 'Unit'"; //By Default 'Unit'  
                List list = executeQuery( hql, new Object[]{companyid});
                if (list.isEmpty()) {
                    defaultsForProduct.setUnitOfMeasure(null);
                } else {
                    defaultsForProduct.setUnitOfMeasure((UnitOfMeasure) list.get(0));
                }

                if (!StringUtil.isNullOrEmpty(productType) && productType.equalsIgnoreCase(Producttype.SERVICE_Name)) {
                    hql = " from Producttype where name = '"+Producttype.SERVICE_Name+"'"; //for 'Service' type product   
                } else {
                    hql = " from Producttype where name = '"+Producttype.INVENTORY_PART_Name+"'"; //By Default 'Inventory Part'  
                }
                list = executeQuery( hql, new Object[]{});
                if (list.isEmpty()) {
                    defaultsForProduct.setProducttype(null);
                } else {
                    defaultsForProduct.setProducttype((Producttype) list.get(0));
                }

                hql = " from Account where company.companyID=? and  name = 'Purchases'";
                list = executeQuery( hql, new Object[]{companyid});
                if (list.isEmpty()) {
                    defaultsForProduct.setPaccount(null);
                } else {
                    defaultsForProduct.setPaccount((Account) list.get(0));
                }

                hql = " from Account where company.companyID=? and  name = 'Sales'";
                list = executeQuery( hql, new Object[]{companyid});
                if (list.isEmpty()) {
                    defaultsForProduct.setSaccount(null);
                } else {
                    defaultsForProduct.setSaccount((Account) list.get(0));
                }
            }
            return defaultsForProduct;

        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("Default Accounts: " + ex.getMessage(), ex);
        }
    }

    @Override
    public KwlReturnObject getProduct(String productCode, String companyid) throws ServiceException {
        try {
            String query = " from Product where productid = ? and company.companyID = ? ";
            List list = executeQuery( query, new Object[]{productCode, companyid});
            return new KwlReturnObject(true, "", null, list, list.size());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("get Product from product code: " + ex.getMessage(), ex);
        }
    }

    public KwlReturnObject getStockStatus(HashMap requestParam) throws ServiceException {
        ArrayList params = new ArrayList();
        List returnList = new ArrayList();
        int cnt = 0;
        try {
            int start = 0;
            int limit = 15;
            boolean pagingFlag = false;
            if (requestParam.containsKey("start") && requestParam.containsKey("limit") && !StringUtil.isNullOrEmpty(requestParam.get("start").toString())) {
                start = Integer.parseInt(requestParam.get("start").toString());
                limit = Integer.parseInt(requestParam.get("limit").toString());
                pagingFlag = true;
            }
            String condition = "";
            Calendar endcal = Calendar.getInstance();

            String companyid = (String) requestParam.get("companyid");
            Date stDate = (Date) requestParam.get("stDate");
            Date endDate = (Date) requestParam.get("endDate");
            Date beginDate = (Date) requestParam.get("beginDate");
            int quantityDigit = Constants.QUANTITY_DIGIT_AFTER_DECIMAL;
            if (Constants.CompanyPreferencePrecisionMap.containsKey(companyid)) {
                quantityDigit = (Integer) Constants.CompanyPreferencePrecisionMap.get(companyid).get(Constants.quantitydecimalforcompany);
            }

            if (stDate != null) {
                params.add(beginDate);
                condition += " AND Date(inv.updatedate) >= ? ";
            }

            if (endDate != null) {
                params.add(endDate);
                condition += " and Date(inv.updatedate) <= ? ";
            }

            params.add(companyid);
            params.add(Producttype.INVENTORY_PART);
            params.add(Producttype.ASSEMBLY);
            String condition1 = "";
            String ss = requestParam.get(Constants.ss) != null ? (String) requestParam.get(Constants.ss) : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"p.name", "p.description", "p.productid"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 3);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition1 += searchQuery;
            }

            String query = "select p.id as ProductId, p.name as ProductName, p.productid as pid, p.description as ProductDescription, pt.name as ProductTypeName, pt.id as ProductTypeId,"
                    + "( "
                    + "   select sum((case when carryIn='T' then FORMAT(inv.baseuomquantity,"+quantityDigit+") else FORMAT(-inv.baseuomquantity,"+quantityDigit+") end))  "
                    + "   from inventory as inv "
                    + "   where inv.deleteflag='F' and product=p.ID "
                    + condition
                    + "   group by product "
                    + " ) as QuantityOnHand, p.unitOfMeasure "
                    + //                        subQuery +                                      
                    " from product as p inner join producttype as pt on p.producttype = pt.id "
                    + " where p.deleteflag='F' and p.isasset <>1 and p.company=? "
                    + " and "
                    + " ( "
                    + "   p.producttype= ? "
                    + "   or p.producttype= ? "
                    + " )  " + condition1
                    + " order by p.name ";
            
            String cntquery = "select p.id as ProductId, p.name as ProductName, p.productid as pid, p.description as ProductDescription, pt.name as ProductTypeName, pt.id as ProductTypeId,"
                    + "( "
                    + "   select sum((case when carryIn='T' then FORMAT(inv.baseuomquantity,"+quantityDigit+") else FORMAT(-inv.baseuomquantity,"+quantityDigit+") end))  "
                    + "   from inventory as inv "
                    + "   where inv.deleteflag='F' and product=p.ID "
                    + condition
                    + "   group by product "
                    + " ) as QuantityOnHand, p.unitOfMeasure "
                    + //                        subQuery +                                      
                    " from product as p inner join producttype as pt on p.producttype = pt.id "
                    + " where p.deleteflag='F' and p.company=? "
                    + " and "
                    + " ( "
                    + "   p.producttype= ? "
                    + "   or p.producttype= ? "
                    + " ) " + condition1 + " limit ? offset ? ";

            returnList = executeSQLQuery( query, params.toArray());
            cnt = returnList.size();

            if (pagingFlag) {
                params.add(limit);
                params.add(start);
                List returnList1 = executeSQLQuery( cntquery, params.toArray());
                cnt = returnList1.size();
            }

        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("get Product from product code: " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, cnt);
    }

    public KwlReturnObject deleteProductCustomData(String productid) throws ServiceException {
        String delQuery = "delete from AccProductCustomData p where p.productId=? ";
        int numRows = executeUpdate( delQuery, new Object[]{productid});
        return new KwlReturnObject(true, "Product Custom Data has been deleted successfully.", null, null, numRows);

    }

    public KwlReturnObject saveProductCategoryMapping(String productid, String productCategory) throws ServiceException {
        List list = new ArrayList();
        try {
            ProductCategoryMapping productMapping = new ProductCategoryMapping();
            if (productid != null) {
                productMapping.setProductID((Product) get(Product.class, productid));
            }
            if (productCategory != null) {
                productMapping.setProductCategory((MasterItem) get(MasterItem.class, productCategory));
            }
            save(productMapping);
            list.add(productMapping);
            
        } catch (Exception e) {
            throw ServiceException.FAILURE("accProductImpl.saveProductCategoryMapping", e);
        }
        return new KwlReturnObject(true, "", "", list, list.size());
    }

     public KwlReturnObject updateProductCategoryIndustryCode(String productid, String industryCode) throws ServiceException {
        String query = "update Product set industryCodeId=? where ID=?";
        int numRows = executeUpdate(query, new Object[]{industryCode, productid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    
    
    public KwlReturnObject deleteProductCategoryMappingDtails(String productid) throws ServiceException {
        int numRows = 0;
        String delQuery = "delete from ProductCategoryMapping pm where pm.productID.ID=?";
        numRows += executeUpdate( delQuery, new Object[]{productid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }

    @Override
    public KwlReturnObject deleteProductInitialInventoryDtails(String productid, String companyid) throws ServiceException {
        int numRows = 0;
        String delQuery = "delete from Inventory inv where inv.carryIn = true and inv.defective = false and inv.newInv = true and description = 'Inventory Opened' and inv.product.ID = ? and inv.company.companyID = ?";
        numRows += executeUpdate( delQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    @Override
    public KwlReturnObject deleteAssemblyProductInventory(String productid, String companyid) throws ServiceException {
        int numRows = 0;
        String delQuery = "delete from Inventory inv where inv.product.ID = ? and inv.company.companyID = ?";
        numRows += executeUpdate( delQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }

    @Override
    public KwlReturnObject getProductIDCount(String productID, String companyId, boolean isFixedAsset) throws ServiceException {
        List list = new ArrayList();
        String q = "from Product where productid=? and asset=? and company.companyID=?";
        if (!StringUtil.isNullOrEmpty(productID)) {
            list = executeQuery( q, new Object[]{productID, isFixedAsset, companyId});
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject getProductTypeByName(String productTypeName) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(productTypeName)) {
            ArrayList params = new ArrayList();
            params.add(productTypeName);
            String query = "from Producttype where name=? ";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    public KwlReturnObject getProductByProductName(String company, String productName) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(productName)) {
            ArrayList params = new ArrayList();

            params.add(company);
            params.add(productName);

            String query = "From Product p where p.company.companyID=? and p.productid=? and p.deleted = 'F'"; //ERP-11493

            List list = executeQuery( query, params.toArray());

            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }
    
    public KwlReturnObject getLocationByName(String company, String locationName, Store storeId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(locationName)) {
            ArrayList params = new ArrayList();

            params.add(storeId.getId());
            params.add(locationName);
            params.add(company);

//            String query = "From Location l where l.company.companyID=? and l.name=? and l.stores in (?)";
            String query = "SELECT l.id FROM in_location  l INNER JOIN in_store_location sl ON l.id=sl.locationid"
                    + " INNER JOIN in_storemaster sm ON sm.id=sl.storeid WHERE sl.storeid=? AND l.name=? AND l.company=?";

//            List list = executeQuery( query, params.toArray());
            List list = executeSQLQuery( query, params.toArray());

            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
            
        }
        return result;
    }
    
    /**
     * Description:This method is used to get the Location Object by passing location id.
     * @param String locationid, String companyid
     * @return KwlReturnObject
     * @throws ServiceException
     */
    public KwlReturnObject getLocationByID(String locid, String company) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(locid)) {
            ArrayList params = new ArrayList();            
            params.add(company);
            params.add(locid);
            String query = "FROM Location lc WHERE lc.company.companyID=? and lc.id=?";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);            
        }
        return result;
    }
    
    public KwlReturnObject getStoreByName(String company, String storeName) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(storeName)) {
            ArrayList params = new ArrayList();

            params.add(company);
            params.add(storeName);
            params.add(storeName);
            params.add(storeName);

            String query = "From Store s "
                    + "where s.company.companyID=? and (s.abbreviation=? OR s.description=? OR (CONCAT(s.abbreviation,' - ',s.description)=?))";

            List list = executeQuery( query, params.toArray());

            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getUOMByName(String productUOMName, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(productUOMName)) {
            ArrayList params = new ArrayList();
            params.add(productUOMName);
            params.add(companyId);
            String query = "from UnitOfMeasure where name=? and company.companyID=?";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getProductByProductID(String productID, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(productID)) {
            ArrayList params = new ArrayList();
            params.add(productID);
            params.add(companyId);
            String query = "from Product where productid=? and company.companyID=?";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getAccountByName(String accountName, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(accountName)) {
            ArrayList params = new ArrayList();
            params.add(accountName);
            params.add(companyId);
            String query = "select id from account where deleteflag='F' and isheaderaccount='F' and BINARY name=? and company=? and mastertypeid!=2 and mastertypeid!=3 and mastertypeid!=4";//ERP-11837
            List list = executeSQLQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getVendorByName(String vendorName, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(vendorName)) {
            ArrayList params = new ArrayList();
            params.add(vendorName);
            params.add(companyId);
            String query = "from Vendor where name=? and company.companyID=?";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getInventoryLocationByName(String inventoryLocation, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(inventoryLocation)) {
            ArrayList params = new ArrayList();
            params.add(inventoryLocation);
            params.add(companyId);
            String query = "from InventoryLocation where name=? and company.companyID=?";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getInventoryWarehouseByName(String inventoryWarehouse, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(inventoryWarehouse)) {
            ArrayList params = new ArrayList();
            params.add(inventoryWarehouse);
            params.add(companyId);
            String query = "from InventoryWarehouse where name=? and company.companyID=?";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getCustomerIDByCode(String customerCode, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(customerCode)) {
            ArrayList params = new ArrayList();
            params.add(customerCode);
            params.add(companyId);
            String query = "select id from customer where acccode=? and company=? ";
            List list = executeSQLQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getCurrencies() throws ServiceException {
        String query = "from KWLCurrency";
        List list = executeQuery(query);
        return new KwlReturnObject(true, "", "", list, list.size());
    }
    @Override
    public List<Frequency> getFrequencies() throws ServiceException {
        String hql = "FROM Frequency";
        return executeQuery(hql);
    }
    @Override
    public KwlReturnObject getVendorIDByCode(String vendorCode, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(vendorCode)) {
            ArrayList params = new ArrayList();
            params.add(vendorCode);
            params.add(companyId);
            String query = "select id from vendor where acccode=? and company=? ";
            List list = executeSQLQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject addAssetOpening(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            FixedAssetOpening assetOpening = new FixedAssetOpening();
            String companyId = (String) dataMap.get("companyId");
            String productId = (String) dataMap.get("productId");

            Product product = (Product) get(Product.class, productId);

            Company company = (Company) get(Company.class, companyId);

            if (product != null) {
                assetOpening.setProduct(product);
            }

            if (company != null) {
                assetOpening.setCompany(company);
            }

            if (dataMap.containsKey("creationDate")) {
                assetOpening.setCreationDate((Date) dataMap.get("creationDate"));
            }
            if (dataMap.containsKey("documentNumber")) {
                assetOpening.setDocumentNumber((String) dataMap.get("documentNumber"));
            }
            if (dataMap.containsKey("quantity")) {
                assetOpening.setQuantity((Double) dataMap.get("quantity"));
            }
            if (dataMap.containsKey("rate")) {
                assetOpening.setRate((Double) dataMap.get("rate"));
            }
            /* // ERP-16629: WDV field should be optional during asset creation
            if (dataMap.containsKey("wdv")) {
                assetOpening.setWdv((Double) dataMap.get("wdv"));
            }  */
            if (dataMap.containsKey("inventory")) {
                String inventoryId = (String) dataMap.get("inventory");
                Inventory inventory = (Inventory) get(Inventory.class, inventoryId);
                assetOpening.setInventory(inventory);
            }

            saveOrUpdate(assetOpening);
            list.add(assetOpening);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("addAssetOpening : " + ex.getMessage(), ex);
        }

        return new KwlReturnObject(true, "Asset Opening information has been added successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject getAssetOpenings(HashMap<String, Object> requestMap) throws ServiceException {
        String condition = "";
        List params = new ArrayList();

        String companyId = (String) requestMap.get("companyId");

        params.add(companyId);

        if (requestMap.containsKey("productId")) {
            condition += " and fao.product.ID=? ";
            params.add((String) requestMap.get("productId"));
        }

        if (requestMap.containsKey("documentNumber")) {
            condition += " and fao.documentNumber=? ";
            params.add((String) requestMap.get("documentNumber"));
        }

        String query = "from FixedAssetOpening fao Where fao.company.companyID=?" + condition;

        List list = executeQuery( query, params.toArray());
        int count=0;
        if (list != null && list.size() > 0) {
            count = list.size();
        }
        if (requestMap.containsKey("start") && requestMap.containsKey("limit") && requestMap.get("start") != null && requestMap.get("limit") != null) {
            String start = (String) requestMap.get("start");
            String limit = (String) requestMap.get("limit");
            list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    @Override
    public KwlReturnObject getPurchaseInvoiceIdOfAssetCreatedFromGRN(HashMap<String, Object> requestMap) throws ServiceException {
        String assetDetailId = (String) requestMap.get("assetDetailId");
        String companyId = (String) requestMap.get("companyId");

        List params = new ArrayList();
        params.add(companyId);
        params.add(assetDetailId);

        String query = "SELECT gr.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm ON ad.id=adm.assetdetails "
                + "INNER JOIN grodetails grod ON grod.id=adm.invoicedetailid "
                + "INNER JOIN grdetails grd ON grd.id= grod.videtails "
                + "INNER JOIN goodsreceipt gr ON gr.id=grd.goodsreceipt WHERE ad.company=? AND ad.id=? and adm.moduleid=28";

        List list = executeSQLQuery( query, params.toArray());

        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject getPurchaseInvoiceIdOfAssetCreatedFromPurchaseInvoice(HashMap<String, Object> requestMap) throws ServiceException {
        String assetDetailId = (String) requestMap.get("assetDetailId");
        String companyId = (String) requestMap.get("companyId");

        List params = new ArrayList();
        params.add(companyId);
        params.add(assetDetailId);

        String query = "SELECT gr.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm ON ad.id=adm.assetdetails "
                + "INNER JOIN grodetails grod ON grod.id=adm.invoicedetailid "
                + "INNER JOIN grdetails grd ON grd.grorderdetails=grod.id "
                + "INNER JOIN goodsreceipt gr ON gr.id=grd.goodsreceipt WHERE ad.company=? AND ad.id=? and adm.moduleid=28";

        List list = executeSQLQuery( query, params.toArray());

        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public List getPurchaseInvoiceNoAndVendorOfAssetPurchaseInvoice(HashMap<String, Object> requestMap) throws ServiceException {
        String assetDetailId = (String) requestMap.get("assetDetailId");
        String companyId = (String) requestMap.get("companyId");

        List params = new ArrayList();
        params.add(companyId);
        params.add(assetDetailId);

        String query = "SELECT gr.grnumber, gr.vendor, gr.journalentry,gr.tax as gtax,grd.tax as ltax,gr.id as grid,grd.id as grdid, "
                + "grd.itctype as itctype,grd.rowtermamount termamount ,grd.rowexcludinggstamount as taxableamt FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm ON ad.id=adm.assetdetails "
                + "INNER JOIN grodetails grod ON grod.id=adm.invoicedetailid "
                + "INNER JOIN grdetails grd ON grd.id=grod.videtails  "
                + "INNER JOIN goodsreceipt gr ON gr.id=grd.goodsreceipt WHERE ad.company=? AND ad.id=?";

        List list = executeSQLQuery( query, params.toArray());

        return list;
    }
    
    public List getPIDetails_AssetGRLinkedInAssetPI(HashMap<String, Object> requestMap) throws ServiceException {
        String assetDetailId = (String) requestMap.get("assetDetailId");
        String companyId = (String) requestMap.get("companyId");

        List params = new ArrayList();
        params.add(companyId);
        params.add(assetDetailId);

        String query = "SELECT gr.grnumber, gr.vendor, gr.journalentry,gr.tax as gtax,grd.tax as ltax,gr.id as grid,grd.id as grdid,"
                + "grd.itctype as itctype,grd.rowtermamount termamount ,grd.rowexcludinggstamount as taxableamt FROM assetdetail ad "
                + "INNER JOIN assetdetailsinvdetailmapping adm ON ad.id=adm.assetdetails "
                + "INNER JOIN grdetails grd ON grd.id=adm.invoicedetailid "
                + "INNER JOIN goodsreceipt gr ON gr.id=grd.goodsreceipt "
                + "INNER JOIN grodetails grod ON grod.id=grd.grorderdetails "
                + "INNER JOIN grorder gro ON gro.id=grod.grorder WHERE ad.company=? AND ad.id in (?) ";

        List list = executeSQLQuery( query, params.toArray());

        return list;
    }
    
    @Override
    public List getVendorForAssetDetail(HashMap<String, Object> requestMap) throws ServiceException {
        String assetDetailId = (String) requestMap.get("assetDetailId");
        String companyId = (String) requestMap.get("companyId");

        List params = new ArrayList();
        params.add(companyId);
        params.add(assetDetailId);

        String query = "SELECT gro.vendor FROM grorder gro "
                + "INNER JOIN grodetails grod ON grod.grorder=gro.id "
                + "INNER JOIN assetdetailsinvdetailmapping adm ON adm.invoicedetailid=grod.id "
                + "INNER JOIN assetdetail ad ON ad.id=adm.assetdetails "
                + "WHERE gro.company=? AND ad.id=?";
        List list = executeSQLQuery( query, params.toArray());

        return list;
    }
    
    @Override
    public KwlReturnObject getAssetDetails(HashMap<String, Object> requestMap) throws ServiceException {
        String condition = "";
        String joinQuery = "";
        ArrayList params = new ArrayList();
        List list = new ArrayList();
        int count=0;
        try{
            String companyId = (String) requestMap.get("companyId");
            boolean isDisposedAssetReport = false, isFixedAssetDetailReport = false;
            boolean isDepreciationDetailReport = false, isexport=false;
            boolean fromYearEndClose = false;
            Date startDate = null;
            Date endDate = null;
            if(requestMap.containsKey("isDisposedAssetReport") && (Boolean) requestMap.get("isDisposedAssetReport")){
                isDisposedAssetReport = (Boolean) requestMap.get("isDisposedAssetReport");
            }
            if(requestMap.containsKey("fromYearEndClose") && (Boolean) requestMap.get("fromYearEndClose")){
                fromYearEndClose = (Boolean) requestMap.get("fromYearEndClose");
            }
            if(requestMap.containsKey("isFixedAssetDetailReport") && (Boolean) requestMap.get("isFixedAssetDetailReport")){
                isFixedAssetDetailReport = (Boolean) requestMap.get("isFixedAssetDetailReport");
            }
            if(requestMap.containsKey("isDepreciationDetailReport") && (Boolean) requestMap.get("isDepreciationDetailReport")){
                isDepreciationDetailReport = (Boolean) requestMap.get("isDepreciationDetailReport");
            }
            if(requestMap.containsKey("isexport") && (Boolean) requestMap.get("isexport")){
                isexport = (Boolean) requestMap.get("isexport");
            }

            params.add(companyId);

            if(requestMap.containsKey("invrecord") && requestMap.get("invrecord") != null){
                condition += " and ad.invrecord=? ";
                params.add((Boolean) requestMap.get("invrecord"));
            }

            if (requestMap.containsKey("productId")) {
                condition += " and ad.product.ID=? ";
                params.add((String) requestMap.get("productId"));
            }

            if (requestMap.containsKey("assetId")) {
                condition += " and ad.assetId=? ";
                params.add((String) requestMap.get("assetId"));
            }

            if (requestMap.containsKey("isTransferHistory")) {
                condition += " and ad.isTransferHistory=? ";
                params.add((Boolean) requestMap.get("isTransferHistory"));
            }else{
                condition += " and ad.isTransferHistory=? ";
                params.add(false);            
            }               

            if (requestMap.containsKey("assetDetailsIds")) {
                String assetDetailsIds = (String) requestMap.get("assetDetailsIds");
                if (!StringUtil.isNullOrEmpty(assetDetailsIds)) {
                    condition += " and ad.id in (" + assetDetailsIds.substring(0,assetDetailsIds.length()-1)+")";
                }
            }

            int type = 0;//0 = All
            if(requestMap.containsKey("type") && requestMap.get("type")!=null){
                type = Integer.parseInt(requestMap.get("type").toString());
            }
            if(isDisposedAssetReport){
                //isDisposed = true means asset has been manually disposed
                //assetSoldFlag = 1 means asset has been sold from CI
                //assetSoldFlag = 2 means asset has been sold from DO
                if(type==1){//type = 1 = Manually Disposed
                    condition += " and (ad.isDisposed=true) ";
                }else if(type==2){//type = 2 = Disposed
                    condition += " and (ad.assetSoldFlag in (1,2)) ";
                }else{//type = 0 = All
                    condition += " and (ad.isDisposed=true or ad.assetSoldFlag in (1,2)) ";
                }
            } else if(isFixedAssetDetailReport){
                if(type==3){//type = 3 = Active Assets
                    condition += " and (ad.isDisposed=false and ad.assetSoldFlag in (0)) ";
                }else if(type==4){//type = 4 = Disposed Assets
                    condition += " and (ad.isDisposed=true or ad.assetSoldFlag in (1,2)) ";
                }
            } else if(requestMap.containsKey("isCreateSchedule") && (Boolean) requestMap.get("isCreateSchedule")){
                condition += " and (ad.isDisposed=false) ";
            }

            if (requestMap.containsKey("assetGroupIds")) {
                String []assetGroupIds = (String[]) requestMap.get("assetGroupIds");
                String []assetGroupIdArray = assetGroupIds[0].split(",");
                String assetIds ="";
                for(int i=0 ; i < assetGroupIdArray.length ; i++){
                    assetIds += "'"+ assetGroupIdArray[i]+"',";                
                }
                if (assetIds.indexOf("All") == -1) {
                    condition += " and ad.product.ID in (" + assetIds.substring(0, assetIds.length() - 1) + ")";
                }
            }

            if (requestMap.containsKey("excludeSoldAsset") && (Boolean) requestMap.get("excludeSoldAsset")) {
                condition += " and ad.assetSoldFlag=0 ";
            }

            if (requestMap.containsKey("ss") && requestMap.get("ss") != null) {
                String ss = requestMap.get("ss").toString();
                if (!StringUtil.isNullOrEmpty(ss)) {
                    String[] searchcol = new String[]{"ad.assetId", "ad.assetDescription"};
                    try {
                        Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                        StringUtil.insertParamSearchString(map);
                    } catch (SQLException ex) {
                        Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                    condition += searchQuery;
                }
            }

            if (requestMap.containsKey(Constants.REQ_startdate) && requestMap.containsKey(Constants.REQ_enddate) 
                    && requestMap.get(Constants.REQ_startdate)!=null && requestMap.get(Constants.REQ_enddate)!=null) {
                startDate = (Date) requestMap.get(Constants.REQ_startdate);
                endDate = (Date) requestMap.get(Constants.REQ_enddate);
                if (startDate != null && endDate != null) {
                    if(isDisposedAssetReport){
                        condition += " and (ad.disposalDate >=? and ad.disposalDate <=?) ";
                        params.add(startDate);
                        params.add(endDate);
                    } else if(isFixedAssetDetailReport){
                        condition += " and (ad.installationDate <=?) ";
                        params.add(endDate);
                    } else if(isDepreciationDetailReport){
                        /**
                         *1. (je.entryDate>= ? and je.entryDate<= ? ) : Condition is used get asset which are not disposed and having
                         * depreciation posted between start and end date.
                         * 2. (ad.disposalDate is not null and ad.disposalDate>=?) : condition is used to get assets which are disposed and having disposal date grated than start date.
                         */
                        condition += " and ((je.entryDate >=? and je.entryDate <=?) or (ad.disposalDate is not null and ad.disposalDate>=?))";
                        params.add(startDate);
                        params.add(endDate);
                        params.add(startDate);
                    }
                }
            }
            
//            if(isDepreciationDetailReport || fromYearEndClose){
//                condition += " and (ad.isDisposed=false and ad.assetSoldFlag=0) ";
//            }

            String appendCase = "and";
            String mySearchFilterString = "";
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (requestMap.containsKey("filterConjuctionCriteria") && requestMap.get("filterConjuctionCriteria") != null) {
                if (requestMap.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }

            String Searchjson = "";
            String searchDefaultFieldSQL = "";
            if (requestMap.containsKey("searchJson") && requestMap.get("searchJson") != null) {
                Searchjson = requestMap.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    JSONObject serachJobj = new JSONObject(Searchjson);
                    JSONArray customSearchFieldArray = new JSONArray();
                    JSONArray defaultSearchFieldArray = new JSONArray();
                    StringUtil.seperateCostomAndDefaultSerachJson(serachJobj, customSearchFieldArray, defaultSearchFieldArray);

                    if (customSearchFieldArray.length() > 0) {   //Advance search case for Custome field
                        requestMap.put(Constants.Searchjson, Searchjson);
                        requestMap.put(Constants.appendCase, appendCase);
                        requestMap.put(Constants.moduleid, Constants.Acc_FixedAssets_Details_ModuleId);
                        requestMap.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestMap, true).get(Constants.myResult));
                        mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "ad.assetDetailsCustomData");
                        mySearchFilterString = mySearchFilterString.replaceAll("assetdetailcustomdata", "ad.assetDetailsCustomData");
                        mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "ad.product.productCustomData");
                        StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                    }
                    mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(searchDefaultFieldSQL, mySearchFilterString, filterConjuctionCriteria);
                }
            }


            String orderBy = "";
            if (requestMap.containsKey("dir") && requestMap.containsKey("sort")) {
    //            String Col_Name = requestMap.get("sort").toString();
                String Col_Dir = requestMap.get("dir").toString();
                orderBy = " order by ad.product.name "+Col_Dir;
            } else {
                orderBy = " order by ad.product.name,ad.installationDate asc";
            }

            String query ="";
            if (isDepreciationDetailReport){
                query="select distinct(ad) from AssetDepreciationDetail assetDepdetail inner join assetDepdetail.assetDetails ad  inner join assetDepdetail.journalEntry je Where ad.company.companyID=? " + condition + mySearchFilterString + orderBy;
            }else{
                query="from AssetDetails ad Where ad.company.companyID=? " + condition + mySearchFilterString + orderBy;
            }

            if (requestMap.containsKey("invdetailId")) {
                params = new ArrayList();
                params.add(companyId);
                params.add((Boolean) requestMap.get("invrecord"));
                params.add((String) requestMap.get("invdetailId"));
                query = "Select ad from AssetDetails ad Inner Join AssetInvoiceDetailMapping adm Where ad.company.companyID=? and ad.invrecord=? and adm.invoiceDetailId=?";
            }
            if (requestMap.containsKey("isMachineMapped")) {
                query = "Select ad from MachineAssetMapping adm right outer Join adm.assetDetails ad Where ad.company.companyID=? "+condition+" group by ad";
            }

            list = executeQuery( query, params.toArray());
            
            if(list!=null && list.size()>0){
                count=list.size();
            }
            if (!isexport && requestMap.containsKey("start") && requestMap.containsKey("limit") && requestMap.get("start") != null && requestMap.get("limit") != null) {
                String start = requestMap.get("start").toString();
                String limit = requestMap.get("limit").toString();
                list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (JSONException | ParseException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, null, null, list,count);
    }
    
    @Override
    public KwlReturnObject isOpeningDepreciationRemaining(Map<String, Object> requestMap) throws ServiceException { 
        List<String> list = new ArrayList<>();
        String hqlQuery = "select ad.id,ad.assetId from AssetDetails ad where openingDepreciation =0  and createdFromOpeningForm='1' and id in(:assetdetailIDList) and company.companyID = (:companyId)";
        list = executeCollectionQuery(hqlQuery, requestMap);
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    @Override
    public KwlReturnObject getMaxPeriodOfSelectedAssets(Map<String, Object> requestMap) throws ServiceException { 
        List<String> list = new ArrayList<>();
        String hqlQuery = "select adp.assetDetails.id,MAX(adp.period) from AssetDepreciationDetail adp where adp.assetDetails.id in(:selectedAssetIdsList) and adp.company.companyID = (:companyId) GROUP BY adp.assetDetails.id ";
        list = executeCollectionQuery(hqlQuery, requestMap);
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject getAssetDetail(HashMap<String, Object> requestMap) throws ServiceException { //Edit  option for  Asset opeening Window 

        String documentId = (String) requestMap.get("documentid");
        String companyId = (String) requestMap.get("companyId");

        List params = new ArrayList();
        params.add(companyId);
        params.add(documentId);
        String query = "select ad.id from assetdetail ad where  ad.id in(select assetdetails from fixedassetopeningmapping where ad.company= ? and assetopening= ?) ";

        List list = executeSQLQuery( query, params.toArray());

        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    public KwlReturnObject getAssetDetailFromAssetID(HashMap<String, Object> requestMap) throws ServiceException { //Edit  option for  Asset opeening Window 
        String assetid = (String) requestMap.get("assetid");
        String companyId = (String) requestMap.get("companyId");

        List params = new ArrayList();
        params.add(assetid);
        params.add(companyId);
        params.add(false);
        String query = "from AssetDetails where assetId=? and company.companyID=? and invrecord=?";

        List list = executeQuery(query, params.toArray());

        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject getAssetDetailsForCombo(HashMap<String, Object> requestMap) throws ServiceException {
        List list = null;
        String query="";

        boolean isLeaseFixedAsset = false;
        if (requestMap.containsKey("isLeaseFixedAsset") && requestMap.get("isLeaseFixedAsset") != null) {
            isLeaseFixedAsset = (Boolean) requestMap.get("isLeaseFixedAsset");
        }
        boolean isFromSalesOrder = false;
        if (requestMap.containsKey("isFromSalesOrder") && requestMap.get("isFromSalesOrder") != null) {
            isFromSalesOrder = (Boolean) requestMap.get("isFromSalesOrder");
        }
        boolean isQuotationFromPR = false;
        if (requestMap.containsKey("isQuotationFromPR") && requestMap.get("isQuotationFromPR") != null) {
            isQuotationFromPR = (Boolean) requestMap.get("isQuotationFromPR");
        }
        boolean isPOfromVQ = false;
        if (requestMap.containsKey("isPOfromVQ") && requestMap.get("isPOfromVQ") != null) {
            isPOfromVQ = (Boolean) requestMap.get("isPOfromVQ");
        }
        boolean isPIFromVQ = false;
        if (requestMap.containsKey("isPIFromVQ") && requestMap.get("isPIFromVQ") != null) {
            isPIFromVQ = (Boolean) requestMap.get("isPIFromVQ");
        }
        boolean isPIFromPO = false;
        if (requestMap.containsKey("isPIFromPO") && requestMap.get("isPIFromPO") != null) {
            isPIFromPO = (Boolean) requestMap.get("isPIFromPO");
        }
        boolean isFixedAssetPR = false;
        if (requestMap.containsKey("isFixedAssetPR") && requestMap.get("isFixedAssetPR") != null) {
            isFixedAssetPR = (Boolean) requestMap.get("isFixedAssetPR");
        }
        boolean isFixedAssetSR = false;
        if (requestMap.containsKey("isFixedAssetSR") && requestMap.get("isFixedAssetSR") != null) {
            isFixedAssetSR = (Boolean) requestMap.get("isFixedAssetSR");
        }
            boolean isEdit = false;
        if (isFixedAssetPR) {
            isEdit = false;
            if (requestMap.containsKey("isEdit") && requestMap.get("isEdit") != null) {
                isEdit = (Boolean) requestMap.get("isEdit");
            }
            
            String condition = "";
            List params = new ArrayList();
            String companyId = (String) requestMap.get("companyId");
            
            params.add(companyId);
            params.add(true);

            if (requestMap.containsKey("productId")) {
                condition += " and ad.product=? ";
                params.add((String) requestMap.get("productId"));
            }
            
            if (!isEdit) {
                condition += " and ad.ispurchasereturn = false ";
            }
            
            query = "SELECT ad.id FROM assetdetail ad WHERE ad.assetsoldflag=0 and ad.company=? AND ad.invrecord=?" + condition;
            
            if (requestMap.containsKey("invdetailId")) {// it is for handling linking and Edit case
                boolean invrecord = true; //(Boolean) requestMap.get("invrecord");

                params = new ArrayList();
                params.add(companyId);
                params.add(true);
                params.add((String) requestMap.get("invdetailId"));

                String conditionSql = "";

                if (requestMap.containsKey("isForGRO")) {
                    boolean isForGRO = (Boolean) requestMap.get("isForGRO");
                    if (isForGRO) {
                        // module id check because seperate entries are present in asset details for GR and PI
                        conditionSql += " and BINARY ad.assetid not in (select assetid from assetdetail where invrecord=? and company=? and id in(select assetdetails from assetdetailsinvdetailmapping where moduleid=28))";
                        params.add(!invrecord);
                        params.add(companyId);
                    }
                }

                if (requestMap.containsKey("usedFlag") && (Boolean) requestMap.get("usedFlag")) {
                    conditionSql += "  and ad.isused=false ";
                }
                
                if (!isEdit) {
                    conditionSql += " and ad.ispurchasereturn = false ";
                }
                
                conditionSql += " and ad.isdisposed=false ";
                
                query = "SELECT ad.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm ON ad.id =adm.assetdetails WHERE ad.company=? and ad.invrecord=? and adm.invoicedetailid=?" + conditionSql;
            }           
            
            list = executeSQLQuery( query, params.toArray());
            
        } else if (isQuotationFromPR || isPOfromVQ || isPIFromVQ || isPIFromPO) {
            String condition = "";
            List params = new ArrayList();

            String companyId = (String) requestMap.get("companyId");

            params.add(companyId);

            if (requestMap.containsKey("productId")) {
                condition += " and ad.product=? ";
                params.add((String) requestMap.get("productId"));
            }
            
             query = "SELECT ad.id FROM purchaserequisitionassetdetail ad "
                    + " INNER JOIN assetdetailspurchaserequisitiondetailmapping adm ON ad.id =adm.purchaserequisitionassetdetails "
                    + " WHERE ad.company=? and ad.invrecord=false and ad.islinkedtoleaseso = false" + condition;
             
             if (isPOfromVQ) {
                if ((Boolean) requestMap.get("isEdit")) {
                    params.add((String) requestMap.get("billid"));
                    query = "SELECT ad.id FROM purchaserequisitionassetdetail ad "
                            + " INNER JOIN assetdetailspurchaserequisitiondetailmapping adm ON ad.id =adm.purchaserequisitionassetdetails "
                            + " LEFT JOIN podetails pod on pod.id = adm.purchaserequisitiondetailid "
                            + " INNER JOIN purchaseorder po on po.id = pod.purchaseorder "
                            + " WHERE ad.company= ? and ad.invrecord=false and ad.islinkedtoleaseso = false and ad.product= ? and po.id = ? ";
                } else {
                    params.add((String) requestMap.get("linkrowid"));
                    query = "SELECT ad.id FROM purchaserequisitionassetdetail ad "
                            + " INNER JOIN assetdetailspurchaserequisitiondetailmapping adm ON ad.id =adm.purchaserequisitionassetdetails "
                            + " INNER JOIN vendorquotationdetails vqd ON vqd.id = adm.purchaserequisitiondetailid  "
                            + "WHERE ad.company= ? and ad.invrecord=false and ad.islinkedtoleaseso = false and ad.product= ? and vqd.id = ? ";
                }
            } else if(isPIFromPO) {
                if ((Boolean) requestMap.get("isEdit")) {
                    params.add((String) requestMap.get("billid"));
                    query = "SELECT ad.id FROM assetdetail ad "
                            + " INNER JOIN assetdetailsinvdetailmapping adm  ON ad.id =adm.assetdetails "
                            + " LEFT JOIN grdetails grd on grd.id = adm.invoicedetailid "
                            + " INNER JOIN goodsreceipt gr on gr.id = grd.goodsreceipt "
                            + " WHERE ad.company= ? and ad.invrecord=false and ad.islinkedtoleaseso = false and ad.product= ? and gr.id = ? ";
                } else {
                    if (isPIFromPO && !isEdit) {
                        condition += " and adm.moduleid='90' ";
            }
                    query = "SELECT ad.id FROM purchaserequisitionassetdetail ad "
                    + " INNER JOIN assetdetailspurchaserequisitiondetailmapping adm ON ad.id =adm.purchaserequisitionassetdetails "
                    + " WHERE ad.company=? and ad.invrecord=false and ad.islinkedtoleaseso = false" + condition;
                }
                
            }
            list = executeSQLQuery( query, params.toArray());
            
        } else if (isLeaseFixedAsset) {
            String condition = "";
//            String conditionForOPeningDocs = "";
            List params = new ArrayList();
//            List paramsForOpeningDocs = new ArrayList();
            boolean invrecord = (Boolean) requestMap.get("invrecord");
            String companyId = (String) requestMap.get("companyId");

//            if (requestMap.containsKey("usedFlag") && (Boolean)requestMap.get("usedFlag")) {
//                condition += "  and ad.isused=false ";
//                conditionForOPeningDocs += "  and ad.isused=false ";
//            }     

            params.add(companyId);
            params.add(invrecord);

            if (requestMap.containsKey("productId")) {
                condition += " and ad.product=? ";
                params.add((String) requestMap.get("productId"));

//                conditionForOPeningDocs += " and ad.product=? ";
//                paramsForOpeningDocs.add((String) requestMap.get("productId"));
            }

//            if (requestMap.containsKey("excludeSoldAsset") && (Boolean) requestMap.get("excludeSoldAsset")) {
            condition += " and ad.assetsoldflag=0 ";
            condition += " and ad.islinkedtoleaseso=false ";
//            }

//                String query = "SELECT ad.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm ON ad.id =adm.assetdetails WHERE ad.company=? and ad.invrecord=?" + condition;
//                String unionQuery = " UNION SELECT ad.id FROM assetdetail ad INNER JOIN fixedassetopeningmapping adm ON ad.id =adm.assetdetails WHERE ad.company=? and ad.invrecord=?" + conditionForOPeningDocs;
//                query+=unionQuery;
//                params.addAll(paramsForOpeningDocs);

            query = "SELECT ad.id FROM assetdetail ad WHERE ad.company=? AND ad.invrecord=?" + condition;

            if (requestMap.containsKey("invdetailId")) {// it is for handling linking and Edit case
                params = new ArrayList();
                params.add(companyId);
                params.add(true);
                params.add((String) requestMap.get("invdetailId"));

                String conditionSql = "";
                String assetUnionQuery = "";

                if (requestMap.containsKey("isLeasedDoCreated") && requestMap.get("isLeasedDoCreated") != null) {
                    conditionSql += "  and ad.isleasedocreated=? ";
                    params.add((Boolean) requestMap.get("isLeasedDoCreated"));
                }

                if (requestMap.containsKey("isLeasedCICreated") && requestMap.get("isLeasedCICreated") != null) {
                    conditionSql += "  and ad.isleasecicreated=? ";
                    params.add((Boolean) requestMap.get("isLeasedCICreated"));
                }

                if (requestMap.containsKey("isLeasedSRCreated") && requestMap.get("isLeasedSRCreated") != null) {
                    conditionSql += "  and ad.islinkedtoleaseso=true ";
                }

                query = "SELECT ad.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm ON ad.id =adm.assetdetails WHERE ad.company=? and ad.invrecord=? and adm.invoicedetailid=?" + conditionSql;

                if (isFromSalesOrder) {  //in edit case of lease order all the asset id of that asset group should be loaded
                    List unionParams = new ArrayList();
                    unionParams.add(companyId);
                    unionParams.add(invrecord);
                    String productCondn = "";
                    if (requestMap.containsKey("productId") && requestMap.get("productId") != null) {
                        unionParams.add((String) requestMap.get("productId"));
                        productCondn = " AND product=? ";
                    }
                    params.addAll(unionParams);
                    assetUnionQuery = "SELECT ad.id FROM assetdetail ad WHERE ad.company=? AND ad.invrecord=? and ad.assetsoldflag=0 and ad.islinkedtoleaseso=false " + productCondn;
                    query += (" UNION " + assetUnionQuery);
                }
            }

            list = executeSQLQuery( query, params.toArray());

        } else {
            String condition = "";
            String conditionForOPeningDocs = "";
            List params = new ArrayList();
            List paramsForOpeningDocs = new ArrayList();

            boolean invrecord = (Boolean) requestMap.get("invrecord");
            boolean isCustomer = false;
            if (requestMap.containsKey("isCustomer") && requestMap.get("isCustomer") != null) {
                isCustomer = (Boolean) requestMap.get("isCustomer");
            }
            isEdit = false;
            if (requestMap.containsKey("isEdit") && requestMap.get("isEdit") != null) {
                isEdit = (Boolean) requestMap.get("isEdit");
            }

            String companyId = (String) requestMap.get("companyId");

            params.add(companyId);
            params.add((Boolean) requestMap.get("invrecord"));
            paramsForOpeningDocs.add(companyId);
            paramsForOpeningDocs.add((Boolean) requestMap.get("invrecord"));

            if (requestMap.containsKey("productId")) {
                condition += " and ad.product=? ";
                params.add((String) requestMap.get("productId"));
                conditionForOPeningDocs += " and ad.product=? ";
                paramsForOpeningDocs.add((String) requestMap.get("productId"));
            }

            if (requestMap.containsKey("excludeSoldAsset") && (Boolean) requestMap.get("excludeSoldAsset")) {
                condition += " and ad.assetsoldflag=0 ";
                conditionForOPeningDocs += " and ad.assetsoldflag=0 ";
            }

            if (requestMap.containsKey("usedFlag") && (Boolean) requestMap.get("usedFlag")) {
                condition += "  and ad.isused=false ";
                conditionForOPeningDocs += "  and ad.isused=false ";
            }

            if (requestMap.containsKey("isSalesReturn") && (Boolean) requestMap.get("isSalesReturn")) {
                condition += " and ad.issalesreturn=false ";
                conditionForOPeningDocs += " and ad.issalesreturn=false ";
            }

            condition += " and ad.isdisposed=false ";
            conditionForOPeningDocs += " and ad.isdisposed=false ";
            
            query = "SELECT ad.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm ON ad.id =adm.assetdetails WHERE ad.company=? and ad.invrecord=? and ad.islinkedtoleaseso = false and ad.ispurchasereturn = false " + condition;
            String unionQuery = " UNION SELECT ad.id FROM assetdetail ad INNER JOIN fixedassetopeningmapping adm ON ad.id =adm.assetdetails WHERE ad.company=? and ad.invrecord=? and ad.islinkedtoleaseso = false and ad.ispurchasereturn = false" + conditionForOPeningDocs;
            query += unionQuery;
            params.addAll(paramsForOpeningDocs);        

            if (requestMap.containsKey("invdetailId")) {// it is for handling linking and Edit case
                params = new ArrayList();
                params.add(companyId);
                params.add((Boolean) requestMap.get("invrecord"));
                params.add((String) requestMap.get("invdetailId"));

                String conditionSql = "";

                if (requestMap.containsKey("isForGRO")) {
                    boolean isForGRO = (Boolean) requestMap.get("isForGRO");
                    if (isForGRO) {
                        // module id check because seperate entries are present in asset details for GR and PI
                        conditionSql += " and BINARY ad.assetid not in (select assetid from assetdetail where invrecord=? and company=? and id in(select assetdetails from assetdetailsinvdetailmapping where moduleid=28))";
                        params.add(!invrecord);
                        params.add(companyId);
                    }
                }

                if (requestMap.containsKey("usedFlag") && (Boolean) requestMap.get("usedFlag")) {
                    conditionSql += "  and ad.isused=false ";
                }
                
//                if (requestMap.containsKey("isSalesReturn") && (Boolean) requestMap.get("isSalesReturn")) {
//                    conditionSql += " and ad.issalesreturn=false ";
//                }

                conditionSql += " and ad.isdisposed=false ";
                
                query = "SELECT ad.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm ON ad.id =adm.assetdetails WHERE ad.company=? and ad.invrecord=? and adm.invoicedetailid=?" + conditionSql;

                String assetUnionQuery = "";

                if (requestMap.containsKey("parentInvdetailId")) {// in case of edit only parent parentInvdetailId will come

                    List unionParams = new ArrayList();
                    unionParams.add(companyId);
                    unionParams.add((String) requestMap.get("parentInvdetailId"));
                    unionParams.add(companyId);

                    if (isCustomer) {// include those asset ids of Parent Transaction, for which any more Child transactions are not created.(i.e. if SI is Linked with DO then DO is Parent Transaction and SI is Child transaction similar vice-versa)
                        assetUnionQuery = "SELECT ad.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm "
                                + "ON ad.id =adm.assetdetails WHERE ad.islinkedtoleaseso = false and ad.company=? and adm.invoicedetailid=? "
                                + "AND ad.id NOT IN "
                                + "(SELECT ad1.id FROM assetdetail ad1 INNER JOIN assetdetailsinvdetailmapping adm1 "
                                + "ON ad1.id =adm1.assetdetails WHERE ad1.company=? and ad1.invrecord=true and adm1.moduleid=?)";
//                        unionParams.add((Boolean) requestMap.get("invrecord"));
                        if ((Boolean) requestMap.get("fromInvoice")) {
                            unionParams.add(Constants.Acc_Invoice_ModuleId);
                        } else {
                            unionParams.add(Constants.Acc_Delivery_Order_ModuleId);
                        }

                    } else {
                        assetUnionQuery = "SELECT ad.id FROM assetdetail ad INNER JOIN assetdetailsinvdetailmapping adm "
                                + "ON ad.id =adm.assetdetails WHERE ad.company=? and adm.invoicedetailid=? "
                                + "AND ad.assetid NOT IN (SELECT assetid FROM assetdetail WHERE company=? and invrecord=?)";
                        unionParams.add((Boolean) requestMap.get("invrecord"));
                    }
                    params.addAll(unionParams);

                    query+=(" UNION "+assetUnionQuery);
                } else if (isCustomer && isEdit && !isFixedAssetSR) { // if edit of sales invoice or DO, which does not have its Parent Transaction(i.e. SI/DO) then all those asset ids must come which has not been sold yet and not given in lease
                    List unionParams = new ArrayList();
                    unionParams.add(companyId);
                    String productCondn = "";
                    if (requestMap.containsKey("productId") && requestMap.get("productId") != null) {
                        unionParams.add((String) requestMap.get("productId"));
                        productCondn = " AND product=? ";
                    }
                    params.addAll(unionParams);
                    productCondn += " and isdisposed=false ";
                    assetUnionQuery = "SELECT id FROM assetdetail WHERE islinkedtoleaseso = false AND invrecord=true AND assetsoldflag=0 AND company=?"+productCondn;
                    query+=(" UNION "+assetUnionQuery);
                }
            }
            list = executeSQLQuery( query, params.toArray());
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject getAssetDetailsMappedWithOPeningDocument(HashMap<String, Object> requestMap) throws ServiceException {
        String condition = "";
        List params = new ArrayList();

        String companyId = (String) requestMap.get("companyId");

        params.add(companyId);

        if (requestMap.containsKey("documentId")) {
            condition += " and ad.assetOpening.id=? ";
            params.add((String) requestMap.get("documentId"));
        }
        
         if (requestMap.containsKey("assetDetails")) {
            condition = " and ad.assetDetails.id=? ";
            params.add((String) requestMap.get("assetDetails"));
        }
        
        String query = "from FixedAssetOpeningMappingWithAssetDetail ad Where ad.company.companyID=?" + condition;

        List list = executeQuery( query, params.toArray());

        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public KwlReturnObject saveAssetDetails(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            AssetDetails assetDetails = new AssetDetails();

            String companyId = (String) dataMap.get("companyId");
            String productId = (String) dataMap.get("productId");

            Company company = (Company) get(Company.class, companyId);
            Product product = (Product) get(Product.class, productId);

            if (company != null) {
                assetDetails.setCompany(company);
            }
            if (product != null) {
                assetDetails.setProduct(product);
            }

            assetDetails = buildAssetDetails(assetDetails, dataMap);

            save(assetDetails);
            list.add(assetDetails);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("saveAssetDetails : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Asset Detail has been added successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject updateAssetDetails(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            String companyId = (String) dataMap.get("companyId");
            String productId = (String) dataMap.get("productId");
            String assetDetailsId = (String) dataMap.get("assetDetailId");
            Company company = null;
            Product product = null;
            if (!StringUtil.isNullOrEmpty(companyId)) {
                company = (Company) get(Company.class, companyId);
            }
            if (!StringUtil.isNullOrEmpty(productId)) {
                product = (Product) get(Product.class, productId);
            }
            AssetDetails assetDetails=null;
            if (!StringUtil.isNullOrEmpty(assetDetailsId)) {
                assetDetails = (AssetDetails) get(AssetDetails.class, assetDetailsId);
            }
            
            if (company != null) {
                assetDetails.setCompany(company);
            }
            if (product != null) {
                assetDetails.setProduct(product);
            }
            if (dataMap.containsKey("isPurchaseReturn") &&  dataMap.get("isPurchaseReturn") != null) {
                assetDetails.setPurchaseReturn((Boolean) dataMap.get("isPurchaseReturn"));
            }
            
            if (dataMap.containsKey("isSalesReturn") &&  dataMap.get("isSalesReturn") != null) {
                boolean isSalesReturn = (Boolean) dataMap.get("isSalesReturn");
                assetDetails.setSalesReturn(isSalesReturn);
                
                // make available by setting assetsold flag to 0
                if (isSalesReturn) {
                    assetDetails.setAssetSoldFlag(0);
                }
            }
            
            if (dataMap.containsKey("accassetdetailscustomdata")) {
                String accassetdetailscustomdata = (String) dataMap.get("accassetdetailscustomdata");
                assetDetails = (AssetDetails) get(AssetDetails.class, accassetdetailscustomdata);
                AssetDetailsCustomData assetDetailsCustomData = null;
                assetDetailsCustomData = (AssetDetailsCustomData) get(AssetDetailsCustomData.class, (String) dataMap.get("accassetdetailscustomdata"));
                assetDetails.setAssetDetailsCustomData(assetDetailsCustomData);
            }

            assetDetails = buildAssetDetails(assetDetails, dataMap);

            saveOrUpdate(assetDetails);
            list.add(assetDetails);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("addAssetOpening : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Asset Detail has been added successfully", null, list, list.size());
    }

    private AssetDetails buildAssetDetails(AssetDetails assetDetails, HashMap<String, Object> dataMap) {
        if (dataMap.containsKey("assetId")) {
            assetDetails.setAssetId((String) dataMap.get("assetId"));
        }
        if (dataMap.containsKey("location")) {
            InventoryLocation location = (InventoryLocation) get(InventoryLocation.class, (String) dataMap.get("location"));
            assetDetails.setLocation(location);
        }
        if (dataMap.containsKey("department")) {
            Department department = (Department) get(Department.class, (String) dataMap.get("department"));
            assetDetails.setDepartment(department);
        }
        if (dataMap.containsKey("assetUser")) {
            User user = (User) get(User.class, (String) dataMap.get("assetUser"));
            assetDetails.setAssetUser(user);
        }
        if (dataMap.containsKey("sellingJE")) {
            JournalEntry je = (JournalEntry) get(JournalEntry.class, (String) dataMap.get("sellingJE"));
            assetDetails.setSellingJE(je);
        }
        if (dataMap.containsKey("cost")) {
            assetDetails.setCost((Double) dataMap.get("cost"));
        }
        if (dataMap.containsKey("costInForeignCurrency")) {
            assetDetails.setCostInForeignCurrency((Double) dataMap.get("costInForeignCurrency"));
        }
        if (dataMap.containsKey("salvageRate")) {
            assetDetails.setSalvageRate((Double) dataMap.get("salvageRate"));
        }
        if (dataMap.containsKey("salvageValue")) {
            assetDetails.setSalvageValue((Double) dataMap.get("salvageValue"));
        }
        if (dataMap.containsKey("salvageValueInForeignCurrency")) {
            assetDetails.setSalvageValueInForeignCurrency((Double) dataMap.get("salvageValueInForeignCurrency"));
        }
        if (dataMap.containsKey("accumulatedDepreciation")) {
            assetDetails.setAccumulatedDepreciation((Double) dataMap.get("accumulatedDepreciation"));
        }
        /* // ERP-16629: WDV field should be optional during asset creation
        if (dataMap.containsKey("wdv")) {
            assetDetails.setWdv((Double) dataMap.get("wdv")); 
        } */
        if (dataMap.containsKey("assetLife")) {
            assetDetails.setAssetLife((Double) dataMap.get("assetLife"));
        }
        if (dataMap.containsKey("elapsedLife")) {
            assetDetails.setElapsedLife((Double) dataMap.get("elapsedLife"));
        }
        if (dataMap.containsKey("nominalValue")) {
            assetDetails.setNominalValue((Double) dataMap.get("nominalValue"));
        }
        if (dataMap.containsKey("sellAmount")) {
            assetDetails.setSellAmount((Double) dataMap.get("sellAmount"));
        }
        if (dataMap.containsKey("installationDate")) {
            assetDetails.setInstallationDate((Date) dataMap.get("installationDate"));
        }
        if (dataMap.containsKey("purchaseDate")) {
            assetDetails.setPurchaseDate((Date) dataMap.get("purchaseDate"));
        }
        if (dataMap.containsKey("assetSoldFlag")) {
            assetDetails.setAssetSoldFlag((Integer) dataMap.get("assetSoldFlag"));
        }
        if (dataMap.containsKey("isUsedFlag")) {
            assetDetails.setIsUsed((Boolean) dataMap.get("isUsedFlag"));
        }
        if (dataMap.containsKey("isCreatedFromOpeningForm")) {
            assetDetails.setCreatedFromOpeningForm((Boolean) dataMap.get("isCreatedFromOpeningForm"));
        }
        if (dataMap.containsKey("isLinkedToLeaseSO")) {
            assetDetails.setLinkedToLeaseSO((Boolean) dataMap.get("isLinkedToLeaseSO"));
        }
        if (dataMap.containsKey("isLeaseDOCreated")) {
            assetDetails.setLeaseDOCreated((Boolean) dataMap.get("isLeaseDOCreated"));
        }
        if (dataMap.containsKey("isLeaseInvoiceCreated")) {
            assetDetails.setLeaseCICreated((Boolean) dataMap.get("isLeaseInvoiceCreated"));
        }
        if (dataMap.containsKey("invrecord")) {
            assetDetails.setInvrecord((Boolean) dataMap.get("invrecord"));
        }
        if (dataMap.containsKey("assetdescription")) {
            assetDetails.setAssetDescription((String) dataMap.get("assetdescription"));
        }
        if(dataMap.containsKey("isDisposed")){
            assetDetails.setIsDisposed((Boolean) dataMap.get("isDisposed"));
        }
        if(dataMap.containsKey("remainingLife")){
            assetDetails.setRemainingLife((Double) dataMap.get("remainingLife"));
        }
        if(dataMap.containsKey("disposalProfitLoss")){
            assetDetails.setDisposalProfitLoss((Double) dataMap.get("disposalProfitLoss"));
        }
        if(dataMap.containsKey("disposalDate")){
            assetDetails.setDisposalDate((Date) dataMap.get("disposalDate"));
        }
        if (dataMap.containsKey("isTransferHistory")) {
            assetDetails.setIsTransferHistory((Boolean) dataMap.get("isTransferHistory"));
        }
        if (dataMap.containsKey("transferDate")) {
            assetDetails.setTransferDate((Date) dataMap.get("transferDate"));
        }
        if(dataMap.containsKey("disposalJE")){
            assetDetails.setDisposalJE((JournalEntry) dataMap.get("disposalJE"));
        }
        if(dataMap.containsKey("reverseJE")){
            assetDetails.setReverseJE((JournalEntry) dataMap.get("reverseJE"));
        }
        if (dataMap.containsKey("batch")) {
            ProductBatch productBatch = dataMap.get("batch") == null ? null : (ProductBatch) get(ProductBatch.class, (String) dataMap.get("batch"));
            if (productBatch != null) {
                assetDetails.setBatch(productBatch);
            }
        }
        return assetDetails;
    }
    
    @Override
    public KwlReturnObject increaseOrDecreaseAvailableQuantity(HashMap<String, Object> reqParams) throws ServiceException {
        List list = new ArrayList();
        try {
            Product product = null;
            if(reqParams.containsKey("product") && reqParams.get("product")!=null){
                product = (Product) reqParams.get("product");
            }
            double availablequantity = -1;
            if(reqParams.containsKey("availablequantity") && reqParams.get("availablequantity")!=null){
                availablequantity = (double) reqParams.get("availablequantity");
            }
            boolean isIncreaseAvailableQuantity = false;
            if(reqParams.containsKey("isIncreaseAvailableQuantity") && reqParams.get("isIncreaseAvailableQuantity")!=null){
                isIncreaseAvailableQuantity = (Boolean) reqParams.get("isIncreaseAvailableQuantity");
            }
            if(product!=null && availablequantity != -1){
                if(isIncreaseAvailableQuantity){
                    availablequantity += 1;
                }else{
                    availablequantity -= 1;
                }
                String query = "update Product set availableQuantity=? where ID=?";
                int numRows = executeUpdate( query, new Object[]{availablequantity, product.getID()});
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("decreaseAvailableQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Available Quantity decreased.", null, list, list.size());
    }

    @Override
    public KwlReturnObject saveAssetOpeningMapping(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            FixedAssetOpeningMappingWithAssetDetail openingMapping = new FixedAssetOpeningMappingWithAssetDetail();

            String companyId = (String) dataMap.get("company");
            Company company = (Company) get(Company.class, companyId);
            if (company != null) {
                openingMapping.setCompany(company);
            }

            if (dataMap.containsKey("assetOpening")) {
                FixedAssetOpening assetOpening = (FixedAssetOpening) get(FixedAssetOpening.class, (String) dataMap.get("assetOpening"));
                openingMapping.setAssetOpening(assetOpening);
            }
            if (dataMap.containsKey("assetDetails")) {
                AssetDetails assetDetails = (AssetDetails) get(AssetDetails.class, (String) dataMap.get("assetDetails"));
                openingMapping.setAssetDetails(assetDetails);
            }

            save(openingMapping);
            list.add(openingMapping);

        } catch (Exception ex) {
            throw ServiceException.FAILURE("addAssetOpening : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Asset Detail has been added successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject deleteAssetDetails(HashMap<String, Object> requestMap) throws ServiceException {
        String condition = "";
        List params = new ArrayList();

        String companyId = (String) requestMap.get("companyId");

        params.add(companyId);

        if (requestMap.containsKey("assetDetailId")) {
            condition += " and ad.id=? ";
            params.add((String) requestMap.get("assetDetailId"));
        }
        String myquery1 = "Delete from fixedassetopeningmapping where company=? and assetdetails =?";
        int numRow1 = executeSQLUpdate( myquery1, params.toArray());

        String myquery2 = "Delete from assetdetailsinvdetailmapping where company=? and assetdetails =?";
        int numRow2 = executeSQLUpdate( myquery2, params.toArray());

//        String myquery7 = "delete from assetmaintenanceworkorderdetail  where assetmaintenanceworkorder in(select asworkorder.id from assetmaintenanceworkorder asworkorder INNER JOIN assetmaintenancescheduler asscheduler"
//                + " ON asworkorder.assetmaintenancescheduler=asscheduler.id and asscheduler.company=? and asscheduler.assetdetails=?)";
        String myquery7 = "delete amdod from assetmaintenanceworkorderdetail amdod inner join assetmaintenanceworkorder asworkorder on amdod.assetmaintenanceworkorder= asworkorder.id INNER JOIN assetmaintenancescheduler asscheduler ON asworkorder.assetmaintenancescheduler=asscheduler.id and asscheduler.company=? and asscheduler.assetdetails=?";
        int numRow7 = executeSQLUpdate( myquery7, params.toArray());
        
//        String myquery6 = "Delete from assetmaintenanceworkorder where company=? and assetmaintenancescheduler in (select id from assetmaintenancescheduler where assetdetails=?) ";
        String myquery6 = "delete asworkorder from assetmaintenanceworkorder asworkorder INNER JOIN assetmaintenancescheduler asscheduler  ON asworkorder.assetmaintenancescheduler=asscheduler.id where asworkorder.company=? and asscheduler.assetdetails=?";
        int numRow6 = executeSQLUpdate( myquery6, params.toArray());
        
        
        String myquery5 = "Delete from assetmaintenancescheduler where company=? and assetdetails =?";
        int numRow5 = executeSQLUpdate( myquery5, params.toArray());
        
        String myquery3 = "Delete from assetmaintenanceschedulerobject where company=? and assetdetails =?";
        int numRow3 = executeSQLUpdate( myquery3, params.toArray());

         String myquery4 = "Delete from assetdepreciationdetail where company=? and assetdetail =?";
         int numRow4 = executeSQLUpdate( myquery4, params.toArray());

        String query = "Delete from AssetDetails ad Where ad.company.companyID=?" + condition;

        int numRows = executeUpdate( query, params.toArray());

        return new KwlReturnObject(true, "Asset Details has been deleted successfully.", null, null, numRows);

    }

    @Override
    public KwlReturnObject deleteAssetOpeningDocument(HashMap<String, Object> requestMap) throws ServiceException {
        String condition = "";
        List params = new ArrayList();

        String companyId = (String) requestMap.get("companyId");

        params.add(companyId);

        if (requestMap.containsKey("documentId")) {
            condition += " and ad.id=? ";
            params.add((String) requestMap.get("documentId"));
        }

        String query = "Delete from FixedAssetOpening ad Where ad.company.companyID=?" + condition;

        int numRows = executeUpdate( query, params.toArray());

        return new KwlReturnObject(true, "Asset Opening Document has been deleted successfully.", null, null, numRows);

    }

    @Override
    public KwlReturnObject addDepreciationDetail(HashMap<String, Object> ddMap) throws ServiceException {
        List list = new ArrayList();
        try {
            AssetDepreciationDetail dd = new AssetDepreciationDetail();
            dd = buildDepreciation(dd, ddMap);
            save(dd);
            list.add(dd);
        } catch (Exception e) {
            throw ServiceException.FAILURE("addDepreciationDetail : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Depreciation Detail has been added successfully", null, list, list.size());
    }

    public AssetDepreciationDetail buildDepreciation(AssetDepreciationDetail dd, HashMap<String, Object> ddMap) {
        if (ddMap.containsKey("period")) {
            dd.setPeriod((Integer) ddMap.get("period"));
        }
        if (ddMap.containsKey("depreciationCreditToAccountId")) {
            Account account = ddMap.get("depreciationCreditToAccountId") == null ? null : (Account) get(Account.class, (String) ddMap.get("depreciationCreditToAccountId"));
            dd.setDepreciationCreditToAccount(account);
        }
        if (ddMap.containsKey("depreciationGLAccountId")) {
            Account account = ddMap.get("depreciationGLAccountId") == null ? null : (Account) get(Account.class, (String) ddMap.get("depreciationGLAccountId"));
            dd.setDepreciationAccount(account);
        }
        if (ddMap.containsKey("productId")) {
            Product product = ddMap.get("productId") == null ? null : (Product) get(Product.class, (String) ddMap.get("productId"));
            dd.setProduct(product);
        }
        if (ddMap.containsKey("assetId")) {
            AssetDetails assetDetails = ddMap.get("assetId") == null ? null : (AssetDetails) get(AssetDetails.class, (String) ddMap.get("assetId"));
            dd.setAssetDetails(assetDetails);
        }
        if (ddMap.containsKey("jeid")) {
            JournalEntry je = ddMap.get("jeid") == null ? null : (JournalEntry) get(JournalEntry.class, (String) ddMap.get("jeid"));
            dd.setJournalEntry(je);
        }
        if (ddMap.containsKey("companyid")) {
            Company company = ddMap.get("companyid") == null ? null : (Company) get(Company.class, (String) ddMap.get("companyid"));
            dd.setCompany(company);
        }
        if (ddMap.containsKey("periodamount")) {
            dd.setPeriodAmount((Double) ddMap.get("periodamount"));
        }
        if (ddMap.containsKey("accamount")) {
            dd.setAccumulatedAmount((Double) ddMap.get("accamount"));
        }
        if (ddMap.containsKey("netbookvalue")) {
            dd.setNetBookValue((Double) ddMap.get("netbookvalue"));
        }
        return dd;
    }
    
    /**
     * To get details of asset depreciation
     *
     * @param jeid
     * @param companyid
     * @return
     * @throws ServiceException
     */
    @Override
    public KwlReturnObject getPostDepreciationJE(String jeid, String companyid) throws ServiceException {
        String selQuery = "from AssetDepreciationDetail where journalEntry.ID =? and company.companyID=?";
        List list = executeQuery(selQuery, new Object[]{jeid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject getAssetDepreciationDetail(HashMap<String, Object> filterParams) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        String condition = "";
        String query = "from AssetDepreciationDetail ";

        if (filterParams.containsKey("period")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "period=?";
            params.add(filterParams.get("period"));
        }
        if (filterParams.containsKey("jeIds") && filterParams.get("jeIds") != null && !StringUtil.isNullOrEmpty(filterParams.get("jeIds").toString())) {
            if (!StringUtil.isNullOrEmpty(filterParams.get("jeIds").toString())) {
                condition += (condition.length() == 0 ? " where " : " and ") + "journalEntry.ID IN (" + filterParams.get("jeIds").toString() + ")";
            }
//            params.add(filterParams.get("jeIds"));
        }
        if (filterParams.containsKey("jeid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "journalEntry.ID=?";
            params.add(filterParams.get("jeid"));
        }
//        if (filterParams.containsKey("depreciationProvisionAccountId")) {
//            condition += (condition.length() == 0 ? " where " : " and ") + "depreciationProvisionAccount.ID=?";
//            params.add(filterParams.get("depreciationProvisionAccountId"));
//        }
        if (filterParams.containsKey("depreciationAccountId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "depreciationAccount.ID=?";
            params.add(filterParams.get("depreciationAccountId"));
        }
        if (filterParams.containsKey("productId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "product.ID=?";
            params.add(filterParams.get("productId"));
        }
        if (filterParams.containsKey("assetDetailsId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "assetDetails.id=?";
            params.add(filterParams.get("assetDetailsId"));
        }
        if (filterParams.containsKey("companyid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "company.companyID=?";
            params.add(filterParams.get("companyid"));
        }

        boolean assetDetails = false;
        if (filterParams.containsKey("assetDetails")) {
           assetDetails = (Boolean) filterParams.get("assetDetails"); 
        }
        if (!assetDetails) {
            condition += (condition.length() == 0 ? " where " : " and ") + "journalEntry.deleted=false";
        }

        query += condition;
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject getAssetInvoiceDetailMapping(HashMap<String, Object> filterParams) throws ServiceException {
        List returnList;
        ArrayList params = new ArrayList();
        String condition = "";
        String query = "from AssetInvoiceDetailMapping ";
        if (filterParams.containsKey("companyid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "company.companyID=?";
            params.add(filterParams.get("companyid"));
        }

        if (filterParams.containsKey("invoiceDetailId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "invoiceDetailId=?";
            params.add(filterParams.get("invoiceDetailId"));
        }

        if (filterParams.containsKey("moduleId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "moduleId=?";
            params.add(filterParams.get("moduleId"));
        }

        query += condition;
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public List isAssetExpire(AssetDetails assetDetails, Date disposalDate) throws ServiceException {
        
        double assetLifeInMonths = assetDetails.getAssetLife() * 12;
        boolean isAssetExpire=true;
        List ls= new ArrayList();
        try {

            Calendar calAssetStartLife = Calendar.getInstance();
            calAssetStartLife.setTime(assetDetails.getInstallationDate());
            
            Calendar calAssetTempLife = Calendar.getInstance();
            calAssetTempLife.set(calAssetStartLife.get(Calendar.YEAR), (int) assetLifeInMonths, calAssetStartLife.get(Calendar.DAY_OF_MONTH));
            
            int daysinmonth = calAssetTempLife.getActualMaximum(Calendar.DAY_OF_MONTH);
            long daysInMillis = daysinmonth * (long) Constants.DAY_MILLIS;
            double remainingMonthValue = daysInMillis * (assetLifeInMonths - Math.floor(assetLifeInMonths));
            int assetEndMonth = (int) assetLifeInMonths + (calAssetStartLife.get(Calendar.MONTH) - 1);
            Calendar calAssetEndLife = Calendar.getInstance();
            calAssetEndLife.set(calAssetStartLife.get(Calendar.YEAR), assetEndMonth, calAssetStartLife.get(Calendar.DAY_OF_MONTH));
            long assetTotalLifeInMillis = calAssetEndLife.getTimeInMillis() + (long) remainingMonthValue;
            calAssetEndLife.setTimeInMillis(assetTotalLifeInMillis);
            Calendar calAssetDisposalDate = Calendar.getInstance();
            calAssetDisposalDate.setTime(disposalDate);
            if (calAssetEndLife.getTimeInMillis() > calAssetDisposalDate.getTimeInMillis()) {
               isAssetExpire=false;
            }
            ls.add(isAssetExpire);
            ls.add(calAssetEndLife.getTimeInMillis());

        } catch (Exception e) {
            throw ServiceException.FAILURE("isAssetExpire : " + e.getMessage(), e);
        }
        return ls;
    }

    @Override
    public boolean isDepreciationPosted(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList;
        try {
            ArrayList params = new ArrayList();
            String condition = "";
            String query= "from AssetDepreciationDetail ";
            if (requestParams.containsKey("period") && requestParams.get("period")!=null) {
                condition += (condition.length() == 0 ? " where " : " and ") + " period=? ";
                params.add(Integer.parseInt(requestParams.get("period").toString()));
            }
            if (requestParams.containsKey("id") && requestParams.get("id")!=null) {
                condition += (condition.length() == 0 ? " where " : " and ") + " assetDetails.id=? ";
                params.add(requestParams.get("id").toString());
            }
            query += condition;
            returnList = executeQuery(query, params.toArray());
            if(returnList.size()>0){
                return true;
            }
        } catch (Exception e) {
            throw ServiceException.FAILURE("isDepreciationPosted : " + e.getMessage(), e);
        }
        return false;
    }

    @Override
    public KwlReturnObject saveAssetInvoiceDetailMapping(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            AssetInvoiceDetailMapping invoiceDetailMapping = new AssetInvoiceDetailMapping();

            String companyId = (String) dataMap.get("company");
            Company company = (Company) get(Company.class, companyId);
            if (company != null) {
                invoiceDetailMapping.setCompany(company);
            }

            if (dataMap.containsKey("moduleId")) {
                invoiceDetailMapping.setModuleId((Integer) dataMap.get("moduleId"));
            }

            if (dataMap.containsKey("invoiceDetail")) {
                invoiceDetailMapping.setInvoiceDetailId((String) dataMap.get("invoiceDetail"));
            }

            if (dataMap.containsKey("assetDetails")) {
                AssetDetails assetDetails = (AssetDetails) get(AssetDetails.class, (String) dataMap.get("assetDetails"));
                invoiceDetailMapping.setAssetDetails(assetDetails);
            }

            save(invoiceDetailMapping);
            list.add(invoiceDetailMapping);

        } catch (Exception ex) {
            throw ServiceException.FAILURE("addAssetOpening : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Asset Detail has been added successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject deleteAssetInvoiceDetailMapping(HashMap<String, Object> dataMap) throws ServiceException {
        ArrayList params = new ArrayList();
        String condition = "";
        String query = "Delete From AssetInvoiceDetailMapping ";

        if (dataMap.get("companyid") == null) {
            throw ServiceException.FAILURE("deleteAssetInvoiceDetailMapping : ", null);
        }

        condition += (condition.length() == 0 ? " where " : " and ") + "company.companyID=?";
        params.add(dataMap.get("companyid"));

        if (dataMap.containsKey("invoiceDetailId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "invoiceDetailId=?";
            params.add(dataMap.get("invoiceDetailId"));
        }

        if (dataMap.containsKey("mappingId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "id=?";
            params.add(dataMap.get("mappingId"));
        }

        if (dataMap.containsKey("moduleId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "moduleId=?";
            params.add(dataMap.get("moduleId"));
        }

        query += condition;

        int numRows = executeUpdate( query, params.toArray());

        return new KwlReturnObject(true, "Asset InvoiceDetail Mapping has been deleted successfully.", null, null, numRows);

    }

//    @Override
//    public boolean isDocumenthasDepreciatedAsset(String documentId, String companyId) throws ServiceException {
//        boolean isInvoicehasDepreciatedAsset = false;
//        ArrayList params = new ArrayList();
//        params.add(documentId);
//        params.add(companyId);
//        String query = "SELECT Distinct(pr.id) FROM deliveryorder do INNER JOIN dodetails dod "
//                + "ON do.id=dod.deliveryorder INNER JOIN inventory invt ON invt.id=dod.id "
//                + "INNER JOIN product pr ON pr.id=invt.product WHERE do.id=? AND do.company=?";
//
//        List list = executeSQLQuery( query, params.toArray());
//        Iterator itr = list.iterator();
//        String idStrings = "";
//        while (itr.hasNext()) {
//
//            String prId = itr.next().toString();
//            idStrings += "'" + prId + "',";
//        }
//        if (!StringUtil.isNullOrEmpty(idStrings)) {
//            idStrings = idStrings.substring(0, idStrings.length() - 1);
//        }
//
//        if (!StringUtil.isNullOrEmpty(idStrings)) {
//            ArrayList assetParams = new ArrayList();
//            assetParams.add(companyId);
//
//            String assetMapDelQuery = "SELECT * FROM assetdepreciationdetail WHERE product IN (" + idStrings + ") and company=?";
//            List asslist = executeSQLQuery( assetMapDelQuery, assetParams.toArray());
//            if ((asslist != null) && !asslist.isEmpty()) {
//                isInvoicehasDepreciatedAsset = true;
//            }
//        }
//
//        return isInvoicehasDepreciatedAsset;
//    }
    @Override
    public KwlReturnObject deleteAssetDetailsLinkedWithOpeningDocuments(HashMap<String, Object> requestParams) throws ServiceException {
        int numtotal = 0;
        try {
            String companyId = "";
            if(requestParams.containsKey("companyId") && requestParams.get("companyId")!=null){
                companyId = (String) requestParams.get("companyId");
            }
            if (requestParams.containsKey("documentId") && requestParams.containsKey("companyId")) {

                int numRows = 0;
                ArrayList params8 = new ArrayList();
                params8.add(requestParams.get("companyId"));
                params8.add(requestParams.get("documentId"));

                String assetDetailIdString = "";
                String inventoryIDs = "";

                // Deleting data from asset details table

                String assetQuery = "SELECT ad.id FROM fixedassetopening op "
                        + "INNER JOIN fixedassetopeningmapping amp ON op.id=amp.assetopening "
                        + "INNER JOIN assetdetail ad on ad.id=amp.assetdetails "
                        + "WHERE ad.assetsoldflag=0 AND op.company=? and op.id=?";

                List assetList = executeSQLQuery( assetQuery, params8.toArray());
                Iterator assetItr = assetList.iterator();

                while (assetItr.hasNext()) {
                    String assetDetailId = assetItr.next().toString();
                    assetDetailIdString += "'" + assetDetailId + "',";
                }
                
                if (!StringUtil.isNullOrEmpty(assetDetailIdString)) {
                    assetDetailIdString = assetDetailIdString.substring(0, assetDetailIdString.length() - 1);
                }

                String myquery = "Delete from fixedassetopeningmapping where company=? and assetopening =?";
                numRows = executeSQLUpdate( myquery, params8.toArray());

                
                if (!StringUtil.isNullOrEmpty(assetDetailIdString)) {
                    HashMap<String,Object> reqMap = new HashMap();
                    reqMap.put("asset", assetDetailIdString);
                    reqMap.put("companyid", requestParams.get("companyId"));
                    KwlReturnObject result = getDisposedOrRevertedAssets(reqMap);
                    List<DisposeRevertAssets> ll = result.getEntityList();
                    for(DisposeRevertAssets disposeRevertAssets : ll){
                        ArrayList assetJEParams = new ArrayList();
                        assetJEParams.add(disposeRevertAssets.getAsset().getId());
                        assetJEParams.add(requestParams.get("companyId"));
                        String updateAssetJEQuery = "UPDATE disposerevertassets SET disposalJE=null, reverseJE=null WHERE asset=? AND company=?";
                        executeSQLUpdate(updateAssetJEQuery, assetJEParams.toArray());

                        String assetJEQuery = "UPDATE assetdetail SET disposalje=null, reverseje=null WHERE id=? AND company=?";
                        executeSQLUpdate(assetJEQuery, assetJEParams.toArray());
                    
                        if(disposeRevertAssets.getDisposalJE()!=null){
                            accJournalEntryobj.deleteJournalEntryPermanent(disposeRevertAssets.getDisposalJE().getID(), companyId);
                        }
                        if(disposeRevertAssets.getReverseJE()!=null){
                            accJournalEntryobj.deleteJournalEntryPermanent(disposeRevertAssets.getReverseJE().getID(), companyId);
                        }
                    }

                    ArrayList assetParams = new ArrayList();
                    assetParams.add(requestParams.get("companyId"));
                    
                    String assetJEQuery = "DELETE FROM disposerevertassets  WHERE asset IN (" + assetDetailIdString + ") AND company=?";
                    numRows += executeSQLUpdate(assetJEQuery, assetParams.toArray());
                    
                    String assupdateQuery = "DELETE FROM assetdetailcustomdata  WHERE assetDetailsId IN (" + assetDetailIdString + ") AND company=?";
                    numRows += executeSQLUpdate( assupdateQuery, assetParams.toArray());
                    
                    String deletemachineasset="DELETE FROM machine_asset_mapping  WHERE assetDetails IN (" + assetDetailIdString + ") AND company=?";
                    numRows += executeSQLUpdate( deletemachineasset, assetParams.toArray());
                    assupdateQuery = "DELETE FROM assetdetail  WHERE id IN (" + assetDetailIdString + ") AND company=?";
                    numRows += executeSQLUpdate( assupdateQuery, assetParams.toArray());
                }

                // get Inventory Ids String Linked to opening document.

                String inventoryQuery = "SELECT inventory FROM fixedassetopening WHERE company=?  and id =?";
                List inventoryList = executeSQLQuery( inventoryQuery, params8.toArray());
                Iterator inventoryItr = inventoryList.iterator();

                while (inventoryItr.hasNext()) {
                    String inventoryId = inventoryItr.next().toString();
                    inventoryIDs += "'" + inventoryId + "',";
                }

                if (!StringUtil.isNullOrEmpty(inventoryIDs)) {
                    inventoryIDs = inventoryIDs.substring(0, inventoryIDs.length() - 1);
                }


                myquery = "Delete from fixedassetopening where company=?  and id =?";
                numRows = executeSQLUpdate( myquery, params8.toArray());

//                ArrayList delParams = new ArrayList();
//                delParams.add(requestParams.get("companyId"));
//
//                if (!StringUtil.isNullOrEmpty(inventoryIDs)) {
//                    myquery = "delete from inventory where company = ? and id in (" + inventoryIDs + ") ";
//                    numRows = executeSQLUpdate( myquery, delParams.toArray());
//                }
                String companyid = (String) requestParams.get("companyId");
                String selQuery = "from Inventory where company.companyID = ? and  ID in (" + inventoryIDs + ") ";
                List resultList = executeQuery( selQuery, new Object[]{companyid});
                Iterator itrInv = resultList.iterator();
                while (itrInv.hasNext()) {
                    Inventory inventory = (Inventory) itrInv.next();
                    if (inventory != null && inventory.isDeleted() == false) {
                        if (inventory.isCarryIn()) {
                            inventory.getProduct().setAvailableQuantity(inventory.getProduct().getAvailableQuantity() - inventory.getBaseuomquantity());// minus Purchase and Plus Sales (for Reverse effect for quantity)
                        } else {
                            inventory.getProduct().setAvailableQuantity(inventory.getProduct().getAvailableQuantity() + inventory.getBaseuomquantity());
                        }
                    }
                }
                deleteAll(resultList);
                numtotal = resultList.size();;
            }

        } catch (Exception ex) {
            throw ServiceException.FAILURE("Cannot delete Goods Receipt as its referance child field is not deleted.", ex);//+ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Goods Receipt has been deleted successfully.", null, null, numtotal);
    }
    public double getBalanceFromAssetOpening(String companyId, String docId) throws ServiceException {
        ArrayList arrayList = new ArrayList();
        arrayList.add(companyId);
        arrayList.add(docId);
        String rateQuery = "select rate from fixedassetopening where company=? and id=?";
        List rateList = executeSQLQuery( rateQuery, arrayList.toArray());
        double rate = Double.parseDouble(rateList.get(0).toString());
        return rate;
    }

    @Override
    public KwlReturnObject getDepreciatedAssetsOfOpeningDocuments(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList;
        ArrayList params = new ArrayList();

        String companyId = (String) requestParams.get("companyId");
        String openingDocumentId = (String) requestParams.get("documentId");

        params.add(companyId);
        params.add(openingDocumentId);

        String condition = "";
        String query = "SELECT ad.id FROM fixedassetopening op INNER JOIN fixedassetopeningmapping omp ON omp.assetopening = op.id "
                + "INNER JOIN assetdetail ad ON ad.id=omp.assetdetails INNER JOIN assetdepreciationdetail adp ON adp.assetdetail=ad.id "
                + "WHERE op.company=? AND op.id=?";


        query += condition;
        returnList = executeSQLQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject getSoldAssetsOfOpeningDocuments(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList;
        ArrayList params = new ArrayList();

        String companyId = (String) requestParams.get("companyId");
        String openingDocumentId = (String) requestParams.get("documentId");

        params.add(companyId);
        params.add(openingDocumentId);

        String condition = "";
        String query = "SELECT ad.id FROM fixedassetopening op INNER JOIN fixedassetopeningmapping omp ON omp.assetopening = op.id "
                + "INNER JOIN assetdetail ad ON ad.id=omp.assetdetails "
                + "WHERE (ad.assetsoldflag=1 || ad.assetsoldflag=2) AND op.company=? AND op.id=?";


        query += condition;
        returnList = executeSQLQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    /*
     Below method is used to get Disposal invoice related data
    */
    @Override
    public KwlReturnObject getDisposalInvoiceDetailsFromAssetDetailID(Map<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        String documentIds = "";
        String companyID = "";
        if (requestParams.containsKey("documentIds")) {
            documentIds = requestParams.get("documentIds").toString();
        }
        if (requestParams.containsKey("companyId")) {
            companyID = requestParams.get("companyId").toString();
        }
        params.add(companyID);
        String sqlQuery = "select asdm.assetdetails,inv.invoicenumber,je.entrydate,je.id,je.entryno from  assetdetailsinvdetailmapping asdm "
                + " inner join invoicedetails invd  on invd.id=asdm.invoicedetailid "
                + " inner join invoice inv on inv.id=invd.invoice "
                + " inner join journalentry je on inv.journalentry=je.id "
                + " where inv.isfixedassetinvoice='1' and asdm.assetdetails in (" + documentIds + ") and asdm.company= ? and asdm.moduleid=2 ";
        returnList = executeSQLQuery(sqlQuery, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject getStockQuantityOnDate(HashMap requestParam) throws ServiceException,SessionExpiredException {
        ArrayList params = new ArrayList();
        List returnList = new ArrayList();
        String condition = "";
        Calendar endcal = Calendar.getInstance();
        DateFormat datef=authHandler.getDateOnlyFormat();
        String companyid = (String) requestParam.get("companyid");
        Date startdate = (Date) requestParam.get("startdate");
        String productId = "";
        if (requestParam.containsKey("productid")) {
            productId = (String) requestParam.get("productid");
        }

        if (startdate != null) {
            endcal.setTime(startdate);
            endcal.add(Calendar.DAY_OF_MONTH, -1);
            Date endDate = endcal.getTime();
            try {
                String edate = datef.format(endDate);
                endDate=datef.parse(edate);
            } catch (ParseException ex) {
                endDate = endcal.getTime();
            }
            params.add(AccountingManager.setFilterTime(endDate, false));
            condition += " and updateDate<= ? ";
        }

        if (!StringUtil.isNullOrEmpty(productId)) {
            params.add(productId);
            condition += " and product.ID= ? ";
        }
        if (!StringUtil.isNullOrEmpty(companyid)) {
            params.add(companyid);
            condition += " and company.companyID= ? ";
        }
        String query = "select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) from Inventory where deleted=false " + condition;

        returnList = executeQuery( query, params.toArray());
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    
    
    
    @Override
        public KwlReturnObject getStockLedger(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        List pagingReturnList = new ArrayList();
        int totalCount = 0;
        
        boolean useTempProductId = false;

        String reportQueryJoin = "";
        String reportQueryWhereClause = "";
        String requestUUID = "";

        //If we want to use temporary IDS use below flag. 
        if (requestParams.containsKey(Constants.USE_OF_TEMP_TABLE) && !StringUtil.isNullOrEmpty((String) requestParams.get(Constants.USE_OF_TEMP_TABLE))) {
            useTempProductId = Boolean.parseBoolean(requestParams.get(Constants.USE_OF_TEMP_TABLE).toString());
            if (requestParams.containsKey(Constants.REQUEST_ID) &&  !StringUtil.isNullOrEmpty((String) requestParams.get(Constants.REQUEST_ID))) {
                requestUUID = (String) requestParams.get(Constants.REQUEST_ID);
            }
        }  
        
        
        try {
            DateFormat df = (DateFormat) requestParams.get(Constants.df);
            String start = (String) requestParams.get("start");
            String limit = (String) requestParams.get("limit");
            String startDate = (String) requestParams.get(Constants.REQ_startdate);
            String endDate = (String) requestParams.get(Constants.REQ_enddate);
            String store = (String) requestParams.get("store");
            String companyid = (String) requestParams.get("companyid");
            int docType = 0;
            String customerVendorId = "";
            String productId = "";
            String customerCondition = "";
            String vendorCondition = "";
            String productCondition = "";
            String productZeroCondition = "";
            String productCategoryId="";
            String productType="";
            boolean isStockLedger=false;
            boolean isInventoryValuation=false;
            boolean isFromStockReport=false;
            boolean isFromStockSummaryReport=false;
            boolean isFromStockValuationSummary=false;
            boolean isSelectedProductIds = false;
            String[] ids = null;
            ArrayList<String> productIdsList= new ArrayList<>();
            
            if (requestParams.containsKey("docType")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("docType"))) {
                    docType = Integer.parseInt(requestParams.get("docType").toString());
                }
            }
            if (requestParams.containsKey("customerId")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("customerId"))) {
                    customerVendorId = (requestParams.get("customerId").toString());
                }
            }
            
                        if (requestParams.containsKey("productCategoryid") && !StringUtil.isNullOrEmpty((String) requestParams.get("productCategoryid"))) {
                productCategoryId = (String) requestParams.get("productCategoryid");

                if (!productCategoryId.equalsIgnoreCase("All") && !StringUtil.isNullOrEmpty(productCategoryId)) {
                    productCategoryId = (String) requestParams.get("productCategoryid");
                    String categoryidarray="";
                    String[] categoryIds= productCategoryId.split(",");
                    for(int i=0;i<categoryIds.length;i++){
                        categoryidarray += categoryIds[i]+ ",";
                        MasterItem pref = (MasterItem) kwlCommonTablesDAOObj.getClassObject(MasterItem.class.getName(), categoryIds[i]);
                        Iterator<MasterItem> itr=pref.getChildren().iterator();
                        while(itr.hasNext()){
                            MasterItem children=itr.next();
                            categoryidarray +=children.getID() + ",";
                        }
                    }
                    
//                    productCategoryId = (requestParams.get("productCategoryid").toString());
                    categoryidarray = categoryidarray.substring(0, categoryidarray.length() - 1);
                    productCategoryId = AccountingManager.getFilterInString(categoryidarray);
                }
            }

            if (requestParams.containsKey("productType") && !StringUtil.isNullOrEmpty((String) requestParams.get("productType"))) {
                productType = (String) requestParams.get("productType");

                if (!productType.equalsIgnoreCase("All") && !StringUtil.isNullOrEmpty(productType)) {
                    productType = (String) requestParams.get("productType");
//                    productType = (requestParams.get("productType").toString());
                    productType = AccountingManager.getFilterInString(productType);
                }
            }

            
            
            if (requestParams.containsKey("selproductIds")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("selproductIds"))) {
                    isSelectedProductIds = true;
                    ids = ((String) requestParams.get("selproductIds")).split(",");
                    for(String s : ids){
                        productIdsList.add(s);
                    }
                }
            } else if (requestParams.containsKey("productId")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("productId"))) {
                    productId = (requestParams.get("productId").toString());
                }
            }
            if (requestParams.containsKey("isStockLedger")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("isStockLedger"))) {
                     isStockLedger=Boolean.parseBoolean((String) requestParams.get("isStockLedger")); 
                }
            }
            if (requestParams.containsKey("isInventoryValuation")) {
                if (requestParams.get("isInventoryValuation") != null) {
                    isFromStockReport = Boolean.parseBoolean(requestParams.get("isInventoryValuation").toString());
                }
            }
            if (requestParams.containsKey("isFromStockReport")) {
                if (requestParams.get("isFromStockReport") != null) {
                    isFromStockReport = Boolean.parseBoolean(requestParams.get("isFromStockReport").toString());
                }
            }
            if (requestParams.containsKey("isFromStockSummaryReport")) {
                if (requestParams.get("isFromStockSummaryReport") != null) {
                    isFromStockSummaryReport = Boolean.parseBoolean(requestParams.get("isFromStockSummaryReport").toString());
                }
            }
            if (requestParams.containsKey("isFromStockValuationSummary") && requestParams.get("isFromStockValuationSummary") != null) {
                isFromStockValuationSummary = Boolean.parseBoolean(requestParams.get("isFromStockValuationSummary").toString());
            }
            
            boolean isAdvanceSearchForValuation = false;
            if (requestParams.containsKey("isAdvanceSearchForValuation") && requestParams.get("isAdvanceSearchForValuation") != null) {
                /**
                 * Code for advance search SDP-9634.
                 */
                isAdvanceSearchForValuation = Boolean.parseBoolean(requestParams.get("isAdvanceSearchForValuation").toString());
            }
            
            boolean isActivateMRPModule=false;
            boolean isValuationCall=false; 
                        
            if (requestParams.containsKey("isActivateMRPModule") && requestParams.get("isActivateMRPModule") != null) {
                /**
                 * Code for MRP Module.
                 */
                isActivateMRPModule = Boolean.parseBoolean(requestParams.get("isActivateMRPModule").toString());
            }
            
            
            if (requestParams.containsKey("isValuationCall") && requestParams.get("isValuationCall") != null) {
                /**
                 * Code for MRP Module
                 * if getStockLedger() call from IVP (INVENTORY VALUATION PROCESS) This Flag will be true.  
                 * if FLAG is True , condition get added in Select 18 as TransType QUERY. 
                 */
                isValuationCall = Boolean.parseBoolean(requestParams.get("isValuationCall").toString());
            }
            
            ArrayList params = new ArrayList();
            ArrayList pagingParams=new ArrayList();
            ArrayList openingBalanceParams = new ArrayList();
            ArrayList openingZeroBalanceParams = new ArrayList();
//            ArrayList openingParams = new ArrayList();
            ArrayList goodsReceiptParams = new ArrayList();
            ArrayList stockAdjustParams = new ArrayList();
            ArrayList stockTransParams = new ArrayList();
            ArrayList stockissueParams = new ArrayList();
            ArrayList stockcollectParams = new ArrayList();
            ArrayList serialParams = new ArrayList();
            ArrayList deliveryOrderParams = new ArrayList();
            ArrayList purchaseReturnParams = new ArrayList();
            ArrayList salesReturnParams = new ArrayList();
            ArrayList assemblyProductParamsMain = new ArrayList();
            ArrayList assemblyProductParams = new ArrayList();
            //For Unbuild Main BOM Products
            ArrayList unbuildProductParamsMain = new ArrayList();
            ArrayList unbuildProductParams = new ArrayList();
            ArrayList stockInParams = new ArrayList();
            ArrayList stockOutParams = new ArrayList();
            ArrayList stockSalesParams = new ArrayList();
            ArrayList srIssueParams = new ArrayList();
            ArrayList srCollectParams = new ArrayList();
            ArrayList issuenoteIssueParams = new ArrayList();
            ArrayList issuenoteCollectParams = new ArrayList();
            ArrayList istIssueParams = new ArrayList();
            ArrayList istCollectParams = new ArrayList();
            ArrayList iltIssueParams = new ArrayList();
            ArrayList iltCollectParams = new ArrayList();
            ArrayList workOrderParams = new ArrayList();
            ArrayList workOrderDetailsParams = new ArrayList();

//            String openingConditionSQL = "";
            String openingBalanceConditionSQL = "";
            String openingBalanceZeroConditionSQL = "";
            String buildassemblyMainConditionSQL = "";
            String buildassemblyConditionSQL = "";
            String goodsReceiptConditionSQL = "";
            String purchaseReturnConditionSQL = "";
            String deliveryOrderConditionSQL = "";
            String salesReturnConditionSQL = "";
            String stockInSQL = "";
            String stockOutSQL = "";
            String stockSalesSQL = "";
            String srIssueSQL = "";
            String srCollectSQL = "";
            String issuenoteIssueSQL = "";
            String issuenoteCollectSQL = "";
            String istIssueSQL = "";
            String istCollectSQL = "";
            String iltIssueSQL = "";
            String iltCollectSQL = "";
            String stockAdjConditionSQL = "";
            String interStoreTransferConditionSQL = "";
            String serialConditionSQL = "";
            String workOrderConditionSQL = "";
            String workOrderDetailsConditionSQL = "";
            String quickSearchString = " ";
            String orderByString = " ";

            if (docType == 0) {                                                                              //0-All Documents,1-Purchase Documents,2-Sales Documents
                // For Product Opening                                                                    
//                openingParams.add((String) requestParams.get("companyid"));
                //For Assembly Sub-Products
                assemblyProductParams.add((String) requestParams.get("companyid"));
                unbuildProductParams.add((String) requestParams.get("companyid"));
                //For Assembly Main-Products
                assemblyProductParamsMain.add((String) requestParams.get("companyid"));
                unbuildProductParamsMain.add((String) requestParams.get("companyid"));
                //Inventory Stock-Out
                stockOutParams.add((String) requestParams.get("companyid"));
                if (isActivateMRPModule) {
                    workOrderParams.add((String) requestParams.get("companyid"));
                    workOrderDetailsParams.add((String) requestParams.get("companyid"));
                }
//                if (!StringUtil.isNullOrEmpty(endDate)) {
//                    Calendar startcal = Calendar.getInstance();
//                    Date startdate = df.parse(startDate);
//                    startcal.setTime(startdate);
//                    if (!StringUtil.isNullOrEmpty(productId)) {
//                        openingParams.add(productId);
//                    }
//                    openingParams.add(startcal);
//                    openingConditionSQL += " and (inv.updatedate<?) ";


                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        assemblyProductParams.addAll(productIdsList);
                        unbuildProductParams.addAll(productIdsList);
                    } else {
                        assemblyProductParams.add(productId);
                        unbuildProductParams.add(productId);
//                        assemblyProductParamsMain.add(productId);
//                        unbuildProductParamsMain.add(productId); 
//                        stockOutParams.add(productId);
//                        workOrderParams.add(productId);
//                        workOrderDetailsParams.add(productId);
                    }

//                        unbuildProductParams.add(productId);                   

                }
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    assemblyProductParams.add(df.parse(endDate));
                    unbuildProductParams.add(df.parse(endDate));
                    buildassemblyConditionSQL += " and (productbuild.entrydate <= ? ) ";
                }
//                    assemblyProductParams.add(df.parse(startDate));
                    
                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        assemblyProductParamsMain.addAll(productIdsList);
                        unbuildProductParamsMain.addAll(productIdsList);
                    } else {
                        assemblyProductParamsMain.add(productId);
                        unbuildProductParamsMain.add(productId);
                    }
                }
//                    assemblyProductParamsMain.add(df.parse(startDate));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    assemblyProductParamsMain.add(df.parse(endDate));
                    unbuildProductParamsMain.add(df.parse(endDate));
                    buildassemblyMainConditionSQL += " and (pb.entrydate <= ? ) ";
                }

                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        stockOutParams.addAll(productIdsList);
                    } else {
                        stockOutParams.add(productId);
                    }
                }
//                    stockOutParams.add(df.parse(startDate));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    stockOutParams.add(df.parse(endDate));
                    stockOutSQL += " and (sa.bussinessdate <=?) ";
                }
//                }
            }

            if (docType == 0 || docType == 1) {
                openingBalanceParams.add((String) requestParams.get("companyid"));          // For Initial Quantity
                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        openingBalanceParams.addAll(productIdsList);
                    } else {
                        openingBalanceParams.add(productId);
                    }
                }
                openingBalanceParams.add((String) requestParams.get("companyid"));
                
                openingZeroBalanceParams.add((String) requestParams.get("companyid"));
                openingZeroBalanceParams.add((String) requestParams.get("companyid"));

                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        openingZeroBalanceParams.addAll(productIdsList);
                    } else {
                        openingZeroBalanceParams.add(productId);
                    }
                }

                if (!StringUtil.isNullOrEmpty(endDate)) {
                    openingZeroBalanceParams.add(df.parse(endDate));
                    openingBalanceZeroConditionSQL += " and (p.asofdate <=? ) ";
                }

                // For Goods Receipt
                goodsReceiptParams.add((String) requestParams.get("companyid"));
                // For Purchase Return
                purchaseReturnParams.add((String) requestParams.get("companyid"));
                //Inventory Stock-IN
                stockInParams.add((String) requestParams.get("companyid"));
                srCollectParams.add((String) requestParams.get("companyid"));
                issuenoteCollectParams.add((String) requestParams.get("companyid"));
                istCollectParams.add((String) requestParams.get("companyid"));
                iltCollectParams.add((String) requestParams.get("companyid"));
                stockAdjustParams.add((String) requestParams.get("companyid")); 
                serialParams.add((String) requestParams.get("companyid")); 
                serialParams.add((String) requestParams.get("companyid")); 
//                if (!StringUtil.isNullOrEmpty(endDate)) {
                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        openingBalanceParams.addAll(productIdsList);
                    } else {
                        openingBalanceParams.add(productId);
                    }
                }
//                    openingBalanceParams.add(df.parse(startDate));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    openingBalanceParams.add(df.parse(endDate));
                    openingBalanceConditionSQL += " and (inv.updatedate <=?) ";
                }
                if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                    goodsReceiptParams.add(customerVendorId);
                }
                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        goodsReceiptParams.addAll(productIdsList);
                    } else {
                        goodsReceiptParams.add(productId);
                    }
                }
//                    goodsReceiptParams.add(df.parse(startDate));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    goodsReceiptParams.add(df.parse(endDate));
                    goodsReceiptConditionSQL += " and (gro.grorderdate <=?) ";
                }
                if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                    purchaseReturnParams.add(customerVendorId);
                }
                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        purchaseReturnParams.addAll(productIdsList);
                    } else {
                        purchaseReturnParams.add(productId);
                    }
                }
//                    purchaseReturnParams.add(df.parse(startDate));

                if (!StringUtil.isNullOrEmpty(endDate)) {
                    purchaseReturnParams.add(df.parse(endDate));
                    purchaseReturnConditionSQL += " and (pr.orderdate <=?) ";
                }

                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        stockInParams.addAll(productIdsList);
                        srCollectParams.addAll(productIdsList);
                        issuenoteCollectParams.addAll(productIdsList);
                        istCollectParams.addAll(productIdsList);
                        iltCollectParams.addAll(productIdsList);
                        /**
                         * append all productids from productIdsList to specified ArrayList workOrderParams and workOrderDetailsParams.                         
                         */
                        if (isActivateMRPModule) {
                            workOrderParams.addAll(productIdsList);
                            workOrderDetailsParams.addAll(productIdsList);
                        }
                    } else {
                        stockInParams.add(productId);
                        srCollectParams.add(productId);
                        issuenoteCollectParams.add(productId);
                        istCollectParams.add(productId);
                        iltCollectParams.add(productId);
                        if (isActivateMRPModule) {
                            workOrderParams.add(productId);
                            workOrderDetailsParams.add(productId);
                        }
                    }
                }
//                    stockInParams.add(df.parse(startDate));

                if (!StringUtil.isNullOrEmpty(endDate)) {
                    stockInParams.add(df.parse(endDate));
                    stockInSQL += " and (sa.bussinessdate <=?) ";
                    srCollectParams.add(df.parse(endDate));
                    srCollectSQL += " and (sa.bussinessdate <=?) ";
                    issuenoteCollectParams.add(df.parse(endDate));
                    issuenoteCollectSQL += " and (sa.bussinessdate <=?) ";
                    istCollectParams.add(df.parse(endDate));
                    stockcollectParams.add(df.parse(endDate));
                    istCollectSQL += " and (DATE_FORMAT(sa.businessdate, '%Y-%m-%d') <=?) ";
                    iltCollectParams.add(df.parse(endDate));
                    iltCollectSQL += " and (sa.businessdate <=?) ";
                }
//                }
            }

            if (docType == 0 || docType == 2) {
                // For Delivery Order
                deliveryOrderParams.add((String) requestParams.get("companyid"));
                // For Sales Return
                salesReturnParams.add((String) requestParams.get("companyid"));
                //Inventory Stock Sales
                stockSalesParams.add((String) requestParams.get("companyid"));
                srIssueParams.add((String) requestParams.get("companyid"));
                issuenoteIssueParams.add((String) requestParams.get("companyid"));
                istIssueParams.add((String) requestParams.get("companyid"));
                iltIssueParams.add((String) requestParams.get("companyid"));
                stockTransParams.add((String) requestParams.get("companyid")); 
//                if (!StringUtil.isNullOrEmpty(endDate)) {
                if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                    deliveryOrderParams.add(customerVendorId);
                }
                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        deliveryOrderParams.addAll(productIdsList);
                    } else {
                        deliveryOrderParams.add(productId);
                    }
                }
//                    deliveryOrderParams.add(df.parse(startDate));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    deliveryOrderParams.add(df.parse(endDate));
                    deliveryOrderConditionSQL += " and (do.orderdate <=?) ";
                }
                deliveryOrderConditionSQL += " and (do.isleasedo!='1') ";

                if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                    salesReturnParams.add(customerVendorId);
                }
                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        salesReturnParams.addAll(productIdsList);
                    } else {
                        salesReturnParams.add(productId);
                    }
                }
//                    salesReturnParams.add(df.parse(startDate));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    salesReturnParams.add(df.parse(endDate));
                    salesReturnConditionSQL += " and (sr.orderdate <=?) ";
                }
                salesReturnConditionSQL += " and (sr.isleasesalesreturn!='1') ";

                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        stockSalesParams.addAll(productIdsList);
                        srIssueParams.addAll(productIdsList);
                        issuenoteIssueParams.addAll(productIdsList);
                        istIssueParams.addAll(productIdsList);
                        iltIssueParams.addAll(productIdsList);
                    } else {
                        stockSalesParams.add(productId);
                        srIssueParams.add(productId);
                        issuenoteIssueParams.add(productId);
                        istIssueParams.add(productId);
                        iltIssueParams.add(productId);
                    }
                }
//                    stockSalesParams.add(df.parse(startDate));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    stockSalesParams.add(df.parse(endDate));
                    stockSalesSQL += " and (sa.bussinessdate <=?) ";
                    srIssueParams.add(df.parse(endDate));
                    srIssueSQL += " and (sa.bussinessdate <=?) ";
                    issuenoteIssueParams.add(df.parse(endDate));
                    issuenoteIssueSQL += " and (sa.bussinessdate <=?) ";
                    istIssueParams.add(df.parse(endDate));
                    stockissueParams.add(df.parse(endDate));
                    istIssueSQL += " and (DATE_FORMAT(sa.businessdate, '%Y-%m-%d') <=?) ";
                    iltIssueParams.add(df.parse(endDate));
                    iltIssueSQL += " and (sa.businessdate <=?) ";
                }
//                }
            }
            
            String ss = (String) requestParams.get("ss");
            String batchNameSearch = "";
            if (requestParams.containsKey("batchNameSearch") && requestParams.get("batchNameSearch") != null) {
                batchNameSearch = requestParams.get("batchNameSearch").toString();
            }
            String doJoin = "";
//            String grJoin = "";
            String prJoin = "";
            String srJoin = "";
            String stockJoin = "";
            String istJoin = "";
            String productJoin = "";
            String serialJoin = "";
            String productZeroJoin = "";
            String appendCase = "and";
            String mySearchFilterString = "";
            String productFilterString = "";
            String masterDOJoin = " ";
            String masterGRJoin = " ";
            String masterSRJoin = " ";
            String masterPRJoin = " ";
            String masterStockJoin = " ";
            String masterISTJoin = " ";
            boolean isAdvanceSearch = false;
            JSONArray doJson = new JSONArray();
            JSONArray grJson = new JSONArray();
            JSONArray srJson = new JSONArray();
            JSONArray stockJson = new JSONArray();
            JSONArray serialJson = new JSONArray();
            JSONArray interStoreTransferJson = new JSONArray();
            JSONArray interLocationJson = new JSONArray();
            JSONArray stockRequestJson = new JSONArray();
            JSONArray stockIssueJson = new JSONArray();
            JSONArray prJson = new JSONArray();
            JSONArray productJson = new JSONArray();
            JSONArray masterDOJson = new JSONArray();
            JSONArray masterGRJson = new JSONArray();
            JSONArray masterPRJson = new JSONArray();
            JSONArray masterSRJson = new JSONArray();
            JSONArray masterStockJson = new JSONArray();
            JSONArray masterISTJson = new JSONArray();
            boolean isAppyMasterSearch = false;
            StringBuilder JoinString=new StringBuilder();
            ArrayList advanceSearchParams = new ArrayList();
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (requestParams.containsKey("filterConjuctionCriteria") && requestParams.get("filterConjuctionCriteria") != null) {
                if (requestParams.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (requestParams.containsKey("searchJson") && requestParams.get("searchJson") != null) {
                Searchjson = requestParams.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    isAdvanceSearch = true;
                    boolean isForprodMaster = false;
                    // For getting Search Json
                    String iscustomcolumn = "", iscustomcolumndata = "", isfrmpmproduct = "", fieldtype = "", searchText = "", columnheader = "",
                            xtype = "", combosearch = "", isinterval = "", interval = "", isbefore = "", isdefaultfield = "", isForProductMasterOnly = "";
                    JSONObject SearchJsonObj = new JSONObject(Searchjson);
                    JSONArray SearchJsonArray = SearchJsonObj.getJSONArray("root");

                    for (int searckArr = 0; searckArr < SearchJsonArray.length(); searckArr++) {
                        JSONObject compareObj = SearchJsonArray.optJSONObject(searckArr);
                        iscustomcolumn = compareObj.optString("iscustomcolumn");
                        iscustomcolumndata = compareObj.optString("iscustomcolumndata");
                        isfrmpmproduct = compareObj.optString("isfrmpmproduct");
                        fieldtype = compareObj.optString("fieldtype");
                        searchText = compareObj.optString("searchText");
                        columnheader = compareObj.optString("columnheader");
                        columnheader = StringUtil.DecodeText(columnheader);
                        xtype = compareObj.optString("xtype");
                        combosearch = StringUtil.DecodeText(compareObj.optString("combosearch"));
                        isinterval = compareObj.optString("isinterval");
                        interval = compareObj.optString("interval");
                        isbefore = compareObj.optString("isbefore");
                        isdefaultfield = compareObj.optString("isdefaultfield");
                        isForProductMasterOnly = compareObj.optString("isForProductMasterOnly");
                        /*
                           Apply Master search on all modules if 'isForprodMaster' is true. (Only applicable for Product Master) 
                        */
                        isForprodMaster = Boolean.parseBoolean(compareObj.optString("isForProductMasterSearch", "false"));
                      
                        String[] coldataArray = combosearch.split(",");
                        String Coldata = "";
                        for (int countArray = 0; countArray < coldataArray.length; countArray++) {
                            Coldata += "'" + coldataArray[countArray] + "',";
                        }
                        Coldata = Coldata.substring(0, Coldata.length() - 1);
                        HashMap<String, Object> requestParams1 = new HashMap<String, Object>();
                        JSONArray productMasterJson = new JSONArray();
//                        columnheader = compareObj.optString("columnheader");
                        requestParams1.put(Constants.filter_names, Arrays.asList(Constants.companyid, "fieldlabel"));
                        requestParams1.put(Constants.filter_values, Arrays.asList(companyid, columnheader));
                        KwlReturnObject result = accAccountDAOobj.getFieldParams(requestParams1);
                        List<FieldParams> lst = result.getEntityList();
                        for (FieldParams fieldParams : lst) {
                            int module = fieldParams.getModuleid();
                            iscustomcolumndata = fieldParams.isIsForKnockOff()? (fieldParams.getCustomcolumn() == 1 ? "true" : "false") : compareObj.getString("iscustomcolumndata");
                            if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", module);
                                cntObj.put("isLineLevel", fieldParams.getCustomcolumn() == 1 ? true:false);
                            if (module == Constants.Acc_Delivery_Order_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                doJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            } else if (module == Constants.Acc_Goods_Receipt_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                grJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            } else if (module == Constants.Acc_Sales_Return_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                srJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            } else if (module == Constants.Acc_Purchase_Return_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                prJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            } else if (module == Constants.Acc_Product_Master_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                productJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            } else if (module == Constants.Inventory_Stock_Adjustment_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                stockJson.put(cntObj);
                                productMasterJson.put(cntObj); 
                            } else if (module == Constants.SerialWindow_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                serialJson.put(cntObj);
                            } else if (module == Constants.Acc_InterStore_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                interStoreTransferJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            } else if (module == Constants.Acc_InterLocation_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                interLocationJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            } else if (module == Constants.Acc_Stock_Request_ModuleId) {
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                stockRequestJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            } else if (module == Constants.Inventory_ModuleId) { // Stock Issue
                                cntObj.put("isForProductMasterSearch",isForprodMaster);
                                stockIssueJson.put(cntObj);
                                productMasterJson.put(cntObj);
                            }
                        }
                      
                        /**
                         * Get criterion wise search string 
                         */
                        StringUtil.getAppendSearchString(productMasterJson, JoinString, requestParams, advanceSearchParams);
                        productFilterString = String.valueOf(requestParams.get("productFilterString"));
                        mySearchFilterString = StringUtil.combineCustomSearchStrings(mySearchFilterString, productFilterString, filterConjuctionCriteria);
                        
                        if (isForprodMaster) {
                            isAppyMasterSearch = true;
                        }
                    }
                    
                   /* 
                    HashMap<String, Object> advRequestParams=new HashMap();
                    if ((doJson.length() > 0 || (productJson.length() > 0)) && (docType==0||docType==2)) {
                        JSONObject putSearchJson = new JSONObject();
                        if (masterDOJson.length() > 0) {  // Apply product master search on all modules
                            isAppyMasterSearch = true;
                            StringUtil.getProductMasterAdvanceSearchString(masterDOJson, deliveryOrderParams, requestParams);
                            masterDOJoin = String.valueOf(requestParams.get("productMasterJoin"));
                            doJoin = String.valueOf(requestParams.get("moduleSpecificJoin"));
                            productFilterString = String.valueOf(requestParams.get("productFilterString"));
                        }
                        if (doJson.length() > 0) {
                            putSearchJson.put("root", doJson);
                            advRequestParams.clear();
                            advRequestParams.put(Constants.Searchjson, putSearchJson);
                            advRequestParams.put(Constants.appendCase, appendCase);
                            advRequestParams.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                            advRequestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                            mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(advRequestParams, true).get(Constants.myResult));
                            if (mySearchFilterString.contains("deliveryordercustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "deliveryordercustomdata");
                                doJoin = " left join deliveryordercustomdata on deliveryordercustomdata.deliveryOrderId=do.accdeliveryordercustomdataref ";
                            }
                            if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "dodetailscustomdata");
                                doJoin += " left join dodetailscustomdata on dod.id=dodetailscustomdata.dodetailsid ";
                            }
                            StringUtil.insertParamAdvanceSearchString1(deliveryOrderParams, putSearchJson.toString());
                            mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(productFilterString, mySearchFilterString, filterConjuctionCriteria);
                            deliveryOrderConditionSQL += mySearchFilterString;
                        } else {
                             deliveryOrderConditionSQL += productFilterString;
                        }
                    }
                    if ((grJson.length() > 0 || (productJson.length() > 0)) && (docType==0||docType==1)) {
                        JSONObject putSearchJson = new JSONObject();
                        if (masterGRJson.length() > 0) {  // Apply product master search on all modules
                            isAppyMasterSearch = true;
                            StringUtil.getProductMasterAdvanceSearchString(masterGRJson, goodsReceiptParams, requestParams);
                            masterGRJoin = String.valueOf(requestParams.get("productMasterJoin"));
                            grJoin = String.valueOf(requestParams.get("moduleSpecificJoin"));
                            productFilterString = String.valueOf(requestParams.get("productFilterString"));
                        }
                        if (grJson.length() > 0) {
                            putSearchJson.put("root", grJson);
                            advRequestParams.clear();
                            advRequestParams.put(Constants.Searchjson, putSearchJson);
                            advRequestParams.put(Constants.appendCase, appendCase);
                            advRequestParams.put(Constants.moduleid, Constants.Acc_Goods_Receipt_ModuleId);
                            advRequestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                            mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(advRequestParams, true).get(Constants.myResult));
                            if (mySearchFilterString.contains("grordercustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "grordercustomdata");
                                grJoin = " left join grordercustomdata on grordercustomdata.goodsreceiptorderid=gro.accgrordercustomdataref ";
                            }
                            if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "grodetailscustomdata");
                                grJoin += " left join grodetailscustomdata on grod.id=grodetailscustomdata.grodetailsid ";
                            }
                            StringUtil.insertParamAdvanceSearchString1(goodsReceiptParams, putSearchJson.toString());
                            mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(productFilterString, mySearchFilterString, filterConjuctionCriteria);
                            goodsReceiptConditionSQL += mySearchFilterString;
                        } else {
                            goodsReceiptConditionSQL += productFilterString;
                        }
                    }
                    if ((srJson.length() > 0 || ( productJson.length() > 0)) && (docType==0||docType==2)) {
                        JSONObject putSearchJson = new JSONObject();
                        if (masterSRJson.length() > 0) {   // Apply product master search on all modules
                            isAppyMasterSearch = true;
                            StringUtil.getProductMasterAdvanceSearchString(masterSRJson, salesReturnParams, requestParams);
                            masterSRJoin = String.valueOf(requestParams.get("productMasterJoin"));
                            srJoin = String.valueOf(requestParams.get("moduleSpecificJoin"));
                            productFilterString = String.valueOf(requestParams.get("productFilterString"));

                        }
                        if (srJson.length() > 0) {
                            putSearchJson.put("root", srJson);
                            advRequestParams.clear();
                            advRequestParams.put(Constants.Searchjson, putSearchJson);
                            advRequestParams.put(Constants.appendCase, appendCase);
                            advRequestParams.put(Constants.moduleid, Constants.Acc_Sales_Return_ModuleId);
                            advRequestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                            mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(advRequestParams, true).get(Constants.myResult));
                            if (mySearchFilterString.contains("salesreturncustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "salesreturncustomdata");
                                srJoin = " left join salesreturncustomdata on salesreturncustomdata.salesreturnid=sr.accsalesreturncustomdataref ";
                            }
                            if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "srdetailscustomdata");
                                srJoin += " left join srdetailscustomdata on srd.id=srdetailscustomdata.srdetailsid ";
                            }

                            StringUtil.insertParamAdvanceSearchString1(salesReturnParams, putSearchJson.toString());
                            mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(productFilterString, mySearchFilterString, filterConjuctionCriteria);
                            salesReturnConditionSQL += mySearchFilterString;
                        } else {
                            salesReturnConditionSQL += productFilterString;
                        }
                    }
                    if ((prJson.length() > 0 || (productJson.length() > 0)) && (docType==0||docType==1)) {
                        JSONObject putSearchJson = new JSONObject();
                        if (masterPRJson.length() > 0) {   // Apply product master search on all modules
                            isAppyMasterSearch = true;
                            StringUtil.getProductMasterAdvanceSearchString(masterPRJson, purchaseReturnParams, requestParams);
                            masterPRJoin = String.valueOf(requestParams.get("productMasterJoin"));
                            prJoin = String.valueOf(requestParams.get("moduleSpecificJoin"));
                            productFilterString = String.valueOf(requestParams.get("productFilterString"));

                        }
                        if (prJson.length() > 0) {
                            putSearchJson.put("root", prJson);
                            advRequestParams.clear();
                            advRequestParams.put(Constants.Searchjson, putSearchJson);
                            advRequestParams.put(Constants.appendCase, appendCase);
                            advRequestParams.put(Constants.moduleid, Constants.Acc_Purchase_Return_ModuleId);
                            advRequestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                            mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(advRequestParams, true).get(Constants.myResult));
                            if (mySearchFilterString.contains("purchasereturncustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "purchasereturncustomdata");
                                prJoin = " left join purchasereturncustomdata on purchasereturncustomdata.purchasereturnid=pr.accpurchasereturncustomdataref ";
                            }
                            if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                                mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "prdetailscustomdata");
                                prJoin += " left join prdetailscustomdata on prd.id=prdetailscustomdata.prdetailsid ";
                            }
                            StringUtil.insertParamAdvanceSearchString1(purchaseReturnParams, putSearchJson.toString());
                            mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(productFilterString, mySearchFilterString, filterConjuctionCriteria);
                            purchaseReturnConditionSQL += mySearchFilterString;
                        } else {
                            purchaseReturnConditionSQL += productFilterString;
                        }
                    } 
                     if ((productJson.length() > 0) && (docType==0||docType==1)) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", productJson);
                        advRequestParams.clear();
                        advRequestParams.put(Constants.Searchjson, putSearchJson);
                        advRequestParams.put(Constants.appendCase, appendCase);
                        advRequestParams.put(Constants.moduleid, Constants.Acc_Product_Master_ModuleId);
                        advRequestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(advRequestParams, true).get(Constants.myResult));

                        if (mySearchFilterString.contains("AccJEDetailsProductCustomData") || mySearchFilterString.contains("accproductcustomdata")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "accproductcustomdata");
                            productJoin += " left join accproductcustomdata on p.id=accproductcustomdata.productId ";
                            productZeroJoin += " left join accproductcustomdata on p.id=accproductcustomdata.productId ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(openingBalanceParams, putSearchJson.toString());
                        StringUtil.insertParamAdvanceSearchString1(openingZeroBalanceParams, putSearchJson.toString());
                        openingBalanceConditionSQL += mySearchFilterString;
                        openingBalanceZeroConditionSQL += mySearchFilterString;
                    } else  if (serialJson.length() > 0) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", serialJson);
                        advRequestParams.clear();
                        advRequestParams.put(Constants.Searchjson, putSearchJson);
                        advRequestParams.put(Constants.appendCase, appendCase);
                        advRequestParams.put(Constants.moduleid, Constants.SerialWindow_ModuleId);
                        advRequestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(advRequestParams, true).get(Constants.myResult));

                        if (mySearchFilterString.contains("AccJEDetailCustomData") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "serialcustomdata");
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "serialcustomdata");
                        }
                        serialJoin += " left join serialcustomdata on sd.id=serialcustomdata.serialdocumentmappingid ";
                        StringUtil.insertParamAdvanceSearchString1(serialParams, putSearchJson.toString());
                        serialConditionSQL += mySearchFilterString;
                    } 
                     if (stockJson.length() > 0 || (productJson.length() > 0)) {
                        JSONObject putSearchJson = new JSONObject();
                         if (masterStockJson.length() > 0) {    // Apply product master search on all modules
                             isAppyMasterSearch = true;
                             StringUtil.getProductMasterAdvanceSearchString(masterStockJson, stockAdjustParams, requestParams);
                             masterStockJoin = String.valueOf(requestParams.get("productMasterJoin"));
                             stockJoin = String.valueOf(requestParams.get("moduleSpecificJoin"));
                             productFilterString = String.valueOf(requestParams.get("productFilterString"));

                         }
                         if (stockJson.length() > 0) {
                             putSearchJson.put("root", stockJson);
                             advRequestParams.clear();
                             advRequestParams.put(Constants.Searchjson, putSearchJson);
                             advRequestParams.put(Constants.appendCase, appendCase);
                             advRequestParams.put(Constants.moduleid, Constants.Inventory_Stock_Adjustment_ModuleId);
                             advRequestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                             mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(advRequestParams, true).get(Constants.myResult));

                             if (mySearchFilterString.contains("AccJEDetailCustomData") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                                 mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "in_stockadjustment_customdata");
                                 mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "in_stockadjustment_customdata");
                             }
                             stockJoin = " left join in_stockadjustment_customdata on sa.id=in_stockadjustment_customdata.stockadjustmentid ";
                             StringUtil.insertParamAdvanceSearchString1(stockAdjustParams, putSearchJson.toString());
                             mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(productFilterString, mySearchFilterString, filterConjuctionCriteria);
                             stockAdjConditionSQL += mySearchFilterString;
                         } else {
                             stockAdjConditionSQL += productFilterString;
                         }
                    }
                     // Inter Store Stock transfer
                      if (interStoreTransferJson.length() > 0 || (productJson.length() > 0)) {
                        JSONObject putSearchJson = new JSONObject();
                         if (masterISTJson.length() > 0) {   // Apply product master search on all modules
                             isAppyMasterSearch = true;
                             StringUtil.getProductMasterAdvanceSearchString(masterISTJson, stockTransParams, requestParams);
                             masterISTJoin = String.valueOf(requestParams.get("productMasterJoin"));
                             istJoin = String.valueOf(requestParams.get("moduleSpecificJoin"));
                             productFilterString = String.valueOf(requestParams.get("productFilterString"));
                         }
                          if (interStoreTransferJson.length() > 0) {
                              putSearchJson.put("root", interStoreTransferJson);
                              requestParams.clear();
                              requestParams.put(Constants.Searchjson, putSearchJson);
                              requestParams.put(Constants.appendCase, appendCase);
                              requestParams.put(Constants.moduleid, Constants.Acc_InterStore_ModuleId);
                              requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                              mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));

                              if (mySearchFilterString.contains("AccJEDetailsProductCustomData") || mySearchFilterString.contains("AccJEDetailCustomData")) {
                                  mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "in_interstoretransfer_customdata");
                                  mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "in_interstoretransfer_customdata");
                              }
                              istJoin = " left join in_interstoretransfer_customdata on sa.id=in_interstoretransfer_customdata.istid ";
                              StringUtil.insertParamAdvanceSearchString1(stockTransParams, putSearchJson.toString());
                              mySearchFilterString = StringUtil.combineCustomAndDefaultSearch(productFilterString, mySearchFilterString, filterConjuctionCriteria);
                              interStoreTransferConditionSQL += mySearchFilterString;
                          } else {
                              interStoreTransferConditionSQL += productFilterString;
                          }
                      }
                      
                      */
                      
                }  // end of search json check
            }
            if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                customerCondition=" and c.id= ? ";
            }
            if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                vendorCondition=" and v.id= ?";
            }
            if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                productCondition = "";
                productZeroCondition = "";
                if (ids != null) {
                    productCondition += " and p.id in(? ";
                    productZeroCondition += " and p.id in(? ";
                    for (int i = 0; i < ids.length - 1; i++) {
                        if (!StringUtil.isNullOrEmpty(ids[i])) {
                            productCondition += " ,?";
                            productZeroCondition += " ,?";
                        }
                    }
                    productCondition += " )";
                    productZeroCondition += " )";

                } else if (!StringUtil.isNullOrEmpty(productId)) {
                    productCondition = " and p.id= ?";
                    productZeroCondition = " and p.id= ?";
                }
            }
            String storeCondition1="";
            String storeCondition2="";
            String storeCondition3="";
            String storeCondition4="";
            String storeCondition5="";
            if (isFromStockSummaryReport) {
                if (!StringUtil.isNullOrEmpty(store)) {
                    storeCondition1 = " and npb.warehouse= ? ";
                    storeCondition2 = " and sa.store= ? ";
                    storeCondition3 = " and sa.fromstore= ? ";
                    storeCondition4 = " and sa.tostore= ? ";
                    storeCondition5 = " and sm.store= ? ";

                    openingBalanceParams.add(store);
                    goodsReceiptParams.add(store);
                    purchaseReturnParams.add(store);
                    assemblyProductParams.add(store);
                    unbuildProductParams.add(store);
                    assemblyProductParamsMain.add(store);
                    unbuildProductParamsMain.add(store);
                    deliveryOrderParams.add(store);
                    salesReturnParams.add(store);
                    stockInParams.add(store);
                    stockSalesParams.add(store);
                    stockOutParams.add(store);
                    srCollectParams.add(store);
                    srIssueParams.add(store);
                    issuenoteCollectParams.add(store);
                    issuenoteIssueParams.add(store);
                    istCollectParams.add(store);
                    istIssueParams.add(store);
                    iltCollectParams.add(store);
                    iltIssueParams.add(store);
                    if (isActivateMRPModule) {
                        workOrderParams.add(store);
                        workOrderDetailsParams.add(store);
                    }
                }
            }
            // filter on Customer Assembly and Customer Inventory type products so that they cannot appear in stock ledger reports
            /**
             * ERP-38563
             * checks of deleteflag, isasset and producttype (NON_INVENTORY_PART and SERVICE) are added in all queries
             * therefore moved these checks into Strings 'productCondition' and 'productZeroCondition'
             * .
             */
            productCondition += " and p.deleteflag = 'F' and p.isasset!='1' and p.producttype NOT IN ('" + Producttype.NON_INVENTORY_PART + "','" + Producttype.SERVICE + "','" + Producttype.CUSTOMER_ASSEMBLY + "','" + Producttype.CUSTOMER_INVENTORY + "') ";
            productZeroCondition += " and p.deleteflag = 'F' and p.isasset!='1' and p.producttype NOT IN ('" + Producttype.NON_INVENTORY_PART + "','" + Producttype.SERVICE + "','" + Producttype.CUSTOMER_ASSEMBLY + "','" + Producttype.CUSTOMER_INVENTORY + "') ";
            
            String prductTypeFilter = "", productTypeFilterForZeroIQ = "";
            if (!productType.equalsIgnoreCase("All") && !StringUtil.isNullOrEmpty(productType)) {
                prductTypeFilter += " and p.producttype in " + productType;
                productTypeFilterForZeroIQ += " and p.producttype in " + productType;
            }
            boolean isMaterialInOutReport = false;// Material IN/OUT Report
            if (requestParams.containsKey("isMaterialInOutReport") && requestParams.get("isMaterialInOutReport") != null) {
                isMaterialInOutReport = Boolean.parseBoolean(requestParams.get("isMaterialInOutReport").toString());
            }
            
            String initialStockMovementJoin = "";
            if (isMaterialInOutReport) {
                initialStockMovementJoin = " left join in_stockmovement sm on sm.modulerefid=p.id and npb.warehouse= sm.store and sm.product = p.id ";
            }
            String stockMovementParameters = "";
            if (isMaterialInOutReport) {
                stockMovementParameters = ", sm.remark, sm.assembled_product,sm.costcenter as costcenter, sm.stockuom as stockuom ";
            }
            String emptyStockMovementParameters = "";
            if (isMaterialInOutReport) {
                emptyStockMovementParameters = ", ' ' as remark, ' ' as assembled_product ,' ' as costcenter, ' ' as stockuom";
            }
            String batchNameSearchString = "";
            batchNameSearchString = (StringUtil.isNullOrEmpty(batchNameSearch) ? "" : " and npb.batchname like '%" + batchNameSearch + "%'");
            String initialQuantityZeroQty = "";
            
            /**
             * ERP-38563
             * Flag to indicate whether or not product columns are to be added in select clause or not
             * .
             */
            boolean includeProductDetailsInSelectQuery = false;
            if (requestParams.containsKey(Constants.includeProductDetailsInSelectQuery) && requestParams.get(Constants.includeProductDetailsInSelectQuery) != null) {
                includeProductDetailsInSelectQuery = Boolean.parseBoolean(requestParams.get(Constants.includeProductDetailsInSelectQuery).toString());
            }
            String productTableJoin = " product p ";
            String productDetailsSelectSubquery = " ";
            if (includeProductDetailsInSelectQuery) {
                /**
                 * New product table alias including joins with tables 'uom' and 'producttype'
                 * join with table 'uom' is to select column uom.name
                 * join with table 'producttype' is to select column 'producttype.name'
                 * .
                 */
                productTableJoin = " ( select p1.*, IF(uom.name = 'N/A', ' ', uom.name) as productuomname, prodtype.name as producttypename from product p1 " 
                        + " left join uom on uom.id = p1.unitOfMeasure " 
                        + " left join producttype prodtype on prodtype.id = p1.producttype where p1.company = '" + companyid + "' ) " 
                        + " as p ";
                // Columns are added to String 'productDetailsSelectSubquery' only when 'includeProductDetailsInSelectQuery' flag is true
                productDetailsSelectSubquery = " , p.productweight, p.description as productdescription, p.isBatchForProduct, p.isrowforproduct, p.israckforproduct, p.isbinforproduct, p.unitOfMeasure as productuomid, p.productuomname, p.producttypename, p.currency as productcurrency ";
            }
            
            
            if (StringUtil.isNullOrEmpty(batchNameSearchString)) {
                /**
                 * Add zero quantity query only if search is not applied on batch name.
                 */
                initialQuantityZeroQty = "select 0 as transType, p.id as pid, p.productid as productid, p.description as description, asofdate as date, 'Initial Quantity' as transactionNumber, p.productid as acccode, ' ' as name,' ' as vid, 0  as invquantity,0 as rate, 1,' ' as landedinvoice,' ' as currency, '1' as grid,' ' as rowid,' ' as spotrate,p.id as detailid,p.unitOfMeasure as uom,' ' as rowdetailid,' ' as srno, p.createdon  as createdon,' ' ,''as location,' ' as warehouse,  ' ' as row, ' ' as rack,' ' as bin,' ' as batchid,0 as quantity,' ' as linktransaction, ' ' AS serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson" + emptyStockMovementParameters + ",' ' as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery + " from " + productTableJoin +""
                        + " where p.id not in (select product from inventory where inventory.newinv='T' and inventory.defective='F' and inventory.carryin='T' and inventory.company = ?) and  p.company = ? " + productZeroCondition + " " + openingBalanceZeroConditionSQL+productTypeFilterForZeroIQ;
            }

            String initialQuantity = "select 0 as transType, p.id as pid, p.productid as productid, p.description as description, updatedate as date, 'Initial Quantity' as transactionNumber, p.productid as acccode, ' ' as name,inv.id as vid, inv.quantity  as invquantity,pl.price as rate, inv.baseuomrate,' ' as landedinvoice,p.currency as currency, '1' as grid, IFNULL(inv.id,' ') as rowid,' ' as spotrate,p.id as detailid,p.unitOfMeasure as uom,' ' as rowdetailid,' ' as srno, p.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname as batchid,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, 0 as discount, 0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",' ' as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from inventory inv  "
                    + " left join " + productTableJoin + " on p.id = inv.product  "
                    + " left join pricelist pl on pl.product = p.id and pl.affecteduser = '-1' and pl.carryin='T' and pl.initialprice='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_CONDITION+" and pl.currency=p.currency and (pl.applydate =(select max(applydate) as ld from pricelist where pricelist.product=inv.product and pricelist.carryin='T' and pricelist.initialprice = 'T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_INNER_CONDITION+" and pricelist.currency=pl.currency and  pricelist.affecteduser='-1'  and pricelist.applydate<=inv.updatedate and inv.company=? " + productCondition +prductTypeFilter+" group by inv.product))  "
                    + " left join locationbatchdocumentmapping lbdm on p.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + initialStockMovementJoin
                    + " where inv.newinv='T' and inv.defective='F' and inv.carryin='T' and inv.company = ? and inv.quantity!=0 " + productCondition + " " + openingBalanceConditionSQL+" "+storeCondition1 + batchNameSearchString  + prductTypeFilter;
           
            String grStockMovementJoin = "";
            if (isMaterialInOutReport) {
                grStockMovementJoin =  " left join in_stockmovement sm on sm.modulerefdetailid = grod.id and npb.warehouse= sm.store and sm.product = p.id ";
            }
            
            String grOrder = " select 1 as transType, p.id as pid, p.productid as productid, grod.description as description, gro.grorderdate as date, gro.gronumber as transactionNumber, v.acccode as acccode, v.name as name, v.id as vid, inv.quantity  as invquantity, grod.rate as rate, inv.baseuomrate, ' ' as landedinvoice, gro.currency ,grd.goodsreceipt as grid, IFNULL(gro.id,' ') as rowid, gro.externalcurrencyrate as spotrate,grod.id as detailid,grod.uom as uom,grod.id as rowdetailid,grod.srno as srno, gro.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin, npb.batchname,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, grod.discount as discount,grod.discountispercent as discountispercent,gro.gstincluded as gstincluded,'F' as serialjson " + stockMovementParameters + ",gro.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from grorder gro "
                    + " left join grodetails grod on grod.grorder = gro.id "
                    + " left join inventory inv on inv.id = grod.id "
                    + " left join " + productTableJoin + " on p.id = inv.product "
                    + " left join vendor v on v.id = gro.vendor "
                    + " left join grdetails grd on (grd.id = grod.videtails) "
                    + " left join locationbatchdocumentmapping lbdm on grod.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + grStockMovementJoin
                    + " where gro.company = ? and gro.deleteflag='F' and gro.approvestatuslevel=11 and inv.quantity!=0 " + vendorCondition + " " + productCondition + " " + goodsReceiptConditionSQL+" "+storeCondition1 + batchNameSearchString  + prductTypeFilter;
            
            String prStockMovementJoin = "";
            if (isMaterialInOutReport) {
                prStockMovementJoin = " left join in_stockmovement sm on sm.modulerefdetailid = prd.id and npb.warehouse= sm.store and sm.product = p.id ";
            }
            String purchaseReturn = " select 2 as transType, p.id as pid, p.productid as productid , prd.description as description, pr.orderdate as date, pr.prnumber as transactionNumber, v.acccode as acccode, v.name as name, v.id as vid, inv.quantity  as invquantity, prd.rate as rate, inv.baseuomrate, ' ' as landedinvoice, pr.currency, IFNULL(pr.id,' ') as grid, pr.id as rowid,pr.externalcurrencyrate as spotrate,prd.id as detailid,prd.uom as uom,prd.id as rowdetailid,prd.srno as srno, pr.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,IFNULL(prd.grdetails,IFNULL(grd.grorderdetails,' ')) as linktransaction, ' ' AS serialnames, prd.discount as discount, prd.discountispercent as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",pr.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from purchasereturn pr "
                    + " left join prdetails prd on prd.purchasereturn = pr.id "
                    + " left join inventory inv on inv.id = prd.id "
                    + " left join " + productTableJoin + " on p.id = inv.product "
                    + " left join vendor v on v.id = pr.vendor "
                    + " left join grdetails grd on grd.id = prd.videtails "
                    + " left join locationbatchdocumentmapping lbdm on prd.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + prStockMovementJoin
                    + " where pr.company = ? and pr.deleteflag='F' and inv.quantity!=0 " + vendorCondition + " " + productCondition + " " + purchaseReturnConditionSQL+" "+storeCondition1+  batchNameSearchString  + prductTypeFilter;
            
            String assemblySubProductJoin = "";
            if (isMaterialInOutReport) {
                assemblySubProductJoin = " left join in_stockmovement sm on sm.modulerefdetailid = productbuild.id and npb.warehouse= sm.store and sm.product = p.id ";
            }
            String assemblySubProduct = "select 5 as transType, p.id as pid, p.productid as productid, p.description as description, productbuild.entrydate as date, productbuild.refno as transactionNumber,' ' as acccode ,' ' as name ,' ' as vid,(inventoryquantity*productbuild.quantity),pb.rate as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(pb.id,' ') as rowid,' ' as spotrate,pb.id as detailid,p.unitOfMeasure as uom,pb.id as rowdetailid,' ' as srno,  productbuild.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, 0 as discount, 0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",productbuild.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from pbdetails pb "
                    + " inner join productbuild on productbuild.id=pb.build "
                    + " left join " + productTableJoin + " on p.id = pb.aproduct "
                    + " left join locationbatchdocumentmapping lbdm on pb.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + assemblySubProductJoin
                    + " where productbuild.isBuild='T' AND productbuild.company = ? and (inventoryquantity*productbuild.quantity)!=0" + productCondition + " " + buildassemblyConditionSQL+" "+storeCondition1+ batchNameSearchString  + prductTypeFilter;
           
            String assemblyMainProductJoin = "";
            if (isMaterialInOutReport) {
                assemblyMainProductJoin = " left join in_stockmovement sm on sm.modulerefdetailid = pb.id and npb.warehouse= sm.store and sm.product = p.id ";
            }
            String assemblyMainProduct = " select 6 as transType, p.id as pid, p.productid as productid, p.description as description, pb.entrydate as date, pb.refno as transactionNumber,' ' as acccode ,' ' as name ,' ',pb.quantity,(pb.productcost/pb.quantity) as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(pb.id,' ') as rowid,' ' as spotrate,pb.id as detailid,p.unitOfMeasure as uom,' ' as rowdetailid,' ' as srno, pb.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames , 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+ stockMovementParameters+ ",pb.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from productbuild pb "
                    + " left join " + productTableJoin + " on p.id = pb.product "
                    + " left join locationbatchdocumentmapping lbdm on pb.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + assemblyMainProductJoin
                    + " where pb.isBuild='T' AND pb.company = ? and pb.refno != ' ' and pb.quantity!=0 " + productCondition + " " + buildassemblyMainConditionSQL+" "+storeCondition1+ batchNameSearchString  + prductTypeFilter;
            
            String unbuildSubProduct = "select 6 as transType, p.id as pid, p.productid as productid, p.description as description, productbuild.entrydate as date, productbuild.refno as transactionNumber,' ' as acccode ,' ' as name ,' ' as vid,(inventoryquantity*productbuild.quantity),pb.rate as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(pb.id,' ') as rowid,' ' as spotrate,pb.id as detailid,p.unitOfMeasure as uom,pb.id as rowdetailid,' ' as srno, productbuild.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson " +stockMovementParameters + ",productbuild.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from pbdetails pb "
                    + " inner join productbuild on productbuild.id=pb.build "
                    + " left join " + productTableJoin + " on p.id = pb.aproduct "
                    + " left join locationbatchdocumentmapping lbdm on pb.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + assemblySubProductJoin
                    + " where productbuild.isBuild='F' AND productbuild.company = ? and (inventoryquantity*productbuild.quantity)!=0 " + productCondition + " " + buildassemblyConditionSQL+" "+storeCondition1+ batchNameSearchString  + prductTypeFilter;
            
            String unbuildMainProduct = " select 5 as transType, p.id as pid, p.productid as productid, p.description as description, pb.entrydate as date, pb.refno as transactionNumber,' ' as acccode ,' ' as name ,' ',pb.quantity,(pb.productcost/pb.quantity) as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(pb.id,' ') as rowid,' ' as spotrate,pb.id as detailid,p.unitOfMeasure as uom,' ' as rowdetailid,' ' as srno, pb.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, 0 as discount, 0 as discountispercent,'F' as gstincluded,'F' as serialjson " +stockMovementParameters + ",pb.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from productbuild pb "
                    + " left join " + productTableJoin + " on p.id = pb.product "
                    + " left join locationbatchdocumentmapping lbdm on pb.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + assemblyMainProductJoin
                    + " where pb.isBuild='F' AND pb.company = ? and pb.refno != ' ' and pb.quantity!=0 " + productCondition + " " + buildassemblyMainConditionSQL+" "+storeCondition1+ batchNameSearchString   + prductTypeFilter;
            
            String salesReturnJoin = "";
            if (isMaterialInOutReport) {
                salesReturnJoin = " left join in_stockmovement sm on sm.modulerefdetailid = srd.id and npb.warehouse= sm.store and sm.product = p.id ";
            }
            String salesReturn = " select 4 as transType, p.id as pid, p.productid as productid, srd.description as description, sr.orderdate as date, sr.srnumber as transactionNumber, c.acccode as acccode, c.name as name, c.id as vid, inv.quantity as invquantity, srd.rate as rate, inv.baseuomrate, ' ' as landedinvoice, sr.currency, ' ' as grid, IFNULL(sr.id,' ') as rowid,sr.externalcurrencyrate as spotrate,srd.id as detailid,srd.uom as uom,srd.id as rowdetailid,srd.srno as srno, sr.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,IFNULL(srd.dodetails,' ') as linktransaction, ' ' AS serialnames, srd.discount as discount,srd.discountispercent as discountispercent,'F' as gstincluded,'F' as serialjson "+ stockMovementParameters + ",sr.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from salesreturn sr "
                    + " left join srdetails srd on srd.salesreturn = sr.id "
                    + " left join inventory inv on inv.id = srd.id "
                    + " left join " + productTableJoin + " on p.id = inv.product "
                    + " left join customer c on c.id = sr.customer "
                    + " left join locationbatchdocumentmapping lbdm on srd.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + salesReturnJoin
                    + " where sr.company = ? and sr.deleteflag='F' and inv.quantity!=0 " + customerCondition + " " + productCondition + " " + salesReturnConditionSQL+" "+storeCondition1+ batchNameSearchString   + prductTypeFilter;
            
            String deliveryOrderJoin = "";
            if (isMaterialInOutReport) {
                deliveryOrderJoin = " left join in_stockmovement sm on sm.modulerefdetailid = dod.id and npb.warehouse= sm.store and sm.product = p.id ";
            }
            String deliveryOrder = "select 3 as transType, p.id as pid, p.productid as productid, dod.description as description, do.orderdate as date, do.donumber as transactionNumber, c.acccode as acccode, c.name as name, c.id as vid, inv.quantity  as invquantity, dod.rate as rate, inv.baseuomrate, ' ' as landedinvoice, do.currency, ' ' as grid, IFNULL(do.id,' ') as rowid, do.externalcurrencyrate as spotrate,dod.id as detailid,dod.uom as uom,dod.id as rowdetailid,dod.srno as srno, do.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, dod.discount as discount,dod.discountispercent as discountispercent,do.gstincluded as gstincluded,'F' as serialjson "+stockMovementParameters+ ",do.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from deliveryorder do "
                    + " left join dodetails dod on dod.deliveryorder = do.id "
                    + " left join inventory inv on inv.id = dod.id "
                    + " left join " + productTableJoin + " on p.id = inv.product "
                    + " left join customer c on c.id = do.customer "
                    + " left join locationbatchdocumentmapping lbdm on dod.id=lbdm.documentid "
                    + " inner join newproductbatch npb on lbdm.batchmapid=npb.id"
                    + deliveryOrderJoin
                    + " where do.company = ? and do.deleteflag= 'F' and do.approvestatuslevel=11 and inv.quantity!=0 " + customerCondition + " " + productCondition + " " + deliveryOrderConditionSQL+" "+storeCondition1+ batchNameSearchString  + prductTypeFilter;
            
            String inventoryStockJoin = "";
            if (isMaterialInOutReport) {
                inventoryStockJoin = " left join in_stockmovement sm on sm.modulerefid = sa.id and sm.product = p.id ";
            }
            String batchSearchStringForAdjustment = "";
            batchSearchStringForAdjustment = (StringUtil.isNullOrEmpty(batchNameSearch) ? "" : " and sad.batchname like '%" + batchNameSearch + "%'");
            /**
             * Alias 'sad' has been merged into alias 'sa' during optimization under ERP-38112
             * therefore the check 'sad.batchname' is replaced by 'sa.batchname'
             */
            String batchSearchStringForAdjustmentNewOptimized = "";
            batchSearchStringForAdjustmentNewOptimized = (StringUtil.isNullOrEmpty(batchNameSearch) ? "" : " and sa.batchname like '%" + batchNameSearch + "%'");
            String inventoryStockIN = " select 7 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, sa.finalquantity  as invquantity,sa.amount as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(sa.id,' ') as rowid, ' ' as spotrate, sa.id as detailid,sa.uom as uom,sa.rowdetailid,' ' as srno,sa.creationdate  as createdon,' ',sa.sadlocation,sa.store,sa.row,sa.rack,sa.bin,sa.batchname,sa.sadfinalquantity,' ' as linktransaction, sa.serialnames, 0 as discount, 0 as discountispercent,'F' as gstincluded,'F' as serialjson"+stockMovementParameters+ ",sa.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.id as rowdetailid, sad.location as sadlocation,sad.row,sad.rack,sad.bin,sad.batchname,sad.finalquantity as sadfinalquantity, sad.finalserialnames AS serialnames from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment) sa  "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + inventoryStockJoin
                    + " where sa.isdeleted='F' and sa.adjustment_type='Stock IN' and sa.company =? and -(sa.finalquantity)!=0  " + productCondition + " " + stockInSQL+" "+storeCondition2+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                    
            String InventoryStockSALES = " select 8 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, -(sa.finalquantity) as invquantity,sa.amount as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(sa.id,' ') as rowid, ' ' as spotrate, sa.id as detailid,sa.uom as uom,sa.rowdetailid,' ' as srno,sa.creationdate as createdon,' ',sa.sadlocation,sa.store,sa.row,sa.rack,sa.bin,sa.batchname,sa.sadfinalquantity,' ' as linktransaction, sa.serialnames , 0 as discount , 0 as discountispercent,'F' as gstincluded,'F' as serialjson"+stockMovementParameters+ " ,sa.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.id as rowdetailid, sad.location as sadlocation,sad.row,sad.rack,sad.bin,sad.batchname,sad.finalquantity as sadfinalquantity, sad.serialnames AS serialnames from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment) sa "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + inventoryStockJoin
                    + " where sa.isdeleted='F' and (sa.adjustment_type='Stock Sales') and sa.company =? and -(sa.finalquantity)!=0 " + productCondition + " " + stockSalesSQL+" "+storeCondition2+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                    
            String inventoryStockOUT = " select 8 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, -(sa.finalquantity) as invquantity,sa.amount as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(sa.id,' ') as rowid, ' ' as spotrate, sa.id as detailid,sa.uom as uom,sa.rowdetailid,' ' as srno,sa.creationdate as createdon,' ',sa.sadlocation,sa.store,sa.row,sa.rack,sa.bin,sa.batchname,sa.sadfinalquantity,' ' as linktransaction, sa.serialnames, 0 as discount, 0 as discountispercent,'F' as gstincluded,'F' as serialjson "+ stockMovementParameters+ ",sa.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.id as rowdetailid, sad.location as sadlocation,sad.row,sad.rack,sad.bin,sad.batchname,sad.finalquantity as sadfinalquantity, sad.serialnames AS serialnames from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment) sa "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + inventoryStockJoin
                    + " where sa.isdeleted='F' and (sa.adjustment_type='Stock OUT') and sa.company =? and -(sa.finalquantity)!=0 " + productCondition + " " + stockOutSQL+" "+storeCondition2+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                    
            String inventorySRIssue = " select 9 as transType, p.id as pid,p.productid as productid, p.description as description, "
                    + " CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.transactionno as transactionNumber,"
                    + " ' ' as acccode, ' ' as name, ' ' as vid, sm.quantity as invquantity, IFNULL(sm.priceperunit,0) as rate,1,"
                    + " ' ' as landedinvoice,' ', ' ' as grid, IFNULL(sa.id,' ') as rowid, ' ' as spotrate,"
                    + "  sm.smid as detailid,sa.uom as uom,sa.rowdetailid,' ' as srno,sa.issueddate as createdon,"
                    + " ' ',sm.location as issued_location,sm.store as tostore,sm.row as issued_row,sm.rack as issued_rack,sm.bin as issued_bin,sm.batchname, "
                    + " sm.quantity as invquantity,''as linktransaction, sm.serialnames, 0 as discount,0 as discountispercent,"
                    + " 'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",' ' as memo, p.isserialforproduct,"
                    + " p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.issuedqty as invquantity, sad.id as rowdetailid, sad.issued_location,sad.issued_row, "
                    + " sad.issued_rack,sad.issued_bin,sad.batchname, sad.issued_serialnames AS serialnames from in_goodsrequest sa1 "
                    + " inner join in_sr_detail sad on sa1.id=sad.stockrequest ) sa  "
                    + " LEFT JOIN (select sm1.*, ism.id as ismid, ism.quantity, ism.location, ism.row,ism.rack,ism.bin,ism.batchname, "
                    + " ism.serialnames AS serialnames from (SELECT id as smid,createdon,modulerefid, priceperunit, remark, assembled_product,"
                    + " costcenter,stockuom,id,store  FROM in_stockmovement WHERE company = '"+companyid+"' and transaction_type <> 1 ) sm1 "
                    + " inner JOIN in_sm_detail ism on sm1.id=ism.stockmovement ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where  sa.module = 0 and sa.company =? and sm.quantity!=0 " + productCondition + " " + srIssueSQL+" "+storeCondition4+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter+" group by sm.ismid";
                   
            String inventorySRCollect = " select 10 as transType, p.id as pid,p.productid as productid, p.description as description, "
                    + " CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.transactionno as transactionNumber, ' ' as acccode,"
                    + " ' ' as name, ' ' as vid, sm.quantity as invquantity, IFNULL(sm.priceperunit,0) as rate,1, ' ' as landedinvoice,' ',"
                    + " ' ' as grid, IFNULL(CONCAT(sa.id,'collect'),' ') as rowid, ' ' as spotrate, CONCAT(sm.smid,'collect') as detailid,"
                    + " sa.uom as uom, sa.rowdetailid,' ' as srno,sa.issueddate as createdon,' ',sm.location as delivered_location,sm.store as fromstore,"
                    + " sm.row as delivered_row,sm.rack as delivered_rack,sm.bin as delivered_bin,sm.batchname,sm.quantity as invquantity,''as linktransaction, sm.serialnames,"
                    + " 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",' ' as memo,"
                    + " p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from ( select sa1.*, sad.deliveredqty as invquantity, CONCAT(sad.id,'collect') as rowdetailid, sad.delivered_location,"
                    + " sad.delivered_row,sad.delivered_rack,sad.delivered_bin,sad.batchname, sad.delivered_serialnames AS serialnames "
                    + " from in_goodsrequest sa1 inner join in_sr_detail sad on sa1.id=sad.stockrequest ) sa "
                    + " LEFT JOIN (select sm1.*, ism.id as ismid, ism.quantity, ism.location, ism.row,ism.rack,ism.bin,ism.batchname, "
                    + " ism.serialnames AS serialnames from (SELECT id as smid,createdon,modulerefid, priceperunit, remark, assembled_product,"
                    + " costcenter,stockuom,id,store  FROM in_stockmovement WHERE company = '"+companyid+"' and transaction_type = 1 ) sm1 "
                    + " inner JOIN in_sm_detail ism on sm1.id=ism.stockmovement ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.delivered_location IS NOT NULL  AND sa.module = 0 and  sa.company =? and "
                    + " sm.quantity!=0 " + productCondition + " " + srCollectSQL+" "+storeCondition3+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter +" group by sm.ismid";
                    
            String inventoryINIssue = " select 11 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, sa.invquantity, IFNULL(sm.priceperunit,0) as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(sa.id,' ') as rowid, ' ' as spotrate, sa.id as detailid,sa.uom as uom,sa.rowdetailid,' ' as srno,sa.issueddate as createdon,' ',sa.issued_location,sa.fromstore,sa.issued_row,sa.issued_rack,sa.issued_bin,sa.batchname,sa.invquantity,''as linktransaction, sa.serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",' ' as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.issuedqty as invquantity,sad.id as rowdetailid,sad.issued_location,sad.issued_row,sad.issued_rack,sad.issued_bin,sad.batchname, sad.issued_serialnames AS serialnames from in_goodsrequest sa1 inner join in_sr_detail sad on sa1.id=sad.stockrequest ) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type <> 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.module = 1 and sa.company =? and sa.invquantity!=0 " + productCondition + " " + issuenoteIssueSQL+" "+storeCondition3+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                    
            String inventoryINCollect = "select 12 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, sa.invquantity, IFNULL(sm.priceperunit,0) as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(CONCAT(sa.id,'collect'),' ') as rowid, ' ' as spotrate, CONCAT(sa.id,'collect') as detailid,sa.uom as uom,sa.rowdetailid,' ' as srno,sa.collecteddate as createdon,' ',sa.delivered_location,sa.tostore,sa.delivered_row,sa.delivered_rack,sa.delivered_bin,sa.batchname,sa.invquantity,''as linktransaction, sa.serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",' ' as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.deliveredqty as invquantity,CONCAT(sad.id,'collect') as rowdetailid,sad.delivered_location,sad.delivered_row,sad.delivered_rack,sad.delivered_bin,sad.batchname, sad.delivered_serialnames AS serialnames from in_goodsrequest sa1 inner join in_sr_detail sad on sa1.id=sad.stockrequest) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type = 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.delivered_location IS NOT NULL AND sa.module = 1 and sa.company =? and sa.invquantity!=0 " + productCondition + " " + issuenoteCollectSQL+" "+storeCondition4+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
            //ERP-42074 Changed sm.createdOn(from in_stockmovement table) to sa.creationdate(from in_interstoretransfer table)
            String inventoryISTIssue = "select 13 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(sa.businessdate,'%Y-%m-%d'),date) as date, sa.transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, sm.invquantity, IFNULL(sm.priceperunit,0) as rate,1, ' ' as landedinvoice,' ', ' ' as grid, sa.rowid, ' ' as spotrate, sm.smid as detailid,sa.uom,sa.rowdetailid,' ' as srno,sa.creationdate as createdon,' ',sm.location,sm.store,sm.row,sm.rack,sm.bin,sm.batchname,sm.quantity,' ' as linktransaction, sm.serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",sa.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery +
                    "from ( select sa1.businessdate, sa1.creationdate, sa1.transactionno as transactionNumber, IFNULL(sa1.id,' ') as rowid, sa1.uom, sa1.memo, sa1.product, sa1.transaction_module, sa1.company, sa1.fromstore, sa1.tostore, sad.id as rowdetailid, sad.issuedqty, sad.batchname from in_interstoretransfer sa1 inner join in_ist_detail sad on sa1.id = sad.istrequest WHERE company = '"+companyid+"' ) sa " +
                    "Inner JOIN ( select sm1.*, ism.id as ismid, ism.quantity as invquantity, ism.location, ism.row,ism.rack,ism.bin,ism.batchname,ism.quantity, ism.serialnames AS serialnames from ( SELECT id as smid,createdon,modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom,id,store " +
                    "FROM in_stockmovement WHERE company = '"+companyid+"' and transaction_type <> 1 ) sm1 Inner JOIN in_sm_detail ism on sm1.smid=ism.stockmovement ) sm ON sm.modulerefid = sa.rowid " +
                    "left join " + productTableJoin + " on p.id = sa.product " +
                    "where sa.transaction_module = 2 and sa.company =? and sa.issuedqty!=0 " + productCondition + " " + istIssueSQL+" "+storeCondition3+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter +" group by sm.ismid";
            //ERP-42074 Changed sm.createdOn(from in_stockmovement table) to sa.creationdate(creationdate from in_interstoretransfer table)
            String inventoryISTCollect = "select 14 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, sm.quantity as invquantity,  IFNULL(sm.priceperunit,0) as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(CONCAT(sa.id,'collect'),' ') as rowid, ' ' as spotrate, CONCAT(sm.smid,'collect') as detailid,sa.uom as uom, sm.ismid as rowdetailid,' ' as srno,sa.creationdate as createdon,' ',sm.location,sm.store,sm.row,sm.rack,sm.bin,sm.batchname,sm.quantity,' ' as linktransaction, sm.serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",sa.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery +
                    "from ( select sa1.*, CONCAT(sad.id,'collect') as rowdetailid, sad.batchname from in_interstoretransfer sa1 inner join in_ist_detail sad on sa1.id=sad.istrequest WHERE company = '"+companyid+"' ) sa " +
                    "inner JOIN (select sm1.*, ism.id as ismid, ism.quantity, ism.location, ism.row,ism.rack,ism.bin,ism.batchname, ism.serialnames AS serialnames from (SELECT id as smid,createdon,modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom,id,store  FROM in_stockmovement WHERE company = '"+companyid+"' and transaction_type = 1 ) sm1 inner JOIN in_sm_detail ism on sm1.id=ism.stockmovement ) sm ON sm.modulerefid = sa.id " +
                    "left join " + productTableJoin + " on p.id = sa.product  " +
                    "where  sa.transaction_module = 2 and sa.company = ?  " + productCondition + " " + istCollectSQL+" "+storeCondition4+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter +" Group by sm.ismid";
           
            String inventoryILTIssue = " select 15 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, sa.invquantity, IFNULL(sm.priceperunit,0) as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(sa.id,' ') as rowid, ' ' as spotrate, sa.id as detailid,sa.uom as uom,sa.rowdetailid,' ' as srno,sa.creationdate as createdon,' ',sa.issued_location,sa.fromstore,sa.issued_row,sa.issued_rack,sa.issued_bin,sa.batchname,sa.invquantity,' ' as linktransaction, sa.serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson " + stockMovementParameters + ",sa.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from ( select sa1.*, sad.issuedqty as invquantity,sad.id as rowdetailid,sad.issued_location,sad.issued_row,sad.issued_rack,sad.issued_bin,sad.batchname, sad.issued_serialnames AS serialnames from in_interstoretransfer sa1 inner join in_ist_detail sad on sa1.id=sad.istrequest ) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type <> 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.transaction_module = 11 and sa.company =? and sa.invquantity!=0 and sa.status <> 5 " + productCondition + " " + iltIssueSQL+" "+storeCondition3+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;

            String inventoryILTCollect = " select 16 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, sa.invquantity,  IFNULL(sm.priceperunit,0) as rate,1, ' ' as landedinvoice,' ', ' ' as grid, IFNULL(CONCAT(sa.id,'collect'),' ') as rowid, ' ' as spotrate, CONCAT(sa.id,'collect') as detailid,sa.uom as uom,sa.rowdetailid,' ' as srno,sa.modifieddate as createdon,' ',sa.delivered_location,sa.tostore,sa.delivered_row,sa.delivered_rack,sa.delivered_bin,sa.batchname,sa.invquantity,' ' as linktransaction, sa.serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",sa.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + " from ( select sa1.*, sad.deliveredqty as invquantity,CONCAT(sad.id,'collect') as rowdetailid,sad.delivered_location,sad.delivered_row,sad.delivered_rack,sad.delivered_bin,sad.batchname, sad.delivered_serialnames AS serialnames from in_interstoretransfer sa1 inner join in_ist_detail sad on sa1.id=sad.istrequest ) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type = 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.delivered_location IS NOT NULL AND  sa.transaction_module = 11 and sa.company =? and sa.invquantity!=0 and sa.status <> 5 " + productCondition + " " + iltCollectSQL+" "+storeCondition4+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
           
            String workOrder = "";
            String workOrderDetails = "";
            if (isActivateMRPModule) {
                /** 
                 * transType 17 is used for Assembly item IN. 
                 */
                workOrder = "select 17 as transType, p.id, p.productid as productid, p.description as description, sm.transaction_date as date, wo.workorderid as transactionNumber,c.acccode as acccode, c.name as name, c.id,if(wo.producedquantity>0,wo.producedquantity,wo.quantity),sm.priceperunit as rate,1, '' as landedinvoice,'', '' as grid, IFNULL(wo.id,'') as rowid,'' as spotrate,sm.id as detailid,p.unitOfMeasure as uom,'' as rowdetailid,sm.auto_sequence as srno, sm.createdon as createdon,'',ism.location, sm.store, ism.row,ism.rack,ism.bin,ism.batchname,ism.quantity,'' as linktransaction, '' AS serialnames , 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson " + stockMovementParameters + ",sm.remark, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                        + " from workorder wo "
                        + " inner join workordercomponentdetail wod  on wo.id = wod.workOrder "
                        + " left join " + productTableJoin + " on p.id = wo.productid "
                        + " left join customer c on c.id = wo.customer "
                        + " inner join  productassembly pa on pa.subproducts = wod.product and pa.product=wod.parentProduct"
                        + " inner join in_stockmovement sm on sm.modulerefid=wo.id and sm.product = p.id"
                        + " inner join in_sm_detail ism on sm.id=ism.stockmovement"
                        + " where sm.transaction_module=16 and wo.company = ? and p.producttype !='" + Constants.Inventory_Non_Sales + "' and wo.quantity!=0 " + productCondition + " " + workOrderDetailsConditionSQL + " "  + storeCondition5 + "GROUP BY ism.id";
             
                String transactionConditionForValuation="";
                          
                if (isValuationCall){
                    transactionConditionForValuation = "if(sm.stock_management_flag=1,sm.transaction_type in (1,2),sm.transaction_type in (2)) and";
                }

                /**
                 * transType 18 is used for Inventory Part Item OUT.
                 */
                workOrderDetails = "select (select case when p.producttype='"+Constants.ASSEMBLY+"' then (select case when (sm.transaction_type=1) then 17 else 18 END) else (select case when pa.componenttype = 2 or pa.componenttype = 3 then 17 else (select case when (sm.transaction_type=1) then 17 else 18 END) END) END) as transType, p.id, p.productid as productid, p.description as description, sm.transaction_date as date, wo.workorderid as transactionNumber,c.acccode as acccode, c.name as name, c.id,wo.quantity,(case when pa.componenttype = 2 or pa.componenttype = 3 then (case when wod.parentProduct = wo.productid then (wod.initialpurchaseprice/(wod.producedquantity)) else 0 end) else sm.priceperunit end) as rate,1, '' as landedinvoice,'', '' as grid, IFNULL(wo.id,'') as rowid,'' as spotrate,sm.id as detailid,p.unitOfMeasure as uom,'' as rowdetailid,sm.auto_sequence as srno, sm.createdon as createdon,'',ism.location, sm.store, ism.row,ism.rack,ism.bin,ism.batchname,if(sm.transaction_module='16',ism.quantity,ism.quantity),'' as linktransaction, '' AS serialnames , 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson " + stockMovementParameters + ",sm.remark, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                        + " from workordercomponentdetail wod "            
                        + " inner join workorder wo on wo.id = wod.workOrder "
                        + " left join " + productTableJoin + " on p.id = wod.product "
                        + " inner join productassembly pa on pa.subproducts = p.id and pa.product = wod.parentProduct"
                        + " left join customer c on c.id = wo.customer "                                           
                        + " inner join in_stockmovement sm on sm.modulerefdetailid = wod.id and sm.product = p.id"
                        + " inner join in_sm_detail ism on sm.id=ism.stockmovement"
                        + " where sm.transaction_module=16 and "+transactionConditionForValuation+" wod.isblockqtyused=if(pa.componenttype = 0 or pa.componenttype=1,'T','F') and wo.company = ? and p.producttype !='" + Constants.Inventory_Non_Sales + "' and wo.quantity!=0  " + productCondition + " " + workOrderDetailsConditionSQL + " " +  storeCondition5+"GROUP BY ism.id";
            }
            
            String mysqlQuery = "";
            if (docType == 1) {
                params.addAll(openingBalanceParams);
                if (!StringUtil.isNullOrEmpty(initialQuantityZeroQty)) {
                    /**
                     * Don't add query parameters for zero initial quantity if
                     * search is applied on batch name.
                     */
                    params.addAll(openingZeroBalanceParams);
                }
                params.addAll(goodsReceiptParams);
                params.addAll(purchaseReturnParams);
                params.addAll(stockInParams);
                mysqlQuery = " SELECT * FROM ("
                        + " (" + initialQuantity + ") ";
                if (!StringUtil.isNullOrEmpty(initialQuantityZeroQty)) {
                    /**
                     * No need to add zero initial quantity query if search is
                     * applied on batch name.
                     */
                    mysqlQuery += " UNION "
                        + " (" + initialQuantityZeroQty + ") ";
                }
                mysqlQuery += " UNION "
                        + " (" + grOrder + ") "
                        + " UNION "
                        + " (" + purchaseReturn + ") "
                        + " UNION "
                        + " (" + inventoryStockIN + ") "
                        + " ) as t1  ";
            }
            String unionQry="";
            if (docType == 2) {
                params.addAll(deliveryOrderParams);
                params.addAll(salesReturnParams);
                params.addAll(stockSalesParams);
                mysqlQuery = "SELECT * FROM ("
                        + "(" + deliveryOrder + ")"
                        + " UNION "
                        + " (" + salesReturn + ") "
                        + " UNION "
                        + " (" + InventoryStockSALES + ")"
                        + " ) as  ";
            }
            if (docType == 0) {
                params.addAll(openingBalanceParams);
                if (!StringUtil.isNullOrEmpty(initialQuantityZeroQty)) {
                    /**
                     * Don't add query parameters for zero initial quantity if
                     * search is applied on batch name.
                     */
                    params.addAll(openingZeroBalanceParams);
                }
                params.addAll(goodsReceiptParams);
                params.addAll(purchaseReturnParams);
                params.addAll(assemblyProductParams);
                params.addAll(unbuildProductParams);
                params.addAll(assemblyProductParamsMain);
                params.addAll(unbuildProductParamsMain);
                params.addAll(deliveryOrderParams);
                params.addAll(salesReturnParams);
                params.addAll(stockInParams);
                params.addAll(stockSalesParams);
                params.addAll(stockOutParams);
                params.addAll(srCollectParams);
                params.addAll(srIssueParams);
                params.addAll(issuenoteCollectParams);
                params.addAll(issuenoteIssueParams);
                params.addAll(istCollectParams);
                params.addAll(istIssueParams);
                params.addAll(iltCollectParams);
                params.addAll(iltIssueParams);
                if (isActivateMRPModule) {
                    params.addAll(workOrderParams);
                    params.addAll(workOrderDetailsParams);
                }
                unionQry = " ("
                        + " (" + initialQuantity + ") ";
                if (!StringUtil.isNullOrEmpty(initialQuantityZeroQty)) {
                    /**
                     * Add query for zero initial quantity if search is not
                     * applied on batch name.
                     */
                    unionQry += " UNION "
                        + " (" + initialQuantityZeroQty + ") ";
                }
                unionQry += " UNION "
                        + " (" + grOrder + ") "
                        + " UNION "
                        + " (" + purchaseReturn + ") "
                        + " UNION "
                        + " (" + assemblySubProduct + ") "
                        + " UNION "
                        + " (" + unbuildSubProduct + ") "
                        + " UNION "
                        + " (" + assemblyMainProduct + ") "
                        + " UNION "
                        + " (" + unbuildMainProduct + ") "
                        + " UNION"
                        + " (" + deliveryOrder + ") "
                        + " UNION "
                        + " (" + salesReturn + ") "
                        + " UNION "
                        + " (" + inventoryStockIN + ") "
                        + " UNION "
                        + " (" + InventoryStockSALES + ") "
                        + " UNION "
                        + " (" + inventoryStockOUT + ") "
                        + " UNION "
                        + " (" + inventorySRIssue + ") "
                        + " UNION "
                        + " (" + inventorySRCollect + ") "
                        + " UNION "
                        + " (" + inventoryINIssue + ") "
                        + " UNION "
                        + " (" + inventoryINCollect + ") "
                        + " UNION "
                        + " (" + inventoryISTIssue + ") "
                        + " UNION "
                        + " (" + inventoryISTCollect + ") "
                        + " UNION "
                        + " (" + inventoryILTIssue + ") "
                        + " UNION "
                        + " (" + inventoryILTCollect + ") ";
                     
                /**
                 * IF MRP is Activate then append UNION with transType 17 and transType 18 query. 
                 */
                if (isActivateMRPModule) { 
                        unionQry += " UNION "
                                + " (" + workOrder + ") "
                                + " UNION "
                                + " (" + workOrderDetails + ") ";
                    }
                
                unionQry+= " ) ";
                       
                String innerCondition = "";
                String pagingQry = "";

                if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false && (isFromStockReport || isInventoryValuation || isFromStockSummaryReport)) {
                    String t2CondiQuer = " ";
                    params.addAll(openingBalanceParams);
                    if (!StringUtil.isNullOrEmpty(initialQuantityZeroQty)) {
                        /**
                         * Don't add query parameters for zero initial quantity
                         * if search is applied on batch name.
                         */
                        params.addAll(openingZeroBalanceParams);
                    }
                    params.addAll(goodsReceiptParams);
                    params.addAll(purchaseReturnParams);
                    params.addAll(assemblyProductParams);
                    params.addAll(unbuildProductParams);
                    params.addAll(assemblyProductParamsMain);
                    params.addAll(unbuildProductParamsMain);
                    params.addAll(deliveryOrderParams);
                    params.addAll(salesReturnParams);
                    params.addAll(stockInParams);
                    params.addAll(stockSalesParams);
                    params.addAll(stockOutParams);
                    params.addAll(srCollectParams);
                    params.addAll(srIssueParams);
                    params.addAll(issuenoteCollectParams);
                    params.addAll(issuenoteIssueParams);
                    params.addAll(istCollectParams);
                    params.addAll(istIssueParams);
                    params.addAll(iltCollectParams);
                    params.addAll(iltIssueParams);

                    innerCondition = " INNER JOIN (SELECT distinct id FROM " + unionQry + " as t2 " + t2CondiQuer + " order by t2.id LIMIT " + start + "," + limit + ") as prodInnerQry ON prodInnerQry.id=t1.id ";

                    pagingQry = " SELECT distinct id FROM " + unionQry + " as t2 " + t2CondiQuer;

                    pagingParams.addAll(openingBalanceParams);
                    if (!StringUtil.isNullOrEmpty(initialQuantityZeroQty)) {
                        /**
                         * Don't add query parameters for zero initial quantity
                         * if search is applied on batch name.
                         */
                        params.addAll(openingZeroBalanceParams);
                    }
                    pagingParams.addAll(goodsReceiptParams);
                    pagingParams.addAll(purchaseReturnParams);
                    pagingParams.addAll(assemblyProductParams);
                    pagingParams.addAll(unbuildProductParams);
                    pagingParams.addAll(assemblyProductParamsMain);
                    pagingParams.addAll(unbuildProductParamsMain);
                    pagingParams.addAll(deliveryOrderParams);
                    pagingParams.addAll(salesReturnParams);
                    pagingParams.addAll(stockInParams);
                    pagingParams.addAll(stockSalesParams);
                    pagingParams.addAll(stockOutParams);
                    pagingParams.addAll(srCollectParams);
                    pagingParams.addAll(srIssueParams);
                    pagingParams.addAll(issuenoteCollectParams);
                    pagingParams.addAll(issuenoteIssueParams);
                    pagingParams.addAll(istCollectParams);
                    pagingParams.addAll(istIssueParams);
                    pagingParams.addAll(iltCollectParams);
                    pagingParams.addAll(iltIssueParams);

                    pagingReturnList = executeSQLQuery(pagingQry, pagingParams.toArray());
                }
                mysqlQuery = "SELECT * FROM " + unionQry + " as t1 " + innerCondition ;
            }
            if (isAdvanceSearch && !isAdvanceSearchForValuation) {
                params.clear();
                mysqlQuery = "";
                if (productJson.length() > 0) {
                    params.addAll(openingBalanceParams);
                    if (StringUtil.isNullOrEmpty(batchNameSearchString)) {
                        params.addAll(openingZeroBalanceParams);
                    }
                      mysqlQuery = "select 0 as transType, p.id as pid, p.productid as productid, p.description as description, updatedate as date, 'Initial Quantity' as transactionNumber, p.productid as acccode, ' ' as name,inv.id as vid, inv.quantity  as invquantity,pl.price as rate, inv.baseuomrate,' ' as landedinvoice,p.currency as currency, '1' as grid, IFNULL(inv.id,' ') as rowid,' ' as spotrate,p.id as detailid,p.unitOfMeasure as uom,' ' as rowdetailid,' ' as srno, p.createdon  as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname as batchid,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",' ' as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery + " from inventory inv  "
                            + "  left join " + productTableJoin + " on p.id = inv.product "
                            + " left join pricelist pl on pl.product = p.id and pl.affecteduser = '-1' and pl.carryin='T' and pl.initialprice = 'T'  "+Constants.PRICELIST_UOM_STOCK_LEDGER_CONDITION+" and (pl.applydate =(select max(applydate) as ld from pricelist where pricelist.product=inv.product and pricelist.carryin='T' and pricelist.initialprice = 'T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_INNER_CONDITION+" and pricelist.affecteduser='-1'  and pricelist.applydate<=inv.updatedate and inv.company=? "+productCondition+" group by inv.product))"
                            +  productJoin
                            + " left join locationbatchdocumentmapping lbdm on p.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + initialStockMovementJoin
                            + " where inv.newinv='T' and inv.defective='F' and inv.carryin='T' and inv.company = ? and inv.quantity!=0 " +productCondition+" "  + openingBalanceConditionSQL+ batchNameSearchString  + prductTypeFilter;
                            
                    if (StringUtil.isNullOrEmpty(batchNameSearchString)) {
                        /**
                         * Add query for zero initial quantity if search is not
                         * applied on batch name.
                         */
                        mysqlQuery += " UNION "
                                + " select 0 as transType, p.id as pid, p.productid as productid, p.description as description, asofdate as date, 'Initial Quantity' as transactionNumber, p.productid as acccode, ' ' as name,' ' as vid, 0  as invquantity,0 as rate, 1,' ' as landedinvoice,' ' as currency, '1' as grid,' ' as rowid,' ' as spotrate,p.id as detailid,p.unitOfMeasure as uom,' ' as rowdetailid,' ' as srno, p.createdon as createdon, ' ' ,' 'as location,' ' as warehouse,  ' ' as row, ' ' as rack,' ' as bin,' ' as batchid,0 as quantity,' ' as linktransaction, ' ' AS serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson" + emptyStockMovementParameters + ",' ' as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery + " from " + productTableJoin + ""
                                + productZeroJoin
                                + " where p.id not in (select product from inventory where inventory.newinv='T' and inventory.defective='F' and inventory.carryin='T' and inventory.company = ?) and  p.company = ? " + productZeroCondition + " " + openingBalanceZeroConditionSQL+productTypeFilterForZeroIQ;
                    }
                            

                } else  if(serialJson.length() > 0){
                    
                    params.addAll(serialParams);
                    mysqlQuery = "select 0 as transType, p.id as pid, p.productid as productid, p.description as description, updatedate as date, 'Initial Quantity' as transactionNumber, p.productid as acccode, ' ' as name,inv.id as vid, inv.quantity  as invquantity,pl.price as rate, inv.baseuomrate,' ' as landedinvoice,p.currency as currency, '1' as grid, IFNULL(inv.id,' ') as rowid,' ' as spotrate,p.id as detailid,p.unitOfMeasure as uom,' ' as rowdetailid,' ' as srno, p.createdon  as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname as batchid,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'T' as serialjson "+stockMovementParameters+ ",' ' as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery + " from inventory inv  "
                            + "  left join " + productTableJoin + " on p.id = inv.product "
                            + " left join pricelist pl on pl.product = p.id and pl.affecteduser = '-1' and pl.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_CONDITION+" and (pl.applydate =(select max(applydate) as ld from pricelist where pricelist.product=inv.product and pricelist.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_INNER_CONDITION+" and pricelist.affecteduser='-1'  and pricelist.applydate<=inv.updatedate and inv.company=? "+productCondition+" group by inv.product))"
                            + " left join serialdocumentmapping sd on p.id=sd.documentid "
                            +  serialJoin
                            + " left join locationbatchdocumentmapping lbdm on p.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + initialStockMovementJoin
                            + " where inv.newinv='T' and inv.defective='F' and inv.carryin='T' and inv.company = ? and inv.quantity!=0 " +productCondition+" "  + serialConditionSQL+ batchNameSearchString  + prductTypeFilter;
                            
                }
                
                if ((grJson.length() > 0) && (docType == 0 || docType == 1)) {
                    params.addAll(goodsReceiptParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select 1 as transType, p.id as pid, p.productid as productid, grod.description as description, gro.grorderdate as date, gro.gronumber as transactionNumber, v.acccode as acccode, v.name as name, v.id as vid, inv.quantity  as invquantity, grod.rate as rate, inv.baseuomrate, ' ' as landedinvoice, gro.currency, IFNULL(grd.goodsreceipt, grd1.goodsreceipt) as grid, IFNULL(gro.id,' ') as rowid, gro.externalcurrencyrate as spotrate,grod.id as detailid,grod.uom as uom,grod.id as rowdetailid,grod.srno as srno, gro.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin, npb.batchname,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames,grod.discount as discount,grod.discountispercent as discountispercent,gro.gstincluded as gstincluded,'F' as serialjson "+stockMovementParameters+ ",gro.memo as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery + " from grorder gro "
                            + " left join grodetails grod on grod.grorder = gro.id "
                            + " left join inventory inv on inv.id = grod.id "
                            + " left join " + productTableJoin + " on p.id = inv.product "
                            + " left join vendor v on v.id = gro.vendor "
                            + " left join grdetails grd on grd.id = grod.videtails "
                            + " left join grdetails grd1 on (grd1.grorderdetails = grod.id) "
                            + " left join locationbatchdocumentmapping lbdm on grod.id=lbdm.documentid "
                           + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + grStockMovementJoin
                            + " where gro.company = ? and gro.deleteflag='F' and gro.approvestatuslevel=11 " +vendorCondition+" "+productCondition+" "+ goodsReceiptConditionSQL+ batchNameSearchString  + prductTypeFilter;
                }
                // For Purchase Return
                if ((prJson.length() > 0) && (docType == 0 || docType == 1)) {
                    params.addAll(purchaseReturnParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select 2 as transType, p.id as pid, p.productid as productid , prd.description as description, pr.orderdate as date, pr.prnumber as transactionNumber, v.acccode as acccode, v.name as name, v.id as vid, inv.quantity  as invquantity, prd.rate as rate, inv.baseuomrate, ' ' as landedinvoice, pr.currency, IFNULL(pr.id,' ') as grid, pr.id as rowid,pr.externalcurrencyrate as spotrate,prd.id as detailid,prd.uom as uom,prd.id as rowdetailid,prd.srno as srno, pr.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,IFNULL(prd.grdetails,' ') as linktransaction, ' ' AS serialnames, prd.discount as discount,prd.discountispercent as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",pr.memo as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery + " from purchasereturn pr "
                            + " left join prdetails prd on prd.purchasereturn = pr.id "
                            + " left join inventory inv on inv.id = prd.id "
                            + " left join " + productTableJoin + " on p.id = inv.product "
                            + " left join vendor v on v.id = pr.vendor "
                            + " left join grdetails grd on grd.id = prd.videtails "
                            + prJoin
                            + " left join locationbatchdocumentmapping lbdm on prd.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + prStockMovementJoin
                            + " where pr.company = ? and pr.deleteflag='F' " +vendorCondition+" "+productCondition+" " + purchaseReturnConditionSQL+ batchNameSearchString  + prductTypeFilter;
                }
                // For Delivery Order
                if ((doJson.length() > 0) && (docType == 0 || docType == 2)) {
                    params.addAll(deliveryOrderParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += "select 3 as transType, p.id as pid, p.productid as productid, dod.description as description, do.orderdate as date, do.donumber as transactionNumber, c.acccode as acccode, c.name as name, c.id as vid, inv.quantity  as invquantity, dod.rate as rate, inv.baseuomrate, ' ' as landedinvoice, do.currency, ' ' as grid, IFNULL(do.id,' ') as rowid, do.externalcurrencyrate as spotrate,dod.id as detailid,dod.uom as uom,dod.id as rowdetailid,dod.srno as srno, do.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,' ' as linktransaction, ' ' AS serialnames, dod.discount as discount,dod.discountispercent as discountispercent,do.gstincluded as gstincluded,'F' as serialjson "+stockMovementParameters+ ",do.memo as memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery + " from deliveryorder do "
                            + " left join dodetails dod on dod.deliveryorder = do.id "
                            + " left join inventory inv on inv.id = dod.id "
                            + " left join " + productTableJoin + " on p.id = inv.product "
                            + " left join customer c on c.id = do.customer "
                            + doJoin
                            + " left join locationbatchdocumentmapping lbdm on dod.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + deliveryOrderJoin
                            + " where do.company = ? and do.deleteflag='F' and do.approvestatuslevel=11 " + customerCondition + " " + productCondition + " " + deliveryOrderConditionSQL+ batchNameSearchString  + prductTypeFilter;
                }
                // For Sales Return
                if ((srJson.length() > 0) && (docType == 0 || docType == 2)) {
                    params.addAll(salesReturnParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select 4 as transType, p.id as pid, p.productid as productid, srd.description as description, sr.orderdate as date, sr.srnumber as transactionNumber, c.acccode as acccode, c.name as name, c.id as vid, inv.quantity as invquantity, srd.rate as rate, inv.baseuomrate, ' ' as landedinvoice, sr.currency, ' ' as grid, IFNULL(sr.id,' ') as rowid,sr.externalcurrencyrate as spotrate,srd.id as detailid,srd.uom as uom,srd.id as rowdetailid,srd.srno as srno, sr.createdon as createdon,' ',npb.location, npb.warehouse, npb.row,npb.rack,npb.bin,npb.batchname,lbdm.quantity,IFNULL(srd.dodetails,' ') as linktransaction, ' ' AS serialnames, srd.discount as discount,srd.discountispercent as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+",sr.memo, p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery + " from salesreturn sr "
                            + " left join srdetails srd on srd.salesreturn = sr.id "
                            + " left join inventory inv on inv.id = srd.id "
                            + " left join " + productTableJoin + " on p.id = inv.product "
                            + " left join customer c on c.id = sr.customer "
                            + srJoin
                            + " left join locationbatchdocumentmapping lbdm on srd.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + salesReturnJoin
                            + " where sr.company = ? and sr.deleteflag='F' " + customerCondition + " " + productCondition + " " + salesReturnConditionSQL+ batchNameSearchString  + prductTypeFilter;
                }
                
                   // For Stock Adjustment
                if ((stockJson.length() > 0) && (docType == 0 || docType == 2)) {
                    // STOCK IN
                    params.addAll(stockAdjustParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select 7 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, sa.finalquantity  as invquantity,sa.amount as rate,1, ' ' as landedinvoice,' ' as currency, ' ' as grid, IFNULL(sa.id,' ') as rowid, "
                    + " ' ' as spotrate, sa.id as detailid,sa.uom as uom,sa.id as rowdetailid,' ' as srno,sa.creationdate  as createdon,' ',sa.sadlocation,sa.store as warehouse,sa.row,sa.rack,sa.bin,sa.batchname,sa.sadquantity,' ' as linktransaction, sa.serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",sa.memo,p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from (select sa1.*, sad.location as sadlocation, sad.row,sad.rack,sad.bin,sad.batchname,sad.finalquantity as sadquantity, sad.finalserialnames AS serialnames from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment ) sa "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + inventoryStockJoin
                    + stockJoin
                    + " where sa.isdeleted='F' and sa.adjustment_type='Stock IN' and sa.company =? " + productCondition + " " + stockAdjConditionSQL+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                    
                    // STOCK OUT
                    params.addAll(stockAdjustParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select 8 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, -(sa.finalquantity) as invquantity,sa.amount as rate,1, ' ' as landedinvoice,' ' as currency, ' ' as grid, IFNULL(sa.id,' ') as rowid, "
                    + " ' ' as spotrate, sa.id as detailid,sa.uom as uom,sa.id as rowdetailid,' ' as srno,sa.creationdate as createdon,' ',sa.sadlocation,sa.store as warehouse,sa.row,sa.rack,sa.bin,sa.batchname,sa.sadquantity,' ' as linktransaction, sa.serialnames, 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",sa.memo,p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from ( select sa1.*, sad.location as sadlocation, sad.row,sad.rack,sad.bin,sad.batchname,sad.finalquantity as sadquantity, sad.serialnames AS serialnames from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment ) sa "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + inventoryStockJoin
                    + stockJoin
                    + " where sa.isdeleted='F' and (sa.adjustment_type='Stock OUT') and sa.company =? " + productCondition + " " + stockAdjConditionSQL+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                            
                    // STOCK Sales
                    params.addAll(stockAdjustParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select 8 as transType, p.id as pid,p.productid as productid, p.description as description, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, ' ' as vid, -(sa.finalquantity) as invquantity,sa.amount as rate,1, ' ' as landedinvoice,' ' as currency, ' ' as grid, IFNULL(sa.id,' ') as rowid, "
                    + " ' ' as spotrate, sa.id as detailid,sa.uom as uom,sa.id as rowdetailid,' ' as srno,sa.creationdate as createdon,' ',sa.sadlocation,sa.store as warehouse,sa.row,sa.rack,sa.bin,sa.batchname,sa.sadquantity,' ' as linktransaction, sa.serialnames , 0 as discount,0 as discountispercent,'F' as gstincluded,'F' as serialjson "+stockMovementParameters+ ",sa.memo,p.isserialforproduct, p.producttype, p.valuationmethod, p.name as productname " + productDetailsSelectSubquery
                    + "  from ( select sa1.*, sad.location as sadlocation,sad.row,sad.rack,sad.bin,sad.batchname,sad.finalquantity as sadquantity, sad.serialnames AS serialnames from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment ) sa "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                     + inventoryStockJoin
                    + stockJoin
                    + " where sa.isdeleted='F' and (sa.adjustment_type='Stock Sales') and sa.company =? " + productCondition + " " + stockAdjConditionSQL+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                }
                if (!StringUtil.isNullOrEmptyWithTrim(mysqlQuery)) {
                    mysqlQuery = "select * from  ( " + mysqlQuery + " ) as t1";
                }
            } else if (isAdvanceSearch && isAdvanceSearchForValuation) {
                params.clear();
                mysqlQuery = "";
                if (productJson.length() > 0) {
                    params.addAll(openingBalanceParams);
                    if (StringUtil.isNullOrEmpty(batchNameSearchString)) {
                        params.addAll(openingZeroBalanceParams);
                    }
                    mysqlQuery = "select p.id as pid, p.id as detailid,p.productid as productid, 'Initial Quantity' as transactionNumber, p.productid as acccode, ' ' as name, updatedate as date, p.description as description,'F' as serialjson,p.id as customreference,p.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery + "  from inventory inv  "
                            + "  left join " + productTableJoin + " on p.id = inv.product "
                            + " left join pricelist pl on pl.product = p.id and pl.affecteduser = '-1' and pl.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_CONDITION+" and (pl.applydate =(select max(applydate) as ld from pricelist where pricelist.product=inv.product and pricelist.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_INNER_CONDITION+" and pricelist.affecteduser='-1'  and pricelist.applydate<=inv.updatedate and inv.company=? " + productCondition + " group by inv.product))"
                            + " left join locationbatchdocumentmapping lbdm on p.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + initialStockMovementJoin
                            + " where inv.newinv='T' and inv.defective='F' and inv.carryin='T' and inv.company = ? and inv.quantity!=0 " + productCondition + " " + openingBalanceConditionSQL + batchNameSearchString  + prductTypeFilter;
                            
                    if (StringUtil.isNullOrEmpty(batchNameSearchString)) {
                        /**
                         * Add query for zero initial quantity if search is not
                         * applied on batch name.
                         */
                        mysqlQuery += " UNION "
                                + " select p.id as pid,p.id as detailid,p.productid as productid, 'Initial Quantity' as transactionNumber, p.productid as acccode, ' ' as name, asofdate as date, p.description as description,'F' as serialjson,p.id as customreference,p.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery + "  from " + productTableJoin + ""
                                + " where p.id not in (select product from inventory where inventory.newinv='T' and inventory.defective='F' and inventory.carryin='T' and inventory.company = ?) and  p.company = ? " + productZeroCondition + " " + openingBalanceZeroConditionSQL + productTypeFilterForZeroIQ;
                    }

                } else if (serialJson.length() > 0) {

                    params.addAll(serialParams);
                    mysqlQuery = "select p.id as pid, p.id as detailid,p.productid as productid, 'Initial Quantity' as transactionNumber, p.productid as acccode, ' ' as name, updatedate as date, p.description as description,'T' as serialjson from inventory inv  "
                            + "  left join " + productTableJoin + " on p.id = inv.product "
                            + " left join pricelist pl on pl.product = p.id and pl.affecteduser = '-1' and pl.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_CONDITION+" and (pl.applydate =(select max(applydate) as ld from pricelist where pricelist.product=inv.product and pricelist.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_INNER_CONDITION+" and pricelist.affecteduser='-1'  and pricelist.applydate<=inv.updatedate and inv.company=? " + productCondition + " group by inv.product))"
                            + " left join serialdocumentmapping sd on p.id=sd.documentid "
                            + " left join locationbatchdocumentmapping lbdm on p.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + initialStockMovementJoin
                            + " where inv.newinv='T' and inv.defective='F' and inv.carryin='T' and inv.company = ? and inv.quantity!=0 " + productCondition + " " + serialConditionSQL + batchNameSearchString  + prductTypeFilter;
                            
                }

                if ((grJson.length() > 0 || isAppyMasterSearch) && (docType == 0 || docType == 1)) {
                    params.addAll(goodsReceiptParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select p.id as pid, grod.id as detailid,p.productid as productid, gro.gronumber as transactionNumber, v.acccode as acccode, v.name as name, gro.grorderdate as date,grod.description as description,'F' as serialjson,gro.accgrordercustomdataref as customreference,grod.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery + " from grorder gro "
                            + " left join grodetails grod on grod.grorder = gro.id "
                            + " left join inventory inv on inv.id = grod.id "
                            + " left join " + productTableJoin + " on p.id = inv.product "
                            + " left join vendor v on v.id = gro.vendor "
                            + " left join grdetails grd on grd.id = grod.videtails "
                            + " left join locationbatchdocumentmapping lbdm on grod.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + grStockMovementJoin
                            + " where gro.company = ? and gro.deleteflag='F' and gro.approvestatuslevel=11 " + vendorCondition + " " + productCondition + " " + goodsReceiptConditionSQL + batchNameSearchString  + prductTypeFilter;
                }
                // For Purchase Return
                if ((prJson.length() > 0 || isAppyMasterSearch) && (docType == 0 || docType == 1)) {
                    params.addAll(purchaseReturnParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select p.id as pid, prd.id as detailid,p.productid as productid, pr.prnumber as transactionNumber, v.acccode as acccode, v.name as name, pr.orderdate as date, prd.description as description,'F' as serialjson, pr.accpurchasereturncustomdataref as customreference,prd.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery + " from purchasereturn pr "
                            + " left join prdetails prd on prd.purchasereturn = pr.id "
                            + " left join inventory inv on inv.id = prd.id "
                            + " left join " + productTableJoin + " on p.id = inv.product "
                            + " left join vendor v on v.id = pr.vendor "
                            + " left join grdetails grd on grd.id = prd.videtails "
                            + " left join locationbatchdocumentmapping lbdm on prd.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + prStockMovementJoin
                            + " where pr.company = ? and pr.deleteflag='F' " + vendorCondition + " " + productCondition + " " + purchaseReturnConditionSQL + batchNameSearchString  + prductTypeFilter;
                }
                // For Delivery Order
                if ((doJson.length() > 0 || isAppyMasterSearch) && (docType == 0 || docType == 2)) {
                    params.addAll(deliveryOrderParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += "select p.id as pid, dod.id as detailid,p.productid as productid, do.donumber as transactionNumber, c.acccode as acccode, c.name as name, do.orderdate as date, dod.description as description,'F' as serialjson,do.accdeliveryordercustomdataref as customreference,dod.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery + "  from deliveryorder do "
                            + " left join dodetails dod on dod.deliveryorder = do.id "
                            + " left join inventory inv on inv.id = dod.id "
                            + " left join " + productTableJoin + " on p.id = inv.product "
                            + " left join customer c on c.id = do.customer "
                            + " left join locationbatchdocumentmapping lbdm on dod.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + deliveryOrderJoin
                            + " where do.company = ? and do.deleteflag='F' and do.approvestatuslevel=11 " + customerCondition + " " + productCondition + " " + deliveryOrderConditionSQL + batchNameSearchString  + prductTypeFilter;
                }
                // For Sales Return
                if ((srJson.length() > 0 || isAppyMasterSearch) && (docType == 0 || docType == 2)) {
                    params.addAll(salesReturnParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select p.id as pid, srd.id as detailid,p.productid as productid, sr.srnumber as transactionNumber, c.acccode as acccode, c.name as name, sr.orderdate as date, srd.description as description,'F' as serialjson,sr.accsalesreturncustomdataref as customreference,srd.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery + "  from salesreturn sr "
                            + " left join srdetails srd on srd.salesreturn = sr.id "
                            + " left join inventory inv on inv.id = srd.id "
                            + " left join " + productTableJoin + " on p.id = inv.product "
                            + " left join customer c on c.id = sr.customer "
                            + " left join locationbatchdocumentmapping lbdm on srd.id=lbdm.documentid "
                            + " left join newproductbatch npb on lbdm.batchmapid=npb.id"
                            + salesReturnJoin
                            + " where sr.company = ? and sr.deleteflag='F' " + customerCondition + " " + productCondition + " " + salesReturnConditionSQL + batchNameSearchString  + prductTypeFilter;
                }

                // For Stock Adjustment
                if ((stockJson.length() > 0 || isAppyMasterSearch) && (docType == 0 || docType == 2)) {
                    // STOCK IN
                    params.addAll(stockAdjustParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select p.id as pid,sa.id as detailid,p.productid as productid, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, p.description as description,'F' as serialjson,sa.id as customreference,sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                            + " from ( select sa1.*, sad.batchname from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment) sa "
                            + " left join " + productTableJoin + " on p.id = sa.product "
                            + inventoryStockJoin
                            + " where sa.isdeleted='F' and p.producttype !='" + Constants.Inventory_Non_Sales + "' and sa.adjustment_type='Stock IN' and sa.company =? " + productCondition + " " + stockAdjConditionSQL + batchSearchStringForAdjustmentNewOptimized + prductTypeFilter;

                    // STOCK OUT
                    params.addAll(stockAdjustParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select p.id as pid, sa.id as detailid,p.productid, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, p.description as description,'F' as serialjson,sa.id as customreference,sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                            + " from ( select sa1.*, sad.batchname from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment) sa "
                            + " left join " + productTableJoin + " on p.id = sa.product "
                            + inventoryStockJoin
                            + " where sa.isdeleted='F' and (sa.adjustment_type='Stock OUT') and sa.company =? " + productCondition + " " + stockAdjConditionSQL + batchSearchStringForAdjustmentNewOptimized + prductTypeFilter;

                    // STOCK Sales
                    params.addAll(stockAdjustParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += " select p.id as pid, sa.id as detailid,p.productid as productid, sa.seqno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, p.description as description,'F' as serialjson,sa.id as customreference,sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                            + " from ( select sa1.*, sad.batchname from in_stockadjustment sa1 inner join in_sa_detail sad on sa1.id=sad.stockadjustment) sa "
                            + " left join " + productTableJoin + " on p.id = sa.product "
                            + inventoryStockJoin
                            + " where sa.isdeleted='F' and (sa.adjustment_type='Stock Sales') and sa.company =? " + productCondition + " " + stockAdjConditionSQL + batchSearchStringForAdjustmentNewOptimized + prductTypeFilter;
                }
                if ((interStoreTransferJson.length() > 0 || isAppyMasterSearch) && (docType == 0 || docType == 2)) {
                    params.addAll(stockTransParams);
                    params.addAll(stockissueParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += "select p.id as pid, sm.smid as detailid, p.productid as productid, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date, p.description as description, 'F' as serialjson,sa.id as customreference,sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                                + "  from ( select sa1.*, sad.issuedqty as sadissuedqty from in_interstoretransfer sa1 inner join in_ist_detail sad on sa1.id=sad.istrequest WHERE company = '"+companyid+"' ) sa "
                                + " Inner JOIN (SELECT id as smid,createdon,modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom,id,store "
                                + " FROM in_stockmovement WHERE company = '"+companyid+"' and transaction_type <> 1  ) sm ON sm.modulerefid = sa.id "
                                + " Inner JOIN in_sm_detail ism on sm.id=ism.stockmovement "
                                + " left join " + productTableJoin + " on p.id = sa.product "
                            + " where sa.transaction_module = 2 and sa.company =? and sa.sadissuedqty!=0 " + productCondition + " " + istIssueSQL + " " + interStoreTransferConditionSQL + " " +storeCondition3 + batchSearchStringForAdjustmentNewOptimized + prductTypeFilter;

                    params.addAll(stockTransParams);
                    params.addAll(stockcollectParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    mysqlQuery += "select p.id as pid, CONCAT(sm.smid,'collect') as detailid, p.productid as productid, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date, p.description as description, 'F' as serialjson,sa.id as customreference,sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                                + "  from ( select sa1.* from in_interstoretransfer sa1 inner join in_ist_detail sad on sa1.id=sad.istrequest  WHERE company = '"+companyid+"' ) sa "
                                + " inner JOIN (SELECT id as smid,createdon,modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom,id,store "
                                + " FROM in_stockmovement WHERE company = '"+companyid+"' and transaction_type = 1 ) sm ON sm.modulerefid = sa.id "
                                + " inner JOIN in_sm_detail ism on sm.id=ism.stockmovement "
                                + " left join " + productTableJoin + " on p.id = sa.product "
                                + " where  sa.transaction_module = 2 and sa.company =? " + productCondition + " " + istCollectSQL + " " + interStoreTransferConditionSQL + " " + storeCondition4 + batchSearchStringForAdjustmentNewOptimized + prductTypeFilter;

                }
                if ((interLocationJson.length() > 0 || isAppyMasterSearch) && (docType == 0 || docType == 2)){
                    params.addAll(iltIssueParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    
                    mysqlQuery += " select p.id as pid, sa.id as detailid, p.productid as productid, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date, p.description as description, 'F' as serialjson, sa.id as customreference, sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                    + " from ( select sa1.*, sad.issuedqty as invquantity,sad.id as rowdetailid,sad.issued_location,sad.issued_row,sad.issued_rack,sad.issued_bin,sad.batchname, sad.issued_serialnames AS serialnames from in_interstoretransfer sa1 inner join in_ist_detail sad on sa1.id=sad.istrequest ) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type <> 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.transaction_module = 11 and sa.company =? and sa.invquantity!=0 and sa.status <> 5 " + productCondition + " " + iltIssueSQL+" "+storeCondition3+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                    
                    params.addAll(iltCollectParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    
                    mysqlQuery += " select p.id as pid, CONCAT(sa.id,'collect') as detailid, p.productid as productid, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date, p.description as description, 'F' as serialjson, sa.id as customreference, sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                    + " from ( select sa1.*, sad.deliveredqty as invquantity,CONCAT(sad.id,'collect') as rowdetailid,sad.delivered_location,sad.delivered_row,sad.delivered_rack,sad.delivered_bin,sad.batchname, sad.delivered_serialnames AS serialnames from in_interstoretransfer sa1 inner join in_ist_detail sad on sa1.id=sad.istrequest ) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type = 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.delivered_location IS NOT NULL AND  sa.transaction_module = 11 and sa.company =? and sa.invquantity!=0 and sa.status <> 5 " + productCondition + " " + iltCollectSQL+" "+storeCondition4+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                    
                }
                 if ((stockRequestJson.length() > 0 || isAppyMasterSearch)){
                    params.addAll(srIssueParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                     
                    mysqlQuery += " select p.id as pid, sa.id as detailid, p.productid as productid, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, p.description as description, 'F' as serialjson, sa.id as customreference, sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.issuedqty as invquantity, sad.id as rowdetailid, sad.issued_location,sad.issued_row,sad.issued_rack,sad.issued_bin,sad.batchname, sad.issued_serialnames AS serialnames from in_goodsrequest sa1 inner join in_sr_detail sad on sa1.id=sad.stockrequest ) sa  "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type <> 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.status IN(2,3,4) AND sa.module = 0 and sa.company =? and sa.invquantity!=0 " + productCondition + " " + srIssueSQL+" "+storeCondition4+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                     
                    params.addAll(srCollectParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                      
                    mysqlQuery += " select p.id as pid, CONCAT(sa.id,'collect') as detailid, p.productid as productid, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, p.description as description, 'F' as serialjson, sa.id as customreference, sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                    + " from ( select sa1.*, sad.deliveredqty as invquantity, CONCAT(sad.id,'collect') as rowdetailid, sad.delivered_location, sad.delivered_row,sad.delivered_rack,sad.delivered_bin,sad.batchname, sad.delivered_serialnames AS serialnames from in_goodsrequest sa1 inner join in_sr_detail sad on sa1.id=sad.stockrequest ) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type = 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " where sa.delivered_location IS NOT NULL AND sa.status IN(4,5) AND sa.module = 0 and sa.company =? and sa.invquantity!=0 " + productCondition + " " + srCollectSQL+" "+storeCondition3+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                     
                 }
                 if ((stockIssueJson.length() > 0 || isAppyMasterSearch)){ 
                    params.addAll(issuenoteIssueParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                      
                    mysqlQuery += " select p.id as pid, sa.id as detailid, p.productid as productid, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, p.description as description, 'F' as serialjson, sa.id as customreference, sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.issuedqty as invquantity,sad.id as rowdetailid,sad.issued_location,sad.issued_row,sad.issued_rack,sad.issued_bin,sad.batchname, sad.issued_serialnames AS serialnames from in_goodsrequest sa1 inner join in_sr_detail sad on sa1.id=sad.stockrequest ) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type <> 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " where sa.module = 1 and sa.company =? and sa.invquantity!=0 " + productCondition + " " + issuenoteIssueSQL+" "+storeCondition3+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                     
                    params.addAll(issuenoteCollectParams);
                    mysqlQuery += StringUtil.isNullOrEmpty(mysqlQuery) ? " " : " union ";
                    
                    mysqlQuery += "select p.id as pid, CONCAT(sa.id,'collect') as detailid, p.productid as productid, sa.transactionno as transactionNumber, ' ' as acccode, ' ' as name, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date, p.description as description, 'F' as serialjson, sa.id as customreference, sa.id as linecustomreference, p.name as productname " + productDetailsSelectSubquery
                    + " from (select sa1.*, sad.deliveredqty as invquantity,CONCAT(sad.id,'collect') as rowdetailid,sad.delivered_location,sad.delivered_row,sad.delivered_rack,sad.delivered_bin,sad.batchname, sad.delivered_serialnames AS serialnames from in_goodsrequest sa1 inner join in_sr_detail sad on sa1.id=sad.stockrequest) sa "
                    + " LEFT JOIN (SELECT modulerefid, priceperunit, remark, assembled_product,costcenter,stockuom FROM in_stockmovement WHERE company = '"+companyid+"' and  transaction_type = 1 GROUP BY  modulerefid ) sm ON sm.modulerefid = sa.id "
                    + " left join " + productTableJoin + " on p.id = sa.product "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " where sa.delivered_location IS NOT NULL AND sa.module = 1 and sa.company =? and sa.invquantity!=0 " + productCondition + " " + issuenoteCollectSQL+" "+storeCondition4+ batchSearchStringForAdjustmentNewOptimized+prductTypeFilter;
                     
                 }
                if (!StringUtil.isNullOrEmptyWithTrim(mysqlQuery)) {
                    mysqlQuery = "select * from  ( " + mysqlQuery + " ) as t1";
                }
            }
            boolean isWhereClause = false;
            if (!(StringUtil.isNullOrEmpty(customerVendorId)) && !isStockLedger) {
                mysqlQuery += "where (t1.name != NULL OR t1.name!= ' ')";
                isWhereClause = true;
            }
             if (!StringUtil.isNullOrEmpty(ss)) {
                if(useTempProductId){
                    reportQueryJoin = " join tempproductcompanyid on t1.pid = tempproductcompanyid.productids ";
                    String temp=  reportQueryJoin;
                    mysqlQuery += temp; 
                }
                //ERM-939 adding productname search in the searchcol array for stock ledger
                String[] searchcol = new String[]{"t1.productid", "t1.description", "t1.transactionNumber", "t1.acccode", "t1.name","t1.productname"}; 
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 6);
                StringUtil.insertParamSearchString(map);
                if (!(StringUtil.isNullOrEmpty(customerVendorId)) && !isStockLedger) {
                    quickSearchString = StringUtil.getSearchString(ss, "and", searchcol);
                } else {
                    quickSearchString = StringUtil.getSearchString(ss, "where", searchcol);    //Deepak Pingle
                    isWhereClause=true;
                }
                 if(useTempProductId){
                     reportQueryWhereClause = " and tempproductcompanyid.requestId = '" + requestUUID + "' ";
                     mysqlQuery += reportQueryWhereClause;
                 }
            }
            String t2CondiQuer = "";
            if (!productCategoryId.equalsIgnoreCase("All") && !StringUtil.isNullOrEmpty(productCategoryId)) {
                if (!isAdvanceSearch) {
                    params.addAll(openingBalanceParams);
                    if (!StringUtil.isNullOrEmpty(initialQuantityZeroQty)) {
                        /**
                         * Don't add query parameters for zero initial quantity
                         * if search is applied on batch name.
                         */
                        params.addAll(openingZeroBalanceParams);
                    }
                    params.addAll(goodsReceiptParams);
                    params.addAll(purchaseReturnParams);
                    params.addAll(assemblyProductParams);
                    params.addAll(unbuildProductParams);
                    params.addAll(assemblyProductParamsMain);
                    params.addAll(unbuildProductParamsMain);
                    params.addAll(deliveryOrderParams);
                    params.addAll(salesReturnParams);
                    params.addAll(stockInParams);
                    params.addAll(stockSalesParams);
                    params.addAll(stockOutParams);
                    params.addAll(srCollectParams);
                    params.addAll(srIssueParams);
                    params.addAll(issuenoteCollectParams);
                    params.addAll(issuenoteIssueParams);
                    params.addAll(istCollectParams);
                    params.addAll(istIssueParams);
                    params.addAll(iltCollectParams);
                    params.addAll(iltIssueParams);
                    if(isActivateMRPModule){
                    params.addAll(workOrderParams);
                    params.addAll(workOrderDetailsParams);
                    }
                }
                if (isAdvanceSearch) {
//                     t2CondiQuer = isWhereClause?" and ":" where  ";mysqlQuery = "SELECT * FROM "+unionQry +" as t1 "+innerCondition+" where t1.invquantity !=0 ";
                    t2CondiQuer += "  SELECT * FROM ( " + mysqlQuery + " ) as t3 inner join productcategorymapping pc on pc.productid = t3.id inner join "
                            + " masteritem on masteritem.id=pc.productcategory and masteritem.mastergroup=19 and pc.productcategory in " + productCategoryId + "";
                } else {
                    t2CondiQuer = isWhereClause ? " and " : " where  ";
                    t2CondiQuer += "  t1.pid in(select distinct t3.pid from " + unionQry + " as t3 inner join productcategorymapping pc on pc.productid = t3.pid inner join "
                            + " masteritem on masteritem.id=pc.productcategory and masteritem.mastergroup=19 and pc.productcategory in " + productCategoryId + ")";
                }
            }
            
            if (useTempProductId && StringUtil.isNullOrEmpty(ss)) {
                reportQueryJoin = " join tempproductcompanyid on t1.pid = tempproductcompanyid.productids ";
                reportQueryWhereClause = " where tempproductcompanyid.requestId = '" + requestUUID + "' ";
                String temp = reportQueryJoin + reportQueryWhereClause;
                mysqlQuery += temp;
                mysqlQuery += t2CondiQuer;
                
            if (!isAdvanceSearch) {
                if (!isStockLedger) {
                        orderByString = " order by t1.productid ,t1.date ,t1.createdon,t1.srno asc";
                    } else {
                        orderByString = " order by t1.productid ,t1.date ,t1.createdon,t1.srno asc";
                    }
                } else if (isAdvanceSearch && (!productCategoryId.equalsIgnoreCase("All") && !StringUtil.isNullOrEmpty(productCategoryId))) {
                    mysqlQuery = t2CondiQuer;
                }
            } else {
                if (!isAdvanceSearch) {
                    if (!isStockLedger) {
                        orderByString = " order by t1.productid ,t1.date ,t1.createdon,t1.srno asc";
                        mysqlQuery += t2CondiQuer ;
                    } else {
                        orderByString = " order by t1.productid ,t1.date ,t1.createdon,t1.srno asc";
                        mysqlQuery += t2CondiQuer ;
                    }
                } else if (isAdvanceSearch && (!productCategoryId.equalsIgnoreCase("All") && !StringUtil.isNullOrEmpty(productCategoryId))) {
                    mysqlQuery = t2CondiQuer;
                } else if (isAdvanceSearch) {
                    /**
                     *  apply all joins combinely to main query instead of applying joins to each module.
                     */
                    params.addAll(advanceSearchParams);
                    mySearchFilterString = isWhereClause ? mySearchFilterString : mySearchFilterString.replace("AND (","WHERE ("); 
                }
            }

            if (!mysqlQuery.equals("")) {
                mysqlQuery = mysqlQuery + JoinString.toString() + quickSearchString + mySearchFilterString + orderByString ;
                returnList = executeSQLQuery(mysqlQuery, params.toArray());
            }
            if (isInventoryValuation || isFromStockReport || isFromStockSummaryReport) {
                totalCount = pagingReturnList.size();
            } else {
                totalCount = returnList.size();
            }

            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false && !isFromStockReport && !isInventoryValuation && !isFromStockValuationSummary && !isFromStockSummaryReport ) {
                    returnList = executeSQLQueryPaging(mysqlQuery, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
                        }
    } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }finally{
            if(useTempProductId){
                String deleteQuery = "delete from tempproductcompanyid where requestId = '" + requestUUID + "' ";
                int totalDelete = executeSQLUpdate(deleteQuery); 
            }
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }
    @Override
    public int getTempProductIdsForReport(Date endDate, int start, int limit, String companyId, String requestUUID, String ss, boolean isExport) throws ServiceException {
        ArrayList params = new ArrayList();
       
        List returnList = new ArrayList();
        String openingBalanceZeroConditionSQL = "";
        String productZeroCondition = "";
        String query = "";
        
        if (endDate != null) {
            openingBalanceZeroConditionSQL += " and prod.asofdate <=? ";
        }
        params.add(companyId);
        params.add(endDate);


        String mysqlSearchQuery = "";
        if (!StringUtil.isNullOrEmpty(ss)) {
            try {
                String[] searchcol = new String[]{"prod.productid", "prod.description", "prod.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 3);
                StringUtil.insertParamSearchString(map);
                mysqlSearchQuery = StringUtil.getSearchString(ss, "and", searchcol);
            } catch (SQLException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
                
        }
        /**
         * Removed as paging for stock status report was not working ERP-39023
         */
//        String limitCheck = "";
//        if (!isExport) {
////            limitCheck = " limit " + start + " , " + limit;
//        }
        
        productZeroCondition += " and prod.producttype != '" + Producttype.CUSTOMER_ASSEMBLY + "' and prod.producttype !=  '" + Producttype.CUSTOMER_INVENTORY + "' " ;
      
        query = "insert into tempproductcompanyid (select prod.id, '" + requestUUID +  "' from product prod  where prod.deleteflag = 'F'  and prod.isasset!='1' "
                + "and prod.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and prod.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and  "
                + "prod.company = ? " + productZeroCondition + " " + openingBalanceZeroConditionSQL +  mysqlSearchQuery + ")";

        String queryToCalculateCount = "select count(prod.id) from product prod  where prod.deleteflag = 'F'  and prod.isasset!='1' "
                + "and prod.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and prod.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and  "
                + "prod.company = ? " + productZeroCondition + " " + openingBalanceZeroConditionSQL + mysqlSearchQuery;
        
        
        returnList = executeSQLQuery(queryToCalculateCount, params.toArray());
        
        int pagedCount = executeSQLUpdate(query, params.toArray());
        return Integer.parseInt(returnList.get(0).toString());
    }

    @Override
    public KwlReturnObject getRG23PartIData(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        List pagingReturnList = new ArrayList();
        int totalCount = 0;
        try {
            DateFormat df = (DateFormat) requestParams.get(Constants.df);
            String start = (String) requestParams.get("start");
            String limit = (String) requestParams.get("limit");
            String startDate = (String) requestParams.get(Constants.REQ_startdate);
            String endDate = (String) requestParams.get(Constants.REQ_enddate);
            int docType = 0;
            String customerVendorId = "";
            String productId = "";
            String customerCondition = "";
            String vendorCondition = "";
            String productCondition = "";
            String productCategoryId="";
            boolean isStockLedger=false;
            boolean isInventoryValuation=false;
            boolean isFromStockReport=false;
            boolean isSelectedProductIds = false;
            boolean rg23part1 = false;
            String[] ids = null;
            ArrayList<String> productIdsList= new ArrayList<>();
            
            if (requestParams.containsKey("docType")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("docType"))) {
                    docType = Integer.parseInt(requestParams.get("docType").toString());
                }
            }
            if (requestParams.containsKey("customerId")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("customerId"))) {
                    customerVendorId = (requestParams.get("customerId").toString());
                }
            }
            if (requestParams.containsKey("productCategoryid")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("productCategoryid"))) {
                    productCategoryId = (requestParams.get("productCategoryid").toString());
                }
            }
            if (requestParams.containsKey("selproductIds")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("selproductIds"))) {
                    isSelectedProductIds = true;
                    ids = ((String) requestParams.get("selproductIds")).split(",");
                    for(String s : ids){
                        productIdsList.add(s);
                    }
                }
            } else if (requestParams.containsKey("productId")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("productId"))) {
                    productId = (requestParams.get("productId").toString());
                }
            }
            if (requestParams.containsKey("isStockLedger")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("isStockLedger"))) {
                     isStockLedger=Boolean.parseBoolean(requestParams.get("isStockLedger").toString()); 
                }
            }
            if (requestParams.containsKey("isInventoryValuation")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("isInventoryValuation"))) {
                     isInventoryValuation=Boolean.parseBoolean(requestParams.get("isInventoryValuation").toString()); 
                }
            }
            if (requestParams.containsKey("isFromStockReport")) {
                if (!StringUtil.isNullOrEmpty((String) requestParams.get("isFromStockReport"))) {
                     isFromStockReport=Boolean.parseBoolean(requestParams.get("isFromStockReport").toString()); 
                }
            }
            if (requestParams.containsKey("isRG23part1")) {
                if ((Boolean)requestParams.get("isRG23part1")) {
                     rg23part1=(Boolean)requestParams.get("isRG23part1"); 
                }
            }
            ArrayList params = new ArrayList();
            ArrayList pagingParams=new ArrayList();
            ArrayList openingBalanceParams = new ArrayList();
//            ArrayList openingParams = new ArrayList();
            ArrayList goodsReceiptParams = new ArrayList();
            ArrayList deliveryOrderParams = new ArrayList();
            ArrayList purchaseReturnParams = new ArrayList();
            ArrayList salesReturnParams = new ArrayList();
            ArrayList assemblyProductParamsMain = new ArrayList();
            ArrayList assemblyProductParams = new ArrayList();
            ArrayList stockInParams = new ArrayList();
            ArrayList stockOutParams = new ArrayList();
            ArrayList stockSalesParams = new ArrayList();

//            String openingConditionSQL = "";
            String openingBalanceConditionSQL = "";
            String buildassemblyMainConditionSQL = "";
            String buildassemblyConditionSQL = "";
            String goodsReceiptConditionSQL = "";
            String purchaseReturnConditionSQL = "";
            String deliveryOrderConditionSQL = "";
            String salesReturnConditionSQL = "";
            String stockInSQL = "";
            String stockOutSQL = "";
            String stockSalesSQL = "";

            if (docType == 0) {                                                                              //0-All Documents,1-Purchase Documents,2-Sales Documents
                // For Product Opening                                                                    
//                openingParams.add(companyid);
                //For Assembly Sub-Products
                assemblyProductParams.add((String) requestParams.get("companyid"));
                //For Assembly Main-Products
                assemblyProductParamsMain.add((String) requestParams.get("companyid"));
                //Inventory Stock-Out
                stockOutParams.add((String) requestParams.get("companyid"));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            assemblyProductParams.addAll(productIdsList);
                        } else {
                            assemblyProductParams.add(productId);
                        }
                    }
//                    assemblyProductParams.add(df.parse(startDate));
                    assemblyProductParams.add(df.parse(endDate));
                    buildassemblyConditionSQL += " and (productbuild.entrydate <= ? ) ";

                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            assemblyProductParamsMain.addAll(productIdsList);
                        } else {
                            assemblyProductParamsMain.add(productId);
                        }
                    }
//                    assemblyProductParamsMain.add(df.parse(startDate));
                    assemblyProductParamsMain.add(df.parse(endDate));
                    buildassemblyMainConditionSQL += " and (pb.entrydate <= ? ) ";

                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            stockOutParams.addAll(productIdsList);
                        } else {
                            stockOutParams.add(productId);
                        }
                    }
//                    stockOutParams.add(df.parse(startDate));
                    stockOutParams.add(df.parse(endDate));
                    stockOutSQL += " and (sa.bussinessdate <=?) ";
                }
            }

            if (docType == 0 || docType == 1) {
                openingBalanceParams.add((String) requestParams.get("companyid"));          // For Initial Quantity
                if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                    if (isSelectedProductIds) {
                        openingBalanceParams.addAll(productIdsList);
                    } else {
                        openingBalanceParams.add(productId);
                    }
                }
                openingBalanceParams.add((String) requestParams.get("companyid"));
                // For Goods Receipt
                goodsReceiptParams.add((String) requestParams.get("companyid"));
                // For Purchase Return
                purchaseReturnParams.add((String) requestParams.get("companyid"));
                //Inventory Stock-IN
                stockInParams.add((String) requestParams.get("companyid"));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            openingBalanceParams.addAll(productIdsList);
                        } else {
                            openingBalanceParams.add(productId);
                        }
                    }
//                    openingBalanceParams.add(df.parse(startDate));
                    openingBalanceParams.add(df.parse(endDate));
                    openingBalanceConditionSQL += " and (inv.updatedate <=?) ";
                    
                    if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                        goodsReceiptParams.add(customerVendorId);
                    }
                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            goodsReceiptParams.addAll(productIdsList);
                        } else {
                            goodsReceiptParams.add(productId);
                        }
                    }
//                    goodsReceiptParams.add(df.parse(startDate));
                    goodsReceiptParams.add(df.parse(endDate));
                    goodsReceiptConditionSQL += " and (gro.grorderdate <=?) ";
                    
                    if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                        purchaseReturnParams.add(customerVendorId);
                    }
                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            purchaseReturnParams.addAll(productIdsList);
                        } else {
                            purchaseReturnParams.add(productId);
                        }
                    }
//                    purchaseReturnParams.add(df.parse(startDate));
                    purchaseReturnParams.add(df.parse(endDate));
                    purchaseReturnConditionSQL += " and (pr.orderdate <=?) ";
                    
                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            stockInParams.addAll(productIdsList);
                        } else {
                            stockInParams.add(productId);
                        }
                    }
//                    stockInParams.add(df.parse(startDate));
                    stockInParams.add(df.parse(endDate));
                    stockInSQL += " and (sa.bussinessdate <=?) ";
                }
            }

            if (docType == 0 || docType == 2) {
                // For Delivery Order
                deliveryOrderParams.add((String) requestParams.get("companyid"));
                // For Sales Return
                salesReturnParams.add((String) requestParams.get("companyid"));
                //Inventory Stock Sales
                stockSalesParams.add((String) requestParams.get("companyid"));
                if (!StringUtil.isNullOrEmpty(endDate)) {
                    if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                        deliveryOrderParams.add(customerVendorId);
                    }
                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            deliveryOrderParams.addAll(productIdsList);
                        } else {
                            deliveryOrderParams.add(productId);
                        }
                    }
//                    deliveryOrderParams.add(df.parse(startDate));
                    deliveryOrderParams.add(df.parse(endDate));
                    deliveryOrderConditionSQL += " and (do.orderdate <=?) ";
                    deliveryOrderConditionSQL += " and (do.isleasedo!='1') ";

                    if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                        salesReturnParams.add(customerVendorId);
                    }
                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            salesReturnParams.addAll(productIdsList);
                        } else {
                            salesReturnParams.add(productId);
                        }
                    }
//                    salesReturnParams.add(df.parse(startDate));
                    salesReturnParams.add(df.parse(endDate));
                    salesReturnConditionSQL += " and (sr.orderdate <=?) ";
                    salesReturnConditionSQL += " and (sr.isleasesalesreturn!='1') ";
                    
                    if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                        if (isSelectedProductIds) {
                            stockSalesParams.addAll(productIdsList);
                        } else {
                            stockSalesParams.add(productId);
                        }
                    }
//                    stockSalesParams.add(df.parse(startDate));
                    stockSalesParams.add(df.parse(endDate));
                    stockSalesSQL += " and (sa.bussinessdate <=?) ";
                }
            }
            String ss = (String) requestParams.get("ss");

            String doJoin = "";
            String grJoin = "";
            String prJoin = "";
            String srJoin = "";
            String productJoin = "";
            String appendCase = "and";
            String mySearchFilterString = "";
            boolean isAdvanceSearch = false;
            JSONArray doJson = new JSONArray();
            JSONArray grJson = new JSONArray();
            JSONArray srJson = new JSONArray();
            JSONArray prJson = new JSONArray();
            JSONArray productJson = new JSONArray();
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (requestParams.containsKey("filterConjuctionCriteria") && requestParams.get("filterConjuctionCriteria") != null) {
                if (requestParams.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (requestParams.containsKey("searchJson") && requestParams.get("searchJson") != null) {
                Searchjson = requestParams.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    isAdvanceSearch = true;
                    // For getting Search Json
                    String iscustomcolumn = "", iscustomcolumndata = "", isfrmpmproduct = "", fieldtype = "", searchText = "", columnheader = "",
                            xtype = "", combosearch = "", isinterval = "", interval = "", isbefore = "", isdefaultfield = "", isForProductMasterOnly = "";
                    JSONObject SearchJsonObj = new JSONObject(Searchjson);
                    JSONArray SearchJsonArray = SearchJsonObj.getJSONArray("root");

                    for (int searckArr = 0; searckArr < SearchJsonArray.length(); searckArr++) {
                        JSONObject compareObj = SearchJsonArray.optJSONObject(searckArr);
                        iscustomcolumn = compareObj.optString("iscustomcolumn");
                        iscustomcolumndata = compareObj.optString("iscustomcolumndata");
                        isfrmpmproduct = compareObj.optString("isfrmpmproduct");
                        fieldtype = compareObj.optString("fieldtype");
                        searchText = compareObj.optString("searchText");
                        columnheader = compareObj.optString("columnheader");
                        columnheader = StringUtil.DecodeText(columnheader);
                        xtype = compareObj.optString("xtype");
                        combosearch = StringUtil.DecodeText(compareObj.optString("combosearch"));
                        isinterval = compareObj.optString("isinterval");
                        interval = compareObj.optString("interval");
                        isbefore = compareObj.optString("isbefore");
                        isdefaultfield = compareObj.optString("isdefaultfield");
                        isForProductMasterOnly = compareObj.optString("isForProductMasterOnly");

                        String[] coldataArray = combosearch.split(",");
                        String Coldata = "";
                        for (int countArray = 0; countArray < coldataArray.length; countArray++) {
                            Coldata += "'" + coldataArray[countArray] + "',";
                        }
                        Coldata = Coldata.substring(0, Coldata.length() - 1);
                        HashMap<String, Object> requestParams1 = new HashMap<String, Object>();
//                        columnheader = compareObj.optString("columnheader");
                        requestParams1.put(Constants.filter_names, Arrays.asList(Constants.companyid, "fieldlabel"));
                        requestParams1.put(Constants.filter_values, Arrays.asList((String) requestParams.get("companyid"), columnheader));
                        KwlReturnObject result = accAccountDAOobj.getFieldParams(requestParams1);
                        List<FieldParams> lst = result.getEntityList();
                        for (FieldParams fieldParams : lst) {
                            int module = fieldParams.getModuleid();
                            if (module == Constants.Acc_Delivery_Order_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Delivery_Order_ModuleId);
                                doJson.put(cntObj);

                            } else if (module == Constants.Acc_Goods_Receipt_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Goods_Receipt_ModuleId);
                                grJson.put(cntObj);

                            } else if (module == Constants.Acc_Sales_Return_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Sales_Return_ModuleId);
                                srJson.put(cntObj);

                            } else if (module == Constants.Acc_Purchase_Return_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Purchase_Return_ModuleId);
                                prJson.put(cntObj);
                            } else if (module == Constants.Acc_Product_Master_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Product_Master_ModuleId);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                productJson.put(cntObj);
                            }
                        }
                    }
                    if ((doJson.length() > 0) && (docType==0||docType==2)) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", doJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        if (mySearchFilterString.contains("deliveryordercustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "deliveryordercustomdata");
                            doJoin = " left join deliveryordercustomdata on deliveryordercustomdata.deliveryOrderId=do.accdeliveryordercustomdataref ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "dodetailscustomdata");
                            doJoin += " left join dodetailscustomdata on dod.id=dodetailscustomdata.dodetailsid ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(deliveryOrderParams, putSearchJson.toString());
                        deliveryOrderConditionSQL += mySearchFilterString;
                    }
                    if ((grJson.length() > 0) && (docType==0||docType==1)) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", grJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Goods_Receipt_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        if (mySearchFilterString.contains("grordercustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "grordercustomdata");
                            grJoin = " left join grordercustomdata on grordercustomdata.goodsreceiptorderid=gro.accgrordercustomdataref ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "grodetailscustomdata");
                            grJoin += " left join grodetailscustomdata on grod.id=grodetailscustomdata.grodetailsid ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(goodsReceiptParams, putSearchJson.toString());
                        goodsReceiptConditionSQL += mySearchFilterString;
                    }
                    if ((srJson.length() > 0) && (docType==0||docType==2)) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", srJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Sales_Return_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        if (mySearchFilterString.contains("salesreturncustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "salesreturncustomdata");
                            srJoin = " left join salesreturncustomdata on salesreturncustomdata.salesreturnid=sr.accsalesreturncustomdataref ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "srdetailscustomdata");
                            srJoin += " left join srdetailscustomdata on srd.id=srdetailscustomdata.srdetailsid ";
                        }

                        StringUtil.insertParamAdvanceSearchString1(salesReturnParams, putSearchJson.toString());
                        salesReturnConditionSQL += mySearchFilterString;
                    }
                    if ((prJson.length() > 0) && (docType==0||docType==1)) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", prJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Purchase_Return_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        if (mySearchFilterString.contains("purchasereturncustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "purchasereturncustomdata");
                            prJoin = " left join purchasereturncustomdata on purchasereturncustomdata.purchasereturnid=pr.accpurchasereturncustomdataref ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "prdetailscustomdata");
                            prJoin += " left join prdetailscustomdata on prd.id=prdetailscustomdata.prdetailsid ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(purchaseReturnParams, putSearchJson.toString());
                        purchaseReturnConditionSQL += mySearchFilterString;
                    }
                    if ((productJson.length() > 0) && (docType==0||docType==1)) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", productJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Product_Master_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));

                        if (mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "accproductcustomdata");
                            productJoin += " left join accproductcustomdata on p.id=accproductcustomdata.productId ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(openingBalanceParams, putSearchJson.toString());
                        openingBalanceConditionSQL += mySearchFilterString;
                    }
                }  // end of search json check
            }
            if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                customerCondition=" and c.id= ? ";
            }
            if (!StringUtil.isNullOrEmpty(customerVendorId)) {
                vendorCondition=" and v.id= ?";
            }
            if (!StringUtil.isNullOrEmpty(productId) || isSelectedProductIds) {
                productCondition = "";
                if (ids != null) {
                    productCondition += " and p.id in(? ";
                    for (int i = 0; i < ids.length - 1; i++) {
                        if (!StringUtil.isNullOrEmpty(ids[i])) {
                            productCondition += " ,?";
                        }
                    }
                    productCondition += " )";

                } else if (!StringUtil.isNullOrEmpty(productId)) {
                    productCondition = " and p.id= ?";
                }
            }
            String rg23part1Qleftjoin="";
            String rg23part1Where="";
            String termAmountParam=",0 as termamount";
            String rg23part1GroupBy="";
            String templateid="";
            if(requestParams.containsKey("isRG23part1") && (Boolean)requestParams.get("isRG23part1")){
                if (requestParams.containsKey("exciseUnit") && !StringUtil.isNullOrEmpty((String) requestParams.get("exciseUnit"))) {
                    String exciseUnit = (String) requestParams.get("exciseUnit");
                    List modt = new ArrayList();
                    requestParams.put("companyunitid", exciseUnit);
                    KwlReturnObject kwltemp = accountingHandlerDAOobj.getModuleTemplates(requestParams);
                    modt = kwltemp.getEntityList();
                    if (modt.size() > 0) {
                        ModuleTemplate moduleTemp = (ModuleTemplate) modt.get(0);
                        templateid = moduleTemp.getTemplateId();
                    }
                }
                rg23part1Qleftjoin=" left join receiptorderdetailtermsmap grodtmp on  grod.id = grodtmp.grodetail left join linelevelterms llt on llt.id = grodtmp.term ";
                termAmountParam=" ,sum(grodtmp.termamount) as termamount "; 
                rg23part1Where= " and llt.termtype=2 ";
                rg23part1GroupBy= " GROUP BY transactionNumber ";
            }
            String initialQuantity = "select 0 as transType, p.id, p.productid as productid, p.description as description, updatedate as date, 'Initial Quantity' as transactionNumber, p.productid as acccode, '' as name,inv.id as vid, inv.quantity  as invquantity,pl.price as rate, inv.baseuomrate,'' as landedinvoice,p.currency as currency, '1' as grid, IFNULL(inv.id,'') as rowid,'' as spotrate,p.id as detailid,p.unitOfMeasure as uom,'' as rowdetailid,'' as srno, p.createdon as createdon,pm.productcategory,0 as termamount,'' as templateid from inventory inv  "
                    + " left join product p on p.id = inv.product  "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " left join pricelist pl on pl.product = p.id and pl.affecteduser = '-1' and pl.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_CONDITION+" and pl.currency=p.currency and (pl.applydate =(select max(applydate) as ld from pricelist where pricelist.product=inv.product and pricelist.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_INNER_CONDITION+" and pricelist.currency=pl.currency and  pricelist.affecteduser='-1'  and pricelist.applydate<=inv.updatedate and inv.company=? "+productCondition+" group by inv.product))  "
                    + " where p.deleteflag = 'F'  and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' and inv.newinv='T' and inv.defective='F' and inv.carryin='T' and inv.company = ? and inv.quantity!=0 "+productCondition+" " + openingBalanceConditionSQL + " GROUP BY inv.product";
            String grOrder = " select 1 as transType, p.id, p.productid as productid, grod.description as description, gro.grorderdate as date, gro.gronumber as transactionNumber, v.acccode as acccode, v.name as name, v.id as vid, inv.quantity  as invquantity, grod.rate as rate, inv.baseuomrate, '' as landedinvoice, gro.currency, gr.id as grid, IFNULL(gro.id,'') as rowid, gro.externalcurrencyrate as spotrate,grod.id as detailid,grod.uom as uom,grod.id as rowdetailid,grod.srno as srno, gro.createdon as createdon,pm.productcategory "+termAmountParam+",gr.moduletemplateid as templateid from grorder gro "  
                    + " left join grodetails grod on grod.grorder = gro.id "
                    + " left join inventory inv on inv.id = grod.id "
                    + " left join product p on p.id = inv.product "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " left join vendor v on v.id = gro.vendor "
                    + " left join grdetails grd on grd.id = grod.videtails "
                    + " left join goodsreceipt gr on gr.id = grd.goodsreceipt " +rg23part1Qleftjoin
                    + " where gro.company = ? and gro.deleteflag='F' and gro.approvestatuslevel=11 and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' " +vendorCondition+" "+productCondition+" " + goodsReceiptConditionSQL+" "+rg23part1Where+" "+rg23part1GroupBy;
            String purchaseReturn = " select 2 as transType, p.id, p.productid as productid , prd.description as description, pr.orderdate as date, pr.prnumber as transactionNumber, v.acccode as acccode, v.name as name, v.id as vid, inv.quantity  as invquantity, prd.rate as rate, inv.baseuomrate, '' as landedinvoice, pr.currency, IFNULL(pr.id,'') as grid, pr.id as rowid,pr.externalcurrencyrate as spotrate,prd.id as detailid,prd.uom as uom,prd.id as rowdetailid,prd.srno as srno, pr.createdon as createdon,pm.productcategory,0 as termamount,gr.moduletemplateid as templateid from purchasereturn pr "
                    + " left join prdetails prd on prd.purchasereturn = pr.id "
                    + " left join inventory inv on inv.id = prd.id "
                    + " left join product p on p.id = inv.product "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " left join vendor v on v.id = pr.vendor "
                    + " left join grdetails grd on grd.id = prd.videtails "
                    + " left join goodsreceipt gr on gr.id = grd.goodsreceipt "
                    + " where pr.company = ? and p.deleteflag = 'F' and pr.deleteflag='F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' "  +vendorCondition+" "+productCondition+" "+ purchaseReturnConditionSQL;
            String assemblySubProduct = "select 5 as transType, p.id, p.productid as productid, p.description as description, productbuild.entrydate as date, productbuild.refno as transactionNumber,'' as acccode ,'' as name ,'' as vid,(inventoryquantity*quantity),pb.rate as rate,1, '' as landedinvoice,'', '' as grid, IFNULL(pb.id,'') as rowid,'' as spotrate,pb.id as detailid,p.unitOfMeasure as uom,pb.id as rowdetailid,'' as srno, '' as createdon,pm.productcategory,0 as termamount,'' as templateid from pbdetails pb "
                    + " inner join productbuild on productbuild.id=pb.build "
                    + " left join product p on p.id = pb.aproduct "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " where productbuild.company = ? and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' "+productCondition+" " + buildassemblyConditionSQL;
            String assemblyMainProduct = " select 0 as transType, p.id, p.productid as productid, p.description as description, pb.entrydate as date, pb.refno as transactionNumber,'' as acccode ,'' as name ,'',pb.quantity,(pb.productcost/pb.quantity) as rate,1, '' as landedinvoice,'', '' as grid, IFNULL(pb.id,'') as rowid,'' as spotrate,'' as detailid,p.unitOfMeasure as uom,'' as rowdetailid,'' as srno, '' as createdon,pm.productcategory,'' as termamount,mtempl.templateid as templateid  from productbuild pb "
                    + " left join product p on p.id = pb.product "
                    + " left join excisedetailstemplatemap as extempld on extempld.warehouseid = p.warehouse "
                    + " left join moduletemplate as mtempl on mtempl.companyunitid= extempld.id "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " where pb.company = ? and pb.refno != '' and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' "+productCondition+" " + buildassemblyMainConditionSQL;
           String salesReturn = " select 4 as transType, p.id, p.productid as productid, srd.description as description, sr.orderdate as date, sr.srnumber as transactionNumber, c.acccode as acccode, c.name as name, c.id as vid, inv.quantity as invquantity, srd.rate as rate, inv.baseuomrate, '' as landedinvoice, sr.currency, '' as grid, IFNULL(sr.id,'') as rowid,sr.externalcurrencyrate as spotrate,srd.id as detailid,srd.uom as uom,srd.id as rowdetailid,srd.srno as srno, sr.createdon as createdon,pm.productcategory,0 as termamount,invoice.moduletemplateid as templateid from salesreturn sr "
                    + " left join srdetails srd on srd.salesreturn = sr.id "
                    + " left join invoicedetails invoiced  on invoiced.id = srd.cidetails "
                    + " left join invoice  on invoice.id = invoiced.invoice "
                    + " left join inventory inv on inv.id = srd.id "
                    + " left join product p on p.id = inv.product "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " left join customer c on c.id = sr.customer "
                    + " where sr.company = ? and sr.deleteflag='F' and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' "  +customerCondition+" "+productCondition+" " + salesReturnConditionSQL;
            String deliveryOrder = "select 3 as transType, p.id, p.productid as productid, dod.description as description, do.orderdate as date, do.donumber as transactionNumber, c.acccode as acccode, c.name as name, c.id as vid, inv.quantity  as invquantity, dod.rate as rate, inv.baseuomrate, ' ' as landedinvoice, do.currency, ' ' as grid, IFNULL(do.id,'') as rowid, do.externalcurrencyrate as spotrate,dod.id as detailid,dod.uom as uom,dod.id as rowdetailid,dod.srno as srno, do.createdon as createdon,pm.productcategory,0 as termamount,invoice.moduletemplateid as templateid from deliveryorder do "
                    + " left join dodetails dod on dod.deliveryorder = do.id "
                    + " left join invoicedetails invoiced  on invoiced.id = dod.cidetails "
                    + " left join invoice  on invoice.id = invoiced.invoice "
                    + " left join inventory inv on inv.id = dod.id "
                    + " left join product p on p.id = inv.product "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " left join customer c on c.id = do.customer "
                    + " where do.company = ? and do.deleteflag= 'F' and do.approvestatuslevel=11 and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' " +customerCondition+" "+productCondition+" "+ deliveryOrderConditionSQL;
//            String invoice = "select 10 as transType, p.id as pid,p.productid as productid, p.description as description, je.entrydate as date, invoice.invoicenumber as transactionNumber,  inv.quantity as quantity, inv.uom as uom, '' as packaging, inv.baseuomrate as uomrate, p.hscode as hsncode,invoice.moduletemplateid as templateid "
//                    + " from invoice "
//                    + " left join journalentry je on je.id = invoice.journalentry  "
//                    + " left join invoicedetails invd on invd.invoice = invoice.id"
//                    + " left join inventory inv on inv.id = invd.id "
//                    + " left join product p on p.id = inv.product "
//                    + " where p.deleteflag = 'F' and p.company= ? and  invoice.isexciseinvoice = 1 " ;

            String mysqlQuery = "";
            if (docType == 0) {
                params.addAll(openingBalanceParams);
                params.addAll(goodsReceiptParams);
                params.addAll(purchaseReturnParams);
                params.addAll(assemblyProductParams);
                params.addAll(assemblyProductParamsMain);
                params.addAll(deliveryOrderParams);
                params.addAll(salesReturnParams);
                
                String unionQry=" ("
                        + " (" + initialQuantity + ") "
                        + " UNION "
                        + " (" + grOrder + ") "
                        + " UNION "
                        + " (" + purchaseReturn + ") "
                        + " UNION "
                        + " (" + assemblySubProduct + ") "
                        + " UNION "
                        + " (" + assemblyMainProduct + ") "
                        + " UNION"
                        + " (" + deliveryOrder + ") "
                        + " UNION "
                        + " (" + salesReturn + ") "
                        + " ) ";
                
                String innerCondition = "";
                String pagingQry = "";
                
                if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false && (isFromStockReport || isInventoryValuation)) {
                    String t2CondiQuer = " ";
                    if (!StringUtil.isNullOrEmpty(productCategoryId)) {
                        t2CondiQuer  = " WHERE t2.productcategory = '" + productCategoryId + "'  AND t2.productcategory IS NOT NULL";
                    }
                    params.addAll(openingBalanceParams);
                    params.addAll(goodsReceiptParams);
                    params.addAll(purchaseReturnParams);
                    params.addAll(assemblyProductParams);
                    params.addAll(assemblyProductParamsMain);
                    params.addAll(deliveryOrderParams);
                    params.addAll(salesReturnParams);
                    params.addAll(stockInParams);
                    params.addAll(stockSalesParams);
                    params.addAll(stockOutParams);
                    
                    innerCondition = " INNER JOIN (SELECT distinct id FROM " + unionQry + " as t2 " + t2CondiQuer + " order by t2.id LIMIT " + start + "," + limit + ") as prodInnerQry ON prodInnerQry.id=t1.id ";
                    
                    pagingQry = " SELECT distinct id FROM " + unionQry + " as t2 " + t2CondiQuer;
                    
                    pagingParams.addAll(openingBalanceParams);
                    pagingParams.addAll(goodsReceiptParams);
                    pagingParams.addAll(purchaseReturnParams);
                    pagingParams.addAll(assemblyProductParams);
                    pagingParams.addAll(assemblyProductParamsMain);
                    pagingParams.addAll(deliveryOrderParams);
                    pagingParams.addAll(salesReturnParams);
//                    pagingParams.addAll(stockInParams);
//                    pagingParams.addAll(stockSalesParams);
//                    pagingParams.addAll(stockOutParams);
                    
                    pagingReturnList = executeSQLQuery(pagingQry, pagingParams.toArray());
                }
                mysqlQuery = "SELECT * FROM "+unionQry +" as t1 "+innerCondition+" where t1.invquantity !=0 ";
            }
            
            if (!(StringUtil.isNullOrEmpty(customerVendorId)) && !isStockLedger) {
                mysqlQuery += "and (t1.name != NULL OR t1.name!= '')";
            }
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"t1.productid", "t1.description", "t1.transactionNumber", "t1.acccode", "t1.name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 5);
                StringUtil.insertParamSearchString(map);
                mysqlQuery = mysqlQuery + StringUtil.getSearchString(ss, "and", searchcol);
            }
            
            if (requestParams.containsKey("exciseUnit") && !StringUtil.isNullOrEmpty((String) requestParams.get("exciseUnit"))) {
                mysqlQuery += " and t1.templateid in( select templateid from moduletemplate where companyunitid = ? ) ";
                params.add(requestParams.get("exciseUnit"));
            }
            
            
            mysqlQuery += " order by t1.productid ,t1.date ,t1.createdon,t1.srno asc";
            returnList = executeSQLQuery(mysqlQuery, params.toArray());
            if(isInventoryValuation || isFromStockReport){
                totalCount=pagingReturnList.size();
            }else{
                totalCount = returnList.size();
            }

            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false  && !isFromStockReport && !isInventoryValuation) {
                returnList = executeSQLQueryPaging(mysqlQuery, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }
    
     @Override
    public KwlReturnObject getDailyStockRegister(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        try {
            DateFormat df = (DateFormat) requestParams.get(Constants.df);
            String start = (String) requestParams.get("start");
            String limit = (String) requestParams.get("limit");
            
            ArrayList assemblyMainProductParams = new ArrayList();
            ArrayList assemblySubProductParams = new ArrayList();
            ArrayList purchaseInvoiceParams = new ArrayList();
            ArrayList stockTransferParams = new ArrayList();
            ArrayList invoiceParams = new ArrayList();
            ArrayList params = new ArrayList();
            
            String assemblyMainProduct = " select 0 as transType, p.id as pid,p.productid as productid, p.description as description, pb.entrydate as date, pb.refno as transactionNumber,  pb.quantity as quantity, p.unitOfMeasure as uom, '' as packaging, '' as uomrate, p.hscode as hsncode,'' as templateid,'' as transactionid,'' as transactiondetailid  "
                    + " from productbuild pb "
                    + " left join product p on p.id = pb.product "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " where pb.company = ? and pb.refno != '' and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";
            
            String assemblySubProduct = "select 1 as transType, p.id as pid,p.productid as productid, p.description as description, productbuild.entrydate as date, productbuild.refno as transactionNumber, (inventoryquantity*quantity) as quantity, p.unitOfMeasure as uom, '' as packaging, '' as uomrate, p.hscode as hsncode,'' as templateid,'' as transactionid,'' as transactiondetailid "
                    + " from pbdetails pb "
                    + " inner join productbuild on productbuild.id=pb.build "
                    + " left join product p on p.id = pb.aproduct "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " where productbuild.company = ? and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            
            String purchaseInvoice = "select 2 as transType, p.id as pid,p.productid as productid, p.description as description, je.entrydate as date, gr.grnumber as transactionNumber,  inv.quantity as quantity, inv.uom as uom, '' as packaging, inv.baseuomrate as uomrate, p.hscode as hsncode,gr.moduletemplateid as templateid, gr.id as transactionid, grd.id as transactiondetailid "
                    + " from goodsreceipt gr "
                    + " left join journalentry je on je.id = gr.journalentry  "
                    + " left join grdetails grd on grd.goodsreceipt = gr.id"
                    + " left join inventory inv on inv.id = grd.id "
                    + " left join product p on p.id = inv.product "
                    + " where p.deleteflag = 'F' and p.company= ? and  gr.isexciseinvoice = 1 " ;
           
            String inventoryStockRegister = "select 3 as transType, p.id as pid,p.productid as productid, p.description as description, st.businessdate as date, st.transactionno as transactionNumber,  st.acceptedqty as quantity, st.uom as uom, st.packaging, '' as uomrate, p.hscode as hsncode,'' as templateid,'' as transactionid,'' as transactiondetailid  "
                    + " from in_interstoretransfer st "
                    + " left join product p on p.id = st.product "
                    + " where p.deleteflag = 'F' and p.company= ? " ;
            
            String invoice = "select 4 as transType, p.id as pid,p.productid as productid, p.description as description, je.entrydate as date, invoice.invoicenumber as transactionNumber,  inv.quantity as quantity, inv.uom as uom, '' as packaging, inv.baseuomrate as uomrate, p.hscode as hsncode,invoice.moduletemplateid as templateid, invoice.id as transactionid, invd.id as transactiondetailid  "
                    + " from invoice "
                    + " left join journalentry je on je.id = invoice.journalentry  "
                    + " left join invoicedetails invd on invd.invoice = invoice.id"
                    + " left join inventory inv on inv.id = invd.id "
                    + " left join product p on p.id = inv.product "
                    + " where p.deleteflag = 'F' and p.company= ? and  invoice.isexciseinvoice = 1 " ;
            
            String unionQry=" ("
                        + " (" + assemblyMainProduct + ") "
                        + " UNION "
                        + " (" + assemblySubProduct + ") "
                        + " UNION "
                        + " (" + purchaseInvoice + ") "
                        + " UNION "
                        + " (" + inventoryStockRegister + ") "
                        + " UNION "
                        + " (" + invoice + ") "
                        + " ) ";
            String mysqlquery = " select * from "+unionQry+" as t1";
            
            
            String companyid = requestParams.get("companyid").toString();
            
            assemblyMainProductParams.add(companyid);
            assemblySubProductParams.add(companyid);
            purchaseInvoiceParams.add(companyid);
            stockTransferParams.add(companyid);
            invoiceParams.add(companyid);
            
            params.addAll(assemblyMainProductParams);
            params.addAll(assemblySubProductParams);
            params.addAll(purchaseInvoiceParams);
            params.addAll(stockTransferParams);
            params.addAll(invoiceParams);
            
            String startDate = (String) requestParams.get(Constants.REQ_startdate);
            String endDate = (String) requestParams.get(Constants.REQ_enddate);
            String conditionQuery = "";
            if (!StringUtil.isNullOrEmpty(startDate) && !StringUtil.isNullOrEmpty(endDate)) {
                conditionQuery += " (t1.date >=? and t1.date <=?) ";
                params.add(df.parse(startDate));
                params.add(df.parse(endDate));
            }
            if (requestParams.containsKey("productid") && !StringUtil.isNullOrEmpty(requestParams.get("productid").toString())) {
                if(!StringUtil.isNullOrEmpty(conditionQuery)){
                    conditionQuery += " and ";
                }
                conditionQuery += " t1.pid = ? ";
                params.add(requestParams.get("productid"));
            }
            if (requestParams.containsKey("exciseunit") && !StringUtil.isNullOrEmpty(requestParams.get("exciseunit").toString())) {
                if(!StringUtil.isNullOrEmpty(conditionQuery)){
                    conditionQuery += " and ";
                }
                conditionQuery += " t1.templateid in( select templateid from moduletemplate where companyunitid = ? ) ";
                params.add(requestParams.get("exciseunit"));
            }
            if(!StringUtil.isNullOrEmpty(conditionQuery)){
                mysqlquery += " where "+conditionQuery;
            }
            mysqlquery += " order by t1.pid ,t1.date ,t1.transactionNumber asc";
            
            returnList = executeSQLQuery(mysqlquery, params.toArray());
            totalCount = returnList.size();
//            if ( !StringUtil.isNullOrEmpty(start) && !StringUtil.isNullOrEmpty(limit)) {
//                returnList = executeSQLQueryPaging(mysqlquery, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
//            }
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }
    
    @Override
    public KwlReturnObject getDetailedStockMovementList(HashMap<String, Object> requestParams) throws ServiceException {
        String company = "";
        Date fromDate = null;
        Date toDate = null;
        String fd = "";
        String td = "";
        String searchString = "";
        String store = "";
        String start = "";
        String limit = "";
        if (requestParams.containsKey("companyId") && requestParams.get("companyId") != null) {
            company = requestParams.get("companyId").toString();
        }
        if (requestParams.containsKey("fromDate") && requestParams.get("fromDate") != null) {
            fd = requestParams.get("fromDate").toString();
        }
        if (requestParams.containsKey("toDate") && requestParams.get("toDate") != null) {
            td = requestParams.get("toDate").toString();
        }
        DateFormat df = null;
        try {
            df = authHandler.getDateOnlyFormat();
        } catch (SessionExpiredException ex) {
            df = new SimpleDateFormat("yyyy-MM-dd");
        }
        if (!StringUtil.isNullOrEmpty(fd) && !StringUtil.isNullOrEmpty(td)) {
            try {
                fromDate = df.parse(fd);
                toDate = df.parse(td);
            } catch (ParseException ex) {
            }
        }
        if (requestParams.containsKey("searchString") && requestParams.get("searchString") != null) {
            searchString = requestParams.get("searchString").toString();
        }
        if (requestParams.containsKey("storeId") && requestParams.get("storeId") != null) {
            store = requestParams.get("storeId").toString();
        }
        if (requestParams.containsKey("start") && requestParams.get("start") != null) {
            start = requestParams.get("start").toString();
        }
        if (requestParams.containsKey("limit") && requestParams.get("limit") != null) {
            limit = requestParams.get("limit").toString();
        }
        boolean isActivateMRPModule = false;
        if (requestParams.containsKey("isActivateMRPModule") && requestParams.get("isActivateMRPModule") != null) {
            isActivateMRPModule = Boolean.parseBoolean(requestParams.get("isActivateMRPModule").toString());
        }
        List params = new ArrayList();
        ArrayList openingParams = new ArrayList();
        ArrayList goodsReceiptParams = new ArrayList();
        ArrayList deliveryOrderParams = new ArrayList();
        ArrayList purchaseReturnParams = new ArrayList();
        ArrayList salesReturnParams = new ArrayList();
        ArrayList stockAdParams = new ArrayList();
        ArrayList stockAdINParams = new ArrayList();
        ArrayList stockTransParams = new ArrayList();
        ArrayList inventorySRIssueParams = new ArrayList();
        ArrayList inventorySRCollectParams = new ArrayList();
        ArrayList inventoryINIssueParams = new ArrayList();
        ArrayList inventoryINCollectParams = new ArrayList();
        ArrayList inventoryISTIssueParams = new ArrayList();
        ArrayList inventoryISTCollectParams = new ArrayList();
        ArrayList inventoryILTIssueParams = new ArrayList();
        ArrayList inventoryILTCollectParams = new ArrayList();
        ArrayList buildAssemblyMainProductParams = new ArrayList();
        ArrayList unbuildAssemblyMainProductParams = new ArrayList();
        ArrayList unbuildAssemblySubProductParams = new ArrayList();
        ArrayList buildAssemblySubProductParams = new ArrayList();
        ArrayList workOrderParams = new ArrayList();
        ArrayList workOrderDetailsParams = new ArrayList();
        
        List returnList = new ArrayList();
        int totalCount = 0;
        String condition = "";
        
        if (isActivateMRPModule) {
            workOrderParams.add(company);
            workOrderParams.add(store);
            workOrderParams.add(fromDate);
            workOrderParams.add(toDate);

            workOrderDetailsParams.add(company);
            workOrderDetailsParams.add(store);
            workOrderDetailsParams.add(fromDate);
            workOrderDetailsParams.add(toDate);

            if (!StringUtil.isNullOrEmpty(searchString)) {
                condition = " AND ( p.productid LIKE ? OR p.name LIKE ?) ";
                workOrderParams.add("%" + searchString + "%");
                workOrderParams.add("%" + searchString + "%");
            }

            if (!StringUtil.isNullOrEmpty(searchString)) {
                condition = " AND ( p.productid LIKE ? OR p.name LIKE ?) ";
                workOrderDetailsParams.add("%" + searchString + "%");
                workOrderDetailsParams.add("%" + searchString + "%");
            }
        }
        
        openingParams.add(company);
        openingParams.add(store);
        openingParams.add(fromDate);
        openingParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            condition = " AND ( p.productid LIKE ? OR p.name LIKE ?) ";
            openingParams.add("%" + searchString + "%");
            openingParams.add("%" + searchString + "%");
        }
        goodsReceiptParams.add(company);
        goodsReceiptParams.add(store);
        goodsReceiptParams.add(fromDate);
        goodsReceiptParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            condition = " AND ( p.productid LIKE ? OR p.name LIKE ?) ";
            goodsReceiptParams.add("%" + searchString + "%");
            goodsReceiptParams.add("%" + searchString + "%");
        }
        deliveryOrderParams.add(company);
        deliveryOrderParams.add(store);
        deliveryOrderParams.add(fromDate);
        deliveryOrderParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            deliveryOrderParams.add("%" + searchString + "%");
            deliveryOrderParams.add("%" + searchString + "%");
        }
        purchaseReturnParams.add(company);
        purchaseReturnParams.add(store);
        purchaseReturnParams.add(fromDate);
        purchaseReturnParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            purchaseReturnParams.add("%" + searchString + "%");
            purchaseReturnParams.add("%" + searchString + "%");
        }
        salesReturnParams.add(company);
        salesReturnParams.add(store);
        salesReturnParams.add(fromDate);
        salesReturnParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            salesReturnParams.add("%" + searchString + "%");
            salesReturnParams.add("%" + searchString + "%");
        }
        stockAdINParams.add(company);
        stockAdINParams.add(store);
        stockAdINParams.add(fromDate);
        stockAdINParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            stockAdINParams.add("%" + searchString + "%");
            stockAdINParams.add("%" + searchString + "%");
        }
        stockAdParams.add(company);
        stockAdParams.add(store);
        stockAdParams.add(fromDate);
        stockAdParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            stockAdParams.add("%" + searchString + "%");
            stockAdParams.add("%" + searchString + "%");
        }
        stockTransParams.add(company);
        stockTransParams.add(store);
        stockTransParams.add(fromDate);
        stockTransParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            stockTransParams.add("%" + searchString + "%");
            stockTransParams.add("%" + searchString + "%");
        }
        
        inventorySRIssueParams.add(company);
        inventorySRIssueParams.add(store);
        inventorySRIssueParams.add(fromDate);
        inventorySRIssueParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            inventorySRIssueParams.add("%" + searchString + "%");
            inventorySRIssueParams.add("%" + searchString + "%");
        }
        
        inventorySRCollectParams.add(company);
        inventorySRCollectParams.add(store);
        inventorySRCollectParams.add(fromDate);
        inventorySRCollectParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            inventorySRCollectParams.add("%" + searchString + "%");
            inventorySRCollectParams.add("%" + searchString + "%");
        }
        
        inventoryINIssueParams.add(company);
        inventoryINIssueParams.add(store);
        inventoryINIssueParams.add(fromDate);
        inventoryINIssueParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            inventoryINIssueParams.add("%" + searchString + "%");
            inventoryINIssueParams.add("%" + searchString + "%");
        }
        
        inventoryINCollectParams.add(company);
        inventoryINCollectParams.add(store);
        inventoryINCollectParams.add(fromDate);
        inventoryINCollectParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            inventoryINCollectParams.add("%" + searchString + "%");
            inventoryINCollectParams.add("%" + searchString + "%");
        }
        
        inventoryISTIssueParams.add(company);
        inventoryISTIssueParams.add(store);
        inventoryISTIssueParams.add(fromDate);
        inventoryISTIssueParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            inventoryISTIssueParams.add("%" + searchString + "%");
            inventoryISTIssueParams.add("%" + searchString + "%");
        }
        
        inventoryISTCollectParams.add(company);
        inventoryISTCollectParams.add(store);
        inventoryISTCollectParams.add(fromDate);
        inventoryISTCollectParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            inventoryISTCollectParams.add("%" + searchString + "%");
            inventoryISTCollectParams.add("%" + searchString + "%");
        }
        
        inventoryILTIssueParams.add(company);
        inventoryILTIssueParams.add(store);
        inventoryILTIssueParams.add(fromDate);
        inventoryILTIssueParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            inventoryILTIssueParams.add("%" + searchString + "%");
            inventoryILTIssueParams.add("%" + searchString + "%");
        }
        
        inventoryILTCollectParams.add(company);
        inventoryILTCollectParams.add(store);
        inventoryILTCollectParams.add(fromDate);
        inventoryILTCollectParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            inventoryILTCollectParams.add("%" + searchString + "%");
            inventoryILTCollectParams.add("%" + searchString + "%");
        }
        
        buildAssemblyMainProductParams.add(company);
        buildAssemblyMainProductParams.add(store);
        buildAssemblyMainProductParams.add(fromDate);
        buildAssemblyMainProductParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            buildAssemblyMainProductParams.add("%" + searchString + "%");
            buildAssemblyMainProductParams.add("%" + searchString + "%");
        }
        
        buildAssemblySubProductParams.add(company);
        buildAssemblySubProductParams.add(store);
        buildAssemblySubProductParams.add(fromDate);
        buildAssemblySubProductParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            buildAssemblySubProductParams.add("%" + searchString + "%");
            buildAssemblySubProductParams.add("%" + searchString + "%");
        }
        
        unbuildAssemblyMainProductParams.add(company);
        unbuildAssemblyMainProductParams.add(store);
        unbuildAssemblyMainProductParams.add(fromDate);
        unbuildAssemblyMainProductParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            unbuildAssemblyMainProductParams.add("%" + searchString + "%");
            unbuildAssemblyMainProductParams.add("%" + searchString + "%");
        }
        
        unbuildAssemblySubProductParams.add(company);
        unbuildAssemblySubProductParams.add(store);
        unbuildAssemblySubProductParams.add(fromDate);
        unbuildAssemblySubProductParams.add(toDate);
        if (!StringUtil.isNullOrEmpty(searchString)) {
            unbuildAssemblySubProductParams.add("%" + searchString + "%");
            unbuildAssemblySubProductParams.add("%" + searchString + "%");
        }
        try {

//            Advance Search code
            String doJoin = "";
            String grJoin = "";
            String prJoin = "";
            String srJoin = "";
            String productJoin = "";
            String saJoin = "";
            String istJoin = "";
            String appendCase = "and";
            String mySearchFilterString = "";
            String openingConditionSQL = "";
            String goodsReceiptConditionSQL = "";
            String purchaseReturnConditionSQL = "";
            String deliveryOrderConditionSQL = "";
            String salesReturnConditionSQL = "";
            String stockAdustConditionSQL = "";
            String interStoreTransferConditionSQL = "";
            String stockInSQL = "";
            boolean isAdvanceSearch = false;
            JSONArray doJson = new JSONArray();
            JSONArray grJson = new JSONArray();
            JSONArray srJson = new JSONArray();
            JSONArray prJson = new JSONArray();
            JSONArray productJson = new JSONArray();
            JSONArray stockAdjustmentJson = new JSONArray();
            JSONArray interStoreTransferJson = new JSONArray();
            String filterConjuctionCriteria = com.krawler.common.util.Constants.and;
            if (requestParams.containsKey("filterConjuctionCriteria") && requestParams.get("filterConjuctionCriteria") != null) {
                if (requestParams.get("filterConjuctionCriteria").toString().equalsIgnoreCase("OR")) {
                    filterConjuctionCriteria = com.krawler.common.util.Constants.or;
                }
            }
            String Searchjson = "";
            if (requestParams.containsKey("searchJson") && requestParams.get("searchJson") != null) {
                Searchjson = requestParams.get("searchJson").toString();

                if (!StringUtil.isNullOrEmpty(Searchjson)) {
                    isAdvanceSearch = true;
                    // For getting Search Json
                    String iscustomcolumn = "", iscustomcolumndata = "", isfrmpmproduct = "", fieldtype = "", searchText = "", columnheader = "",
                            xtype = "", combosearch = "", isinterval = "", interval = "", isbefore = "", isdefaultfield = "", isForProductMasterOnly = "";
                    JSONObject SearchJsonObj = new JSONObject(Searchjson);
                    JSONArray SearchJsonArray = SearchJsonObj.getJSONArray("root");

                    for (int searckArr = 0; searckArr < SearchJsonArray.length(); searckArr++) {
                        JSONObject compareObj = SearchJsonArray.optJSONObject(searckArr);
                        iscustomcolumn = compareObj.optString("iscustomcolumn");
                        iscustomcolumndata = compareObj.optString("iscustomcolumndata");
                        isfrmpmproduct = compareObj.optString("isfrmpmproduct");
                        fieldtype = compareObj.optString("fieldtype");
                        searchText = compareObj.optString("searchText");
                        columnheader = compareObj.optString("columnheader");
                        columnheader = StringUtil.DecodeText(columnheader);
                        xtype = compareObj.optString("xtype");
                        combosearch = compareObj.optString("combosearch");
                        isinterval = compareObj.optString("isinterval");
                        interval = compareObj.optString("interval");
                        isbefore = compareObj.optString("isbefore");
                        isdefaultfield = compareObj.optString("isdefaultfield");
                        isForProductMasterOnly = compareObj.optString("isForProductMasterOnly");

                        String[] coldataArray = combosearch.split(",");
                        String Coldata = "";
                        for (int countArray = 0; countArray < coldataArray.length; countArray++) {
                            Coldata += "'" + coldataArray[countArray] + "',";
                        }
                        Coldata = Coldata.substring(0, Coldata.length() - 1);
                        HashMap<String, Object> requestParams1 = new HashMap<String, Object>();
//                        columnheader = compareObj.optString("columnheader");
                        requestParams1.put(Constants.filter_names, Arrays.asList(Constants.companyid, "fieldlabel"));
                        requestParams1.put(Constants.filter_values, Arrays.asList(company, columnheader));
                        KwlReturnObject result = accAccountDAOobj.getFieldParams(requestParams1);
                        List<FieldParams> lst = result.getEntityList();
                        for (FieldParams fieldParams : lst) {
                            int module = fieldParams.getModuleid();
                            if (module == Constants.Acc_Delivery_Order_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Delivery_Order_ModuleId);
                                doJson.put(cntObj);

                            } else if (module == Constants.Acc_Goods_Receipt_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Goods_Receipt_ModuleId);
                                grJson.put(cntObj);

                            } else if (module == Constants.Acc_Sales_Return_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Sales_Return_ModuleId);
                                srJson.put(cntObj);

                            } else if (module == Constants.Acc_Purchase_Return_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Purchase_Return_ModuleId);
                                prJson.put(cntObj);
                            } else if (module == Constants.Acc_Product_Master_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                                }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_Product_Master_ModuleId);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                productJson.put(cntObj);
                            } else if (module == Constants.Inventory_Stock_Adjustment_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                            }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Inventory_Stock_Adjustment_ModuleId);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                stockAdjustmentJson.put(cntObj);
                            }else if (module == Constants.Acc_InterStore_ModuleId) {
                                if (fieldtype.equalsIgnoreCase("" + 4) || fieldtype.equalsIgnoreCase("" + 7) || fieldtype.equalsIgnoreCase("" + 12)) {
                                    searchText = fieldManagerDAOobj.getIdsUsingParamsValue(fieldParams.getId(), Coldata.replaceAll("'", ""));
                        }
                                JSONObject cntObj = new JSONObject();
                                cntObj.put("iscustomcolumn", iscustomcolumn);
                                cntObj.put("iscustomcolumndata", iscustomcolumndata);
                                cntObj.put("isfrmpmproduct", isfrmpmproduct);
                                cntObj.put("fieldtype", fieldtype);
                                cntObj.put("columnheader", columnheader);
                                cntObj.put("xtype", xtype);
                                cntObj.put("isinterval", isinterval);
                                cntObj.put("interval", interval);
                                cntObj.put("isbefore", isbefore);
                                cntObj.put("isdefaultfield", isdefaultfield);
                                cntObj.put("searchText", searchText);
                                cntObj.put("search", searchText);
                                cntObj.put("combosearch", combosearch);
                                cntObj.put("column", fieldParams.getId());
                                cntObj.put("refdbname", "Col" + fieldParams.getColnum());
                                cntObj.put("xfield", "Col" + fieldParams.getColnum());
                                cntObj.put("moduleid", Constants.Acc_InterStore_ModuleId);
                                cntObj.put("isForProductMasterOnly", isForProductMasterOnly);
                                interStoreTransferJson.put(cntObj);
                    }
                        }
                    }
                    if (doJson.length() > 0) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", doJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Delivery_Order_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        if (mySearchFilterString.contains("deliveryordercustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "deliveryordercustomdata");
                            doJoin = " left join deliveryordercustomdata on deliveryordercustomdata.deliveryOrderId=do.accdeliveryordercustomdataref ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "dodetailscustomdata");
                            doJoin += " left join dodetailscustomdata on dod.id=dodetailscustomdata.dodetailsid ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(deliveryOrderParams, putSearchJson.toString());
                        deliveryOrderConditionSQL += mySearchFilterString;
                    }
                    if (grJson.length() > 0) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", grJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Goods_Receipt_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        if (mySearchFilterString.contains("grordercustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "grordercustomdata");
                            grJoin = " left join grordercustomdata on grordercustomdata.goodsreceiptorderid=gro.accgrordercustomdataref ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "grodetailscustomdata");
                            grJoin += " left join grodetailscustomdata on grod.id=grodetailscustomdata.grodetailsid ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(goodsReceiptParams, putSearchJson.toString());
                        goodsReceiptConditionSQL += mySearchFilterString;
                    }
                    if (srJson.length() > 0) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", srJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Sales_Return_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        if (mySearchFilterString.contains("salesreturncustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "salesreturncustomdata");
                            srJoin = " left join salesreturncustomdata on salesreturncustomdata.salesreturnid=sr.accsalesreturncustomdataref ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "srdetailscustomdata");
                            srJoin += " left join srdetailscustomdata on srd.id=srdetailscustomdata.srdetailsid ";
                        }

                        StringUtil.insertParamAdvanceSearchString1(salesReturnParams, putSearchJson.toString());
                        salesReturnConditionSQL += mySearchFilterString;
                    }
                    if (prJson.length() > 0) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", prJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Purchase_Return_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));
                        if (mySearchFilterString.contains("purchasereturncustomdata") || mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "purchasereturncustomdata");
                            prJoin = " left join purchasereturncustomdata on purchasereturncustomdata.purchasereturnid=pr.accpurchasereturncustomdataref ";
                        }
                        if (mySearchFilterString.contains("AccJEDetailCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "prdetailscustomdata");
                            prJoin += " left join prdetailscustomdata on prd.id=prdetailscustomdata.prdetailsid ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(purchaseReturnParams, putSearchJson.toString());
                        purchaseReturnConditionSQL += mySearchFilterString;
                    }
                    if (productJson.length() > 0) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", productJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_Product_Master_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));

                        if (mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "accproductcustomdata");
                            productJoin += " left join accproductcustomdata on p.id=accproductcustomdata.productId ";
                        }
                        StringUtil.insertParamAdvanceSearchString1(openingParams, putSearchJson.toString());
                        openingConditionSQL += mySearchFilterString;
                    }
                    if (stockAdjustmentJson.length() > 0) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", stockAdjustmentJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Inventory_Stock_Adjustment_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));

                        if (mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "in_stockadjustment_customdata");
                        }
                        saJoin += " left join in_stockadjustment_customdata on sa.id=in_stockadjustment_customdata.stockadjustmentid ";
                        StringUtil.insertParamAdvanceSearchString1(stockAdParams, putSearchJson.toString());
                        stockAdustConditionSQL += mySearchFilterString;
                    }
                    if (interStoreTransferJson.length() > 0) {
                        JSONObject putSearchJson = new JSONObject();
                        putSearchJson.put("root", interStoreTransferJson);
                        requestParams.clear();
                        requestParams.put(Constants.Searchjson, putSearchJson);
                        requestParams.put(Constants.appendCase, appendCase);
                        requestParams.put(Constants.moduleid, Constants.Acc_InterStore_ModuleId);
                        requestParams.put("filterConjuctionCriteria", filterConjuctionCriteria);
                        mySearchFilterString = String.valueOf(StringUtil.getAdvanceSearchString(requestParams, true).get(Constants.myResult));

                        if (mySearchFilterString.contains("AccJEDetailsProductCustomData")) {
                            mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "in_interstoretransfer_customdata");
                        }
                        istJoin += " left join in_interstoretransfer_customdata on ist.id=in_interstoretransfer_customdata.istid ";
                        StringUtil.insertParamAdvanceSearchString1(stockTransParams, putSearchJson.toString());
                        interStoreTransferConditionSQL += mySearchFilterString;
                    }
                }  // end of search json check
            }

            String productQuery = " select smd.id as smdid,sm.id as smid ,p.id as productid,p.createdon as createdon, 'Product' as module,p.id as moduleid, p.id as moduledetailid, "
                    + " 0 as transType,p.id,updatedate as date,inv.baseuomrate,p.currency as currency, '' as spotrate,p.id as detailid,'' as srno"
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Initial Quantity                                                                                                  
                    + " INNER JOIN product p on sm.modulerefid=p.id "
                    + " left JOIN inventory inv on inv.product=p.id ";

            String grQuery = " select smd.id as smdid,sm.id as smid,p.id as productid,gro.createdon as createdon ,'Goods Receipt' as module,gro.id as moduleid, grod.id as moduledetailid,"
                    + " 1 as transType, p.id,  gro.grorderdate as date, inv.baseuomrate, gro.currency,  gro.externalcurrencyrate as spotrate,grod.id as detailid,grod.srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement" //Goods Receipt Order
                    + " INNER JOIN grodetails grod on grod.id=sm.modulerefdetailid "
                    + " INNER JOIN grorder gro on grod.grorder=gro.id "
                    + " left join inventory inv on inv.id = grod.id "
                    + " INNER join product p on (inv.product=p.id and p.id=sm.product)";

            String doquery = " select smd.id as smdid,sm.id as smid,p.id as productid,do.createdon as createdon ,'Delivery Order' as module,do.id as moduleid, dod.id as moduledetailid, "
                    + " 3 as transType, p.id,  do.orderdate as date, inv.baseuomrate, do.currency,  do.externalcurrencyrate as spotrate,dod.id as detailid,dod.srno " 
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Delivery Order
                    + " INNER JOIN dodetails dod on dod.id=sm.modulerefdetailid "
                    + " INNER JOIN deliveryorder do on do.id=dod.deliveryorder "
                    + " left join inventory inv on inv.id = dod.id "
                    + " INNER join product p on (inv.product=p.id and p.id=sm.product)";

            String prQuery = " select smd.id as smdid,sm.id as smid,p.id as productid,pr.createdon as createdon ,'Purchase Return' as module,pr.id as moduleid, prd.id as moduledetailid, "
                    + " 2 as transType, p.id,  pr.orderdate as date, inv.baseuomrate, pr.currency,  pr.externalcurrencyrate as spotrate,prd.id as detailid,prd.srno " 
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Purchase Return
                    + " INNER JOIN prdetails prd on prd.id=sm.modulerefdetailid "
                    + " INNER JOIN purchasereturn pr on pr.id=prd.purchasereturn "
                    + " left join inventory inv on inv.id = prd.id "
                    + " INNER join product p on (inv.product=p.id and p.id=sm.product)";
            
            String srQuery = " select smd.id as smdid,sm.id as smid,p.id as productid,sr.createdon as createdon ,'Sales Return' as module,sr.id as moduleid, srd.id as moduledetailid, "
                    + " 4 as transType, p.id,  sr.orderdate as date, inv.baseuomrate, sr.currency,  sr.externalcurrencyrate as spotrate,srd.id as detailid,srd.srno " 
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Sales Return
                    + " INNER JOIN srdetails srd on srd.id=sm.modulerefdetailid "
                    + " INNER JOIN salesreturn sr on sr.id=srd.salesreturn "
                    + " left join inventory inv on inv.id = srd.id "
                    + " INNER join product p on (inv.product=p.id and p.id=sm.product)";  
            
            String stockAdjustINQuery = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.creationdate as createdon ,'Stock Adjustment' as module,sa.id as moduleid, sad.id as moduledetailid,"
                    + " 7 as transType,p.id,CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno"
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Stock Adjustment
                    + " INNER JOIN in_stockadjustment sa on sa.id=sm.modulerefid "
                    + " INNER JOIN in_sa_detail sad on sad.stockadjustment=sa.id"
//                    + " left join inventory inv on inv.id = sa.inventoryref "
                    + " INNER join product p on (p.id=sm.product)";
            
            String stockAdjustQuery = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.creationdate as createdon ,'Stock Adjustment' as module,sa.id as moduleid, sad.id as moduledetailid,"
                    + " 8 as transType,p.id,CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Stock Adjustment
                    + " INNER JOIN in_stockadjustment sa on sa.id=sm.modulerefid "
                    + " INNER JOIN in_sa_detail sad on sad.stockadjustment=sa.id"
//                    + " left join inventory inv on inv.id = sa.inventoryref "
                    + " INNER join product p on (p.id=sm.product)";
            
            String buildAssemblyMainProduct = " select smd.id as smdid,sm.id as smid,p.id as productid,pb.createdon as createdon ,'Product Build Assembly' as module,pb.id as moduleid, pb.id as moduledetailid, "
                    + " 6 as transType, p.id,  pb.entrydate as date,1,' ', '' as spotrate,pb.id as detailid,'' "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN productbuild pb on pb.id=sm.modulerefdetailid "
                    + " INNER join product p on pb.product=p.id and p.id=sm.product";
            
            
            String buildAssemblySubProduct = " select smd.id as smdid,sm.id as smid,p.id as productid,pb.createdon as createdon ,'Product Build Assembly' as module,pbd.id as moduleid, pbd.id as moduledetailid, "
                    + " 5 as transType, p.id,  pb.entrydate as date,1,'', '' as spotrate,pb.id as detailid,'' "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN productbuild pb on pb.id=sm.modulerefdetailid "
		    + " INNER JOIN pbdetails pbd on pb.id = pbd.build "
                    + " INNER join product p on pbd.aproduct=p.id and p.id=sm.product";
            
            
            String unbuildAssemblyMainProduct = " select smd.id as smdid,sm.id as smid,p.id as productid,pb.createdon as createdon ,'Product Build Assembly' as module,pb.id as moduleid, pb.id as moduledetailid, "
                    + " 5 as transType, p.id,  pb.entrydate as date,1,' ', '' as spotrate,pb.id as detailid,'' "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN productbuild pb on pb.id=sm.modulerefdetailid "
                    + " INNER join product p on pb.product=p.id and p.id=sm.product";

            String unbuildAssemblySubProduct = " select smd.id as smdid,sm.id as smid,p.id as productid,pb.createdon as createdon ,'Product Build Assembly' as module,pbd.id as moduleid, pbd.id as moduledetailid, "
                    + " 6 as transType, p.id,  pb.entrydate as date,1,'', '' as spotrate,pb.id as detailid,'' "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN productbuild pb on pb.id=sm.modulerefdetailid "
                    + " INNER JOIN pbdetails pbd on pb.id = pbd.build "
                    + " INNER join product p on pbd.aproduct=p.id and p.id=sm.product";
//            String interstoreTransferQuery = " select smd.id as smdid,sm.id as smid,p.id as productid,UNIX_TIMESTAMP(ist.createdon )*1000 as createdon ,'Inter Store Transfer' as module,ist.id as moduleid, istd.id as moduledetailid,"
//                    + " 9 as transType,p.id,ist.businessdate as date,'','','' as spotrate,ist.id as detailid,'' as srno"
//                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Inter-Store/Inter-Location Transfer
//                    + " INNER JOIN in_interstoretransfer ist on ist.id=sm.modulerefid "
//                    + " INNER JOIN in_ist_detail istd on istd.istrequest=ist.id"
//                    + " INNER JOIN product p on sm.product=p.id ";
            
            
            String inventorySRIssue = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.issueddate as createdon ,'Stock Request' as module,sa.id as moduleid, sad.id as moduledetailid,"
                    + " 9 as transType, p.id,CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN in_goodsrequest sa on sa.id=sm.modulerefid and sm.transaction_type <> 1"
                    + " INNER JOIN in_sr_detail sad on sa.id=sad.stockrequest "
                    + " INNER JOIN product p on p.id = sm.product ";

            String inventorySRCollect = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.collecteddate as createdon ,'Stock Request Collect' as module,sa.id as moduleid, sad.id as moduledetailid,"
                    + " 10 as transType, p.id,CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN in_goodsrequest sa on sa.id=sm.modulerefid and sm.transaction_type = 1"
                    + " inner join in_sr_detail sad on sa.id=sad.stockrequest "
                    + " left join product p on p.id = sm.product ";

            String inventoryINIssue = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.issueddate as createdon ,'Issue Note' as module,sa.id as moduleid, sad.id as moduledetailid, "
                    + " 11 as transType, p.id,CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN in_goodsrequest sa on sa.id=sm.modulerefid and sm.transaction_type <> 1"
                    + " inner join in_sr_detail sad on sa.id=sad.stockrequest  "
                    + " left join product p on p.id = sm.product ";

            String inventoryINCollect = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.collecteddate as createdon ,'Issue Note' as module,sa.id as moduleid, sad.id as moduledetailid, "
                    + " 12 as transType, p.id, CONVERT(DATE_FORMAT(bussinessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN in_goodsrequest sa on sa.id=sm.modulerefid and sm.transaction_type = 1"
                    + " inner join in_sr_detail sad on sa.id=sad.stockrequest "
                    + " left join product p on p.id = sm.product ";

            String inventoryISTIssue = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.creationdate as createdon ,'Issue Note' as module,sa.id as moduleid, sad.id as moduledetailid, "
                    + " 13 as transType, p.id,CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN in_interstoretransfer sa on sa.id=sm.modulerefid  and transaction_type <> 1"
                    + " INNER JOIN in_ist_detail sad on sa.id=sad.istrequest"
                    + " left join product p on p.id = sm.product ";

            String inventoryISTCollect = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.modifieddate as createdon ,'Issue Note' as module,sa.id as moduleid, sad.id as moduledetailid, "
                    + " 14 as transType, p.id,CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN in_interstoretransfer sa on sa.id=sm.modulerefid  and transaction_type =1"
                    + " INNER JOIN in_ist_detail sad on sa.id=sad.istrequest"
                    + " left join product p on p.id = sm.product ";               

            String inventoryILTIssue = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.creationdate as createdon ,'Issue Note' as module,sa.id as moduleid, sad.id as moduledetailid, "
                    + " 15 as transType, p.id,CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN in_interstoretransfer sa on sa.id=sm.modulerefid  and transaction_type <> 1"
                    + " INNER JOIN in_ist_detail sad on sa.id=sad.istrequest"
                    + " left join product p on p.id = sm.product ";

            String inventoryILTCollect = " select smd.id as smdid,sm.id as smid,p.id as productid,sa.modifieddate as createdon ,'Issue Note' as module,sa.id as moduleid, sad.id as moduledetailid, "
                    + " 16 as transType, p.id,CONVERT(DATE_FORMAT(businessdate,'%Y-%m-%d'),date) as date,1,'','' as spotrate,sa.id as detailid,'' as srno "
                    + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement "
                    + " INNER JOIN in_interstoretransfer sa on sa.id=sm.modulerefid  and transaction_type =1"
                    + " INNER JOIN in_ist_detail sad on sa.id=sad.istrequest"
                    + " left join product p on p.id = sm.product " ;
            
            String workOrder = "";
            String workOrderDetails = "";
             /** 
                 * transType 17 is used for Assembly item IN. 
                 * this Query return result only if MRP is Activate.
             */
            if (isActivateMRPModule) {
                workOrder = " select smd.id as smdid,sm.id as smid,p.id as productid,wo.workorderdate as createdon ,'Work Order' as module,wo.id as moduleid, wod.id as moduledetailid,"
                        + " 17 as transType,p.id,wo.workorderdate as date,1,'','' as spotrate,wo.id as detailid,'' as srno"
                        + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Work Order
                        + " INNER JOIN workorder wo on wo.id=sm.modulerefid "
                        + " INNER JOIN workordercomponentdetail wod on wod.workorder=wo.id"              
                        + " INNER join product p on (p.id=sm.product) ";
                

                 /** 
                      * transType 18 is used for Inventory part item OUT. 
                      * this Query return result only if MRP is Activate.
                 */

                workOrderDetails = " select smd.id as smdid,sm.id as smid,p.id as productid,wo.workorderdate as createdon ,'Work Order' as module,wo.id as moduleid, wod.id as moduledetailid,"
                        + " 18 as transType,p.id,wo.workorderdate as date,1,'','' as spotrate,wo.id as detailid,'' as srno"
                        + " from in_sm_detail smd INNER JOIN in_stockmovement sm on sm.id=smd.stockmovement " //Work Order
                        + " INNER JOIN workorder wo on wo.id=sm.modulerefid "
                        + " INNER JOIN workordercomponentdetail wod on wod.workorder=wo.id"                       
                        + " INNER join product p on (p.id=sm.product)";
                

            }
            String productCondition = " where sm.company=? and newinv='T' and sm.store=? and sm.transaction_module=10 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";

            String grCondition = " where sm.company=? and sm.store=? and sm.transaction_module=5 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and gro.deleteflag='F'  and gro.approvestatuslevel=11 and p.deleteflag = 'F' and p.isasset!='1' and "
                    + " p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";

            String doCondition = " where sm.company=? and sm.store=? and (sm.transaction_module=6 or sm.transaction_module=7) and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and do.deleteflag='F' and do.approvestatuslevel=11 and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";

            String prCondition = " where sm.company=? and sm.store=? and sm.transaction_module=8 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and pr.deleteflag='F'  and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";

            String srCondition = " where sm.company=? and sm.store=? and sm.transaction_module=9 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and sr.deleteflag='F'  and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";
            
            String stockINCondition = " where sm.company=? and sm.store=? and sm.transaction_module=3 and sa.adjustment_type='Stock IN'and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' and sa.isdeleted='F'";
           
            String stockCondition = " where sm.company=? and sm.store=? and sm.transaction_module=3 and  (sa.adjustment_type='Stock OUT' || sa.adjustment_type='Stock Sales')and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' and sa.isdeleted='F'";
            
            String stockINCondition1="";
            String stockCondition1="";
            if(isActivateMRPModule)
            {
             /**
              * transaction_type=1 for IN. 
              */
             stockINCondition1 = " where sm.company=? and sm.store=? and sm.transaction_module=16 and sm.transaction_type=1 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
             /**
              * transaction_type=2 for OUT. 
              */
             stockCondition1 = " where sm.company=? and sm.store=? and sm.transaction_module=16 and  sm.transaction_type=2 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";

            }
            String buildAssemblyMainCondition = " where pb.isBuild='T' and sm.company=? and sm.store=? and sm.transaction_module=13 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";
            
            String buildAssemblySubProductCondition = " where pb.isBuild='T' and sm.company=? and sm.store=? and sm.transaction_module=13 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";
            
            String unbuildAssemblyMainCondition = " where pb.isBuild='F' and sm.company=? and sm.store=? and sm.transaction_module=13 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";

            String unbuildAssemblySubProductCondition = " where pb.isBuild='F' and sm.company=? and sm.store=? and sm.transaction_module=13 and sm.transaction_date >= ? and sm.transaction_date <= ?"
                    + " and p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' "
                    + " and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";

//            String storeCondition = " where sm.company=? and sm.store=? and sm.transaction_module=2  and sm.transaction_date >= ? and sm.transaction_date <= ?"
//                    + " and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
//                    + " and p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa' ";
            
            String inventorySRIssueCondition=" where sm.company=? and sm.store=? and sa.status IN(2,3,4) AND sa.module = 0  and sm.transaction_date >= ? and sm.transaction_date <= ? "
                    + " AND p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " AND p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            String inventorySRCollectCondition=" where sm.company=? and sm.store=? and sad.delivered_location IS NOT NULL AND sa.status IN(4,5) AND sa.module = 0  and sm.transaction_date >= ? and sm.transaction_date <= ? "
                    + " AND p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " AND p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            String inventoryINIssueCondition=" where sm.company=? and sm.store=? and sa.module = 1  and sm.transaction_date >= ? and sm.transaction_date <= ? "
                    + " AND p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " AND p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            String inventoryINCollectCondition=" where sm.company=? and sm.store=? and sad.delivered_location IS NOT NULL AND sa.module = 1  and sm.transaction_date >= ? and sm.transaction_date <= ? "
                    + " AND p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " AND p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            String inventoryISTIssueCondition=" where sm.company=? and sm.store=? and sa.status IN(0,1,2,6) AND sa.transaction_module = 2  and sm.transaction_date >= ? and sm.transaction_date <= ? "
                    + " AND p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " AND p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            String inventoryISTCollectCondition=" where sm.company=? and sm.store=? and sad.delivered_location IS NOT NULL AND sa.status IN(1,6) AND  sa.transaction_module = 2  and sm.transaction_date >= ? and sm.transaction_date <= ? "
                    + " AND p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " AND p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            String inventoryILTIssueCondition=" where sm.company=? and sm.store=? and sa.transaction_module = 11 and sm.transaction_date >= ? and sm.transaction_date <= ? "
                    + " AND p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " AND p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            String inventoryILTCollectCondition=" where sm.company=? and sm.store=? and sad.delivered_location IS NOT NULL AND  sa.transaction_module = 11 and sm.transaction_date >= ? and sm.transaction_date <= ? "
                    + " AND p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' "
                    + " AND p.producttype !='ff8080812f5c78bb012f5cfe7edb000c9cfa'";
            
            String mynewquery = "select * from ("
                    + "(" + productQuery + productCondition + condition + ")"
                    + " UNION "
                    + "(" + grQuery + grCondition + condition + ")"
                    + " UNION "
                    + "(" + doquery + doCondition + condition + ")"
                    + " UNION "
                    + "(" + prQuery + prCondition + condition + ")"
                    + " UNION "
                    + "(" + srQuery + srCondition + condition + ")"
                    + " UNION "
                    + "(" + stockAdjustINQuery + stockINCondition + condition + ")"
                    + " UNION "
                    + "(" + stockAdjustQuery + stockCondition + condition + ")"
                    + " UNION "
                    + "(" + inventorySRIssue + inventorySRIssueCondition + condition + ")"
                    + " UNION "
                    + "(" + inventorySRCollect + inventorySRCollectCondition + condition + ")"
                    + " UNION "
                    + "(" + inventoryINIssue + inventoryINIssueCondition + condition + ")"
                    + " UNION "
                    + "(" + inventoryINCollect + inventoryINCollectCondition + condition + ")"
                    + " UNION "
                    + "(" + inventoryISTIssue + inventoryISTIssueCondition + condition + ")"
                    + " UNION "
                    + "(" + inventoryISTCollect + inventoryISTCollectCondition + condition + ")"
                    + " UNION "
                    + "(" + inventoryILTCollect + inventoryILTCollectCondition + condition + ")"
                    + " UNION "
                    + "(" + inventoryILTIssue + inventoryILTIssueCondition + condition + ")"
                    + " UNION "
                    + "(" + buildAssemblyMainProduct + buildAssemblyMainCondition + condition + ")"
                    + " UNION "
                    + "(" + buildAssemblySubProduct + buildAssemblySubProductCondition + condition + ")"
                    + " UNION "
                    + "(" + unbuildAssemblyMainProduct + unbuildAssemblyMainCondition + condition + ")"
                    + " UNION "
                    + "(" + unbuildAssemblySubProduct + unbuildAssemblySubProductCondition + condition + ")";
         
             /** 
                 * IF MRP is Activate then Append UNION with transType 17 and transType 18 query.
              */
            if (isActivateMRPModule) {
                 mynewquery += " UNION "
                            + "(" + workOrder + stockINCondition1 + condition + ")"
                            + " UNION "
                            + "(" + workOrderDetails + stockCondition1 + condition + ")";
                  }
         
             mynewquery+= " )"
                       + " as stock order by stock.productid,stock.date ,stock.createdon,stock.srno";
            
            params.addAll(openingParams);
            params.addAll(goodsReceiptParams);
            params.addAll(deliveryOrderParams);
            params.addAll(purchaseReturnParams);
            params.addAll(salesReturnParams);
            params.addAll(stockAdINParams);
            params.addAll(stockAdParams);
//            params.addAll(stockTransParams);
            params.addAll(inventorySRIssueParams);
            params.addAll(inventorySRCollectParams);
            params.addAll(inventoryINIssueParams);
            params.addAll(inventoryINCollectParams);
            params.addAll(inventoryISTIssueParams);
            params.addAll(inventoryISTCollectParams);
            params.addAll(inventoryILTIssueParams);
            params.addAll(inventoryILTCollectParams);
            params.addAll(buildAssemblyMainProductParams);
            params.addAll(buildAssemblySubProductParams);
            params.addAll(unbuildAssemblyMainProductParams);
            params.addAll(unbuildAssemblySubProductParams);
            if (isActivateMRPModule) {
                params.addAll(workOrderParams);
                params.addAll(workOrderDetailsParams);
            }

            if (isAdvanceSearch) {
                params.clear();
                String a = "select * from (";
                mynewquery = "";
                if (productJson.length() > 0) {
                    mynewquery += a + "(" + productQuery + productJoin + productCondition + condition + openingConditionSQL + ")";
                    params.addAll(openingParams);
                }
                if (grJson.length() > 0) {
                    mynewquery += StringUtil.isNullOrEmpty(mynewquery) ? a : " UNION ";
                    mynewquery += "(" + grQuery + grJoin + grCondition + condition + goodsReceiptConditionSQL + ")";
                    params.addAll(goodsReceiptParams);
                }
                if (doJson.length() > 0) {
                    mynewquery += StringUtil.isNullOrEmpty(mynewquery) ? a : " UNION ";
                    mynewquery += "(" + doquery + doJoin + doCondition + condition + deliveryOrderConditionSQL + ")";
                    params.addAll(deliveryOrderParams);
                }
                if (prJson.length() > 0) {
                    mynewquery += StringUtil.isNullOrEmpty(mynewquery) ? a : " UNION ";
                    mynewquery += "(" + prQuery + prJoin + prCondition + condition + purchaseReturnConditionSQL + ")";
                    params.addAll(purchaseReturnParams);
                }
                if (srJson.length() > 0) {
                    mynewquery += StringUtil.isNullOrEmpty(mynewquery) ? a : " UNION ";
                    mynewquery += "(" + srQuery + srJoin + srCondition + condition + salesReturnConditionSQL + ")";
                    params.addAll(salesReturnParams);
                }
                if (saJoin.length() > 0) {
                    /**
                     * stock in
                     */
                    mynewquery += StringUtil.isNullOrEmpty(mynewquery) ? a : " UNION ";
                    mynewquery += "(" + stockAdjustINQuery + saJoin + stockINCondition + condition + stockAdustConditionSQL + ")";
                    params.addAll(stockAdINParams);
                    /**
                     * Stock Out
                     */
                    mynewquery += StringUtil.isNullOrEmpty(mynewquery) ? a : " UNION ";
                    mynewquery += "(" + stockAdjustQuery + saJoin + stockCondition + condition + stockAdustConditionSQL + ")";
                    params.addAll(stockAdParams);
                }
//                if (istJoin.length() > 0) {
//                    mynewquery += StringUtil.isNullOrEmpty(mynewquery) ? a : " UNION ";
//                    mynewquery += "(" + interstoreTransferQuery + istJoin + storeCondition + condition + interStoreTransferConditionSQL + ")";
//                    params.addAll(stockTransParams);
//                }
                mynewquery += " ) as stock order by stock.productid,stock.date ,stock.createdon,stock.srno";

            }
            returnList = executeSQLQuery(mynewquery, params.toArray());
            totalCount = returnList.size();
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                returnList = executeSQLQueryPaging(mynewquery, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }
            
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);

    }

//    @Override
//    public KwlReturnObject consignmentInvoice(String invoiceID, String companyid) throws ServiceException {
//        String returnString = "";
//        String query = " select gr.id from goodsreceipt gr INNER JOIN t_goodsreceiptid_landedInvoice tgl on gr.id=tgl.goodsreceiptid where tgl.landedinvoice=? and gr.company=? ";
//        List list = executeSQLQuery( query, new Object[]{invoiceID, companyid});
//        
//        return new KwlReturnObject(true, "", null, list, list.size());
//    }
    @Override
    public String consignmentInvoice(String invoiceID, String companyid) throws ServiceException {
        String returnString = "";
        String query = " select gr.id from goodsreceipt gr "
                + " INNER JOIN goodsreceiptid_landedInvoice tgl on gr.id=tgl.goodsreceiptid where tgl.landedinvoice=? and gr.company=? ";
        List list = executeSQLQuery(query, new Object[]{invoiceID, companyid});
        if (!list.isEmpty()) {
            returnString = (String) list.get(0);
        }
        return returnString;
    }
    
    @Override
    public String procrutmentInvoice(String invoiceID, String companyid) throws ServiceException {
        String returnString = "";
        String query = " select tgl.landedinvoice from goodsreceipt gr "
                + " INNER JOIN goodsreceiptid_landedInvoice tgl on gr.id=tgl.goodsreceiptid where tgl.goodsreceiptid=? and gr.company=? ";
        List list = executeSQLQuery(query, new Object[]{invoiceID, companyid});
        if (!list.isEmpty()) {
            returnString = (String) list.get(0);
        }
        return returnString;
    }
    
    @Override
    public List getVendorInvoiceTotalAmountDetail(String invoiceID, String personName, String companyid) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(companyid);
//        params.add(personName);
        String conditionSQL = " where jed.company = ?  ";

        if (!StringUtil.isNullOrEmpty(invoiceID)) {
            params.add(invoiceID);
            conditionSQL += " and gr.id = ? GROUP BY jed.id";
        }

        String mysqlQuery = " select jed.amount, je.currency, je.entrydate, je.externalcurrencyrate, gr.creationdate from jedetail jed "
                + " inner join journalentry je on jed.journalentry = je.id "
                + " inner join goodsreceipt gr on gr.journalentry = je.id "
                + " inner join vendor v on v.account = jed.account and jed.isseparated='F' " + conditionSQL;

        List list = executeSQLQuery( mysqlQuery, params.toArray());

        return list;
    }

//    @Override
//    public List getCustomerInvoiceTotalAmountDetail(String invoiceID, String personName, String companyid) throws ServiceException {
//        ArrayList params = new ArrayList();
//        params.add(companyid);
//        params.add(personName);
//        String conditionSQL = " where jed.company = ? and c.name = ? ";
//
//        if (!StringUtil.isNullOrEmpty(invoiceID)) {
//            params.add(invoiceID);
//            conditionSQL += " and i.id = ? ";
//        }
//        
//        String mysqlQuery = " select jed.amount, je.currency, je.entrydate, je.externalcurrencyrate from jedetail jed "
//                + " inner join journalentry je on jed.journalentry = je.id "
//                + " inner join invoice i on i.journalentry = je.id "
//                + " inner join customer c on c.account = jed.account " + conditionSQL;
//
//        List list = executeSQLQuery( mysqlQuery, params.toArray());
//        
//        return list;
//    }
    @Override
    public KwlReturnObject getOnhandQuantityOfProduct(HashMap requestParam) throws ServiceException {
        ArrayList params = new ArrayList();
        List returnList = new ArrayList();
        int cnt = 0;
        try {
            String companyid = (String) requestParam.get("companyid");

            params.add(companyid);
            params.add(Producttype.INVENTORY_PART);
            params.add(Producttype.ASSEMBLY);

            int quantityDigit = Constants.QUANTITY_DIGIT_AFTER_DECIMAL;
            if (Constants.CompanyPreferencePrecisionMap.containsKey(companyid)) {
                quantityDigit = (Integer) Constants.CompanyPreferencePrecisionMap.get(companyid).get(Constants.quantitydecimalforcompany);
            }

            String query = "select p.id, "
                    + "( "
                    + "   select sum((case when carryIn = 'T' then FORMAT(inv.baseuomquantity,"+quantityDigit+") else FORMAT(-inv.baseuomquantity,"+quantityDigit+") end))  "
                    + "   from inventory as inv "
                    + "   where inv.deleteflag = false and product = p.id "
                    + "   group by product "
                    + " ) as QuantityOnHand "
                    + " from product as p "
                    + " where p.deleteflag = false and p.company = ? and ( p.producttype = ? or p.producttype = ? ) and p.isasset = false "
                    + " order by p.name ";

            returnList = executeSQLQuery( query, params.toArray());
            cnt = returnList.size();

        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("get Product from product code: " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, cnt);
    }

    @Override
    public KwlReturnObject getRateandQtyOfOpeningGRSR(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        String openingCondition="";
        String goodsReceiptCondition="";
        String salesReturnCondition="";
        String stockInCondition="";

        ArrayList params = new ArrayList();
        ArrayList openingBalanceParams = new ArrayList();
        ArrayList goodsReceiptParams = new ArrayList();
        ArrayList salesReturnParams = new ArrayList();
        ArrayList stockINParams = new ArrayList();

        boolean isForOpeningTransactions = false;
        boolean isForPeriodTransactions = false;
        if (requestParams.containsKey("isForOpeningTransactions")) {
            isForOpeningTransactions = (Boolean) requestParams.get("isForOpeningTransactions");
        }
        if (requestParams.containsKey("isForPeriodTransactions") && !StringUtil.isNullOrEmpty((String)requestParams.get("isForPeriodTransactions"))) {
            isForPeriodTransactions = Boolean.parseBoolean(requestParams.get("isForPeriodTransactions").toString());
        }
        
        // For Opening Balance
        openingBalanceParams.add((String) requestParams.get("companyid"));
        openingBalanceParams.add((String) requestParams.get("productid"));
        openingBalanceParams.add((String) requestParams.get("productid"));
        openingBalanceParams.add((String) requestParams.get("companyid"));
        if (requestParams.containsKey("enddate")) {
            if (isForPeriodTransactions) {
                if (requestParams.containsKey("stdate")) {
                    openingCondition = " and inv.updatedate > ? ";
                    openingBalanceParams.add(requestParams.get("stdate"));
                }
            }
            openingBalanceParams.add(requestParams.get("enddate"));
            openingCondition += " and inv.updatedate<= ? ";
        }
        // For Goods Receipt
        goodsReceiptParams.add((String) requestParams.get("productid"));
        goodsReceiptParams.add((String) requestParams.get("companyid"));
        if (requestParams.containsKey("enddate")) {
            if (isForOpeningTransactions) {
                goodsReceiptParams.add(requestParams.get("enddate"));
                goodsReceiptCondition = " and gro.grorderdate<?  ";
            } else {
                goodsReceiptParams.add(requestParams.get("enddate"));
                goodsReceiptCondition = " and gro.grorderdate<=?  ";
            }
        }
        salesReturnParams.add((String) requestParams.get("productid"));
        salesReturnParams.add((String) requestParams.get("companyid"));
        if (requestParams.containsKey("enddate")) {
            if (isForOpeningTransactions) {
                    salesReturnParams.add(requestParams.get("enddate"));
                    salesReturnCondition = " and entrydate<? ";
                }else{
                    salesReturnParams.add(requestParams.get("enddate"));
                    salesReturnCondition = " and entrydate<=? ";
                }
            }
        String productTypeID = "";
        if (requestParams.containsKey("producttypeid")) {
            productTypeID = (String) requestParams.get("producttypeid");
        }
        stockINParams.add((String) requestParams.get("productid"));
        stockINParams.add((String) requestParams.get("companyid"));
        if (requestParams.containsKey("enddate")) {
            if (isForOpeningTransactions) {
                stockINParams.add(requestParams.get("enddate"));
                stockInCondition = " and sa.bussinessdate<=?  ";
            } else {
                stockINParams.add(requestParams.get("enddate"));
                stockInCondition = " and sa.bussinessdate<=?  ";
            }
        }
//        String addNewInvcheck = "";
//        if (!productTypeID.equals(Producttype.ASSEMBLY)) {
//            addNewInvcheck = " and inv.newinv='T' ";
//        }
        // For Sales Return
//        salesReturnParams.add((String) requestParams.get("productid"));
//        salesReturnParams.add((String) requestParams.get("companyid"));

        params.addAll(openingBalanceParams);
        params.addAll(goodsReceiptParams);
        params.addAll(salesReturnParams);
        params.addAll(stockINParams);

        String mysqlQuery =
                // For Opening Balance
                "select * from "
                +" (select inv.updatedate, 'Opening' as transactionNumber, inv.quantity, inv.baseuomrate, pl.price as rate, p.currency as currency, 'Opening' as transactionType, inv.updatedate as date, p.createdon as createdon,'','' as grodid, '' as currate,'' as returnquantity,'' as srno from inventory inv "
                + " left join product p on p.id = inv.product "
                + " left join pricelist pl on pl.product = p.id and pl.affecteduser = '-1' and pl.currency=p.currency and pl.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_CONDITION+" and (pl.applydate =(select max(applydate) as ld from pricelist where pricelist.product=inv.product and pricelist.carryin='T' "+Constants.PRICELIST_UOM_STOCK_LEDGER_INNER_CONDITION+" and pricelist.affecteduser='-1' and pricelist.currency=p.currency and inv.company=? and p.id=?  group by inv.product))  "
                + " where p.deleteflag = 'F'  and inv.newinv='T' and inv.defective='F' and inv.carryin='T' and p.id = ? and inv.company = ?  "+openingCondition //+ openingBalanceConditionSQL
                // For Goods Receipt
                + " union "
                + " select gro.grorderdate, gro.gronumber as transactionNumber, inv.quantity, inv.baseuomrate, grod.rate, gro.currency, 'Goods Receipt' as transactionType, gro.grorderdate as date, gro.createdon as createdon,prd.id , grod.id as grodid, externalcurrencyrate as currate,prd.returnquantity as returnquantity,grod.srno as srno  from grorder gro "
                + " left join grodetails grod on grod.grorder = gro.id "
                + " left join prdetails prd on prd.grdetails = grod.id  "
                + " left join inventory inv on inv.id = grod.id "
                + " left join product p on p.id = inv.product "
                + " where p.deleteflag = 'F' and p.id = ? and gro.company = ? "+goodsReceiptCondition //+ goodsReceiptConditionSQL
                +" union "
                + " select entrydate,'',quantity,1,(productcost/quantity),company.currency,'Assembly Build' as transactionType,entrydate as date,entrydate,'','' as grodid,'' as currate,'' as returnquantity,'' as srno from productbuild "
                + " inner join company on company.companyid=productbuild.company "
                + " inner join product p on p.id = productbuild.product "
                + " where p.deleteflag = 'F' and p.id = ? and p.company = ? "+salesReturnCondition
                +" union"
                + " select sa.bussinessdate, sa.seqno as transactionNumber, (sa.finalquantity), inv.baseuomrate, sa.amount as rate,  '' as currency, 'Stock IN' as transactionType, sa.bussinessdate as date, UNIX_TIMESTAMP(sa.createdon )*1000 as createdon, '',sa.id as grodid, '' as currate , '' as returnquantity,'' as srno from in_stockadjustment sa"
                + " left join in_sa_detail sad on sad.stockadjustment = sa.id "
                + " left join inventory inv on inv.id = sa.inventoryref "
                + " left join product p on p.id = inv.product "
                + " where p.deleteflag = 'F' and p.id = ? and sa.company = ? and sa.adjustment_type='Stock IN' "+stockInCondition +") t1 order by t1.date,t1.createdon,t1.srno";
        // For Sales Return
//                + " union "
//                + " select sr.orderdate, sr.srnumber as transactionNumber, inv.quantity, inv.baseuomrate, srd.rate, sr.currency, 'Sales Return' as transactionType, DATE_FORMAT(sr.orderdate,'%m-%d-%Y') as date, sr.createdon as createdon from salesreturn sr "
//                + " left join srdetails srd on srd.salesreturn = sr.id "
//                + " left join inventory inv on inv.id = srd.id "
//                + " left join product p on p.id = inv.product "
//                + " where p.deleteflag = 'F' and p.id = ? and sr.company = ? "; //+ salesReturnConditionSQL
//                + " order by date, createdon asc ";
        try{
        returnList = executeSQLQuery( mysqlQuery, params.toArray());
        totalCount = returnList.size();
        } catch(Exception se){
            se.printStackTrace();
        }

        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }
    @Override
    public KwlReturnObject getLocationSummary(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        try {
            String locationid = (String) requestParams.get("locationid");
            String companyid=(String) requestParams.get("companyid");
            String start = (String) requestParams.get("start");
            String limit = (String) requestParams.get("limit");
            int type=6;
            String Type="";
            if(!requestParams.get("type").equals("")){
            type=Integer.valueOf(requestParams.get("type")+"");
            }
            ArrayList params = new ArrayList();
            params.add((String) requestParams.get("companyid"));
            String conditionSQL = "";
            if (!StringUtil.isNullOrEmpty(locationid)) {
                conditionSQL = " and id = ? ";
                params.add(locationid);
            }
            String ss = (String) requestParams.get("ss");
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol1 = new String[]{"name"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 1);
                StringUtil.insertParamSearchString(map);
                String searchQuery1 = StringUtil.getSearchString(ss, "and", searchcol1);
                conditionSQL += searchQuery1;
            }
            String tableName="InventoryLocation";
            switch(type){
                case 1:
                    tableName="InventoryWarehouse";
                    break;
                case 2:
                    tableName="InventoryLocation";
                    break;
                case 3:
                    tableName="StoreMaster";
                    conditionSQL+=" and type = ?";
                    params.add(1);
                    break;
                case 4:
                    tableName="StoreMaster";
                    conditionSQL+=" and type = ?";
                    params.add(2);
                    break;
                case 5:
                    tableName="StoreMaster";
                    conditionSQL+=" and type = ?";
                    params.add(3);
                    break;
                case 6:
                    tableName="NewProductBatch";
                    break;
            }
            
            
            String countQuery = " SELECT COUNT(*) from "+tableName+" where company.companyID=? " + conditionSQL;
            List countList = executeQuery( countQuery, params.toArray());
            if(!countList.isEmpty()){
                Long count = countList.get(0) != null ? (Long)countList.get(0) : 0;
                totalCount = count.intValue();
            }
            
            String query = " from "+tableName+" where company.companyID=? " + conditionSQL;
            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                returnList = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }else{
                returnList = executeQuery( query, params.toArray());
            }
            
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }
    @Override
    public KwlReturnObject getQuantityAndRateOfProductForLocation(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        try {
            DateFormat df = (DateFormat) requestParams.get(Constants.df);
            String conditionSQL = "";
            ArrayList params = new ArrayList();
            params.add((String) requestParams.get("companyid"));
            params.add((String) requestParams.get("locationid"));
            int type=(Integer)requestParams.get("type");
            String gcurrencyid = requestParams.get("gcurrencyid").toString();
            if (requestParams.get(Constants.REQ_enddate) != null && requestParams.get(Constants.REQ_enddate) != null) {
                String startDate = (String) requestParams.get(Constants.REQ_startdate);
                String endDate = (String) requestParams.get(Constants.REQ_enddate);
                params.add(df.parse(startDate));
                params.add(df.parse(endDate));
                conditionSQL += " and(gro.grorderdate >=? and gro.grorderdate <=?)";
            }

//            String mysqlQuery = " select grod.rate, grod.baseuomquantity, gro.currency, gro.grorderdate, gro.id from grodetails grod "
//                    + " inner join grorder gro on gro.id = grod.grorder "
//                    + " inner join productbatch pb on pb.id = grod.batch "
//                    + " inner join inventorylocation invloc on invloc.id = pb.location "
//                    + " where grod.company = ? and  invloc.id = ? " + conditionSQL;
            String mysqlQuery ="";
            String attachQuery="";
            String location="";
            switch (type) {
                case 1:
                    attachQuery = " inner join inventorywarehouse invloc on invloc.id = pb.warehouse ";
                    location=" inner join inventorywarehouse invloc on invloc.id =prb.warehouse";
                    break;
                case 2:
                    attachQuery = " inner join inventorylocation invloc on invloc.id = pb.location ";
                    location=" inner join inventorylocation invloc on invloc.id =prb.location";
                    break;
                case 3:
                    attachQuery = " inner join storemaster invloc on invloc.id = pb.row ";
                    location=" inner join storemaster invloc on invloc.id =prb.row";
                    break;
                case 4:
                    attachQuery = " inner join storemaster invloc on invloc.id = pb.rack ";
                    location=" inner join storemaster invloc on invloc.id =prb.rack";
                    break;
                case 5:
                    attachQuery = " inner join storemaster invloc on invloc.id = pb.bin ";
                    location=" inner join storemaster invloc on invloc.id =prb.bin";
                    break;
            }
            
            params.add((String) requestParams.get("companyid"));
            params.add((String) requestParams.get("locationid"));
            mysqlQuery = " select grod.rate, grod.baseuomquantity, gro.currency, gro.grorderdate, grod.id, 1 as value,p.productid, pb.batchname as batchname, '' as baseuomdeliveredquantity, 'false' as isOpeningTransaction, pb.id as batchid,p.id as proid,grod.baseuomrate from grodetails grod "
                    + " inner join grorder gro on gro.id = grod.grorder "
                    +  "inner join locationbatchdocumentmapping loc on loc.documentid=grod.id "
                    + " inner join newproductbatch pb on pb.id = loc.batchmapid "
                    + attachQuery
                    + " inner join product p on p.id = grod.product "
                    + " INNER JOIN inventory inv on inv.product=p.id "
                    + " where  inv.newinv=\"F\" and grod.company = ? and  invloc.id = ? " + conditionSQL
                    + " UNION "
                    + " select  pl.price as rate , prb.quantity as baseuomquantity,'"+gcurrencyid+"' as currency , FROM_UNIXTIME(pro.createdon/1000) as grorderdate , prb.id, 1 as value, pro.productid as productid, prb.batchname as batchname, prb.quantity as baseuomdeliveredquantity ,'true' as isOpeningTransaction , prb.id as batchid, pro.id as proid,inv.baseuomrate from product pro "
                    + " INNER JOIN pricelist pl on pl.product=pro.id "
                    + " INNER JOIN locationbatchdocumentmapping proloc on proloc.documentid=pro.id  "
                    + " inner join newproductbatch prb on prb.id = proloc.batchmapid "
                    + location+" "
                    + " INNER JOIN inventory inv on inv.product=pro.id "
                    + " where  inv.isopening=\"T\" and inv.newinv=\"T\" "
                    + " and pro.company= ? and pl.carryin='T' and invloc.id = ?";
                    
            returnList = executeSQLQuery( mysqlQuery, params.toArray());
            totalCount = returnList.size();
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }

    @Override
    public KwlReturnObject getQuantityAndRateOfProductForLocationDetails(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        try {
            DateFormat df = (DateFormat) requestParams.get(Constants.df);
            String conditionSQL = "";
            String conditionSQL1 = "";
            String conditionForOpeningDate= "";
            boolean onlyBatchesFlag = false;
            if (requestParams.containsKey("onlyBatches") && requestParams.get("onlyBatches") != null) {
                onlyBatchesFlag = Boolean.parseBoolean(requestParams.get("onlyBatches").toString());
            }
            ArrayList params = new ArrayList();
            params.add((String) requestParams.get("companyid"));

            if (!onlyBatchesFlag) {  //in batch case dont need to send locationid as we have only batches in this case
                params.add((String) requestParams.get("locationid"));
            }
            String companyid=(String) requestParams.get("companyid");

            int type = (Integer) requestParams.get("type");
            String batchid = (String) requestParams.get("batchid");

            String gcurrencyid = requestParams.get("gcurrencyid").toString();
            
            String invlocid = "";
            if (!StringUtil.isNullOrEmpty(batchid)) {
                conditionSQL += " and pb.id = ? ";
                params.add(batchid);
            }

            String ss = (String) requestParams.get("ss");
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol1 = new String[]{"p.productid", "pb.batchname"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                StringUtil.insertParamSearchString(map);
                String searchQuery1 = StringUtil.getSearchString(ss, "and", searchcol1);
                conditionSQL += searchQuery1;
            }

            if (requestParams.get(Constants.REQ_startdate) != null && requestParams.get(Constants.REQ_enddate) != null) {
                String startDate = (String) requestParams.get(Constants.REQ_startdate);
                String endDate = (String) requestParams.get(Constants.REQ_enddate);
                params.add(df.parse(startDate));
                params.add(df.parse(endDate));
                conditionSQL += " and (gro.grorderdate >=? and gro.grorderdate <=?) ";
            }
            
            String mysqlQuery = "";
            String proconditionSQL = "";
            String attachQuery = "";
            String gronlyBatchQuery = "";
            String pronlyBatchQuery = "";
            String location="";
            switch (type) {
                case 1:
                    attachQuery = " inner join inventorywarehouse invloc on invloc.id = pb.warehouse ";
                    location=" inner join inventorywarehouse invloc on invloc.id =prb.warehouse";
                    break;
                case 2:
                    attachQuery = " inner join inventorylocation invloc on invloc.id = pb.location ";
                    location=" inner join inventorylocation invloc on invloc.id =prb.location";
                    break;
                case 3:
                    attachQuery = " inner join storemaster invloc on invloc.id = pb.row ";
                    location=" inner join storemaster invloc on invloc.id =prb.row";
                    break;
                case 4:
                    attachQuery = " inner join storemaster invloc on invloc.id = pb.rack ";
                    location=" inner join storemaster invloc on invloc.id =prb.rack";
                    break;
                case 5:
                    attachQuery = " inner join storemaster invloc on invloc.id = pb.bin ";
                    location=" inner join storemaster invloc on invloc.id =prb.bin";
                    break;
                case 6:
                    break;
            }
            params.add((String) requestParams.get("companyId"));
            if (!onlyBatchesFlag) {  //in batch case dont need to send locationid as we have only batches in this case
                params.add((String) requestParams.get("locationid"));
            }
            if (onlyBatchesFlag) {
                attachQuery = "";
                gronlyBatchQuery = " AND pb.location is NULL AND pb.warehouse is NULL AND pb.row is NULL AND pb.rack is NULL AND pb.bin is NULL";
                pronlyBatchQuery = " AND prb.location is NULL AND prb.warehouse is NULL AND prb.row is NULL AND prb.rack is NULL AND prb.bin is NULL";
            } else {
                invlocid = " and  invloc.id = ?";
            } 
            if (!StringUtil.isNullOrEmpty(batchid)) {
                proconditionSQL = " and prb.id = ? ";
                params.add(batchid);
            }
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol1 = new String[]{"pro.productid", "prb.batchname"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                StringUtil.insertParamSearchString(map);
                String searchQuery1 = StringUtil.getSearchString(ss, "and", searchcol1);
                conditionSQL1 += searchQuery1;
            }
            if (requestParams.get(Constants.REQ_startdate) != null && requestParams.get(Constants.REQ_enddate) != null) {
                String startDate = (String) requestParams.get(Constants.REQ_startdate);
                String endDate = (String) requestParams.get(Constants.REQ_enddate);
                params.add(df.parse(startDate));
                params.add(df.parse(endDate));
                conditionSQL1 += " and (inv.updatedate >=? and inv.updatedate  <=?) ";
            }
                //1st Query before union for taking for stock valuation of products whose gr is done
                //2nd query for stock valuation of opening quantity
            mysqlQuery = " (select grod.rate, grod.baseuomquantity, gro.currency, gro.grorderdate, grod.id as groid, mi.value, p.productid, pb.batchname as batchname,grod.baseuomdeliveredquantity ,'false' as isOpeningTransaction, pb.id,p.id as proid,grod.baseuomrate from grodetails grod "
                    + " inner join grorder gro on gro.id = grod.grorder "
                    + "inner join locationbatchdocumentmapping loc on loc.documentid=grod.id "
                    + " inner join newproductbatch pb on pb.id = loc.batchmapid "
                    + attachQuery
                    + " inner join product p on p.id = grod.product "
                    + " left join productcategorymapping pm on p.id=pm.productid "
                    + " left join masteritem mi on mi.id = pm.productcategory "
                    + " where grod.company = ?" + gronlyBatchQuery + invlocid + "" + conditionSQL+" order by mi.value, p.productid)"
                    + " UNION "
                    + " (select  pl.price as rate , inv.baseuomquantity as baseuomquantity,'"+gcurrencyid+"' as currency , FROM_UNIXTIME(pro.createdon/1000) as grorderdate , prb.id as groid , '' as value ,pro.productid as productid, prb.batchname, prb.quantity as baseuomdeliveredquantity ,'true' as isOpeningTransaction , prb.id, pro.id as proid,inv.baseuomrate from product pro "
                    + " INNER JOIN pricelist pl on pl.product=pro.id "
                    + " INNER JOIN locationbatchdocumentmapping proloc on proloc.documentid=pro.id  inner join newproductbatch prb on prb.id = proloc.batchmapid "
                    + location+" "
                    + " INNER JOIN inventory inv on inv.product=pro.id "
                    + " left join productcategorymapping pm on pro.id=pm.productid "
                    + " left join masteritem mi on mi.id = pm.productcategory "
                    + " where  inv.isopening=\"T\" and inv.newinv=\"T\" and pl.carryin='T' and pro.company= ? " +pronlyBatchQuery+ ""+invlocid+ "" + proconditionSQL+""+conditionSQL1+ conditionForOpeningDate + ") order by productid" ;
            
            returnList = executeSQLQuery( mysqlQuery, params.toArray());
            totalCount = returnList.size();
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }

    @Override
    public KwlReturnObject getAssetMaintenanceWorkOrders(HashMap<String, Object> requestParams) throws ServiceException {


        String companyId = (String) requestParams.get("companyId");

        String condition = "";
        ArrayList params = new ArrayList();
        List<AssetMaintenanceScheduler> list = null;
        int count = 0;

        try {
            params.add(companyId);

            if (requestParams.containsKey("scheduleId") && requestParams.get("scheduleId") != null) {
                condition += " and ams.assetMaintenanceScheduler.id=? ";
                params.add((String) requestParams.get("scheduleId"));
            }

            if (requestParams.containsKey("fromDate") && requestParams.get("fromDate") != null && requestParams.containsKey("toDate") && requestParams.get("toDate") != null) {
                params.add((Date) requestParams.get("fromDate"));
                params.add((Date) requestParams.get("toDate"));
                condition += " and (ams.workOrderDate>=? and ams.workOrderDate<=?) ";
            }

            String start = "";
            String limit = "";

            if (requestParams.containsKey(Constants.start) && requestParams.get(Constants.start) != null && requestParams.containsKey(Constants.limit) && requestParams.get(Constants.limit) != null) {
                start = (String) requestParams.get(Constants.start);
                limit = (String) requestParams.get(Constants.limit);
            }


            String ss = (requestParams.containsKey("ss") && requestParams.get("ss") != null) ? (String) requestParams.get("ss") : "";
            if (!StringUtil.isNullOrEmpty(ss)) {
                String[] searchcol = new String[]{"ams.workOrderNumber"};
                Map map = StringUtil.insertParamSearchStringMap(params, ss, 1);
                StringUtil.insertParamSearchString(map);
                String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                condition += searchQuery;
            }



            String orderByStr = " order by ams.workOrderDate desc";

            String query = "From AssetMaintenanceWorkOrder ams where ams.company.companyID=? " + condition + orderByStr;

            list = executeQuery( query, params.toArray());
            count = list.size();

            if (StringUtil.isNullOrEmpty(start) == false && StringUtil.isNullOrEmpty(limit) == false) {
                list = executeQueryPaging( query, params.toArray(), new Integer[]{Integer.parseInt(start), Integer.parseInt(limit)});
            }

        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accProductImpl.getAssetMaintenanceWorkOrders:" + ex.getMessage(), ex);
        }

        return new KwlReturnObject(true, null, null, list, count);
    }

    @Override
    public KwlReturnObject deleteAssetMaintenanceSchedule(HashMap<String, Object> dataMap) throws ServiceException {
        List list = null;
        int numRows = 0;

        String id = (String) dataMap.get("id");
        String companyId = (String) dataMap.get("companyId");

        ArrayList params = new ArrayList();

        params.add(id);
        params.add(companyId);

        String query = "delete from AssetMaintenanceScheduler amso where amso.assetMaintenanceSchedulerObject.id=? and amso.company.companyID=?";
        numRows = executeUpdate( query, params.toArray());

        return new KwlReturnObject(true, "Schedule has been deleted successfully.", null, null, numRows);

    }

    @Override
    public KwlReturnObject getScheduleNumberCount(String scheduleNumber, String companyid) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        String q = "from AssetMaintenanceSchedulerObject where scheduleName=? and company.companyID=?";
        list = executeQuery( q, new Object[]{scheduleNumber, companyid});
        count = list.size();
        return new KwlReturnObject(true, "", null, list, count);
    }

    @Override
    public KwlReturnObject saveMaintenanceSchedulerObject(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        AssetMaintenanceSchedulerObject schedulerObject = new AssetMaintenanceSchedulerObject();

        if(dataMap.containsKey("id") && dataMap.get("id")!= null){
            schedulerObject = (AssetMaintenanceSchedulerObject) get(AssetMaintenanceSchedulerObject.class, (String) dataMap.get("id"));
        }

        schedulerObject = createAssetMaintenanceSchedulerObject(schedulerObject, dataMap);

        save(schedulerObject);

        list.add(schedulerObject);

        return new KwlReturnObject(true, "", null, list, list.size());

    }

    @Override
    public KwlReturnObject saveMaintenanceSchedule(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        AssetMaintenanceScheduler scheduler = new AssetMaintenanceScheduler();

        scheduler = createAssetMaintenanceScheduler(scheduler, dataMap);

        save(scheduler);

        list.add(scheduler);

        return new KwlReturnObject(true, "", null, list, list.size());

    }

    public AssetMaintenanceSchedulerObject createAssetMaintenanceSchedulerObject(AssetMaintenanceSchedulerObject schedulerObject, HashMap<String, Object> dataMap) {
        if (dataMap.containsKey("startDate") && dataMap.get("startDate") != null) {
            schedulerObject.setStartDate((Date) dataMap.get("startDate"));
        }


        if (dataMap.containsKey("endDate") && dataMap.get("endDate") != null) {
            schedulerObject.setEndDate((Date) dataMap.get("endDate"));
        }

        if (dataMap.containsKey("scheduleNumber") && dataMap.get("scheduleNumber") != null) {
            schedulerObject.setScheduleName((String) dataMap.get("scheduleNumber"));
        }

        if (dataMap.containsKey("isAdhocSchedule") && dataMap.get("isAdhocSchedule") != null) {
            schedulerObject.setAdHoc((Boolean) dataMap.get("isAdhocSchedule"));
        }

        if (dataMap.containsKey("frequency") && dataMap.get("frequency") != null) {
            schedulerObject.setFrequency((Integer) dataMap.get("frequency"));
        }

        if (dataMap.containsKey("frequencyType") && dataMap.get("frequencyType") != null) {
            schedulerObject.setFrequencyType((String) dataMap.get("frequencyType"));
        }

        if (dataMap.containsKey("totalSchedules") && dataMap.get("totalSchedules") != null) {
            schedulerObject.setTotalEvents((Integer) dataMap.get("totalSchedules"));
        }

        if (dataMap.containsKey("scheduleDuration") && dataMap.get("scheduleDuration") != null) {
            schedulerObject.setScheduleDuration((Integer) dataMap.get("scheduleDuration"));
        }

        if (dataMap.containsKey("companyId") && dataMap.get("companyId") != null) {
            Company company = (Company) get(Company.class, (String) dataMap.get("companyId"));
            schedulerObject.setCompany(company);
        }

        if (dataMap.containsKey("assetId") && dataMap.get("assetId") != null) {
            AssetDetails assetDetails = (AssetDetails) get(AssetDetails.class, (String) dataMap.get("assetId"));
            schedulerObject.setAssetDetails(assetDetails);
        }

        if (dataMap.containsKey("contractId") && dataMap.get("contractId") != null) {
            schedulerObject.setContractId((String) dataMap.get("contractId"));
        }

        if (dataMap.containsKey("scheduleType") && dataMap.get("scheduleType") != null) {
            schedulerObject.setScheduleType((Integer) dataMap.get("scheduleType"));
        }
        if (dataMap.containsKey("maintenanceType") && dataMap.get("maintenanceType") != null) {
            schedulerObject.setMaintenanceType((Integer) dataMap.get("maintenanceType"));
        }
        return schedulerObject;
    }

    public AssetMaintenanceScheduler createAssetMaintenanceScheduler(AssetMaintenanceScheduler scheduler, HashMap<String, Object> dataMap) {
        if (dataMap.containsKey("startDate") && dataMap.get("startDate") != null) {
            scheduler.setStartDate((Date) dataMap.get("startDate"));
        }

        if (dataMap.containsKey("endDate") && dataMap.get("endDate") != null) {
            scheduler.setEndDate((Date) dataMap.get("endDate"));
        }

        if (dataMap.containsKey("actualStartDate") && dataMap.get("actualStartDate") != null) {
            scheduler.setActualStartDate((Date) dataMap.get("actualStartDate"));
        }

        if (dataMap.containsKey("actualEndDate") && dataMap.get("actualEndDate") != null) {
            scheduler.setActualEndDate((Date) dataMap.get("actualEndDate"));
        }

        if (dataMap.containsKey("isAdhocSchedule") && dataMap.get("isAdhocSchedule") != null) {
            scheduler.setAdHoc((Boolean) dataMap.get("isAdhocSchedule"));
        }
        if (dataMap.containsKey("isScheduleEdit") && dataMap.get("isScheduleEdit") != null) {
            scheduler.setIsScheduleEdit((Boolean) dataMap.get("isScheduleEdit"));
        }

        if (dataMap.containsKey("frequency") && dataMap.get("frequency") != null) {
            scheduler.setFrequency((Integer) dataMap.get("frequency"));
        }

        if (dataMap.containsKey("frequencyType") && dataMap.get("frequencyType") != null) {
            scheduler.setFrequencyType((String) dataMap.get("frequencyType"));
        }

        if (dataMap.containsKey("totalSchedules") && dataMap.get("totalSchedules") != null) {
            scheduler.setTotalEvents((Integer) dataMap.get("totalSchedules"));
        }

        if (dataMap.containsKey("scheduleDuration") && dataMap.get("scheduleDuration") != null) {
            scheduler.setScheduleDuration((Integer) dataMap.get("scheduleDuration"));
        }

        if (dataMap.containsKey("companyId") && dataMap.get("companyId") != null) {
            Company company = (Company) get(Company.class, (String) dataMap.get("companyId"));
            scheduler.setCompany(company);
        }

//        if (dataMap.containsKey("workOrderId") && dataMap.get("workOrderId") != null) {
//            AssetMaintenanceWorkOrder workOrder = (AssetMaintenanceWorkOrder) get(AssetMaintenanceWorkOrder.class, (String) dataMap.get("workOrderId"));
//            scheduler.setAssetMaintenanceWorkOrder(workOrder);
//        }

        if (dataMap.containsKey("assignedTo") && dataMap.get("assignedTo") != null) {
            MasterItem masterItem = (MasterItem) get(MasterItem.class, (String) dataMap.get("assignedTo"));
            scheduler.setAssignedTo(masterItem);
        }

        if (dataMap.containsKey("status") && dataMap.get("status") != null) {
            MasterItem masterItem = (MasterItem) get(MasterItem.class, (String) dataMap.get("status"));
            scheduler.setStatus(masterItem);
        }

        if (dataMap.containsKey("assetId") && dataMap.get("assetId") != null) {
            AssetDetails assetDetails = (AssetDetails) get(AssetDetails.class, (String) dataMap.get("assetId"));
            scheduler.setAssetDetails(assetDetails);
        }

        if (dataMap.containsKey("scheduleType") && dataMap.get("scheduleType") != null) {
            scheduler.setScheduleType((Integer) dataMap.get("scheduleType"));
        }

        if (dataMap.containsKey("schedulerObjectId") && dataMap.get("schedulerObjectId") != null) {
            AssetMaintenanceSchedulerObject schedulerObject = (AssetMaintenanceSchedulerObject) get(AssetMaintenanceSchedulerObject.class, (String) dataMap.get("schedulerObjectId"));
            scheduler.setAssetMaintenanceSchedulerObject(schedulerObject);
        }
        if (dataMap.containsKey("maintenanceType") && dataMap.get("maintenanceType") != null) {
            scheduler.setMaintenanceType((Integer) dataMap.get("maintenanceType"));
        }
        return scheduler;
    }

    @Override
    public KwlReturnObject updateMaintenanceSchedule(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        AssetMaintenanceScheduler scheduler = (AssetMaintenanceScheduler) get(AssetMaintenanceScheduler.class, (String) dataMap.get("id"));

        scheduler = createAssetMaintenanceScheduler(scheduler, dataMap);

        save(scheduler);

        list.add(scheduler);

        return new KwlReturnObject(true, "", null, list, list.size());

    }
    @Override
    public boolean isAssetUsedInMaintenanceSchedule(HashMap<String, Object> requestParams) throws ServiceException {
        List list = new ArrayList();
        boolean isUsed = false;
        try {
            String condition = "";
            ArrayList params = new ArrayList();
            String companyid = (String) requestParams.get("companyId");
            params.add(companyid);
            if (requestParams.containsKey("assetDetailsId")) {
                condition = " and assetDetails.id=?";
                params.add(requestParams.get("assetDetailsId"));
            }
            String selQuery = "from AssetMaintenanceScheduler where company.companyID= ? " + condition;
            list = executeQuery(selQuery, params.toArray());
            if (list.size() > 0) {
                isUsed = true;
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("isAssetUsedInMaintenanceSchedule : " + ex.getMessage(), ex);
        }
        return isUsed;
    }
    
//    @Override
//    public KwlReturnObject getSerialNoWhoseDONotCreated(HashMap<String, Object> requestParams) throws ServiceException {
//        List returnList = new ArrayList();
//        int totalCount = 0;
//        try {
//            ArrayList params = new ArrayList();
//            params.add((String) requestParams.get("groid"));
//            params.add((String) requestParams.get("companyid"));
//            
//             String mysqlQuery="SELECT pb.id from productbatch pb "
//                    + " inner join grodetails grod on grod.batch = pb.id "
//                    + " inner join grorder gro on gro.id = grod.grorder "
//                    + " where pb.id not in (select bsm.purchaseserial from batchserialmapping as bsm where bsm.purchaseserial is not null) and gro.id = ? and gro.company = ? and gro.deleteflag = 'F' ";
//
//            returnList = executeSQLQuery( mysqlQuery, params.toArray());
//            totalCount = returnList.size();
//        } catch (Exception ex) {
//            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
//        }
//        return new KwlReturnObject(true, "", null, returnList, totalCount);
//    }
//       public KwlReturnObject getSerialNoWhoseDONotCreated(HashMap<String, Object> requestParams) throws ServiceException {
//        List returnList = new ArrayList();
//        int totalCount = 0;
//        ArrayList params = new ArrayList();
//        params.add((String) requestParams.get("groid"));
//        params.add((String) requestParams.get("companyid"));
//        String selQuery = " select serialid  from serialdocumentmapping  inner join  grodetails on grodetails.id=documentid where grodetails.grorder=? and grodetails.company=?"; // issue unable to delete GRN as company column become ambigious
//        List list = executeSQLQuery( selQuery, params.toArray());
//        String docids = "";
//        List lst = new ArrayList();
//        Iterator itrSerial = list.iterator();
//        while (itrSerial.hasNext()) {
//            String serialstring = itrSerial.next().toString();
//            docids += "'" + serialstring + "',";
//        }
//
//        if (!StringUtil.isNullOrEmpty(docids)) {
//            docids = docids.substring(0, docids.length() - 1);
//        }
//        if (!StringUtil.isNullOrEmpty(docids)) {
//            selQuery = " select serialid  from serialdocumentmapping where serialid not in (" + docids + ") and transactiontype in(27,31)";
//            lst = executeSQLQuery( selQuery);
//
//
//
//        }
//        return new KwlReturnObject(true, "", null, lst, lst.size());
//    }
    public KwlReturnObject getSerialNoWhoseDONotCreated(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        try {
            ArrayList params = new ArrayList();
            params.add((String) requestParams.get("groid"));
            params.add((String) requestParams.get("companyid"));
//            params.add((String) requestParams.get("groid"));
//            params.add((String)requestParams.get("companyid"));
            String selQuery = " select batchmapid  from locationbatchdocumentmapping  inner join  grodetails on grodetails.id=documentid where grodetails.id=? and grodetails.company=? ";// issue unable to delete GRN as company column become ambigious
//                    + " union "
//                    + " select batchmapid from locationbatchdocumentmapping inner join product on product.id=documentid  where product.id= ?  and product.company= ? "; 
                                 
            returnList = executeSQLQuery( selQuery, params.toArray());
            totalCount = returnList.size();
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }

    public List getQuantityWhoseDOCreated(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        try {
            ArrayList params = new ArrayList();
            params.add((String) requestParams.get("batchId"));
            double soldquantity = 0;
            double purchreturnquantity = 0;
            double salesreturnquantity = 0;
            double salesreturnquantity1 = 0;
            double availableQty = 0;
            double doquantity = 0.0;
            String salesBatchID = "";
            String batchname = "";
//            String mysqlQuery = " select sum(quantity) from salespurchasebatchmapping where purchaseBatch=? ";
//            List list1 = executeSQLQuery( mysqlQuery, params.toArray());
//            if (list1.size() > 0 && !list1.contains(null)) {
//                soldquantity = (Double) list1.get(0);  //DO quantity
//            }
//            String query1 = " select sum(quantity) from returnbatchmapping where batchtomap=? and returntype=2 ";
//            List list2 = executeSQLQuery( query1, params.toArray());
//            if (list2.size() > 0 && !list2.contains(null)) {
//                purchreturnquantity = (Double) list2.get(0); //purchase retuen quantity 
//
//            }
//            String mysqlQuery2 = " select salesBatch from salespurchasebatchmapping where purchaseBatch=? ";
//            List list3 = executeSQLQuery( mysqlQuery2, params.toArray());
//            if (list3.size() > 0 && !list3.contains(null)) {
//                salesBatchID = (String) list3.get(0); //salesbatchid
//
//            }
//            String query2 = " select sum(quantity) from returnbatchmapping where batchtomap=? and returntype=1 ";
//            List list5 = executeSQLQuery( query2, new Object[]{salesBatchID});
//            if (list5.size() > 0 && !list5.contains(null)) {
//                salesreturnquantity1 = (Double) list5.get(0); //sales retuen quantity of Purchase Return(Purchase Return)
//            }
//            String query4 = " select sum(quantity) from returnbatchmapping where batchtomap=? and returntype=1 ";
//            List list4 = executeSQLQuery( query4, params.toArray());
//            if (list4.size() > 0 && !list4.contains(null)) {
//                salesreturnquantity = (Double) list4.get(0); //sales retuen quantity 
//            }
//          //  doquantity = soldquantity - salesreturnquantity;            // do quantity
//            double totalsalesreturn=(salesreturnquantity+salesreturnquantity1);
//            returnList.add(soldquantity);
//            returnList.add(purchreturnquantity);
//            returnList.add(totalsalesreturn);
//            
            String query2 = "select quantitydue,batchname from newproductbatch where id =? ";
            List<Object[]> list5 = executeSQLQuery( query2, params.toArray());
            if (list5.size() > 0 && !list5.contains(null)) {
//                availableQty = (Double) list5.get(0); //abalible quantity of batch
                Object[] obj = list5.get(0);
                availableQty = (Double) obj[0];
                batchname = obj[1] != null ? obj[1].toString() : "";
            }
            returnList.add(availableQty);
            returnList.add(batchname);
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return returnList;
    }
    
    public boolean IsBatchUsedInOutTransaction(HashMap<String, Object> requestParams) throws ServiceException {
        boolean IsBatchUsedInOutTransaction = false;
        try {
            String batchName = "";
            String company = "",documentId="";
            int moduleId=0;
            boolean isEdit=false;
            if (requestParams.containsKey("batchname") && requestParams.get("batchname") != null) {
                batchName = requestParams.get("batchname").toString();
            }
            if (requestParams.containsKey("company") && requestParams.get("company") != null) {
                company =  requestParams.get("company").toString();
            }
            if (requestParams.containsKey("documentid") && requestParams.get("documentid") != null) {
                documentId =  requestParams.get("documentid").toString();
            }
            if (requestParams.containsKey("moduleid") && requestParams.get("moduleid") != null) {
                moduleId =  Integer.parseInt(requestParams.get("moduleid").toString());
            }
            if (requestParams.containsKey("productid") && requestParams.get("productid") != null && moduleId ==Constants.Acc_Product_Master_ModuleId) {
                documentId =  requestParams.get("productid").toString();
            }
            if (requestParams.containsKey("isEdit") && requestParams.get("isEdit") != null) {
                isEdit =  Boolean.parseBoolean(requestParams.get("isEdit").toString());
            }
            NewProductBatch productBatch = null;
            LocationBatchDocumentMapping lbdm = null;
            String hql="";
            List params = new ArrayList();
            params.add(company);
            params.add(batchName);
            if (isEdit && !StringUtil.isNullOrEmpty(documentId)) {    //in edit case check is batch exist in company or not using documentid check
                hql = "FROM NewProductBatch WHERE company.companyID = ? AND batchname = ? AND id not in (Select batchmapid from LocationBatchDocumentMapping where documentid =?)";
                params.add(documentId);
            } else {
                hql = "FROM NewProductBatch WHERE company.companyID = ? AND batchname = ? ";
            }

            List list = executeQuery(hql, params.toArray());
            if (list.size() > 0) {
                for (Iterator it = list.iterator(); it.hasNext();) {
                    NewProductBatch nsr = (NewProductBatch) it.next();
                    double qtyDue = nsr.getQuantitydue();
                    if (qtyDue != 0) {
                        IsBatchUsedInOutTransaction = true;
                        break;
                    } else {
                        String hql1 = "FROM LocationBatchDocumentMapping WHERE  batchmapid.id = ? ";           //check out transaction of batches 28 is used  for In transaction
                        List params1 = new ArrayList();
                        params1.add(nsr.getId());
                        List list1 = executeQuery(hql1, params1.toArray());
                        if (!list1.isEmpty()) {
                            for (Iterator it1 = list1.iterator(); it1.hasNext();) {
                                lbdm = (LocationBatchDocumentMapping) it1.next();
                                if(lbdm.getTransactiontype()==28 && qtyDue==0){
                                    IsBatchUsedInOutTransaction = false;
                                }
                                else{
                                    IsBatchUsedInOutTransaction = true;
                                    break;
                                }
                            }
                            break;
                        } else {
                            IsBatchUsedInOutTransaction = isBatchUsedInQA(company, nsr.getId(),nsr.getBatchname());     // check batchused in QA flow
                            if (IsBatchUsedInOutTransaction) {
                                break;
                            }
                        }
                    }

                }
            }


        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return IsBatchUsedInOutTransaction;
    }

    public boolean isBatchUsedInQA(String companyId, String batchId,String batchName) throws ServiceException {
        boolean isUsedinQA = false;
        KwlReturnObject retObj = new KwlReturnObject(false, null, null, null, 0);
        List params = new ArrayList();
        String consqry = "";
        String DoQuery = "";
        String stockRequest = "";
        String stockOutQA = "";
        String stockOut = "";
        String interStore = "";
        String allquery = "";
        String consignmentStatus = "";
        String stockoutStatus = "";
        String stockRequestStatus = "";
//        String nullCheck = "";
        StringBuilder groConditionQuery = new StringBuilder();
        StringBuilder doConditionQuery = new StringBuilder();
        String buildAssQAStatusQuery = "";
        String statusType = "'3','5'";
        if (!StringUtil.isNullOrEmpty(statusType)) {
//            nullCheck = " AND cda.approval_status <> NULL and cda.repair_status <> NULL ";
            consignmentStatus = " AND (cda.approval_status not in (" + statusType + ") OR cda.repair_status not in (" + statusType + "))";
            stockoutStatus = " AND (sadtl.approval_status not in (" + statusType + ") OR sadtl.repair_status not in (" + statusType + "))";
            stockRequestStatus = " AND (stkdtl.approval_status not in (" + statusType + ") OR stkdtl.repair_status not in (" + statusType + "))";
            buildAssQAStatusQuery = " and (pb.approvedquantity + pb.rejectedquantity) != pb.quantity "; // QA Pending
        }

        List returnList = new ArrayList();

        consqry = "SELECT 1 from in_consignment c "
                +"INNER JOIN in_consignmentdetails cda ON  cda.consignment = c.id"
                + " INNER JOIN product p   ON c.product= p.id  AND  c.company=p.company "
                + "  INNER JOIN newproductbatch npb on p.id=npb.product WHERE c.company=? AND cda.batchName = ? " + consignmentStatus;

        params.add(companyId);
        params.add(batchName);
        

        DoQuery = " select 2 from productbuild pb "
                + " inner join product p on p.id=pb.product INNER JOIN newproductbatch npb on p.id=npb.product"
                + " where pb.company=? and pb.isbuild='T' and npb.id=? and pb.ispendingforqa='T'  " + buildAssQAStatusQuery + " group by pb.id";

        params.add(companyId);
        params.add(batchId);
        

        stockOutQA = "SELECT 3 from in_sa_approval sap "
                + " INNER JOIN in_sa_detail_approval sadtl ON sap.id=sadtl.sa_approval "
                + " INNER JOIN in_stockadjustment sa   ON sap.stock_adjustment= sa.id "
                +" INNER JOIN in_sa_detail sad ON  sad.stockadjustment = sa.id "
                + " INNER JOIN newproductbatch npb   ON sa.product= npb.product "
                + " WHERE sa.company=? and sad.batchname=? " + stockoutStatus;
        params.add(companyId);
        params.add(batchName);
        
        stockRequest = "SELECT 4 from in_stocktransfer_approval stkapr "
                + " INNER JOIN in_stocktransfer_detail_approval stkdtl ON stkapr.id=stkdtl.stocktransfer_approval "
                + " INNER JOIN in_goodsrequest gr ON gr.id=stkapr.stocktransferid "
               +" INNER JOIN in_sr_detail std ON  std.stockrequest = gr.id "
                + "  WHERE gr.company=? AND std.batchname = ? And stkapr.transaction_module=0  " + stockRequestStatus;

        params.add(companyId);
        params.add(batchName);
        
        interStore = "SELECT 5 from in_stocktransfer_approval stkapr "
                + " INNER JOIN in_stocktransfer_detail_approval stkdtl ON stkapr.id=stkdtl.stocktransfer_approval "
                + " INNER JOIN in_interstoretransfer gr ON gr.id=stkapr.stocktransferid "
                +" INNER JOIN in_ist_detail std ON  std.istrequest = gr.id "
                + "  WHERE gr.company=? AND std.batchname=? " + stockRequestStatus;

        params.add(companyId);
        params.add(batchName);
        
        StringBuilder grnQuery = new StringBuilder();

        grnQuery.append("select 6 from grodetails grod "
                + "inner join grorder gro on gro.id = grod.grorder "
                + "inner join grodetailistmapping grodistmapping on grod.id = grodistmapping.grodetail "
                + "inner join product p on grod.product = p.id "
                + "inner join inventory inv on inv.id = grod.id "
                + "left join locationbatchdocumentmapping lbdm on grod.id=lbdm.documentid "
                + "inner join newproductbatch npb on lbdm.batchmapid=npb.id "
                + "inner join in_interstoretransfer inst on inst. fromstore = npb.warehouse and grodistmapping.istrequest = inst.id "
                + "inner join in_storemaster str on str.id = npb.warehouse where grod.company = ? and npb.id=? ");
        if (!StringUtil.isNullOrEmpty(statusType)) {
            grnQuery.append(" and grodistmapping.quantitydue > 0 ");
        }
        grnQuery.append(groConditionQuery.toString());
        params.add(companyId);
        params.add(batchId);
        
        StringBuilder doQuery = new StringBuilder();

        doQuery.append("select 7 "
                + "from dodqcistmapping dodistmapping "
                + "inner join dodetails dod on  dod.id = dodistmapping.dodetailid "
                + "inner join deliveryorder do on do.id = dod.deliveryorder "
                + "inner join in_interstoretransfer inst on dodistmapping.qcistrequest = inst.id "
                + "inner join product p on inst.product = p.id "
                + "inner join newproductbatch npb on inst.product = npb.product "
                + "inner join uom u on u.id = inst.uom "
                + "inner join in_storemaster str on str.id = inst.fromstore where do.company = ? and npb.id=? ");
        if (!StringUtil.isNullOrEmpty(statusType)) {
            doQuery.append(" and dodistmapping .quantitydue > 0 ");
        }
        doQuery.append(doConditionQuery.toString());
        params.add(companyId);
        params.add(batchId);
        allquery = doQuery.toString();

        DoQuery = " UNION  " + DoQuery;

        grnQuery = new StringBuilder(" UNION " + grnQuery.toString());

        doQuery = new StringBuilder(" UNION " + doQuery.toString());

        
       stockOut = "SELECT 8 from in_stockadjustment sa "
                +" INNER JOIN in_sa_detail sad ON  sad.stockadjustment = sa.id "
                + " WHERE sa.company=? and sad.batchname=? and isdeleted='F' ";
        params.add(companyId);
        params.add(batchName);
        allquery = stockOut;
        
        allquery = consqry + DoQuery + " UNION  " + stockOutQA + " UNION  " + stockRequest + " UNION  " + interStore +" UNION  " + stockOut + grnQuery.toString() + doQuery.toString();
        String seleQuery = "SELECT tb.* FROM (" + allquery + ") as tb ";
        returnList = executeSQLQuery(seleQuery, params.toArray());
        if (!returnList.isEmpty()) {
            isUsedinQA = true;
        }

        return isUsedinQA;
    }
    @Override
    public KwlReturnObject getAutoBuildAssemblyEntriesForDeliveryOrder(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        try {
            ArrayList params = new ArrayList();
            params.add((String) requestParams.get("doid"));
            params.add((String) requestParams.get("companyid"));

            String mysqlQuery = " from ProductBuild where deliveryOrder = ? and company.companyID = ? ";

            returnList = executeQuery( mysqlQuery, params.toArray());
            totalCount = returnList.size();
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }

    public KwlReturnObject getPO_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from PurchaseOrderDetail pod where product.ID=? and pod.company.companyID=?";// and pod.purchaseOrder.deleted=false";
        String q = "select count(pod.id) from podetails pod where product=? and pod.company=?";// and pod.purchaseOrder.deleted=false";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getSO_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from SalesOrderDetail sod where product.ID=? and sod.company.companyID=? and sod.salesOrder.deleted=false";
        String q = "select count(sod.id) from sodetails sod inner join salesorder so on so.id=sod.salesorder where sod.product=? and sod.company=? and so.deleteflag=false";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getGoodsReceipt_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from GoodsReceiptDetail grd where inventory.product.ID=? and grd.company.companyID=?";// and grd.goodsReceipt.deleted=false";
        String q = "select count(grd.id) from grdetails grd inner join inventory inv on inv.id=grd.id where inv.product=? and grd.company=?";// and grd.goodsReceipt.deleted=false";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getInvoice_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from InvoiceDetail invd where inventory.product.ID=? and invd.company.companyID=? and invd.invoice.deleted=false";
        String q = "select count(invd.id) from invoicedetails invd inner join invoice inv on inv.id=invd.invoice inner join inventory invt on inv.id=invt.id where invt.product=? and invd.company=? and inv.deleteflag=false";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getGR_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from GoodsReceiptOrderDetails grod where grod.product.ID=? and grod.company.companyID=?";// and grod.grOrder.deleted=false ";
        String q = "select count(grod.id) from grodetails grod where grod.product=? and grod.company=?";// and grod.grOrder.deleted=false ";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getDO_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from DeliveryOrderDetail dod where dod.product.ID=? and dod.company.companyID=?";// and dod.deliveryOrder.deleted=false ";
        String q = "select count(dod.id) from dodetails dod where dod.product=? and dod.company=?";// and dod.deliveryOrder.deleted=false ";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getSalesReturn_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from SalesReturnDetail srd where srd.product.ID=? and srd.company.companyID=?";// and srd.salesReturn.deleted=false ";
        String q = "select count(srd.id) from srdetails srd where srd.product=? and srd.company=?";// and srd.salesReturn.deleted=false ";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    /*
    * check whether product is used in Inventory or not.
    * also check in transaction module : STOCK_REQUEST,ISSUE_NOTE,INTER_STORE_TRANSFER,STOCK_ADJUSTMENT,CYCLE_COUNT,INTER_LOCATION_TRANSFER,
    */
    public KwlReturnObject getInventoryTransaction_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from StockMovement ism where ism.product.ID=? and ism.company.companyID=?  and transactionModule in (0,1,2,3,4,11)";
        String q = "select count(ism.id) from in_stockmovement ism where ism.product=? and ism.company=?  and ism.transaction_module in (0,1,2,3,4,11)";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getCQ_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from QuotationDetail qd where qd.product.ID=? and qd.company.companyID=? ";
        String q = "select count(qd.id) from quotationdetails qd where qd.product=? and qd.company=? "; 
        /*
         * and qd.quotation.deleted=false "
         */
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getPR_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from PurchaseRequisitionDetail prd where prd.product.ID=? and prd.company.companyID=?";// and prd.purchaserequisition.deleted=false ";
        String q = "select count(prd.id) from purchaserequisitiondetail prd where prd.product=? and prd.company=?";// and prd.purchaserequisition.deleted=false ";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getVQ_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from VendorQuotationDetail vqd where vqd.product.ID=? and vqd.company.companyID=? ";//and vqd.vendorquotation.deleted=false ";
        String q = "select count(vqd.id) from vendorquotationdetails vqd where vqd.product=? and vqd.company=? ";//and vqd.vendorquotation.deleted=false ";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getPurchaseReturn_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
//        String q = "from PurchaseReturnDetail prd where prd.product.ID=? and prd.company.companyID=?";// and prd.purchaseReturn.deleted=false ";
        String q = "select count(prd.id) from prdetails prd where prd.product=? and prd.company=?";// and prd.purchaseReturn.deleted=false ";
        list = executeSQLQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject getSerialNos(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "from com.krawler.common.admin.NewBatchSerial bs where bs.quantitydue>0 and bs.product=? and bs.company.companyID=?";
        list = executeQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject getProductPriceFromPricingBand(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        try {
            boolean isPurchase = requestParams.get("isPurchase") != null ? (Boolean) requestParams.get("isPurchase") : false;
            String productID = requestParams.get("productID") != null ? (String) requestParams.get("productID") : "";
            String pricingBandMasterID = requestParams.get("pricingBandMasterID") != null ? (String) requestParams.get("pricingBandMasterID") : "";
            String companyID = requestParams.get("companyID") != null ? (String) requestParams.get("companyID") : "";
            String currencyID = requestParams.get("currencyID") != null ? (String) requestParams.get("currencyID") : "";

            String condition = "";
            String innerCondition = "";
            ArrayList params = new ArrayList();
            params.add(productID);
            params.add(pricingBandMasterID);
            params.add(companyID);

            if (!StringUtil.isNullOrEmpty(currencyID)) {
                params.add(currencyID);
                condition += " and pbmd.currency.currencyID = ? ";
                innerCondition += " and currency.currencyID = pbmd.currency.currencyID ";
            }

            if (requestParams.containsKey("applicableDate") && requestParams.get("applicableDate") != null) {
                params.add((Date) requestParams.get("applicableDate"));
                condition += "and pbmd.applicableDate in (select max(applicableDate) as ld from PricingBandMasterDetail where company.companyID =pbmd.company.companyID and pricingBandMaster = pbmd.pricingBandMaster and product = pbmd.product " + innerCondition + " and applicableDate <= ? group by product) ";
            }

            String query = "";
            if (isPurchase) {
                query = "select pbmd.purchasePrice, pbmd.currency.currencyID, pbmd.pricingBandMaster.name, pbmd.purchasePrice from PricingBandMasterDetail pbmd where pbmd.product = ? and pbmd.pricingBandMaster.ID = ? and pbmd.company.companyID = ? " + condition;
            } else {
                query = "select pbmd.salesPrice, pbmd.currency.currencyID, pbmd.pricingBandMaster.name, pbmd.purchasePrice from PricingBandMasterDetail pbmd where pbmd.product = ? and pbmd.pricingBandMaster.ID = ? and pbmd.company.companyID = ? " + condition;
            }

            returnList = executeQuery( query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getProductPriceFromPricingBand : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject getPriceListBandIDByName(String priceListBandName, String companyId) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(priceListBandName)) {
            ArrayList params = new ArrayList();
            params.add(priceListBandName);
            params.add(companyId);
            String query = "select id from PricingBandMaster where name=? and company.companyID=? ";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }

    @Override
    public KwlReturnObject getProductPriceFromPriceListVolumeDiscount(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        try {
            boolean isPricePolicyUseDiscount = requestParams.get("isPricePolicyUseDiscount") != null ? (Boolean) requestParams.get("isPricePolicyUseDiscount") : false;
            boolean isPurchase = requestParams.get("isPurchase") != null ? (Boolean) requestParams.get("isPurchase") : false;
            String productID = requestParams.get("productID") != null ? (String) requestParams.get("productID") : "";
            String companyID = requestParams.get("companyID") != null ? (String) requestParams.get("companyID") : "";
            String currencyID = requestParams.get("currencyID") != null ? (String) requestParams.get("currencyID") : "";

            String condition = "";
            ArrayList params = new ArrayList();
            params.add(productID);
            params.add(companyID);
            
            if (isPricePolicyUseDiscount) {
                condition += " and pbmd.pricingBandMaster.pricePolicyValue = 1 ";
            } else {
                condition += " and pbmd.pricingBandMaster.pricePolicyValue = 2 ";
            }

            if (!StringUtil.isNullOrEmpty(currencyID)) {
                params.add(currencyID);
                condition += " and pbmd.currency.currencyID = ? ";
            } else {
                condition += " and pbmd.currency is null ";
            }

            if (requestParams.containsKey("applicableDate") && requestParams.get("applicableDate") != null) {
                params.add((Date) requestParams.get("applicableDate"));
                condition += " and pbmd.applicableDate = (select max(applicableDate) as ld from PricingBandMasterDetail where company.companyID =pbmd.company.companyID and pricingBandMaster = pbmd.pricingBandMaster and product = pbmd.product and applicableDate <= ? group by product) ";
            }

            if (requestParams.containsKey("quantity") && requestParams.get("quantity") != null) {
                params.add((Integer) requestParams.get("quantity"));
                params.add((Integer) requestParams.get("quantity"));
                condition += " and (pbmd.minimumQty <= ? and pbmd.maximumQty >= ?) ";
            }

            String query = "";
            if (isPurchase) {
                query = "select pbmd.purchasePrice, pbmd.currency.currencyID, pbmd.minimumQty, pbmd.maximumQty, pbmd.pricingBandMaster.name, pbmd.id, pbmd.purchasePrice, pbmd.pricingBandMaster.id from PricingBandMasterDetail pbmd where pbmd.pricingBandMaster.volumeDiscount = true and pbmd.product = ? and pbmd.company.companyID = ? " + condition;
            } else {
                query = "select pbmd.salesPrice, pbmd.currency.currencyID, pbmd.minimumQty, pbmd.maximumQty, pbmd.pricingBandMaster.name, pbmd.id, pbmd.purchasePrice,pbmd.pricingBandMaster.id from PricingBandMasterDetail pbmd where pbmd.pricingBandMaster.volumeDiscount = true and pbmd.product = ? and pbmd.company.companyID = ? " + condition;
            }

            returnList = executeQuery( query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getProductPriceFromPriceListVolumeDiscount : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject deleteAssetDepreciationJE(String jeid, String companyid) throws ServiceException {
        deleteJEDtails(jeid, companyid);
        //Delete Journal Entry
        String delQuery = "delete from JournalEntry je where ID=? and je.company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{jeid, companyid});
        return new KwlReturnObject(true, "Journal Entry has been deleted successfully.", null, null, numRows);
    }

    public KwlReturnObject deleteJEDtails(String jeid, String companyid) throws ServiceException {
        //Delete Journal Entry details
        String delQuery1 = "delete from AccJEDetailCustomData where jedetailId in (select ID from JournalEntryDetail where journalEntry.ID=? and company.companyID=?)";
        int numRows1 = executeUpdate(delQuery1, new Object[]{jeid, companyid});
        
        String delQuery = "delete from JournalEntryDetail jed where jed.journalEntry.ID=? and jed.company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{jeid, companyid});
        return new KwlReturnObject(true, "JournalEntry details has been deleted successfully.", null, null, numRows);
    }
   
    public KwlReturnObject deleteAssetDepreciationDetails(String je, int period) throws ServiceException {
        String delQuery = "delete from AssetDepreciationDetail where journalEntry.ID=? and period=?";
        int count = executeUpdate( delQuery, new Object[]{je, period});
        return new KwlReturnObject(true, "", null, null, count);
    }
    
    /* 
      Delete All the asset depreciation details
    */
    @Override
    public KwlReturnObject deleteAssetDepreciationDetails(Map<String, Object> dataMap) throws ServiceException {
        String delQuery = "delete from AssetDepreciationDetail where journalEntry.ID in(:journalEntryList)";
        int numRows = executeUpdateCollectionQuery(delQuery,dataMap);
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    
    @Override
    public KwlReturnObject deleteAssetDepreciationJE(Map<String, Object> dataMap) throws ServiceException {
        deleteJEDetails(dataMap);
        //Delete Journal Entry
        String delQuery = "delete from JournalEntry je where ID in(:journalEntryList) and je.company.companyID= (:companyId)";
        int numRows = executeUpdateCollectionQuery(delQuery,dataMap);
        return new KwlReturnObject(true, "Journal Entry has been deleted successfully.", null, null, numRows);
    }
    
    public KwlReturnObject deleteJEDetails(Map<String, Object> dataMap) throws ServiceException {
        //Delete Journal Entry details
        String companyid = "";
        String jeids = "";
        if (dataMap.containsKey("companyId") && dataMap.get("companyId") != null) {
            companyid = dataMap.get("companyId").toString();
        }

        if (dataMap.containsKey("jeids") && dataMap.get("jeids") != null) {
            jeids = (String) dataMap.get("jeids");
        }
        String delQuery1 = "delete accjedcdata.* from accjedetailcustomdata accjedcdata inner join  jedetail jed  ON jed.id= accjedcdata.jedetailId  where jed.journalEntry in(" + jeids + ") and jed.company=? ";
        int numRows1 = executeSQLUpdate(delQuery1, new Object[]{companyid});

        if (dataMap.containsKey("jeids")) {
            dataMap.remove("jeids");
        }
        String delQuery = "delete from JournalEntryDetail jed where jed.journalEntry.ID in(:journalEntryList) and jed.company.companyID= (:companyId)";
        int numRows = executeUpdateCollectionQuery(delQuery, dataMap);
        return new KwlReturnObject(true, "JournalEntry details has been deleted successfully.", null, null, numRows);
    }

    @Override
    public KwlReturnObject saveProductExportDetails(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            ProductExportDetail exportDetail = new ProductExportDetail();
            if (dataMap.containsKey("id") && dataMap.get("id") != null) {
                exportDetail = (ProductExportDetail) get(ProductExportDetail.class, (String) dataMap.get("id"));
            }

            if (dataMap.containsKey("companyId") && dataMap.get("companyId") != null) {
                Company company = (Company) get(Company.class, (String) dataMap.get("companyId"));
                exportDetail.setCompany(company);
            }

            if (dataMap.containsKey("fileName") && dataMap.get("fileName") != null) {
                exportDetail.setFileName((String) dataMap.get("fileName"));
            }

            if (dataMap.containsKey("fileType") && dataMap.get("fileType") != null) {
                exportDetail.setFileType((String) dataMap.get("fileType"));
            }

            if (dataMap.containsKey("requestTime") && dataMap.get("requestTime") != null) {
                exportDetail.setRequestTime((Date) dataMap.get("requestTime"));
            }

            if (dataMap.containsKey("status") && dataMap.get("status") != null) {
                exportDetail.setStatus((Integer) dataMap.get("status"));
            }

            saveOrUpdate(exportDetail);
            list.add(exportDetail);
        } catch (Exception e) {
            throw ServiceException.FAILURE("saveProductExportDetails : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "Export Details has been added successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject getProductExportDetails(HashMap requestParam) throws ServiceException {
        List returnList = new ArrayList();
        try {
            String condition = "";
            ArrayList params = new ArrayList();

            String companyid = (String) requestParam.get("companyId");
            params.add(companyid);

            if (requestParam.containsKey("startdate") && requestParam.containsKey("enddate")) {
                Date startdate = (Date) requestParam.get("startdate");
                Date enddate = (Date) requestParam.get("enddate");
                params.add(startdate);
                params.add(enddate);

                condition += " and (ped.requestTime>? and ped.requestTime<=?) ";
            }

            String query = "from ProductExportDetail ped where ped.company.companyID = ? " + condition + " order by ped.requestTime desc";
            returnList = executeQuery( query, params.toArray());
            return new KwlReturnObject(true, "", null, returnList, returnList.size());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("getProductExportDetails: " + ex.getMessage(), ex);
        }
    }

    @Override
    public KwlReturnObject getBuildAssemblyProducts(HashMap<String, Object> request) throws ServiceException {
        List list = null;
        int count = 0;
        try {
            String condition = "";
            String companyid = (String) request.get(Constants.companyKey);
            DateFormat df = (DateFormat) request.get(Constants.df);
            CompanyAccountPreferences pref = (CompanyAccountPreferences) get(CompanyAccountPreferences.class, companyid);
            String productid = (String) request.get("productid"); //customerid
            int datefilter = (request.containsKey("datefilter") && request.get("datefilter") != null) ? Integer.parseInt(request.get("datefilter").toString()) : 0;// 0 = Invoice Due date OR 1 = Invoice date
            ArrayList params = new ArrayList();
            params.add(companyid);
            Date startDate = (Date) request.get(Constants.REQ_startdate);
            Date endDate = (Date) request.get(Constants.REQ_enddate);
            if (startDate != null && endDate != null) {
                condition += " and (pb.entryDate >=? and pb.entryDate <=?)";
                params.add(startDate);
                params.add(endDate);
            }
            if (request.containsKey("ss") && request.get("ss") != null) {
                String ss = request.get("ss").toString();
                if (!StringUtil.isNullOrEmpty(ss)) {
                    if (!ss.equals("undefined")) {
                        String[] searchcol = new String[]{"pb.product.name", "pb.product.productid", "pb.product.description"};
                        try {
                            Map map = StringUtil.insertParamSearchStringMap(params, ss, 3);
                            StringUtil.insertParamSearchString(map);
                        } catch (SQLException ex) {
                            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                        condition += searchQuery;
                    }
                }
            } else if (request.containsKey("search") && request.get("search") != null) {
                String ss = request.get("search").toString();
                if (!StringUtil.isNullOrEmpty(ss)) {
                    String[] searchcol = new String[]{"pb.product.name", "pb.product.productid", "pb.product.description"};
                    try {
                        Map map = StringUtil.insertParamSearchStringMap(params, ss, 3);
                        StringUtil.insertParamSearchString(map);
                    } catch (SQLException ex) {
                        Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                    }
                    String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                    condition += searchQuery;
                }
            }
            int type = 0;
            String Type = (String) request.get("type");
            if (Type == null) {
                Type = "";
            }
            String query = "";
            String locationid = "";
            if (!Type.equals("")) {
                type = Integer.valueOf(Type);
                locationid = (String) request.get("locationid");
                if (locationid.equals("")) {
                    switch (type) {
                        case 1:
                            condition += " and l.batchmapid.location.id is not null ";
                            break;
                        case 2:
                            condition += " and l.batchmapid.warehouse.id is not null ";
                            break;
                        case 3:
                            condition += " and l.batchmapid.row.id is not null and l.batchmapid.row.type=1 ";
                            break;
                        case 4:
                            condition += " and l.batchmapid.rack.id is not null and l.batchmapid.rack.type=2 ";
                            break;
                        case 5:
                            condition += " and l.batchmapid.bin.id is not null  and l.batchmapid.bin.type=3 ";
                            break;
                    }
                } else {
                    params.add(locationid);
                    switch (type) {
                        case 1:
                            condition += " and l.batchmapid.location.id=? ";
                            break;
                        case 2:
                            condition += " and l.batchmapid.warehouse.id=? ";
                            break;
                        case 3:
                            condition += " and l.batchmapid.row.id=? and l.batchmapid.row.type=1 ";
                            break;
                        case 4:
                            condition += " and l.batchmapid.rack.id=? and l.batchmapid.rack.type=2 ";
                            break;
                        case 5:
                            condition += " and l.batchmapid.bin.id=? and l.batchmapid.bin.type=3 ";
                            break;
                    }
                }
//                query = "select distinct pb.build.ID as buildid ,pb.build.product.ID as productid,pb.build.product.name as productname,pb.build.quantity as quantity,pb.build.entryDate as entrydate,(pb.build.quantity * pb.rate) as cost from ProductBuildDetails pb,LocationBatchDocumentMapping l where pb.build.product.ID=l.documentid and pb.build.company.companyID=? " + condition;
                query = "select distinct pb.ID as buildid ,pb.product.ID as productid,pb.product.name as productname,pb.quantity as quantity,pb.entryDate as entrydate,pb.productcost as cost from ProductBuild pb,LocationBatchDocumentMapping l where pb.product.ID=l.documentid and pb.company.companyID=? " + condition;
            } else { // for all 
//                query = "select distinct pb.build.ID as buildid ,pb.build.product.ID as productid,pb.build.product.name as productname,pb.build.quantity as quantity,pb.build.entryDate as entrydate,(pb.build.quantity * pb.rate) as cost from ProductBuildDetails pb where pb.build.company.companyID=?" + condition;
                query = "select distinct pb.ID as buildid ,pb.product.ID as productid,pb.product.name as productname,pb.quantity as quantity,pb.entryDate as entrydate,pb.productcost as cost from ProductBuild pb where   pb.company.companyID=?" + condition;
            }
            list = executeQuery( query, params.toArray());
            count = list.size();
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accInvoiceImpl.getInvoices:" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    @Override
    public KwlReturnObject getAssetPurchaseRequisitionDetailMapping(HashMap<String, Object> filterParams) throws ServiceException {
        List returnList;
        ArrayList params = new ArrayList();
        String condition = "";
        String query = "from AssetPurchaseRequisitionDetailMapping ";
        if (filterParams.containsKey("companyid")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "company.companyID=?";
            params.add(filterParams.get("companyid"));
        }

        if (filterParams.containsKey("purchaseRequisitionDetailID")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "purchaseRequisitionDetailID=?";
            params.add(filterParams.get("purchaseRequisitionDetailID"));
        }

        if (filterParams.containsKey("moduleId")) {
            condition += (condition.length() == 0 ? " where " : " and ") + "moduleId=?";
            params.add(filterParams.get("moduleId"));
        }

        query += condition;
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public KwlReturnObject savePurchaseRequisitionAssetDetails(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            PurchaseRequisitionAssetDetails assetDetails = new PurchaseRequisitionAssetDetails();

            String companyId = (String) dataMap.get("companyId");
            String productId = (String) dataMap.get("productId");

            Company company = (Company) get(Company.class, companyId);
            Product product = (Product) get(Product.class, productId);

            if (company != null) {
                assetDetails.setCompany(company);
            }
            if (product != null) {
                assetDetails.setProduct(product);
            }

            assetDetails = buildPurchaseRequisitionAssetDetails(assetDetails, dataMap);

            save(assetDetails);
            list.add(assetDetails);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("savePurchaseRequisitionAssetDetails : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Purchase Requisition Asset Detail has been added successfully", null, list, list.size());
    }
    
    private PurchaseRequisitionAssetDetails buildPurchaseRequisitionAssetDetails(PurchaseRequisitionAssetDetails assetDetails, HashMap<String, Object> dataMap) {
        if (dataMap.containsKey("assetId")) {
            assetDetails.setAssetId((String) dataMap.get("assetId"));
        }
        if (dataMap.containsKey("location")) {
            InventoryLocation location = (InventoryLocation) get(InventoryLocation.class, (String) dataMap.get("location"));
            assetDetails.setLocation(location);
        }
        if (dataMap.containsKey("department")) {
            Department department = (Department) get(Department.class, (String) dataMap.get("department"));
            assetDetails.setDepartment(department);
        }
        if (dataMap.containsKey("assetUser")) {
            User user = (User) get(User.class, (String) dataMap.get("assetUser"));
            assetDetails.setAssetUser(user);
        }
        if (dataMap.containsKey("sellingJE")) {
            JournalEntry je = (JournalEntry) get(JournalEntry.class, (String) dataMap.get("sellingJE"));
            assetDetails.setSellingJE(je);
        }
        if (dataMap.containsKey("cost")) {
            assetDetails.setCost((Double) dataMap.get("cost"));
        }
        if (dataMap.containsKey("costInForeignCurrency")) {
            assetDetails.setCostInForeignCurrency((Double) dataMap.get("costInForeignCurrency"));
        }
        if (dataMap.containsKey("salvageRate")) {
            assetDetails.setSalvageRate((Double) dataMap.get("salvageRate"));
        }
        if (dataMap.containsKey("salvageValue")) {
            assetDetails.setSalvageValue((Double) dataMap.get("salvageValue"));
        }
        if (dataMap.containsKey("salvageValueInForeignCurrency")) {
            assetDetails.setSalvageValueInForeignCurrency((Double) dataMap.get("salvageValueInForeignCurrency"));
        }
        if (dataMap.containsKey("accumulatedDepreciation")) {
            assetDetails.setAccumulatedDepreciation((Double) dataMap.get("accumulatedDepreciation"));
        }
        if (dataMap.containsKey("wdv")) {
            assetDetails.setWdv((Double) dataMap.get("wdv"));
        }
        if (dataMap.containsKey("assetLife")) {
            assetDetails.setAssetLife((Double) dataMap.get("assetLife"));
        }
        if (dataMap.containsKey("elapsedLife")) {
            assetDetails.setElapsedLife((Double) dataMap.get("elapsedLife"));
        }
        if (dataMap.containsKey("nominalValue")) {
            assetDetails.setNominalValue((Double) dataMap.get("nominalValue"));
        }
        if (dataMap.containsKey("sellAmount")) {
            assetDetails.setSellAmount((Double) dataMap.get("sellAmount"));
        }
        if (dataMap.containsKey("installationDate")) {
            assetDetails.setInstallationDate((Date) dataMap.get("installationDate"));
        }
        if (dataMap.containsKey("purchaseDate")) {
            assetDetails.setPurchaseDate((Date) dataMap.get("purchaseDate"));
        }
        if (dataMap.containsKey("assetSoldFlag")) {
            assetDetails.setAssetSoldFlag((Integer) dataMap.get("assetSoldFlag"));
        }
        if (dataMap.containsKey("isUsedFlag")) {
            assetDetails.setIsUsed((Boolean) dataMap.get("isUsedFlag"));
        }
        if (dataMap.containsKey("isCreatedFromOpeningForm")) {
            assetDetails.setCreatedFromOpeningForm((Boolean) dataMap.get("isCreatedFromOpeningForm"));
        }
        if (dataMap.containsKey("isLinkedToLeaseSO")) {
            assetDetails.setLinkedToLeaseSO((Boolean) dataMap.get("isLinkedToLeaseSO"));
        }
        if (dataMap.containsKey("isLeaseDOCreated")) {
            assetDetails.setLeaseDOCreated((Boolean) dataMap.get("isLeaseDOCreated"));
        }
        if (dataMap.containsKey("isLeaseInvoiceCreated")) {
            assetDetails.setLeaseCICreated((Boolean) dataMap.get("isLeaseInvoiceCreated"));
        }
        if (dataMap.containsKey("invrecord")) {
            assetDetails.setInvrecord((Boolean) dataMap.get("invrecord"));
        }
        if (dataMap.containsKey("assetdescription")) {
            assetDetails.setAssetDescription((String) dataMap.get("assetdescription"));
        }
        if (dataMap.containsKey("batch")) {
            ProductBatch productBatch = dataMap.get("batch") == null ? null : (ProductBatch) get(ProductBatch.class, (String) dataMap.get("batch"));
            if (productBatch != null) {
                assetDetails.setBatch(productBatch);
            }
        }
        return assetDetails;
    }

    @Override
    public KwlReturnObject saveAssetPurchaseRequisitionDetailMapping(HashMap<String, Object> dataMap) throws ServiceException {
        List list = new ArrayList();
        try {
            AssetPurchaseRequisitionDetailMapping invoiceDetailMapping = new AssetPurchaseRequisitionDetailMapping();

            String companyId = (String) dataMap.get("company");
            Company company = (Company) get(Company.class, companyId);
            if (company != null) {
                invoiceDetailMapping.setCompany(company);
            }

            if (dataMap.containsKey("moduleId")) {
                invoiceDetailMapping.setModuleId((Integer) dataMap.get("moduleId"));
            }

            if (dataMap.containsKey("purchaseRequisitionDetail")) {
                invoiceDetailMapping.setPurchaseRequisitionDetailID((String) dataMap.get("purchaseRequisitionDetail"));
            }

            if (dataMap.containsKey("assetDetails")) {
                PurchaseRequisitionAssetDetails assetDetails = (PurchaseRequisitionAssetDetails) get(PurchaseRequisitionAssetDetails.class, (String) dataMap.get("assetDetails"));
                invoiceDetailMapping.setPurchaseRequisitionAssetDetails(assetDetails);
            }

            save(invoiceDetailMapping);
            list.add(invoiceDetailMapping);

        } catch (Exception ex) {
            throw ServiceException.FAILURE("saveAssetPurchaseRequisitionDetailMapping : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "Purchase Requisition Asset Detail has been added successfully", null, list, list.size());
    }

    @Override
    public KwlReturnObject updateTotalIssueCount(double totalIssueCount, String prductID, String companyid, boolean updateflag,boolean isEdit) throws ServiceException {
        List list = new ArrayList();
        try {
            double totalIssuCountAddition = 0, currentCount = 0;
            Product product = new Product();
            if (!StringUtil.isNullOrEmpty(prductID)) {
                KwlReturnObject catresult = getObject(Product.class.getName(), prductID);
                product = (Product) catresult.getEntityList().get(0);
                if (product != null) {

                    if (updateflag) { //this flag is for update previous issue count value in srdetails table when we delete condignment return temporary
                        product.setTotalIssueCount(totalIssueCount);
                    }
                    else if(isEdit)     //When we edit he sales cong=signment return
                    {
                      product.setTotalIssueCount(totalIssueCount);  
                    }
                 else {                 //else update the value total issue count in product master add totalissuecount every time when fill reusable issue count
                    currentCount = product.getTotalIssueCount();
                    totalIssuCountAddition = currentCount + totalIssueCount;
                    product.setTotalIssueCount(totalIssuCountAddition);
                }
                saveOrUpdate(product);
                list.add(product);
            }
        }
        } catch (Exception e) {
            throw ServiceException.FAILURE("updateTotalIssueCount : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject getPurchaseRequisitionAssetDetails(HashMap<String, Object> requestMap) throws ServiceException {
        String condition = "";
        List params = new ArrayList();

        String companyId = (String) requestMap.get("companyId");

        params.add(companyId);

        if (requestMap.containsKey("invrecord") && requestMap.get("invrecord") != null) {
            condition += " and ad.invrecord=? ";
            params.add((Boolean) requestMap.get("invrecord"));
        }

        if (requestMap.containsKey("productId")) {
            condition += " and ad.product.ID=? ";
            params.add((String) requestMap.get("productId"));
        }

        if (requestMap.containsKey("assetId")) {
            condition += " and ad.assetId=? ";
            params.add((String) requestMap.get("assetId"));
        }

        if (requestMap.containsKey("excludeSoldAsset") && (Boolean) requestMap.get("excludeSoldAsset")) {
            condition += " and ad.assetSoldFlag=0 ";
        }

        String query = "from PurchaseRequisitionAssetDetails ad Where ad.company.companyID=? " + condition;



        if (requestMap.containsKey("invdetailId")) {
            params = new ArrayList();
            params.add(companyId);
            params.add((Boolean) requestMap.get("invrecord"));
            params.add((String) requestMap.get("invdetailId"));
            query = "Select ad from PurchaseRequisitionAssetDetails ad Inner Join AssetPurchaseRequisitionDetailMapping adm Where ad.company.companyID=? and ad.invrecord=? and adm.purchaseRequisitionDetailID=?";
        }

        List list = executeQuery( query, params.toArray());

        return new KwlReturnObject(true, null, null, list, list.size());
    }
  
    @Override
    public KwlReturnObject deleteNewProductBatch(String productId, String companyid) throws ServiceException {
        boolean successflag = false;
        try {
            String delQuery = " delete from NewProductBatch where product=? and company.companyID=?";
            int num = executeUpdate( delQuery,new Object[]{productId, companyid});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accProductImpl:deleteNewProductBatch :" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(successflag, "Product batch has been deleted successfully.", null, null, 1);
    }
    @Override
    public KwlReturnObject deleteLocationDocumentMap(String productId, String companyid) throws ServiceException {
        boolean successflag = false;
        try {
            String delQuery = " DELETE FROM locationbatchdocumentmapping WHERE batchmapid IN (SELECT id FROM newproductbatch WHERE product=? AND company=? )";
            int num = executeSQLUpdate( delQuery,new Object[]{productId, companyid});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accProductImpl:deleteNewProductBatch :" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(successflag, "Product batch has been deleted successfully.", null, null, 1);
    }
    
    public KwlReturnObject getProductByInventoryID(String inventoryid, String companyid) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(inventoryid);
        params.add(companyid);
        List returnList = new ArrayList();
        String query = "select p, product from Inventory p where p.ID=? and p.company.companyID=? ";
        returnList = executeQuery( query, params.toArray());
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
     @Override
    public KwlReturnObject getPriceBandProductsPrice(HashMap<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        try {
            ArrayList params = new ArrayList();
            String condition = "";
            params.add(requestParams.get("companyID"));
            
            if (requestParams.containsKey("isSyncToPOS") && requestParams.get("isSyncToPOS") != null) {
                params.add((Boolean) requestParams.get("isSyncToPOS"));
                condition += " and pricingBandMaster.defaultToPOS = ? ";
            }
            
            if (requestParams.containsKey("currencyID") && requestParams.get("currencyID") != null) {
                params.add(requestParams.get("currencyID"));
                condition += " and currency.currencyID = ? ";
            }
            if (requestParams.containsKey("productId") && requestParams.get("productId") != null) {
                params.add(requestParams.get("productId"));
                condition += " and product = ? ";
            }
            
            String selQuery = " from PricingBandMasterDetail where company.companyID = ? " + condition;
            
            returnList = executeQuery( selQuery, params.toArray());
            totalCount = returnList.size();
        }  catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }
     
    public KwlReturnObject getProductTypeByProductID(String productTypeID) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(productTypeID)) {
            ArrayList params = new ArrayList();
            params.add(productTypeID);
            String query = "FROM Producttype pt where pt.id IN (SELECT p.producttype FROM Product p where p.productid = ?)";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }    
    
    @Override
    public KwlReturnObject getProductBuildDetailInventory(String productBuildID) throws ServiceException {
        List list = new ArrayList();
        String query = "from ProductBuildDetails pbd where pbd.build.ID=? ";
        list = executeQuery( query, new Object[]{productBuildID});
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    /**
     * Method to get ProductBuildDetails object using ID.
     *
     * @param pbDetailsID
     * @return
     * @throws ServiceException
     */
    public KwlReturnObject getProductBuildDetails(String pbDetailsID) throws ServiceException {
        List list = new ArrayList();
        String query = "from ProductBuildDetails pbd where pbd.ID=? ";
        list = executeQuery(query, new Object[]{pbDetailsID});
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    @Override
    public KwlReturnObject getProductCategoryIDByName(String productCategoryName, String companyId) throws ServiceException {
        KwlReturnObject result = null;

             if (!StringUtil.isNullOrEmpty(companyId) && !StringUtil.isNullOrEmpty(productCategoryName)) {    
            ArrayList params = new ArrayList();
                //params.add(URLEncoder.encode(productCategoryName, Constants.DECODE_ENCODE_FORMAT));
                params.add(productCategoryName);
                params.add(companyId);
                String query = "select ID from MasterItem where value=? and company.companyID=? ";
                List list = executeQuery(query, params.toArray());
                int totalCount = list.size();
                result = new KwlReturnObject(true, null, null, list, totalCount);
            
             }
        return result;
    }
    
    @Override
    public KwlReturnObject getProductCategoryMapping(String productID, String productCategoryID) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(productID) && !StringUtil.isNullOrEmpty(productCategoryID)) {
            ArrayList params = new ArrayList();
            params.add(productID);
            params.add(productCategoryID);
            String query = "select ID from ProductCategoryMapping where productID.ID=? and productCategory.ID=? ";
            List list = executeQuery( query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }
    
    @Override
    public KwlReturnObject deleteProductCategoryMappingForNoneCategory(String productID) throws ServiceException {
        int numRows = 0;
        String delQuery = " delete from ProductCategoryMapping where productID.ID=? and productCategory is null ";
        numRows += executeUpdate( delQuery, new Object[]{productID});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
     @Override
    public double getProductQuantityUnderParticularStore(Product product, String storeId) throws ServiceException {
        double quantity = 0;
        StringBuilder hql = new StringBuilder("SELECT SUM(s.quantity) FROM Stock s WHERE s.company = ? AND s.product = ? AND s.store.id=?  GROUP BY s.product,s.store ");
        List params = new ArrayList();
        params.add(product.getCompany());
        params.add(product);
        params.add(storeId);
        List list = executeQuery( hql.toString(), params.toArray());

        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            quantity = (Double) itr.next();
        }
        return authHandler.roundQuantity(quantity,product.getCompany().getCompanyID());
    }
    public double getProductQuantityUnderParticularStoreLocation(String product, String warehouseId,String locationId,String companyId) throws ServiceException {
        double quantity = 0;
        StringBuilder hql = new StringBuilder("SELECT SUM(nb.quantitydue) FROM NewProductBatch nb WHERE nb.company.companyID = ? AND nb.product = ? AND nb.warehouse.id=?  AND nb.location.id=?");
        List params = new ArrayList();
        params.add(companyId);
        params.add(product);
        params.add(warehouseId);
        params.add(locationId);
        List list = executeQuery( hql.toString(), params.toArray());
        if (list.size() > 0 && !list.contains(null)) {
            quantity = (Double) list.get(0);
        }
        return authHandler.roundQuantity(quantity,companyId);
    }

    @Override
     public synchronized String updateProductEntryNumber(Map<String, Object> seqNumberMap) {
        String documnetNumber = "";
        try {
            documnetNumber = seqNumberMap.containsKey(Constants.AUTO_ENTRYNUMBER) ? (String)seqNumberMap.get(Constants.AUTO_ENTRYNUMBER) : "";
            int seqNumber = 0;
            if(seqNumberMap.containsKey(Constants.SEQNUMBER) && !StringUtil.isNullObject(seqNumberMap.get(Constants.SEQNUMBER)) && !StringUtil.isNullOrEmpty(seqNumberMap.get(Constants.SEQNUMBER).toString())){
               seqNumber= Integer.parseInt(seqNumberMap.get(Constants.SEQNUMBER).toString());
            }
            String datePrefix = seqNumberMap.containsKey(Constants.DATEPREFIX) ? (String)seqNumberMap.get(Constants.DATEPREFIX) : "";
            String dateSuffix = seqNumberMap.containsKey(Constants.DATESUFFIX) ? (String)seqNumberMap.get(Constants.DATESUFFIX) : "";
            String dateafterpreffix = seqNumberMap.containsKey(Constants.DATEAFTERPREFIX) ? (String)seqNumberMap.get(Constants.DATEAFTERPREFIX) : "";
            String sequenceFormatID = seqNumberMap.containsKey(Constants.SEQUENCEFORMATID) ? (String)seqNumberMap.get(Constants.SEQUENCEFORMATID) : "";
            String documentID = seqNumberMap.containsKey(Constants.DOCUMENTID) ? (String)seqNumberMap.get(Constants.DOCUMENTID) : "";
            
            String query = "update Product set productid = ?,seqnumber=?,datePreffixValue=?, dateSuffixValue=?, dateAfterPreffixValue = ? ,seqformat.ID=? where ID=?";
            int numRows = executeUpdate( query, new Object[]{documnetNumber,seqNumber,datePrefix,dateSuffix,dateafterpreffix,sequenceFormatID, documentID});
        } catch (Exception e) {
            System.out.println(e);
        }
        return documnetNumber;
    }
     
     @Override
     public synchronized String updateNAProductEntryNumber(String pid,String entrynumber) {
        try {
            String query = "update Product set productid = ? where ID=?";
            int numRows = executeUpdate( query, new Object[]{entrynumber,pid});
        } catch (Exception e) {
            System.out.println(e);
        }
        return entrynumber;
    }
      public KwlReturnObject getVendors_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "from VendorProductMapping vpm where vpm.products.ID=? ";// and srd.salesReturn.deleted=false ";
        list = executeQuery( q, new Object[]{productid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
 public KwlReturnObject getCustomers_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
         String q = "from CustomerProductMapping vpm where vpm.products.ID=? ";// and srd.salesReturn.deleted=false ";
        list = executeQuery( q, new Object[]{productid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
     public KwlReturnObject isQuantityInStockMovementfor_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "select count(sm.id) as count from StockMovement sm where sm.product.ID=? and sm.company.companyID=?";// and prd.purchaseReturn.deleted=false ";
        list = executeQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
     public KwlReturnObject getBatchesfor_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "select count(prd.id) as count from NewProductBatch prd where prd.product=? and prd.company.companyID=? and prd.quantitydue<>0 ";// and prd.purchaseReturn.deleted=false ";
        list = executeQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
     public KwlReturnObject getSerialsfor_Product(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "select count(prd.id) as count from NewBatchSerial prd where prd.product=? and prd.company.companyID=?";// and prd.purchaseReturn.deleted=false ";
        list = executeQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
// @Override
//    public KwlReturnObject getinvoiceDocuments(HashMap<String, Object> dataMap) throws ServiceException {
//        List list = null;
//        int count = 0;
//        try {
//
//            ArrayList params = new ArrayList();
//
//            params.add((String) dataMap.get(Constants.companyKey));
//
//            String conditionSQL = " where invoicedoccompmap.company=?";
//
//            String invoiceId = (String) dataMap.get("invoiceID");
//            if (!StringUtil.isNullOrEmpty(invoiceId)) {
//                params.add(invoiceId);
//                conditionSQL += " and invoicedoccompmap.invoiceid=?";
//                }
//
//            String mysqlQuery = "select invoicedocuments.docname  as docname,invoicedocuments.doctypeid as doctypeid,invoicedocuments.docid as docid "
//                    + "from invoicedoccompmap inner join invoicedocuments on invoicedoccompmap.documentid=invoicedocuments.id " + conditionSQL;
//
//            list = executeSQLQuery( mysqlQuery, params.toArray());
//            count = list.size();
//        } catch (Exception ex) {
//            throw ServiceException.FAILURE("accCustomerDAOImpl.getinvoiceDocuments:" + ex.getMessage(), ex);
//        }
//        return new KwlReturnObject(true, "", null, list, count);
//    }
    
     public KwlReturnObject getProductCategoryForDetailsReport(String productId) throws ServiceException { //function to check delivery order used in sales return
         List returnlist = new ArrayList();
        ArrayList params = new ArrayList();
        int count = 0;
        try {
            String query = "from ProductCategoryMapping where productID.ID=? ";
            returnlist = executeQuery( query,new Object[]{productId});
            count = returnlist.size();
        } catch (Exception ex) {
           throw ServiceException.FAILURE("accCustomerDAOImpl.getinvoiceDocuments:" + ex.getMessage(), ex);
        }

        return new KwlReturnObject(true, "", null, returnlist, count);
    }
    
    @Override
    public KwlReturnObject getAssetOpeningsEditCount(String documentNumber, String companyId, String assetOpeningId) throws ServiceException {
        try {
            List list = new ArrayList();
            int count = 0;
            String q = "from FixedAssetOpening where documentNumber=? and company.companyID=? and id!=?";
            list = executeQuery( q, new Object[]{documentNumber, companyId, assetOpeningId});
            count = list.size();
            return new KwlReturnObject(true, "", null, list, count);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accProductImpl.getAssetOpeningsEditCount:" + ex.getMessage(), ex);
    }
    }  

    public KwlReturnObject getDepartment(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from Department ";
        return buildNExecuteQuery( query, requestParams);
    }

    public KwlReturnObject getUser(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from User ";
        return buildNExecuteQuery( query, requestParams);
    }

    public KwlReturnObject getRowRackBin(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from StoreMaster ";
        return buildNExecuteQuery( query, requestParams);
    }
    
    public KwlReturnObject deleteOpeningAssetDepreciationDetails(Map<String, Object> requestMap) throws ServiceException {
        String delQuery = "";
        List<String> selectedAssetIdsList=new ArrayList<>();
        if(requestMap.containsKey("selectedAssetIdsList")){
          selectedAssetIdsList = (List<String>)requestMap.get("selectedAssetIdsList");
        }
        if(!selectedAssetIdsList.isEmpty()){
            delQuery = "delete from AssetDepreciationDetail adp where adp.journalEntry.ID is null and adp.assetDetails.id in(:selectedAssetIdsList) and adp.company.companyID = (:companyId)";
        }else{
            requestMap.remove("selectedAssetIdsList");
            delQuery = "delete from AssetDepreciationDetail adp where adp.journalEntry.ID is null and adp.company.companyID = (:companyId)";
        }
        int count = executeUpdateCollectionQuery(delQuery, requestMap);
        return new KwlReturnObject(true, "Opening Asset Depreciation has deleted successfully.", null, null, count);
    }
    
    @Override
    public KwlReturnObject getPeriodicDepreciationOFAssetIds(Map<String, Object> requestMap) throws ServiceException {
        List<AssetDetails> list = new ArrayList<>();
        String hqlQuery = "select adp.assetDetails  from AssetDepreciationDetail adp where adp.journalEntry.ID is not null and adp.assetDetails.id in(:selectedAssetIdsList) and adp.company.companyID = (:companyId) GROUP BY adp.assetDetails.id ";
        list = executeCollectionQuery(hqlQuery, requestMap);
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    public KwlReturnObject resetOpeningDepreciationOfAssets(Map<String, Object> requestMap) throws ServiceException {        
        String hql = "";
        List<String> selectedAssetIdsList=new ArrayList<>();
         if(requestMap.containsKey("selectedAssetIdsList")){
          selectedAssetIdsList = (List<String>)requestMap.get("selectedAssetIdsList");
        }
        if (!selectedAssetIdsList.isEmpty()) {
            hql = "update AssetDetails ad set ad.openingDepreciation=0 where ad.id in(:selectedAssetIdsList) and ad.company.companyID = (:companyId)";
        } else {
            requestMap.remove("selectedAssetIdsList");
            hql = "update AssetDetails ad set ad.openingDepreciation=0 where ad.company.companyID = (:companyId)";
        }
        int numRows = executeUpdateCollectionQuery(hql, requestMap);
        return new KwlReturnObject(true, "Opening Asset Depreciation has reset successfully.", null, null, numRows);
    }

    public String getfieldComboIdFromAssetDetail(String assetId, String column) throws ServiceException {
        String query = "select " + column + " from assetdetailcustomdata where assetDetailsId=?";
        List list = executeSQLQuery( query, new Object[]{assetId});
        String Id = "";
        if (list.size() > 0) {
            if (list.get(0) != null) {
                Id = list.get(0).toString();
            }
        }
        return Id;
    }
    public boolean isOpeningPresentForAsset(String productId, String companyId) throws ServiceException {
        String query = "select id from fixedassetopening where product=? and company=?";
        ArrayList arrayList = new ArrayList();
        arrayList.add(productId);
        arrayList.add(companyId);
        List list = executeSQLQuery( query, arrayList.toArray());
        int number = list.size();
        if (number > 0) {
            return true;
        } else {
            return false;
        }
    }
    public String getDefaultBomId(String productId) throws ServiceException {
        String query = "select id from bomdetail where product=?  and isdefaultbom='T'";
        ArrayList arrayList = new ArrayList();
        arrayList.add(productId);
        List list = executeSQLQuery( query, arrayList.toArray());
        String Id = "";
        if (list.size() > 0) {
            if (list.get(0) != null) {
                Id = list.get(0).toString();
            }
        }
        return Id;
    }
    
    public boolean isProductQuantityFromColumn(String companyid) {
        boolean isProductQuantityFromColumn = false;
        try {
            String query = "select count(id) from extracompanypreferences where id=? and productquantityfromcolumn=?";
            ArrayList arrayList = new ArrayList();
            arrayList.add(companyid);
            arrayList.add('T');
            List list = executeSQLQuery( query, arrayList.toArray());
            int number = list.size();
            if (number > 0) {
                isProductQuantityFromColumn = true;
            } else {
                isProductQuantityFromColumn = false;
            }
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            return isProductQuantityFromColumn;
        }
    }
      @Override
    public KwlReturnObject getChildproducts(HashMap<String, Object> requestParams) throws ServiceException {
         KwlReturnObject result;
         List cntlist=new ArrayList();
        try {
            ArrayList params = new ArrayList();
            String condition = "";
            String parentCompanyProductID = requestParams.containsKey("parentCompanyProductID") ? (String) requestParams.get("parentCompanyProductID") : "";
            
            condition += "  prod.deleted=false ";
            if (!StringUtil.isNullOrEmpty(parentCompanyProductID)) {
                condition += " and prod.propagatedProductID.ID=? ";
                params.add(parentCompanyProductID);
}
            String query = "select prod from Product prod where  " + condition;
            Long totalCount = 0l;
             cntlist = executeQuery( query, params.toArray());
            
            result = new KwlReturnObject(true, null, null, cntlist, cntlist.size());
        } catch (Exception ex) {
           throw ServiceException.FAILURE("accProductImpl.getChildproducts :" + ex.getMessage(), ex);
        }
        return result;
    }
    public KwlReturnObject checkDuplicateProductForEdit(String entryNumber, String companyid, String productid,boolean isFixedAsset) throws ServiceException {
        try {
            List list = new ArrayList();
            int count = 0;
            String q = "select ID from Product where productid=? and asset=? and company.companyID=? and ID!=?";
            list = executeQuery( q, new Object[]{entryNumber, isFixedAsset,companyid, productid});
            count = list.size();
            return new KwlReturnObject(true, "", null, list, count);

        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accProductImpl.checkduplicate:" + ex.getMessage(), ex);
        }
    }
    
    @Override
    public List getRetailStorelistForPOS(String companyID) throws ServiceException {
        try {
            ArrayList params = new ArrayList();
            params.add(companyID);
            String query = "select id,abbrev,description,address from in_storemaster where company=? and type=1 and isActive=1";
            List list = executeSQLQuery(query, params.toArray());
            return list;
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accProductImpl.getRetailStorelistForPOS:" + ex.getMessage(), ex);
        }
    }

    @Override
    public List getProductIDsOfCompanyForPOS(String companyID) throws ServiceException {
        try {
            ArrayList params = new ArrayList();

            params.add(companyID);
            String productQuery = "select id from product where company=?";
            List productList = executeSQLQuery(productQuery, params.toArray());
            return productList;
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accProductImpl.getProductIDsOfCompanyForPOS:" + ex.getMessage(), ex);
        }
    }
    
    @Override
    public List getProductQuantityForPOS(String pid) throws ServiceException {
        try {
            ArrayList params = new ArrayList();
            params.add(pid);
            String query = "select sum((case when carryIn=true then baseuomquantity else -baseuomquantity end)) AS quantity from Inventory where deleted=false and product.ID=? group by product.ID";
            List list = executeQuery(query, params.toArray());
            return list;
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accProductImpl.getProductQuantityForPOS:" + ex.getMessage(), ex);
        }
    }
    
    @Override
    public List<Product> getSyncableProduct(String companyid) throws ServiceException {
        try {
            ArrayList params = new ArrayList();
            params.add(companyid);
            String query = " from Product p where p.deleted=false and p.company.companyID=? and p.syncable='T' order by p.producttype, p.name ";
            List<Product> list = executeQuery(query, params.toArray());
            return list;
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("accProductImpl.getSyncableProduct:" + ex.getMessage(), ex);
        }
    }
    @Override
    public Set getProductIdUsedInTransaction(String[] productIds, boolean unbuild) throws ServiceException {
//        boolean isUsed = false;
//        List params = new ArrayList();
        StringBuilder query = new StringBuilder("SELECT product FROM podetails WHERE product IN ( :prods ) "); // Is used in Purchase Order ?
//        params.add(productIds);
        query.append(" UNION ALL SELECT sod.product FROM sodetails sod INNER JOIN salesorder so ON so.id = sod.salesorder WHERE sod.product IN ( :prods ) AND so.deleteflag=false");// Is used in Sales Order ?
//        params.add(productIds);
        query.append(" UNION ALL SELECT inv.product FROM grdetails grd INNER JOIN inventory inv ON grd.id = inv.id where inv.product IN ( :prods )");// Is Used in Vendor Invoice?
//        params.add(productIds);
        query.append(" UNION ALL SELECT inventory.product FROM invoicedetails invd INNER JOIN invoice inv ON invd.invoice = inv.id INNER JOIN inventory ON invd.id = inventory.id WHERE inventory.product IN ( :prods ) AND inv.deleteflag=false");  // Is used in Customer Invoice?
//        params.add(productIds);
        query.append(" UNION ALL SELECT pa.subproducts FROM productassembly pa INNER JOIN product p ON pa.product = p.id WHERE pa.subproducts IN ( :prods ) and p.deleteflag=false");//Is used in Assembly Product? 
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM grodetails WHERE product IN ( :prods ) ");// Is used in Goods Receipt
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM dodetails WHERE product IN ( :prods ) ");//Is used in Delivery Order?
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM purchaserequisitiondetail WHERE product IN ( :prods ) ");//Is used in Purchase Requisition?
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM purchaserequisitionassetdetail WHERE product IN ( :prods )");//Is used in Purchase Requisition?
//        params.add(productIds);
        query.append(" UNION ALL SELECT prd.product FROM assetdetailspurchaserequisitiondetailmapping aprd INNER JOIN purchaserequisitionassetdetail prd ON prd.id = aprd.purchaserequisitionassetdetails WHERE prd.product IN ( :prods )");//Is used in Purchase Requisition?
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM requestforquotationdetail WHERE product IN ( :prods )"); //Is used in Purchase Requisition?
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM vendorquotationdetails WHERE product IN ( :prods )"); // Is used in Vendor Quotation
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM quotationdetails WHERE product IN ( :prods )"); //Is used in Customer Quotation
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM prdetails WHERE product IN ( :prods )"); //Is used in Purchase Return?
//        params.add(productIds);
        query.append(" UNION ALL SELECT product FROM srdetails WHERE product IN ( :prods )"); //Is used in Sales Return?
//        params.add(productIds);
        query.append(" UNION ALL SELECT vendorproducts FROM vendorproductmapping WHERE vendorproducts IN ( :prods )"); //Is used in Sales Return?
//        params.add(productIds);
        query.append(" UNION ALL SELECT customerproducts FROM customerproductmapping WHERE customerproducts IN ( :prods ) "); //Is used in Sales Return?
        
        query.append(" UNION ALL SELECT fao.product FROM fixedassetopening fao INNER JOIN product p ON fao.product = p.id WHERE fao.product IN ( :prods ) AND p.isasset = 1");
        
        
        if(!unbuild){
            query.append(" UNION ALL SELECT pb.product FROM pbdetails pbd INNER JOIN productbuild pb ON pbd.build = pb.id WHERE pb.product IN ( :prods ) and pbd.isunbuild <> 'T'"); //Is used in Sales Return?
//            params.add(productIds);
            query.append(" UNION ALL SELECT subproducts FROM productassembly WHERE subproducts IN ( :prods )");
//            params.add(productIds);
        }
        
        Map params = new HashMap();
        List productIdList = Arrays.asList(productIds);
        params.put("prods", productIdList);
        
        List list = executeCollectionSqlQuery(query.toString(), params, null);
        Set productSet = new HashSet(list);
        return productSet;
    }

    @Override
    public List getProductListByIds(Set<String> productIds) throws ServiceException {
        StringBuilder query = new StringBuilder("FROM Product WHERE id IN ( :prods ) ");
        Map params = new HashMap();
        params.put("prods", productIds);
        
        List list = executeCollectionQuery(query.toString(), params, null);
        
        return list;
    }
    
    @Override
    public List getProductListByIdsSQL(Set<String> productIds) throws ServiceException {
        StringBuilder query = new StringBuilder("select p.id pid,p.productid,p.name,p.description,p.currency prodcurrency,p.valuationmethod,\n"
                + "if(p.isSerialForProduct = 'F','false','true') isSerialForProduct,if(p.isBatchForProduct = 'F',false,true) isBatchForProduct,\n"
                + "if(p.isrowforproduct = 'F','false','true') isrowforproduct,if(p.israckforproduct = 'F','false','true') israckforproduct,\n"
                + "if(p.isbinforproduct = 'F','false','true') isbinforproduct,\n"
                + "p.company,c.subdomain,c.currency compcurrency,pt.id producttypeid,pt.name producttypename,uom.name uom,uom.id uomid\n"
                + "FROM product p\n"
                + "inner join company c on c.companyid =  p.company\n"
                + "inner join producttype pt on pt.id = p.producttype\n"
                + "inner join uom uom on uom.id = p.unitOfMeasure\n"
                + "WHERE p.id IN ( :prods ) ");
        Map params = new HashMap();
        params.put("prods", productIds);

        List list = executeCollectionSqlQuery(query.toString(), params, null);

        return list;
    }
    @Override
    public List getProductCodesListByIds(Set<String> productIds) throws ServiceException {
        StringBuilder query = new StringBuilder("SELECT productid FROM Product WHERE id IN ( :prods ) ");
        Map params = new HashMap();
        params.put("prods", productIds);
        
        List list = executeCollectionQuery(query.toString(), params, null);
        
        return list;
    }
    @Override
    public KwlReturnObject getProductCategoryDetails(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from ProductCategoryMapping";
        return buildNExecuteQuery(query, requestParams);
    }

    public KwlReturnObject getProductPriceReportCustVen(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        try {
            String query = "from PriceList";
            String productid = (String) request.get("productid");
            String companyid = (String) request.get("companyid");
            boolean carryin = (Boolean) request.get("carryin");
            boolean productPriceinMultipleCurrency = (Boolean) request.get("productPriceinMultipleCurrency");
            String vendorid = (String) request.get("vendorid");

            String condition = " where company.companyID=? ";//SDP-175


            condition += carryin ? " and carryIn=true " : " and carryIn=false ";
            if (!productPriceinMultipleCurrency) {
                condition += " and currency='" + request.get(Constants.globalCurrencyKey) + "' ";
            }
            ArrayList params = new ArrayList();
            params.add(companyid);
            if (!StringUtil.isNullOrEmpty(productid) && !productid.equalsIgnoreCase("All")) {
                productid = AccountingManager.getFilterInString(productid);
                condition += " and product.ID in " + productid + "";
            }
            if (StringUtil.isNullOrEmpty(vendorid) == false) {
                vendorid = AccountingManager.getFilterInString(vendorid);
                condition += " and affecteduser in " + vendorid + "";
            }
            
            condition += " order by product.ID ASC,applyDate desc";
            query += condition;
            list = executeQuery(query, params.toArray());
            count = list.size();

        } catch (Exception e) {
            throw ServiceException.FAILURE("getPrice : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, count);
    }

    public KwlReturnObject getPriceBandListReportCustVen(HashMap<String, Object> request) throws ServiceException {
        List list = new ArrayList();
        int count = 0;
        try {
            String productid = (String) request.get("productid");
            String vendorid = (String) request.get("vendorid");
            boolean carryin = (Boolean) request.get("carryin");
            String query = " SELECT pbmd.id as priceband ,pbmd.product,pbmd.purchaseprice,pbmd.salesprice,pbmd.applicabledate,pbmd.pricingbandmaster,pbmd.currency,v.id FROM pricingbandmasterdetails pbmd INNER JOIN vendor v on v.pricingbandmaster=pbmd.pricingbandmaster";
            String companyid = (String) request.get("companyid");
            ArrayList params = new ArrayList();
            String condition = " where pbmd.company = ? ";//SDP-175
            params.add(companyid);
            if (!StringUtil.isNullOrEmpty(productid) && !productid.equalsIgnoreCase("All")) {
                productid = AccountingManager.getFilterInString(productid);
                condition += " and pbmd.product in " + productid + "";
            }
            if (StringUtil.isNullOrEmpty(vendorid) == false) {
                vendorid = AccountingManager.getFilterInString(vendorid);
                condition += " and v.id in  " + vendorid + "";
            }
            condition += carryin ? " and pbmd.purchaseprice <> 0 " : " and pbmd.salesprice <> 0 ";
            condition += " order by pbmd.product ASC , v.name ASC ,pbmd.applicabledate desc";
            query += condition;

            list = executeSQLQuery(query, params.toArray());
            count = list.size();
        } catch (Exception e) {
            throw ServiceException.FAILURE("getPrice : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, count);
    }
    
    @Override
    public KwlReturnObject getSpecialRateofProduct(String productid, boolean isPurchase, Date transactionDate, String affectedUser, String forCurrency) throws ServiceException {
        List returnList = new ArrayList();
        try {
            Product product = (Product) get(Product.class, productid);
            Company cmp = product != null ? product.getCompany() : null;

            String condition = "";
            String conditionSubquery = "";
            String stockUOMId = "";
            ArrayList params = new ArrayList();
            ArrayList paramsSubquery = new ArrayList();
            params.add(productid);
            params.add(isPurchase);

            if (transactionDate != null) {
                paramsSubquery.add(transactionDate);
                conditionSubquery += " and applyDate<=? ";
            }
            
            if (StringUtil.isNullOrEmpty(forCurrency)) {
                if (cmp != null) {
                    forCurrency = cmp.getCurrency().getCurrencyID();
                }
            }
            condition += " and pl1.currency.currencyID = ? ";
            conditionSubquery += " and currency.currencyID = ? ";
            params.add(forCurrency);
            paramsSubquery.add(forCurrency);

            condition += " and pl1.affecteduser = ? ";
            conditionSubquery += " and affecteduser = ? ";
            params.add(affectedUser);
            paramsSubquery.add(affectedUser);
            
            if (product.getUnitOfMeasure() != null) {
                stockUOMId = product.getUnitOfMeasure().getID();
            }
            condition += Constants.PRICELIST_UOM_CONDITION;
            params.add(stockUOMId);
            conditionSubquery += Constants.PRICELIST_UOM_INNER_CONDITION;
            
            params.addAll(paramsSubquery);

            String query = "select pl1.price from PriceList pl1 where product.ID=? and carryIn=? " + condition + " and applyDate = (select max(applyDate) as ld from PriceList where product.ID=pl1.product.ID and carryIn=pl1.carryIn " + conditionSubquery + " group by product)";      //ERM-389 / ERP-35140

            List list = executeQuery(query, params.toArray());
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add((Double) itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSpecialRateofProduct : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    /**
     * 
     * @param productid = get details for product
     * @param companyid
     * @return = Return Stock Adjustment for product
     * @throws ServiceException 
     */
    public KwlReturnObject getStockAdjustment_Product(Map<String, Object> requestMap) throws ServiceException {
        ArrayList params = new ArrayList();
        String condition = "";
        String productId = "";
        String companyId = "";
        DateFormat df = null;
        String startdate = "";
        String enddate = "";
        
        params.add(false);
        if (requestMap.containsKey("productId")) {
            productId = requestMap.get("productId").toString();
            params.add(productId);
        }
        if (requestMap.containsKey("companyId")) {
            companyId = requestMap.get("companyId").toString();
            params.add(companyId);
        }
        if (requestMap.containsKey("df")) {
            try {
                df = (DateFormat) requestMap.get("df");
                if (requestMap.containsKey("startdate")) {
                    startdate = requestMap.get("startdate").toString();
                }
                if (requestMap.containsKey("enddate")) {
                    enddate = requestMap.get("enddate").toString();
                }
                condition += " and (grod.businessDate >=? and grod.businessDate <=?)";
                params.add(df.parse(startdate));
                params.add(df.parse(enddate));
            } catch (ParseException ex) {
                Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        List list = new ArrayList();
        String q = "from StockAdjustment grod where grod.isdeleted=? and grod.product.ID=? and grod.company.companyID=?"+condition;// and grod.grOrder.deleted=false ";
        list = executeQuery(q, params.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }
  
    @Override
    public KwlReturnObject deletePriceList(HashMap<String, Object> requestParams) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(requestParams.get("priceListID"));
        params.add(requestParams.get("companyID"));

        String delQuery = "delete  from PriceList where ID = ? and company.companyID = ? ";
        int numRows = executeUpdate(delQuery, params.toArray());

        return new KwlReturnObject(true, "Price List entry has been deleted successfully.", null, null, numRows);
    }
    
    @Override
    public double getValuationPrice(String productId, int transactionType, ValuationMethod valuationMethod, double baseUomQuantity, double priceInTransUom, double baseUomRate, boolean isOpening, List<TransactionBatch> pvbList) throws ServiceException {
        int originalListSize = pvbList.size();
        double totalAmount = 0;
        double quantity = baseUomQuantity;
        List<TransactionBatch> tempList = new ArrayList();
        if (transactionType == 0 || transactionType == 1 || transactionType == 4 || transactionType == 7) {
            if (transactionType == 4) {                                                                                                                                                                                                                                  // Sales Return
                if(valuationMethod == ValuationMethod.STANDARD){ //LIFO
                    Collections.sort(pvbList, new PVBSorter.sortDESC()); // for Lifo consider sales return from last batch no. 
                }else{
                    Collections.sort(pvbList, new PVBSorter.sortASC());  // for Fifo or Average consider sales return from first batch no. 
                }
                
                for(TransactionBatch pvb : pvbList){ 
                    if(!pvb.isOutEntry() || pvb.getQuantity() == 0 || pvb.getRemovedQty()>=pvb.getQuantity()){ 
                        continue;
                    }
                    if(quantity > 0){
                        double retQty = 0;
                        if(quantity >= pvb.getQuantity()-pvb.getRemovedQty()){
                            retQty = pvb.getQuantity()-pvb.getRemovedQty();
                        }else{
                            retQty = quantity;
                        }
                        quantity -= retQty;
                        
                        TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), retQty, isOpening, tempList.size()+originalListSize,"","");
                        tempList.add(pbvTemp);
                        
                        totalAmount += pvb.getPrice() * retQty;
                    }else{
                        break;
                    }
                }
                for(TransactionBatch pvbTemp : tempList){ // breaking quantity by batch for given base uom quantity.
                    double qty = pvbTemp.getQuantity();
                    if(pvbTemp.getQuantity() == 0){ // considering batch which removed quantity. Because adding quantity from previously removed quantity.
                        continue;
                    }
                    if(qty > 0){
                        for (TransactionBatch pvbMain : pvbList) {
                            double availQty = pvbMain.getQuantity() - pvbMain.getRemovedQty();
                            if(!pvbMain.isOutEntry() || availQty <= 0){
                                continue;
                            }
                            double retQty = 0;
                            if (qty >= availQty) {
                                retQty = availQty;
                            } else {
                                retQty = quantity;
                            }
                            qty -= retQty;
                            pvbMain.setRemovedQty(pvbMain.getRemovedQty() + retQty);
                            
                            if(qty <= 0){
                                break;
                            }
                        }
                    }
                }
                if((quantity > 0 && valuationMethod != ValuationMethod.AVERAGE) || (totalAmount == 0 && valuationMethod == ValuationMethod.AVERAGE)){ // if base uom quntity is more than DO quantity or for average valuation if total amount is zero then use product purchase price 
                    KwlReturnObject purchase = getProductPrice(productId, true, null, "", "");
//                    if (purchase.getEntityList().get(0) != null) {
                        double price = purchase.getEntityList().get(0) != null ?(Double) purchase.getEntityList().get(0) : 0;
                        if (valuationMethod == ValuationMethod.AVERAGE) {
                            TransactionBatch pbvTemp = new TransactionBatch(price, baseUomQuantity, isOpening, tempList.size()+originalListSize,"","");
                            tempList.add(pbvTemp);
                            totalAmount += price * baseUomQuantity;
                        } else {
                            TransactionBatch pbvTemp = new TransactionBatch(price, quantity, isOpening, tempList.size()+originalListSize,"","");
                            tempList.add(pbvTemp);
                            totalAmount += price * quantity;
                        }
//                    }
                } else if(quantity > 0 && valuationMethod == ValuationMethod.AVERAGE){ // if base uom qty is more than DO quantity for average valuation then remaining quantity should be as same average price 
                    double price = totalAmount/(baseUomQuantity - quantity);
                    TransactionBatch pbvTemp = new TransactionBatch(price, quantity, isOpening, tempList.size() + originalListSize,"","");
                    tempList.add(pbvTemp);
                    totalAmount += quantity * price;
                }

            } else {
                double priceInBaseUom = priceInTransUom / baseUomRate; // Before creating batch need to convert price in base uom
                double price = priceInBaseUom;
                if (valuationMethod == ValuationMethod.AVERAGE) { // for average valuation set average price in existing batches if price is not matches with existing.
                    if (!pvbList.isEmpty() && pvbList.get(0).getPrice() != price) {
                        double tQty = quantity;
                        double tAmount = quantity * priceInBaseUom;
                        for (TransactionBatch pvb : pvbList) {
                            if (pvb.isOutEntry()) {
                                tQty -= pvb.getQuantity();
                                tAmount -= pvb.getQuantity() * pvb.getPrice();
                            } else {
                                tQty += pvb.getQuantity();
                                tAmount += pvb.getQuantity() * pvb.getPrice();
                            }
                        }
                        if (tQty != 0) {
                            price = tAmount / tQty;
                        }
                        for (TransactionBatch pvb : pvbList) {
                            pvb.setPrice(price);
                        }
                    }
                }
                TransactionBatch pvb = new TransactionBatch(price, quantity, isOpening, originalListSize,"","");
                pvbList.add(pvb);

                totalAmount = priceInBaseUom * quantity; // returning current added price.
            }
         } else if (transactionType == 2 || transactionType == 3 || transactionType == 5 || transactionType == 8) {

            if (valuationMethod == ValuationMethod.STANDARD) { // for Lifo consider sales return from last batch no. 
                Collections.sort(pvbList, new PVBSorter.sortDESC());
            } else {
                Collections.sort(pvbList, new PVBSorter.sortASC()); // for Fifo consider sales return from first batch no. 
            }
            for (TransactionBatch pvb : pvbList) { // breaking quantity by batch for given base uom quantity.
                if (pvb.isOutEntry() || pvb.getQuantity() == 0) { // considering batch which has IN quantity. Because for DO or out transaction remove quantity from IN quantity
                    continue;
                }
                if (quantity > 0) {
                    double outQty = 0;
                    if (quantity >= (pvb.getQuantity() - pvb.getRemovedQty())) {
                        outQty = (pvb.getQuantity() - pvb.getRemovedQty());
                    } else {
                        outQty = quantity;
                    }
                    quantity -= outQty;
                    pvb.setRemovedQty(pvb.getRemovedQty() + outQty);
                    TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), outQty, isOpening, tempList.size()+originalListSize,"","");
                    pbvTemp.setOutEntry(true);
                    tempList.add(pbvTemp);
                    
                    totalAmount += pvb.getPrice() * outQty;
                } else {
                    break;
                }
            }
            if ((quantity > 0 && valuationMethod != ValuationMethod.AVERAGE) || (totalAmount == 0 && valuationMethod == ValuationMethod.AVERAGE)) {// if base uom quntity is more than DO quantity or for average valuation if total amount is zero then use product purchase price 
                KwlReturnObject purchase = getProductPrice(productId, true, null, "", "");
//                if (purchase.getEntityList().get(0) != null) {
                    double price = purchase.getEntityList().get(0) != null ? (Double) purchase.getEntityList().get(0) : 0;
                    if(valuationMethod == ValuationMethod.AVERAGE){
                        TransactionBatch pbvTemp = new TransactionBatch(price, baseUomQuantity, isOpening, tempList.size()+originalListSize,"","");
                        pbvTemp.setOutEntry(true);
                        tempList.add(pbvTemp);
                        totalAmount += price * baseUomQuantity;
                    }else{
                        TransactionBatch pbvTemp = new TransactionBatch(price, quantity, isOpening, tempList.size()+originalListSize,"","");
                        pbvTemp.setOutEntry(true);
                        tempList.add(pbvTemp);
                        totalAmount += price * quantity;
                    }
                    
//                }
            } else if (quantity > 0 && valuationMethod == ValuationMethod.AVERAGE) { // if base uom qty is more than batch quantity for average valuation then remaining quantity should be as same average price 
                double price = totalAmount / (baseUomQuantity - quantity);
                TransactionBatch pbvTemp = new TransactionBatch(price, quantity, isOpening, tempList.size() + originalListSize,"","");
                pbvTemp.setOutEntry(true);
                tempList.add(pbvTemp);
                totalAmount += quantity * price;
            }
        }
        if(!tempList.isEmpty()){
            pvbList.addAll(tempList);
        }
        return baseUomQuantity != 0 ? totalAmount/baseUomQuantity : 0;
    }
    
    @Override
    public double getValuationPriceForSerialBatches(String productId, int transactionType, ValuationMethod valuationMethod, double baseUomQuantity, double priceInTransUom, double baseUomRate, boolean isOpening, List<TransactionBatch> pvbList, boolean isForSerials, String[] batchSerialId) throws ServiceException {
        int originalListSize = pvbList.size();
        double totalAmount = 0;
        double quantity = baseUomQuantity;
        List<TransactionBatch> tempList = new ArrayList();
        if (isForSerials) {                                                                                             // For Products having serials activated.
            if (transactionType == 4) {
                for (int i = 0; i <= batchSerialId.length - 1; i++) {
                    for (TransactionBatch pvb : pvbList) {
                        if (!pvb.isOutEntry() || pvb.getQuantity() == 0 || !pvb.getSerialId().equals(batchSerialId[i])) {
                            continue;
                        }
                        if (quantity > 0 && pvb.getSerialId().equals(batchSerialId[i])) {
                            double retQty = 0;
                            if (quantity >= pvb.getQuantity()) {
                                retQty = 1;
                            }
                            quantity -= retQty;

                            TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), retQty, isOpening, tempList.size() + originalListSize, "", batchSerialId[i]);
                            tempList.add(pbvTemp);

                            totalAmount += pvb.getPrice() * retQty;
                        } else {
                            break;
                        }
                    }
                }
                for (TransactionBatch pvbTemp : tempList) { // breaking quantity by batch for given base uom quantity.
                    double qty = pvbTemp.getQuantity();
                    if (pvbTemp.getQuantity() == 0) { // considering batch which removed quantity. Because adding quantity from previously removed quantity.
                        continue;
                    }
                    for (int i = 0; i <= batchSerialId.length - 1; i++) {
                        if (qty > 0 && pvbTemp.getSerialId().toString().equals(batchSerialId[i])) {
                            for (TransactionBatch pvbMain : pvbList) {
                                double availQty = pvbMain.getQuantity() - pvbMain.getRemovedQty();
                                if (pvbMain.isOutEntry() || availQty <= 0 || !pvbMain.getSerialId().equals(pvbTemp.getSerialId())) {
                                    continue;
                                }
                                double retQty = 0;
                                if (qty >= availQty) {
                                    retQty = 1;
                                } 
                                qty -= retQty;
                                pvbMain.setRemovedQty(pvbMain.getRemovedQty() - retQty);

                                if (qty <= 0) {
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            else if (transactionType == 0 || transactionType == 1 || transactionType == 7) {
                for (int i = 0; i <= batchSerialId.length - 1; i++) {
                    double priceInBaseUom = priceInTransUom / baseUomRate; // Before creating batch need to convert price in base uom
                    double price = priceInBaseUom;
                    TransactionBatch pvb = new TransactionBatch(price, 1, isOpening, originalListSize, "", batchSerialId[i]);
                    pvbList.add(pvb);
                    totalAmount = priceInBaseUom * quantity; // returning current added price.
                }
            } else if (transactionType == 2 || transactionType == 3 || transactionType == 5 || transactionType == 8) {
                for (TransactionBatch pvb : pvbList) {
                    if (pvb.isOutEntry() || pvb.getQuantity() == 0) { // considering batch which has IN quantity. Because for DO or out transaction remove quantity from IN quantity
                        continue;
                    }
                    for (int i = 0; i <= batchSerialId.length - 1; i++) {
                        if (quantity > 0 && pvb.getSerialId().equals(batchSerialId[i])) {
                            double outQty = 0;
                            if (quantity >= (pvb.getQuantity() - pvb.getRemovedQty())) {
                                outQty = (pvb.getQuantity() - 1);
                            }
                            quantity--;
                            outQty = 1;
                            pvb.setRemovedQty(outQty);
                            TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), outQty, isOpening, tempList.size() + originalListSize, "", batchSerialId[i]);
                            pbvTemp.setOutEntry(true);
                            tempList.add(pbvTemp);

                            totalAmount += pvb.getPrice() * outQty;
                        }
                    }
                }
            }
        } else {                                                                                                            //For products having serials activated
            if (transactionType == 4) {
                if (valuationMethod == ValuationMethod.STANDARD) { // for Lifo consider sales return from last batch no. 
                    Collections.sort(pvbList, new PVBSorter.sortDESC());
                } else {
                    Collections.sort(pvbList, new PVBSorter.sortASC()); // for Fifo consider sales return from first batch no. 
                }
                for (int i = 0; i <= batchSerialId.length - 1; i++) {
                    for (TransactionBatch pvb : pvbList) {
                        if (!pvb.isOutEntry() || pvb.getQuantity() == 0 || !pvb.getBatchId().equals(batchSerialId[i])) {
                            continue;
                        }
                        if (quantity > 0 && pvb.getBatchId().equals(batchSerialId[i])) {
                            double retQty = 0;
                            if (quantity >= pvb.getQuantity()) {
                                retQty = pvb.getQuantity();
                            } else {
                                retQty = quantity;
                            }
                            quantity -= retQty;

                            TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), retQty, isOpening, tempList.size() + originalListSize, batchSerialId[i], "");
                            tempList.add(pbvTemp);

                            totalAmount += pvb.getPrice() * retQty;
                        } else {
                            break;
                        }
                    }
                }
                for (TransactionBatch pvbTemp : tempList) { // breaking quantity by batch for given base uom quantity.
                    double qty = pvbTemp.getQuantity();
                    if (pvbTemp.getQuantity() == 0) { // considering batch which removed quantity. Because adding quantity from previously removed quantity.
                        continue;
                    }
                    for (int i = 0; i <= batchSerialId.length - 1; i++) {
                        if (qty > 0 && pvbTemp.getBatchId().toString().equals(batchSerialId[i])) {
                            for (TransactionBatch pvbMain : pvbList) {
                                double availQty = pvbMain.getQuantity() - pvbMain.getRemovedQty();
                                if (pvbMain.isOutEntry() || availQty <= 0) {
                                    continue;
                                }
                                double retQty = 0;
                                if (qty >= availQty) {
                                    retQty = availQty;
                                } else {
                                    retQty = quantity;
                                }
                                qty -= retQty;
                                pvbMain.setRemovedQty(pvbMain.getRemovedQty() - retQty);

                                if (qty <= 0) {
                                    break;
                                }
                            }
                        }
                    }
                }
                
            }else if (transactionType == 0 || transactionType == 1 || transactionType == 7) {
                for (int i = 0; i <= batchSerialId.length - 1; i++) {
                    double priceInBaseUom = priceInTransUom; // Before creating batch need to convert price in base uom
                    double price = priceInBaseUom;
                    TransactionBatch pvb = new TransactionBatch(price, baseUomQuantity, isOpening, originalListSize, batchSerialId[i],"");
                    pvbList.add(pvb);
                    totalAmount = priceInBaseUom * quantity; // returning current added price.
                }
            } else if (transactionType == 2 || transactionType == 3 || transactionType == 5 || transactionType == 8) {
                if (valuationMethod == ValuationMethod.STANDARD) { // for Lifo consider sales return from last batch no. 
                    Collections.sort(pvbList, new PVBSorter.sortDESC());
                } else {
                    Collections.sort(pvbList, new PVBSorter.sortASC()); // for Fifo consider sales return from first batch no. 
                }
                for (TransactionBatch pvb : pvbList) {
                    if (pvb.isOutEntry() || pvb.getQuantity() == 0) { // considering batch which has IN quantity. Because for DO or out transaction remove quantity from IN quantity
                        continue;
                    }
                    for (int i = 0; i <= batchSerialId.length - 1; i++) {
                        if (quantity > 0 && pvb.getBatchId().equals(batchSerialId[i])) {
                            double outQty = 0;
                            if (quantity >= (pvb.getQuantity() - pvb.getRemovedQty())) {
                                outQty = (pvb.getQuantity() - pvb.getRemovedQty());
                            }else{
                                outQty = quantity;
                            }
                            quantity -= outQty;
                            pvb.setRemovedQty(pvb.getRemovedQty() + outQty);
                            TransactionBatch pbvTemp = new TransactionBatch(pvb.getPrice(), outQty, isOpening, tempList.size() + originalListSize, batchSerialId[i],"");
                            pbvTemp.setOutEntry(true);
                            tempList.add(pbvTemp);
                            totalAmount += pvb.getPrice() * outQty;
                        }
                    }
                }
                
                if (quantity > 0) {
                    
                }
            }
        }
        if (!tempList.isEmpty()) {
            pvbList.addAll(tempList);
        }
        return baseUomQuantity != 0 ? totalAmount / baseUomQuantity : 0;
    }
    
    @Override
    public KwlReturnObject getSADetailByStockAdjustment(String stockAdjustmentId) throws ServiceException {
        List returnList = new ArrayList();
        String query = " select id,stockadjustment,location,batchname,finalquantity,finalserialnames from in_sa_detail where stockadjustment=? ";
        returnList = executeSQLQuery(query, stockAdjustmentId);
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    
    @Override
    public KwlReturnObject getInventoryTransactions(String productId,String companyid) throws ServiceException {
        List returnList = new ArrayList();
        String query = " SELECT product FROM in_stockmovement WHERE transaction_type IN (1,2) AND transaction_module <> 10 AND product=? and company=? ";
        returnList = executeSQLQuery(query, new Object[]{productId, companyid});
        int count = returnList.size();
        return new KwlReturnObject(true, "", null, returnList, count);
    }
    
    @Override
    public KwlReturnObject getSubstituteProduct(String productid, String companyid) throws ServiceException {
        String q = "from Product where substituteProduct.ID=? and company.companyID=? ";
        List list = executeQuery(q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    @Override
    public KwlReturnObject getProductTermDetails(Map<String, Object> mapData) throws ServiceException {
        List<Object> listData = new ArrayList<Object>();
        String productid = "", condtion = "";
        boolean salesOrPurchase = false;
        boolean isAdditional = false;
        boolean isDefault = false;
        if (mapData.containsKey("productid")) {
            
            condtion += " where product.ID = ? ";
            productid = mapData.get("productid").toString();
            listData.add(productid);

        }
        
        if (mapData.containsKey("isAdditional")) {            
            if (condtion.trim().length() > 1) {
                condtion += " and term.isAdditionalTax= ? ";
            }
            isAdditional = Boolean.parseBoolean(mapData.get("isAdditional").toString());
            listData.add(isAdditional);
        }
        
        if (mapData.containsKey("salesOrPurchase")) {            
            
            if (condtion.trim().length() > 1) {
                condtion += " and term.salesOrPurchase= ? ";
            }
            salesOrPurchase = Boolean.parseBoolean(mapData.get("salesOrPurchase").toString());
            listData.add(salesOrPurchase);

        }
        if (mapData.containsKey("isDefault")) {
            
            if (condtion.trim().length() > 1) {
                condtion += " and isDefault= ? ";
            }
            isDefault = Boolean.parseBoolean(mapData.get("isDefault").toString());
            listData.add(isDefault);

        }
        condtion += " order by term.termSequence ASC ";
        String q = "from ProductTermsMap" + condtion;
        List list = executeQuery(q, listData.toArray());
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject saveProductTermsMap(HashMap<String, Object> productTermsMap) throws ServiceException {
        List list = new ArrayList();
        ProductTermsMap productTermsMapObj = new ProductTermsMap();
            if (productTermsMap.containsKey("id")) {
                productTermsMapObj = (ProductTermsMap) get(ProductTermsMap.class, (String) productTermsMap.get("id"));
                if(productTermsMapObj == null){
                    productTermsMapObj = new ProductTermsMap();
                }
            }
            
            if (productTermsMap.containsKey("term") && productTermsMap.get("term")!=null) {
                productTermsMapObj.setTerm((LineLevelTerms) productTermsMap.get("term"));
            }
            if (productTermsMap.containsKey("percentage") && productTermsMap.get("percentage")!=null) {
                productTermsMapObj.setPercentage(Double.parseDouble(productTermsMap.get("percentage").toString()));
            }
            if (productTermsMap.containsKey("isDefault")) {
                productTermsMapObj.setIsDefault(Boolean.parseBoolean(productTermsMap.get("isDefault").toString()));
            }
            if (productTermsMap.containsKey("account") && productTermsMap.get("account")!=null) {
                productTermsMapObj.setAccount((Account) productTermsMap.get("account"));
            }
            if (productTermsMap.containsKey("creator") && productTermsMap.get("creator")!=null) {
                productTermsMapObj.setCreator((User) productTermsMap.get("creator"));
            }
            if (productTermsMap.containsKey("createdOn") && productTermsMap.get("createdOn")!=null && !StringUtil.isNullOrEmpty(productTermsMap.get("createdOn").toString())) {
                productTermsMapObj.setCreatedOn((Date) productTermsMap.get("createdOn"));
            }   
            if (productTermsMap.containsKey("product") && productTermsMap.get("product")!=null) {
                productTermsMapObj.setProduct((Product) productTermsMap.get("product"));
            }
            if (productTermsMap.containsKey("purchasevalueorsalevalue")) {
                productTermsMapObj.setPurchaseValueOrSaleValue(Double.parseDouble(productTermsMap.get("purchasevalueorsalevalue").toString()));
            }
            if (productTermsMap.containsKey("deductionorabatementpercent")) {
                productTermsMapObj.setDeductionOrAbatementPercent(Double.parseDouble(productTermsMap.get("deductionorabatementpercent").toString()));
            }
            if (productTermsMap.containsKey("termamount")) {
                productTermsMapObj.setTermAmount(Double.parseDouble(productTermsMap.get("termamount").toString()));
            }
            if (productTermsMap.containsKey("taxtype")) {
                productTermsMapObj.setTaxType(Integer.parseInt(productTermsMap.get("taxtype").toString()));
            }
            if (productTermsMap.containsKey("formType")) {
                productTermsMapObj.setFormType(productTermsMap.get("formType").toString());
            }
        saveOrUpdate(productTermsMapObj);
        list.add(productTermsMapObj);
        return new KwlReturnObject(true, "Product term mapped successfully!!", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject saveQualityControlData(Map<String, Object> map) throws ServiceException {
        List list = new ArrayList();
        try {
            QualityControl qualityControl = new QualityControl();
            
            if (map.containsKey("qcbomcodeid") && map.get("qcbomcodeid") != null) {
                BOMDetail bomDetail = (BOMDetail) get(BOMDetail.class, (String) map.get("qcbomcodeid"));
                qualityControl.setBom(bomDetail);
            }
            if (map.containsKey("qcgroupid") && map.get("qcgroupid") != null) {
                MasterItem masterItem = (MasterItem) get(MasterItem.class, (String) map.get("qcgroupid"));
                qualityControl.setQcgroup(masterItem);
            }
            if (map.containsKey("qcuom") && map.get("qcuom") != null) {
                UnitOfMeasure qcuom = (UnitOfMeasure) get(UnitOfMeasure.class, (String) map.get("qcuom"));
                qualityControl.setQcuom(qcuom);
            }
            if (map.containsKey("qcparameterid") && map.get("qcparameterid") != null) {
                MasterItem masterItem = (MasterItem) get(MasterItem.class, (String) map.get("qcparameterid"));
                qualityControl.setQcparameter(masterItem);
            }
            if (map.containsKey("qcvalue") && map.get("qcvalue") != null) {
                qualityControl.setQcvalue(Integer.parseInt(map.get("qcvalue").toString()));
            }
            if (map.containsKey("qcdescription") && map.get("qcdescription") != null) {
                qualityControl.setQcdescription(map.get("qcdescription").toString());
            }
            if (map.containsKey("productid") && map.get("productid") != null) {
                Product product = (Product) get(Product.class, (String) map.get("productid"));
                qualityControl.setProduct(product);
            }
            if (map.containsKey("companyid") && map.get("companyid") != null) {
                Company company = (Company) get(Company.class, (String) map.get("companyid"));
                qualityControl.setCompany(company);
            }

            save(qualityControl);
            list.add(qualityControl);
        } catch (NumberFormatException | ServiceException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    @Override
    public KwlReturnObject deleteQualityControlData(String productid) throws ServiceException {
        int numRows = 0;
        try {
            String delQuery = "delete from QualityControl where product.ID = ?";
            numRows = executeUpdate(delQuery, new Object[]{productid});
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    
    public KwlReturnObject getQualityControlData(Map<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        List params = new ArrayList();
        try {
            String productid = "";
            if(requestParams.containsKey("productid") && requestParams.get("productid")!=null){
                productid = requestParams.get("productid").toString();
            }
            params.add(productid);
            
            String query = "from QualityControl where product.ID=?";
            returnList = executeQuery(query, params.toArray());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    // Save BOMDetail for the product
    @Override
    public KwlReturnObject saveBOMDetail(Map<String, Object> bomMap) throws ServiceException {
        List list = new ArrayList();
        try {
            BOMDetail bomdetail = new BOMDetail();
            if (bomMap.containsKey("id")) {
                bomdetail = bomMap.get("id") == null ? null : (BOMDetail) get(BOMDetail.class, (String) bomMap.get("id"));
            }
            if (bomMap.containsKey("productid")) {
                Product pproduct = bomMap.get("productid") == null ? null : (Product) get(Product.class, (String) bomMap.get("productid"));
                bomdetail.setProduct(pproduct);
            }
            boolean assigndefaultbomcode = false;
            if (bomMap.containsKey("assigndefaultbomcode") && bomMap.get("assigndefaultbomcode") != null) {
                assigndefaultbomcode = Boolean.parseBoolean(bomMap.get("assigndefaultbomcode").toString());
            }
            if (!assigndefaultbomcode) { // mrp flow activated
                if (bomMap.containsKey("bomCode") && bomMap.get("bomCode") != null) {
                    bomdetail.setBomCode(bomMap.get("bomCode").toString());
                }
                if (bomMap.containsKey("bomName") && bomMap.get("bomName") != null) {
                    bomdetail.setBomName(bomMap.get("bomName").toString());
                }
                if (bomMap.containsKey("isdefaultbom") && bomMap.get("isdefaultbom") != null) {
                    bomdetail.setIsDefaultBOM(Boolean.parseBoolean(bomMap.get("isdefaultbom").toString()));
                }
            } else { // mrp flow not activated
                bomdetail.setBomCode("Default BOM");
                bomdetail.setBomName("Default BOM");
                bomdetail.setIsDefaultBOM(true);
            }
            save(bomdetail);
            list.add(bomdetail);
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    //BOM Detail
    public KwlReturnObject deleteBOMDetail(String productid) throws ServiceException {
        int numRows = 0;
        try {
            String delQuery = "delete from BOMDetail where product.ID = ?";
            numRows = executeUpdate(delQuery, new Object[]{productid});
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    @Override
    public KwlReturnObject deleteBOMDetailById(String bomid) throws ServiceException {
        int numRows = 0;
        String delQuery = "delete from BOMDetail where ID = ?";
        numRows = executeUpdate(delQuery, new Object[]{bomid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    @Override
    public KwlReturnObject deleteProductAssemblyByBOMDetailId(String bomid) throws ServiceException {
        int numRows = 0;
        String delQuery = "delete from ProductAssembly where bomdetail.ID = ?";
        numRows = executeUpdate(delQuery, new Object[]{bomid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    @Override
    public KwlReturnObject getBOMids(String productid) throws ServiceException {
        List numRows = null;
        try {
            String query = "select ID from BOMDetail where product.ID = ?";
             numRows = executeQuery(query, new Object[]{productid});
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, numRows, numRows.size());
    }

    public KwlReturnObject getBOMDetail(Map<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        try {
            String productid = (String) requestParams.get("productid");
            String query = "from BOMDetail where product.ID=?";
            List params = new ArrayList();
            params.add(productid);
            if (requestParams.containsKey("isdefaultbom")) {
                boolean isdefaultbom = (Boolean) requestParams.get("isdefaultbom");
                if (isdefaultbom) {
                    query += " and isDefaultBOM=?";
                    params.add(isdefaultbom);
                }
            }
            if (requestParams.containsKey("bomid") && requestParams.get("bomid") != null) {
                query += (query.indexOf("where") != -1) ? " and ID=?" : " ID=?";
                params.add(requestParams.get("bomid").toString());
            }
            if (requestParams.containsKey("bomCode") && requestParams.get("bomCode") != null) {
                query += (query.indexOf("where") != -1) ? " and bomCode=?" : " bomCode=?";
                params.add(requestParams.get("bomCode").toString());
            }
            returnList = executeQuery(query, params.toArray());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    public KwlReturnObject saveAssetMachineMapping(Map<String, String> hashMap) throws ServiceException {
        List list = new ArrayList();
        String id = "", delQuery1 = "";
        int numRows1 = 0;
        try {
            String uuid = UUID.randomUUID().toString();
            String assetdetailId = hashMap.get("assetdetailId");
            String machineid = hashMap.get("machineid");
            String companyid = hashMap.get("companyid");
            delQuery1 = "delete from  machine_asset_mapping where machine=? and company=?";
            numRows1 = executeSQLUpdate(delQuery1, new Object[]{machineid, companyid});
            String query = "insert into machine_asset_mapping (id,machine,assetDetails,company) values(?,?,?,?)";
            executeSQLUpdate(query, new Object[]{uuid, machineid, assetdetailId, companyid});
            list.add(uuid);
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accProductImpl.saveAssetMachineMapping:" + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    public KwlReturnObject getMachineId(Map<String, Object> requestParams) throws ServiceException {
        ArrayList params = new ArrayList();
        String companyId = "";
        String assetid = "";
        List list = null;
        int count = 0;
        try {
            if (requestParams.containsKey("assetDetails")) {
                assetid = requestParams.get("assetDetails").toString();
                params.add(assetid);
            }
            if (requestParams.containsKey("companyId")) {
                companyId = requestParams.get("companyId").toString();
                params.add(companyId);
            }
            String query = "select machine from machine_asset_mapping where assetDetails =? and company=?";
            list = executeSQLQuery(query, params.toArray());
            count = list.size();
        } catch (Exception ex) {
            throw ServiceException.FAILURE("MachineIDAlreadyPresent : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, list, count);
    }

    @Override
    public KwlReturnObject getBOMCombo(Map<String, Object> requestParams) throws ServiceException {
        ArrayList params = new ArrayList();
        String companyId = "";
        String productid = "";
        List list = null;
        int count = 0;
        try {
            String conditionStr = "";   
            if (requestParams.containsKey("companyId") && requestParams.get("companyId") != null) {
                companyId = requestParams.get("companyId").toString();
                conditionStr = " where bd.product.company.companyID in ('" + companyId + "')";
                
            }
            if (requestParams.containsKey("productid") && requestParams.get("productid") != null) {
                productid = requestParams.get("productid").toString();
                if (StringUtil.isNullOrEmpty(conditionStr)) {
                    conditionStr = " where bd.product.ID in (" + productid + ")";
                } else {
                    conditionStr += " and bd.product.ID in (" + productid + ")";
                }
                
            }
//            String query = "select id, bomname, bomcode from bomdetail " + conditionStr ;
            String query = "select bd.ID, bd.bomName, bd.bomCode, bd.product.productid, bd.product.name, bd.isDefaultBOM from BOMDetail bd " + conditionStr ;   //ERP-31663
            list = executeQuery(query, params.toArray());
            count = list.size();
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, list, count);
    }
    public boolean checkProductBuild(String productid) {
        boolean isAssemblyProductBuild = false;
        try {
            String selQuery = "select count(*) from productbuild pb inner join bomdetail bd on pb.bomdetail=bd.id where bd.product=? ";
            List countList = executeSQLQuery(selQuery, new Object[]{productid});
            if (!countList.isEmpty()) {
                BigInteger bigInteger = (BigInteger) countList.get(0);
                if (bigInteger.intValue() > 0) {
                    isAssemblyProductBuild = true;
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return isAssemblyProductBuild;
    }
    
    public boolean checkProductBomDetail(String productid) {
        boolean isProductBomDetail = false;
        try {
            String selQuery = "select count(*) from productassembly where subbom in (select id from bomdetail where product = ?) ";
            List countList = executeSQLQuery(selQuery, new Object[]{productid}); 
            if (!countList.isEmpty()) {
                BigInteger bigInteger = (BigInteger) countList.get(0);
                if (bigInteger.intValue() > 0) {
                    isProductBomDetail = true;
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return isProductBomDetail;
    }
    /*
    * Author: Sayed Kausar Ali
    * Params: String productid
    * Purpose: To Check if JW assembly product is used in JWO.
    */
    public boolean checkProductUsedinJWO(String productid) {
        boolean isusedinJWO = false;
        try {
            String selQuery = "select count(*) from sodetails where bomcode in (select id from bomdetail where product = ?) ";
            List countList = executeSQLQuery(selQuery, new Object[]{productid}); 
            if (!countList.isEmpty()) {
                BigInteger bigInteger = (BigInteger) countList.get(0);
                if (bigInteger.intValue() > 0) {
                    isusedinJWO = true;
                }
            }
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return isusedinJWO;
    }
    
    @Override
    public KwlReturnObject getAssetDetailsbyAssetIds(String companyId, JSONArray array) throws ServiceException {
        List params = new ArrayList();
        String query = " from AssetDetails Where company.companyID=? ";
        params.add(companyId);
        if (array != null && array.length() > 0) {
             String s = array.toString();
             s= s.replaceAll("\"", "\'");
    
            query += " and assetId in ("+s.substring(1,s.length()-1)+ ")";
            
        }
        List list = executeQuery(query, params.toArray());
        int count = 0;
        if (list != null && list.size() > 0) {
            count = list.size();
        }
        return new KwlReturnObject(true, null, null, list, count);
    }
    
    @Override
    public KwlReturnObject getProductBrandDiscountDetails(Map<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        int totalCount = 0;
        try {
            String bandID = "";
            if (requestParams.containsKey("bandID") && requestParams.get("bandID") != null) {
                bandID = (String) requestParams.get("bandID");
            }
            boolean isCustomerCategory = false;
            if (requestParams.containsKey("isCustomerCategory") && requestParams.get("isCustomerCategory") != null) {
                isCustomerCategory = (Boolean) requestParams.get("isCustomerCategory");
            }
            boolean isSaveProductBrandDiscountDetails = false;
            if (requestParams.containsKey("isSaveProductBrandDiscountDetails") && requestParams.get("isSaveProductBrandDiscountDetails") != null) {
                isSaveProductBrandDiscountDetails = (Boolean) requestParams.get("isSaveProductBrandDiscountDetails");
            }
            String currencyID = requestParams.get("currencyID") != null ? (String) requestParams.get("currencyID") : "";

            String customerID = "";
            if (requestParams.containsKey("customerID") && requestParams.get("customerID") != null) {
                customerID = (String) requestParams.get("customerID");
            }

            String customerCategoryID = "";
            if (requestParams.containsKey("customerCategoryID") && requestParams.get("customerCategoryID") != null) {
                customerCategoryID = (String) requestParams.get("customerCategoryID");
            }

            String productBrandID = "";
            if (requestParams.containsKey("productBrandID") && requestParams.get("productBrandID") != null) {
                productBrandID = (String) requestParams.get("productBrandID");
            }

            String discountType = "";
            if (requestParams.containsKey("discountType") && requestParams.get("discountType") != null) {
                discountType = (String) requestParams.get("discountType");
            }

            ArrayList params = new ArrayList();
            String conditionSQL = "";

            params.add((String) requestParams.get("companyID"));

            if (!StringUtil.isNullOrEmpty(bandID)) {
                params.add(bandID);
                conditionSQL += " and pbd.pricingbandmaster = ? ";
            }
            
            if (!StringUtil.isNullOrEmpty(currencyID)) {
                params.add(currencyID);
                conditionSQL += " and pbd.currency = ? ";
            }

            if (!StringUtil.isNullOrEmpty(productBrandID)) {
                params.add(productBrandID);
                conditionSQL += " and pbd.productbrand = ? ";
            }

            if (!StringUtil.isNullOrEmpty(discountType)) {
                params.add(discountType);
                conditionSQL += " and pbd.discounttype = ? ";
            }

            // condition for customer category
            if (isCustomerCategory) {
                if (!StringUtil.isNullOrEmpty(customerCategoryID)) {
                    params.add(customerCategoryID);
                    conditionSQL += " and pbd.customercategory = ? ";
                }

                if (requestParams.containsKey("applicableDate") && requestParams.get("applicableDate") != null && isSaveProductBrandDiscountDetails) {
                    params.add((Date) requestParams.get("applicableDate"));
                    conditionSQL += " and pbd.applicabledate = ? ";
                } else if (requestParams.containsKey("applicableDate") && requestParams.get("applicableDate") != null) {
                    params.add((Date) requestParams.get("applicableDate"));
                    conditionSQL += " and pbd.applicabledate in (select max(applicabledate) as ld from productbranddiscountdetails where company=pbd.company and currency=pbd.currency and productbrand=pbd.productbrand and applicabledate <= ? and customercategory=pbd.customercategory group by customercategory ) ";
                }
            } else { // condition for customer
                if (!StringUtil.isNullOrEmpty(customerID)) {
                    params.add(customerID);
                    conditionSQL += " and pbd.customer = ? ";
                }

                if (requestParams.containsKey("applicableDate") && requestParams.get("applicableDate") != null && isSaveProductBrandDiscountDetails) {
                    params.add((Date) requestParams.get("applicableDate"));
                    conditionSQL += " and pbd.applicabledate = ? ";
                } else if (requestParams.containsKey("applicableDate") && requestParams.get("applicableDate") != null) {
                    params.add((Date) requestParams.get("applicableDate"));
                    conditionSQL += " and pbd.applicabledate in (select max(applicabledate) as ld from productbranddiscountdetails where company=pbd.company and currency=pbd.currency and productbrand=pbd.productbrand and applicabledate <= ? and customer=pbd.customer group by customer ) ";
                }
            }

            String query = " select pbd.id from productbranddiscountdetails pbd "
                    + " where pbd.company = ? "
                    + conditionSQL;

            returnList = executeSQLQuery(query, params.toArray());

            totalCount = returnList.size();
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, totalCount);
    }

    @Override
    public KwlReturnObject getProductBrandDiscountDetailsList(HashMap<String, Object> requestParams) throws ServiceException {
        String query = "from ProductBrandDiscountDetails";
        return buildNExecuteQuery(query, requestParams);
    }

    @Override
    public KwlReturnObject saveOrUpdateProductBrandDiscountDetails(Map<String, Object> requestParams) throws ServiceException {
        List list = new ArrayList();
        try {
            ProductBrandDiscountDetails productBrandDiscountDetails;
            String rowid = (String) requestParams.get("rowid");
            if (!StringUtil.isNullOrEmpty(rowid)) {
                productBrandDiscountDetails = (ProductBrandDiscountDetails) get(ProductBrandDiscountDetails.class, rowid);
            } else {
                productBrandDiscountDetails = new ProductBrandDiscountDetails();
            }

            if (requestParams.containsKey("bandID") && requestParams.get("bandID") != null) {
                PricingBandMaster PricingBandMaster = (PricingBandMaster) get(PricingBandMaster.class, (String) requestParams.get("bandID"));
                productBrandDiscountDetails.setPricingBandMaster(PricingBandMaster);
            }

            if (requestParams.containsKey("isCustomerCategory") && requestParams.get("isCustomerCategory") != null) {
                productBrandDiscountDetails.setIsCustomerCategory((Boolean) requestParams.get("isCustomerCategory"));
            }

            if (requestParams.containsKey("applicableDate") && requestParams.get("applicableDate") != null) {
                productBrandDiscountDetails.setApplicableDate((Date) requestParams.get("applicableDate"));
            }

            if (requestParams.containsKey("currencyID") && requestParams.get("currencyID") != null) {
                KWLCurrency currency = (KWLCurrency) get(KWLCurrency.class, (String) requestParams.get("currencyID"));
                productBrandDiscountDetails.setCurrency(currency);
            }

            if (requestParams.containsKey("companyID") && requestParams.get("companyID") != null) {
                Company company = (Company) get(Company.class, (String) requestParams.get("companyID"));
                productBrandDiscountDetails.setCompany(company);
            }

            if (requestParams.containsKey("customerID") && requestParams.get("customerID") != null) {
                Customer customer = (Customer) get(Customer.class, (String) requestParams.get("customerID"));
                productBrandDiscountDetails.setCustomer(customer);
            }

            if (requestParams.containsKey("customerCategoryID") && requestParams.get("customerCategoryID") != null) {
                MasterItem customerCategory = (MasterItem) get(MasterItem.class, (String) requestParams.get("customerCategoryID"));
                productBrandDiscountDetails.setCustomerCategory(customerCategory);
            }

            if (requestParams.containsKey("productBrandID") && requestParams.get("productBrandID") != null) {
                FieldComboData productBrand = (FieldComboData) get(FieldComboData.class, (String) requestParams.get("productBrandID"));
                productBrandDiscountDetails.setProductBrand(productBrand);
            }

            if (requestParams.containsKey("discountType") && requestParams.get("discountType") != null) {
                productBrandDiscountDetails.setDiscountType((String) requestParams.get("discountType"));
            }

            if (requestParams.containsKey("disocuntValue") && requestParams.get("disocuntValue") != null) {
                productBrandDiscountDetails.setDiscountValue(Double.parseDouble((String) requestParams.get("disocuntValue")));
            }

            saveOrUpdate(productBrandDiscountDetails);

            list.add(productBrandDiscountDetails);
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    @Override
    public KwlReturnObject deleteProductBrandDiscountDetails(HashMap<String, Object> requestParams) throws ServiceException {
        ArrayList params = new ArrayList();
        String condition = "";
        
        params.add((String) requestParams.get("companyID"));
        
        if (requestParams.containsKey("productBrandID") && requestParams.get("productBrandID") != null) {
            condition += " and productBrand.ID=? ";
            params.add((String) requestParams.get("productBrandID"));
        }
        
        if (requestParams.containsKey("customerCategoryID") && requestParams.get("customerCategoryID") != null) {
            condition += " and customerCategory.ID=? ";
            params.add((String) requestParams.get("productBrandID"));
        }
        
        if (requestParams.containsKey("customerID") && requestParams.get("customerID") != null) {
            condition += " and customer.ID=? ";
            params.add((String) requestParams.get("customerID"));
        }
        
        String delQuery = "delete from ProductBrandDiscountDetails where company.companyID=? " + condition;
        int numRows = executeUpdate(delQuery, params.toArray());
        
        return new KwlReturnObject(true, "Discount Details has been deleted successfully.", null, null, numRows);
    }
    public KwlReturnObject getSumOfOpeningBalanceForProduct(Map<String, Object> requestMap) throws ServiceException {
        List list = new ArrayList();
        try {
            List params = new ArrayList();
            String companyId = (String) requestMap.get(Constants.companyKey);
            params.add(companyId);
            String sql = "select sum(openingbalanceamountinbase) from product where company=?";
            if (requestMap.containsKey("inventoryaccount") && requestMap.get("inventoryaccount") != null) {
                String inventoryaccount = requestMap.get("inventoryaccount").toString();
                sql += " and inventoryaccount=?";
                params.add(inventoryaccount);
            }
            list = executeSQLQuery(sql, params.toArray());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    /**
     * Get sum for work order block quantity
     * @param productid = get details for product
     * @return = SUM of block quantity for work order
     * @throws ServiceException
     */
    @Override
    public KwlReturnObject getWOLockQuantity(String productid) throws ServiceException {
        KwlReturnObject workordercomponentdetails=getWOLockQuantity(productid,false);
        return new KwlReturnObject(true, "", null, workordercomponentdetails.getEntityList(), workordercomponentdetails.getEntityList().size());
     }
    
    @Override
    public KwlReturnObject getWOLockQuantity(String productid,boolean isManageQuantity) throws ServiceException { //for selecting a locked quantity of inventory product used in workorder
        List returnList = new ArrayList();
        try {
            String query="";
            if (isManageQuantity) {     //ERP-40045 : Query altered as per Product Master
                query = "select sum(case when isblockqtyused='T' then (blockquantity-(blockquantityused+rejectedquantity+returnquantity)) else blockquantity end) from workordercomponentdetail where product=? ";                
            } else {
                query = "select sum(case when isblockqtyused='T' then (blockquantity-blockquantityused) else blockquantity end) from workordercomponentdetail where product=? ";
            }
            List list = executeSQLQuery(query, new Object[]{productid});
            Iterator itr = list.iterator();
            if (itr.hasNext()) {
                returnList.add(itr.next());
            } else {
                returnList.add(null);
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getWOLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    @Override
    public KwlReturnObject getVATCommodityCodeByName(Map<String,String> mapData) throws ServiceException { //for selecting a locked quantity of inventory product used in workorder
        
        List returnList = new ArrayList();
        String vatcommodityname=mapData.get("vatcommodityname"),company=mapData.get("company");
        try {
            String query = "SELECT id FROM masteritem WHERE mastergroup='42' AND value = ? AND company = ? ";
            if(!StringUtil.isNullOrEmpty(vatcommodityname) && !StringUtil.isNullOrEmpty(company)){
             returnList = executeSQLQuery(query, new Object[]{vatcommodityname,company});
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getWOLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    public KwlReturnObject getNatureofStockItemCodeByName(Map<String,String> mapData) throws ServiceException { //for selecting a locked quantity of inventory product used in workorder
        
        List returnList = new ArrayList();
        String natureofStockItemname=mapData.get("natureofStockItemname"),company=mapData.get("company");
        try {
            String query = "SELECT id FROM masteritem WHERE mastergroup='52' AND value = ? AND company = ? ";
            if(!StringUtil.isNullOrEmpty(natureofStockItemname) && !StringUtil.isNullOrEmpty(company)){
             returnList = executeSQLQuery(query, new Object[]{natureofStockItemname,company});
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getWOLockQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    
    @Override
    public KwlReturnObject getJEFromDisposedOrRevertedAssetDetails(String jeId, String CompanyId, Boolean isReverseJe) throws ServiceException {
        List list = new ArrayList();
        String query = "";
        try {
            if (isReverseJe) {
                query = "from DisposeRevertAssets ad where ad.reverseJE.ID = ? and ad.company.companyID = ?";
            } else {
                query = "from DisposeRevertAssets ad where ad.disposalJE.ID = ? and ad.company.companyID = ?";
            }
            list = executeQuery( query, new Object[]{jeId, CompanyId});
        } catch (ServiceException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    public KwlReturnObject getDisposedOrRevertedAssets(HashMap<String,Object> reqMap) throws ServiceException {
        List list = new ArrayList();
        String query = "";
        try {
            String asset = "", companyid = "";
            if(reqMap.containsKey("asset") && reqMap.get("asset")!=null){
                asset = (String) reqMap.get("asset");
            }
            if(reqMap.containsKey("companyid") && reqMap.get("companyid")!=null){
                companyid = (String) reqMap.get("companyid");
            }
            
            query = "from DisposeRevertAssets dra where dra.asset.id in("+asset+") and dra.company.companyID = ?";
            list = executeQuery( query, new Object[]{companyid});
        } catch (ServiceException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    @Override
    public int deleteDisposedAssets(HashMap<String,Object> reqMap) throws ServiceException {
        int numRows = 0;
        try {
            String asset = "";
            if(reqMap.containsKey("asset") && reqMap.get("asset")!=null){
                asset = reqMap.get("asset").toString();
            }
            String companyid = "";
            if(reqMap.containsKey("companyid") && reqMap.get("companyid")!=null){
                companyid = reqMap.get("companyid").toString();
            }
            
            //Update assetdetail table by setting disposalJE, reverseJE to null before deleting JE from journal entry table.
            String assetJEQuery = "UPDATE assetdetail SET disposalje=null, reverseje=null, disposaldate=null, remaininglife=0, disposalprofitloss=0, "
                    + "isdisposed=false  WHERE id=? AND company=?";
            executeSQLUpdate(assetJEQuery, new Object[]{asset, companyid});
            
            reqMap.put("asset", "'"+asset+"'");
            reqMap.put("companyid",  companyid);
            KwlReturnObject result = getDisposedOrRevertedAssets(reqMap);
            List<DisposeRevertAssets> ll = result.getEntityList();
            for(DisposeRevertAssets disposeRevertAssets : ll){
                ArrayList assetJEParams = new ArrayList();
                assetJEParams.add(disposeRevertAssets.getAsset().getId());
                assetJEParams.add(companyid);
                //Update disposerevertassets table by setting disposalJE, reverseJE to null before deleting JE from journal entry table
                String updateAssetJEQuery = "UPDATE disposerevertassets SET disposalJE=null, reverseJE=null WHERE asset=? AND company=?";
                executeSQLUpdate(updateAssetJEQuery, assetJEParams.toArray());

                if(disposeRevertAssets.getDisposalJE()!=null){
                    accJournalEntryobj.deleteJournalEntryPermanent(disposeRevertAssets.getDisposalJE().getID(), companyid);
                }
                if(disposeRevertAssets.getReverseJE()!=null){
                    accJournalEntryobj.deleteJournalEntryPermanent(disposeRevertAssets.getReverseJE().getID(), companyid);
                }
            }
            
            ArrayList assetParams = new ArrayList();
            assetParams.add(companyid);
            assetJEQuery = "DELETE FROM disposerevertassets  WHERE asset IN ('" + asset + "') AND company=?";//Delete entries from disposerevertassets after deleting form journalentry table
            numRows += executeSQLUpdate(assetJEQuery, assetParams.toArray());
        } catch (ServiceException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return numRows;
    }
    
    @Override
    public KwlReturnObject saveOrUpdateDisposeRevertAssets(Map<String, Object> requestParams) throws ServiceException {
        List list = new ArrayList();
        try {
            DisposeRevertAssets disposeRevertAssets = null;
            if (requestParams.get("disposeRevertAssets")!=null) {
                disposeRevertAssets = (DisposeRevertAssets) requestParams.get("disposeRevertAssets");
            } else {
                disposeRevertAssets = new DisposeRevertAssets();
            }

            if (requestParams.containsKey("asset") && requestParams.get("asset") != null) {
                AssetDetails assetDetails = (AssetDetails) get(AssetDetails.class, (String) requestParams.get("asset"));
                disposeRevertAssets.setAsset(assetDetails);
            }

            if (requestParams.containsKey("companyID") && requestParams.get("companyID") != null) {
                Company company = (Company) get(Company.class, (String) requestParams.get("companyID"));
                disposeRevertAssets.setCompany(company);
            }

            if (requestParams.containsKey("disposalJE") && requestParams.get("disposalJE") != null) {
                JournalEntry disposalJE = (JournalEntry) get(JournalEntry.class, (String) requestParams.get("disposalJE"));
                disposeRevertAssets.setDisposalJE(disposalJE);
            }

            if (requestParams.containsKey("reverseJE") && requestParams.get("reverseJE") != null) {
                JournalEntry reverseJE = (JournalEntry) get(JournalEntry.class, (String) requestParams.get("reverseJE"));
                disposeRevertAssets.setReverseJE((reverseJE));
            }

            if (requestParams.containsKey("isreverted") && requestParams.get("isreverted") != null) {
                disposeRevertAssets.setIsreverted((Boolean) requestParams.get("isreverted"));
            }
            
            saveOrUpdate(disposeRevertAssets);

            list.add(disposeRevertAssets);
        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }

    @Override
    public boolean mapCompanyTaxToProductTax(HashMap<String, String> requestParams, Product product, Map<String, List<String>> mapDefaultTerm) throws ServiceException {
        List returnList = new ArrayList();
        boolean isCompletFlag = false;
        int count = 0;
        try {
            /*
              Turn Loop Twice (Sales and Purchase) to set Specifice type tax as default .
             */            
            for (String termType : mapDefaultTerm.keySet()) {
                List<String> defaultTerms = mapDefaultTerm.get(termType);
                String selQuery = "from LineLevelTerms where company.companyID=? ";
                selQuery += " and salesOrPurchase= ?" ;
                boolean checkSalesOrPurchase=!termType.equals("Purchases");
                if (!StringUtil.isNullOrEmpty(requestParams.get("companyid"))) {
                    returnList = executeQuery(selQuery, new Object[]{requestParams.get("companyid"),checkSalesOrPurchase});
                }
                Iterator itr = returnList.iterator();
                while (itr.hasNext()) {
                    LineLevelTerms llt = (LineLevelTerms) itr.next();
                    ProductTermsMap ptm = new ProductTermsMap();
                    String uuid = UUID.randomUUID().toString();
                    ptm.setId(uuid);
                    ptm.setPercentage(llt.getPercentage());
                    ptm.setPurchaseValueOrSaleValue(llt.getPurchaseValueOrSaleValue());
                    ptm.setAccount(llt.getAccount());
                    ptm.setCreator(llt.getCreator());
                    ptm.setDeductionOrAbatementPercent(llt.getDeductionOrAbatementPercent());
                    /**
                     * While importing product with default terms, apply default
                     * terms check true on imported product defaultTerms list
                     * data present only while importing product, If line level
                     * terms As Tax Check ON
                     */
                    if (defaultTerms != null && !defaultTerms.isEmpty() && defaultTerms.contains(llt.getTerm())) {
                        ptm.setIsDefault(true);
                    } else if (defaultTerms.isEmpty()) {
                        ptm.setIsDefault(llt.isIsDefault());
                    }
                    ptm.setTaxType(llt.getTaxType());  // Save Company type tax to Product level
                    ptm.setProduct(product);
                    ptm.setTerm(llt);
                    ptm.setTermAmount(llt.getTermAmount());
                    save(ptm);
                }
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("mapCompanyTaxToProductTax : " + ex.getMessage(), ex);
        }
        return isCompletFlag;
    }
    
    @Override
    public boolean UpdateTaxToProductTax(HashMap<String, String> requestParams, Product product, Map<String, List<String>> mapDefaultTerm) throws ServiceException {
        boolean isCompletFlag = false;
        try {
            if (product != null && !StringUtil.isNullOrEmpty(requestParams.get("companyid")) && !mapDefaultTerm.isEmpty()) {
                for (String termType : mapDefaultTerm.keySet()) {

                    List<String> defaultTerms = mapDefaultTerm.get(termType);
                    boolean checkSalesOrPurchase = !termType.equals("Purchases");

                    String updateQuery = "update producttermsmap pt INNER JOIN linelevelterms llt on pt.term=llt.id SET pt.isDefault=? WHERE llt.company =? and pt.product =? and llt.salesorpurchase= ?";
                    /*
                     * ------ Set default flag as false to all tax respective
                     * product -----
                     */
                    if (!defaultTerms.isEmpty()) {
                        executeSQLUpdate(updateQuery, new Object[]{'F', requestParams.get("companyid"), product.getID(), checkSalesOrPurchase});
                        /*
                         * ------ Update default flag as true to tex respective
                         * product mention in file  -----
                         */
                        String termNames = "";
                        Iterator<String> itr = defaultTerms.iterator();
                        while (itr.hasNext()) {
                            String termname = itr.next().toString();
                            termNames += "'" + termname + "',";
                        }
                        if (!StringUtil.isNullOrEmpty(termNames)) {
                            termNames = termNames.substring(0, termNames.length() - 1);
                        }

                        updateQuery += " and llt.term in (" + termNames + ")";
                        executeSQLUpdate(updateQuery, new Object[]{'T', requestParams.get("companyid"), product.getID(), checkSalesOrPurchase});
                        isCompletFlag = true;
                    }
                }
            }


        } catch (Exception ex) {
            throw ServiceException.FAILURE("mapCompanyTaxToProductTax : " + ex.getMessage(), ex);
        }
        return isCompletFlag;
    }
    /**
     * @Description function to get the list of product IDS for company
     * @param reqMap
     * @return <KwlReturnObject>
     */
    @Override
    public KwlReturnObject getProductIdsForCompany(Map<String, Object> reqMap) {
        List list = new ArrayList();
        try {
            String companyid = reqMap.get(Constants.companyKey).toString();
            String query = "select id from product where company = ? and deleteflag='F'";
            List params = new ArrayList();
            params.add(companyid);
            if (reqMap.containsKey("valuationMethod") && reqMap.get("valuationMethod") != null) {
                query += " and valuationmethod=?";
                params.add(reqMap.get("valuationMethod"));
            }
            list = executeSQLQuery(query, params.toArray());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, ex.getMessage());
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    /**
     * @Description : Function to get the valuation method of a product 
     * @param productid
     * @return <KwlReturnObject>
     */
    @Override
    public int getProductValuationMethod(String productid) {
        int valuationmethod = 0;
        try {
            String query = "select valuationmethod from product where id = ? and deleteflag='F'";
            List params = new ArrayList();
            params.add(productid);
            List list = executeSQLQuery(query, params.toArray());
            if (list != null && !list.isEmpty() && list.get(0) != null) {
                valuationmethod = Integer.parseInt(list.get(0).toString());
            }
        } catch (ServiceException | NumberFormatException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, ex.getMessage());
        }catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, ex.getMessage());
        }
        return valuationmethod;
    }
    @Override
    public KwlReturnObject getSerialIdByStorageDetails(Map<String, String> storageDetail) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        try {
            String condidtionSql = "";
            String query = "";
            String Searchjson = "",isSerialJson="";
            int transType = 0;
            String filterConjuctionCriteria = "";
            if(storageDetail.containsKey("searchjson") && storageDetail.get("searchjson") !=null){
                Searchjson = storageDetail.get("searchjson").toString();
            }
            if(storageDetail.containsKey("transType") && storageDetail.get("transType") !=null){
                transType = Integer.parseInt(String.valueOf(storageDetail.get("transType")));
            }
            if(storageDetail.containsKey("isSerialJson") && storageDetail.get("isSerialJson") !=null){
                isSerialJson = storageDetail.get("isSerialJson").toString();
            }
            if(storageDetail.containsKey("filterConjuctionCriteria") && storageDetail.get("filterConjuctionCriteria") !=null){
                filterConjuctionCriteria = storageDetail.get("filterConjuctionCriteria").toString();
            }
            boolean isAdvanceSearch = false;
            String detailID = storageDetail.get("detailid").toString();
            int transactiontype = Integer.parseInt(storageDetail.get("transactiontype").toString());
            params.add(detailID);
            params.add(transactiontype);
            if (storageDetail.containsKey("locationId") && !StringUtil.isNullOrEmpty(storageDetail.get("locationId"))) {
                condidtionSql += " and sd.serialid.batch.location.id=? ";
                params.add(storageDetail.get("locationId"));
            }
            if (storageDetail.containsKey("warehouseId") && !StringUtil.isNullOrEmpty(storageDetail.get("warehouseId"))) {
                condidtionSql += " and sd.serialid.batch.warehouse.id=? ";
                params.add(storageDetail.get("warehouseId"));
            }
            if (storageDetail.containsKey("rowId") && !StringUtil.isNullOrEmpty(storageDetail.get("rowId"))) {
                condidtionSql += " and sd.serialid.batch.row.id=? ";
                params.add(storageDetail.get("rowId"));
            }
            if (storageDetail.containsKey("rackId") && !StringUtil.isNullOrEmpty(storageDetail.get("rackId"))) {
                condidtionSql += " and sd.serialid.batch.rack.id=? ";
                params.add(storageDetail.get("rackId"));
            }
            if (storageDetail.containsKey("binId") && !StringUtil.isNullOrEmpty(storageDetail.get("binId"))) {
                condidtionSql += " and sd.serialid.batch.bin.id=? ";
                params.add(storageDetail.get("binId"));
            }
            if (storageDetail.containsKey("batchName") && !StringUtil.isNullOrEmpty(storageDetail.get("batchName"))) {
                condidtionSql += " and sd.serialid.batch.batchname=? ";
                params.add(storageDetail.get("batchName"));
            }
            if (storageDetail.containsKey("serialNameSearch") && !StringUtil.isNullOrEmpty(storageDetail.get("serialNameSearch"))) {
                condidtionSql += " and sd.serialid.serialname like ? ";
                params.add("%" + storageDetail.get("serialNameSearch") + "%");
            }

            if (isSerialJson.equalsIgnoreCase("T") && !StringUtil.isNullOrEmpty(Searchjson) && transType == 0 ) {
                isAdvanceSearch = true;
                String mySearchFilterString = "";
                HashMap<String, Object> reqPar1 = new HashMap<String, Object>();
                reqPar1.put(Constants.Acc_Search_Json, Searchjson);
                reqPar1.put(Constants.Filter_Criteria, filterConjuctionCriteria);
                reqPar1.put(Constants.appendCase, "and");
                reqPar1.put(Constants.moduleid,Constants.SerialWindow_ModuleId);
     
                    if (!StringUtil.isNullOrEmpty(Searchjson)) {
                        reqPar1.put(Constants.Searchjson, Searchjson);
                        mySearchFilterString = String.valueOf(StringUtil.getMyAdvanceSearchString(reqPar1, true).get(Constants.myResult));
                        mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailCustomData", "sd.serialCustomData");//  
                        mySearchFilterString = mySearchFilterString.replaceAll("AccJEDetailsProductCustomData", "sd.serialCustomData");
                        String joinCustomVQ = " INNER JOIN sd.serialCustomData ";
                        if (!StringUtil.isNullOrEmpty(Searchjson)) {
                            StringUtil.insertParamAdvanceSearchString1(params, Searchjson);
                        }
                    }
                
                // Fetch only searials which matches search criterion
                query = " select sd.serialid.id from SerialDocumentMapping sd INNER JOIN sd.serialCustomData sc where sd.documentid= ? and sd.transactiontype = ? " + condidtionSql + mySearchFilterString;
            } else{
                query = " select sd.serialid.id from SerialDocumentMapping sd where sd.documentid= ? and sd.transactiontype = ? " + condidtionSql; 
            }
            returnList = executeQuery(query, params.toArray());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getSerialNoByDocumentid : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }
    /**
     * Get Line level Product Terms details for CRM Integration
     * This Product terms details used in CRM for Quotation, 
     * Integration with ERP (At Product level).
     * @param customParams
     * @return 
     */
   @Override
     public JSONArray getProductTermsJsonArray(Map<String, Object> customParams) {
        JSONArray productData = new JSONArray();
        try {
            KwlReturnObject result = getProductTermDetails(customParams);
            ArrayList<ProductTermsMap> ProductTermPurchaselist = (ArrayList<ProductTermsMap>) result.getEntityList();
            for (ProductTermsMap mt : ProductTermPurchaselist) {
                JSONObject jsonobj = new JSONObject();
                jsonobj.put("id", mt.getId());
                jsonobj.put("term", mt.getTerm().getTerm());
                jsonobj.put("glaccount", mt.getAccount().getID());
                jsonobj.put("glaccountname", !StringUtil.isNullOrEmpty(mt.getAccount().getName()) ? mt.getAccount().getName() : "");
                jsonobj.put("accode", !StringUtil.isNullOrEmpty(mt.getAccount().getAcccode()) ? mt.getAccount().getAcccode() : "");
                jsonobj.put("sign", mt.getTerm().getSign());
                jsonobj.put("formula", mt.getTerm().getFormula());
                jsonobj.put("isdefault", mt.isIsDefault());
                jsonobj.put("isothertermtaxable", mt.getTerm().isOtherTermTaxable());
                jsonobj.put("termid", mt.getTerm().getId());
                jsonobj.put("formulaids", mt.getTerm().getFormula());
                jsonobj.put("termpercentage", mt.getPercentage());
                jsonobj.put("termamount", mt.getTermAmount());
                jsonobj.put("termtype", mt.getTerm().getTermType());
                jsonobj.put("termsequence", mt.getTerm().getTermSequence() + "");
                jsonobj.put(Constants.productid, mt.getProduct().getID());
                jsonobj.put("producttermmapid", mt.getId());
                jsonobj.put("purchasevalueorsalevalue", mt.getPurchaseValueOrSaleValue());
                jsonobj.put("deductionorabatementpercent", mt.getDeductionOrAbatementPercent());
                jsonobj.put("formtype", !StringUtil.isNullOrEmpty(mt.getFormType()) ? mt.getFormType() : "1"); // 1 for without form
                jsonobj.put("taxtype", mt.getTaxType());
                jsonobj.put("taxvalue", mt.getPercentage());
                productData.put(jsonobj);
            }
        } catch (Exception ex) {
            Logger.getLogger(productHandler.class.getName()).log(Level.SEVERE, null, ex);
        }
        return productData;
    }
     /**
      * Get Line level Company Terms details for CRM Integration
      * This Product terms details used in CRM for Quotation,
      * Integration with ERP(At Company Level).
      * @param customParams
      * @return 
      */
    @Override
    @Transactional(propagation = Propagation.REQUIRED)
     public JSONArray getCompanyTermsJsonArray(HashMap<String, String> customParams) {
        JSONArray jarr = new JSONArray();
        try {
            KwlReturnObject result = accAccountDAOobj.getIndianTermsCompanyLevel(customParams);
            List<LineLevelTerms> list = result.getEntityList();
            for (LineLevelTerms mt : list) { 
                JSONObject jsonobj = new JSONObject();
                jsonobj.put("id", mt.getId());
                jsonobj.put("term", mt.getTerm());
                jsonobj.put("glaccount", mt.getAccount().getID());
                jsonobj.put("glaccountname", !StringUtil.isNullOrEmpty(mt.getAccount().getName()) ? mt.getAccount().getName() : "");
                jsonobj.put("accode", !StringUtil.isNullOrEmpty(mt.getAccount().getAcccode()) ? mt.getAccount().getAcccode() : "");
                jsonobj.put("sign", mt.getSign());
                jsonobj.put("formula", mt.getFormula());
                jsonobj.put("formulaids", mt.getFormula());
                jsonobj.put("termformulaids", mt.getFormulaids());
                jsonobj.put("termid", mt.getId());
                jsonobj.put("termpercentage", mt.getPercentage());
                jsonobj.put("termamount", mt.getTermAmount());
                jsonobj.put("termtype", mt.getTermType());
                jsonobj.put("purchasevalueorsalevalue", mt.getPurchaseValueOrSaleValue());
                jsonobj.put("deductionorabatementpercent", mt.getDeductionOrAbatementPercent());
                jsonobj.put("taxtype", mt.getTaxType());
                jsonobj.put("taxvalue", mt.getTaxType()==0 ? mt.getTermAmount() : mt.getPercentage());
                jsonobj.put("isdefault", mt.isIsDefault());
                jsonobj.put("termsequence", mt.getTermSequence());
                jsonobj.put("formtype", !StringUtil.isNullOrEmpty(mt.getFormType())?mt.getFormType():"1");
                jsonobj.put("isadditionaltax", mt.isIsAdditionalTax());
                jsonobj.put("masteritem", mt.getMasteritem() == null ? "" : mt.getMasteritem().getID());
                jsonobj.put("isothertermtaxable", mt.isOtherTermTaxable());
                jarr.put(jsonobj);
            }
        } catch (JSONException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, ex.getMessage(), ex);
        } 
        return jarr;
    }
    @Override
    public KwlReturnObject getLineLevelTerm(HashMap<String,Object> pamsHashMap) throws ServiceException {
        List list = new ArrayList();
        String query = "";
        try {
            String productId=pamsHashMap.get("productId").toString();
            String companyId=pamsHashMap.get("companyId").toString();
            boolean salesOrPurchase=Boolean.parseBoolean(pamsHashMap.get("purchaseSalesVal").toString());
            int termType=Integer.parseInt(pamsHashMap.get("termType").toString());
            query = "from ProductTermsMap where product.ID = ? and term.company.companyID = ? and term.termType= ? and term.isDefault=true and term.salesOrPurchase=?";
            list = executeQuery(query, new Object[]{productId, companyId, termType, salesOrPurchase});
        } catch (ServiceException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    @Override //This method is used to check that user entered BOM Code is already exist in system or not.
    public boolean isBOMCodeExist(String bomCode, String productid, String companyId) throws ServiceException {
        try {
            List list = new ArrayList();
            int count = 0;
            String q = "FROM BOMDetail bd WHERE bd.bomCode = ? AND bd.product.ID = ? AND bd.product.company.companyID = ?";
            list = executeQuery(q, new Object[]{bomCode, productid, companyId});
            count = list.size();
            if(count > 0){
                return true;
            } else {
                return false;
            }
        } catch (Exception ex) {
            throw ServiceException.FAILURE("accProductImpl.isBOMCodeExist() : " + ex.getMessage(), ex);
        }
    }
      @Override
    public KwlReturnObject saveQAApprovalDetails(HashMap<String, Object> documentMap) throws ServiceException {
        List list = new ArrayList();
        int listSize = 0;
        try {
            AssemblyProductApprovalDetails assPrAppD=null;
            if (documentMap.containsKey("qadetailid") && !StringUtil.isNullOrEmpty((String) documentMap.get("qadetailid"))) {
                 assPrAppD = (AssemblyProductApprovalDetails) get(AssemblyProductApprovalDetails.class, (String) documentMap.get("qadetailid"));
            } else {
                assPrAppD = new AssemblyProductApprovalDetails();
            }

            if (documentMap.containsKey("quantity") && !StringUtil.isNullOrEmpty((String) documentMap.get("quantity"))) {
                double qty = Double.parseDouble((String) documentMap.get("quantity"));
                assPrAppD.setQuantity(qty);
            }
            if (documentMap.containsKey("location")) {
                Location location = (Location) get(Location.class, (String) documentMap.get("location"));
                if (location != null) {
                    assPrAppD.setLocation(location);
                }
            }
            if (documentMap.containsKey("warehouse")) {
                InventoryWarehouse warehouse =  (InventoryWarehouse) get(InventoryWarehouse.class, (String) documentMap.get("warehouse"));
                if (warehouse != null) {
                    assPrAppD.setWarehouse(warehouse);
                }
            }
            if (documentMap.containsKey("row") && !StringUtil.isNullOrEmpty((String) documentMap.get("row"))) {
                StoreMaster storeMaster = new StoreMaster();
                storeMaster = (StoreMaster) get(StoreMaster.class, (String) documentMap.get("row"));
                if (storeMaster != null) {
                    assPrAppD.setRow(storeMaster);
                }
            }
            if (documentMap.containsKey("rack") && !StringUtil.isNullOrEmpty((String) documentMap.get("rack"))) {
                StoreMaster storeMaster = new StoreMaster();
                storeMaster = (StoreMaster) get(StoreMaster.class, (String) documentMap.get("rack"));
                if (storeMaster != null) {
                    assPrAppD.setRack(storeMaster);
                }
            }
            if (documentMap.containsKey("bin") && !StringUtil.isNullOrEmpty((String) documentMap.get("bin"))) {
                StoreMaster storeMaster = new StoreMaster();
                storeMaster = (StoreMaster) get(StoreMaster.class, (String) documentMap.get("bin"));
                if (storeMaster != null) {
                    assPrAppD.setBin(storeMaster);
                }
            }
            if (documentMap.containsKey("documentid")) {  //productbuild id
                ProductBuild prb = (ProductBuild) get(ProductBuild.class, (String) documentMap.get("documentid"));
                if (prb != null) {
                    assPrAppD.setPrBuild(prb);
                }
            }
            if (documentMap.containsKey("batchmapid")) {
                NewProductBatch newProductBatch = newProductBatch = (NewProductBatch) get(NewProductBatch.class, (String) documentMap.get("batchmapid"));
                if (newProductBatch != null) {
                    assPrAppD.setProductBatch(newProductBatch);
                }
            }
            if (documentMap.containsKey("mfgdate")) {
                assPrAppD.setMfgdate((Date) documentMap.get("mfgdate"));
            }
            if (documentMap.containsKey("expdate")) {
                assPrAppD.setExpdate((Date) documentMap.get("expdate"));
            }
            if (documentMap.containsKey("batchname")) {
                assPrAppD.setBatchname((String) documentMap.get("batchname"));
            }

            if (documentMap.containsKey("serialmapid")) {
                NewBatchSerial newBatchSerial = newBatchSerial = (NewBatchSerial) get(NewBatchSerial.class, (String) documentMap.get("serialmapid"));
                if (newBatchSerial != null) {
                    assPrAppD.setSerial(newBatchSerial);
                }
            }
            if (documentMap.containsKey("serialname")) {
                assPrAppD.setSerialname((String) documentMap.get("serialname"));
            }
            if (documentMap.containsKey("expfromdate")) {
                assPrAppD.setExpfromdate((Date) documentMap.get("expfromdate"));
            }
            if (documentMap.containsKey("exptodate")) {
                assPrAppD.setExptodate((Date) documentMap.get("exptodate"));
            }

            if (documentMap.containsKey("approvalstatus")) {
                AssemblyQAStatus status = (AssemblyQAStatus) documentMap.get("approvalstatus");
                assPrAppD.setApprovalStatus(status);
            }
            if (documentMap.containsKey("repareDate")) {
                assPrAppD.setReapirDate((Date) documentMap.get("repareDate"));
            }
            if (documentMap.containsKey("inspectedDate")) {
                assPrAppD.setInspectionDate((Date) documentMap.get("inspectedDate"));
            }
            if (documentMap.containsKey("remark")) {
                assPrAppD.setRemark(documentMap.get("remark").toString());
            }
            if (documentMap.containsKey("reason")) {
                assPrAppD.setReason(documentMap.get("reason").toString());
            }
       
            saveOrUpdate(assPrAppD);
            list.add(assPrAppD);
        } catch (Exception e) {
            throw ServiceException.FAILURE("accountingHandlerDAOobj.saveQAApprovalDetails : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }

    @Override
    public KwlReturnObject saveProductBuildsApprovedQty(HashMap<String, Object> ApprovalStatusData) throws ServiceException {
         List list = new ArrayList();
        int listSize = 0;
        double currentApprQty=0.0d;
        double curretRejQty=0.0d;
        try {
            ProductBuild productBuild=null;
            if (ApprovalStatusData.containsKey("productBuildId") && !StringUtil.isNullOrEmpty((String) ApprovalStatusData.get("productBuildId"))) {
                productBuild = (ProductBuild) get(ProductBuild.class, (String) ApprovalStatusData.get("productBuildId"));
                
                if (ApprovalStatusData.containsKey("approvedQty") && !StringUtil.isNullOrEmpty((String) ApprovalStatusData.get("approvedQty").toString())) {
                    double qty = Double.parseDouble((String) ApprovalStatusData.get("approvedQty").toString());
                    productBuild.setApprovedQuantity(productBuild.getApprovedQuantity() + qty);
                    currentApprQty=qty;
                }
                if (ApprovalStatusData.containsKey("rejectedQty") && !StringUtil.isNullOrEmpty((String) ApprovalStatusData.get("rejectedQty").toString())) {
                    double qty = Double.parseDouble((String) ApprovalStatusData.get("rejectedQty").toString());
                    productBuild.setRejectedQuantity(productBuild.getRejectedQuantity() + qty);
                    curretRejQty=qty;
                }
                if(ApprovalStatusData.containsKey("quantity") && !StringUtil.isNullOrEmpty((String) ApprovalStatusData.get("quantity").toString()) && ApprovalStatusData.containsKey("ApprQuantity") && !StringUtil.isNullOrEmpty((String) ApprovalStatusData.get("ApprQuantity").toString()) && ApprovalStatusData.containsKey("rejQuantity") && !StringUtil.isNullOrEmpty((String) ApprovalStatusData.get("rejQuantity").toString())){
                    double totalQty = Double.parseDouble((String) ApprovalStatusData.get("quantity").toString());
                    double totalApprQty = Double.parseDouble((String) ApprovalStatusData.get("ApprQuantity").toString());
                    double totalRejQty = Double.parseDouble((String) ApprovalStatusData.get("rejQuantity").toString());
                    
                    if((currentApprQty + curretRejQty + totalApprQty + totalRejQty) == totalQty){
                        productBuild.setIspendingforqa(false);
                    }
                }
            } 

     
            saveOrUpdate(productBuild);
            list.add(productBuild);
        } catch (Exception e) {
            throw ServiceException.FAILURE("accountingHandlerDAOobj.saveQAApprovalDetails : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
     public KwlReturnObject GetWareHouseNamesOfProductBuild(String productBuild) throws ServiceException {
        List resultList=new ArrayList();
        try {
            String selQuery = " Select distinct(warehouse) from qa_of_buildassemblyproduct  where prbuildid=?";
            resultList = executeSQLQuery(selQuery, new Object[]{productBuild});
        } catch (Exception ex) {
            throw ServiceException.FAILURE("GetWareHouseNamesOfProductBuild:" + ex.getMessage(), ex);
        }
         return new KwlReturnObject(true, "", null, resultList, resultList.size());
    }
     
     public KwlReturnObject checkIsAssetIDAlreadyUsed(Map<String, Object> requestParams)throws   ServiceException{
        List resultList=Collections.emptyList();
        List filterParams=new ArrayList();
        boolean succesMsg=false;
        try{
            String hqlQuery=" from NewBatchSerial where company.companyID= ? and skufield= ? and id!= ?";
            filterParams.add(requestParams.get("company"));
            filterParams.add(requestParams.get("SkufieldValue"));
            filterParams.add(requestParams.get("serialid"));
            resultList=executeQuery(hqlQuery, filterParams.toArray());
            succesMsg=true;
        }catch(Exception ex){
                throw ServiceException.FAILURE("AccProductDaoImpl.checkIsAssetIDAlreadyUsed", ex);
        }
       return new KwlReturnObject(succesMsg, null, null, resultList, resultList.size());
     } 
    @Override
    public KwlReturnObject getVendorList(HashMap<String, Object> requestParams) throws ServiceException {
        String initialQuery = "from Vendor";
        return buildNExecuteQuery(initialQuery, requestParams);
    }

    @Override
    public KwlReturnObject getSameNameProductCategoryIds(Map<String, Object> customParams) throws ServiceException {
        String companyids = AccountingManager.getFilterInString(customParams.get("companyids").toString());
        String categoryName = (String) customParams.get("categoryname");
        String masterGroupID = String.valueOf(19);// 19 is group id of product Category

        List params = new ArrayList();
        params.add(categoryName);
        params.add(masterGroupID);
        String query = "select id from masteritem where company in " + companyids + " and value = ? and masterGroup=? ";
        List listSql = executeSQLQuery(query, params.toArray());

        return new KwlReturnObject(true, "", "", listSql, listSql.size());
    }
    public JSONArray getProductDocumentsArray(Map<String, Object> docsParams) {
        JSONArray jar = new JSONArray();
        try {
            KwlReturnObject docskwl = getDocuments(docsParams);
            List lst = docskwl.getEntityList();
            Iterator itr = lst.iterator();
            while (itr.hasNext()) {
                com.krawler.common.admin.Docs doc = (com.krawler.common.admin.Docs) itr.next();
                JSONObject jobj = new JSONObject();
                String documentid = doc.getId();
                jobj.put("docid", documentid);
                jobj.put("docname", doc.getDocname());
                jobj.put("docsize", doc.getDocsize());
                jobj.put("doctype", doc.getDoctype());
                jobj.put("uploadedon", doc.getUploadedon());
                jobj.put("storename", doc.getStorename());
                jobj.put("storageindex", doc.getStorageindex());
                jobj.put("moduleId", Constants.Acc_Product_Master_ModuleId);
                jobj.put("recordId", doc.getRecordId());
                jobj.put("deleteflag",doc.getDeleteflag());
                jobj.put("tags", doc.getTags());
                jobj.put("comments", doc.getComments());
                jobj.put("isshared", doc.getIsshared());
                jar.put(jobj);
            }
        } catch (ServiceException ex) {
            Logger.getLogger(productHandler.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception e) {
            Logger.getLogger(productHandler.class.getName()).log(Level.SEVERE, null, e);
        }
        return jar;
    }

    /**
     * description : return Sync Product associated Docs & update the sharedflag true for sharable docs.
     *
     * @param requestParams
     * @return
     * @throws ServiceException
     */
    public KwlReturnObject getDocuments(Map<String, Object> requestParams) throws ServiceException {
        List ll = new ArrayList();
        int size = 0;
        String productid = "", moduleid = "", companyid = "";
        try {
            if (requestParams != null) {
                productid = (String) requestParams.get("recid");
                moduleid = (String) requestParams.get("module");
                companyid = (String) requestParams.get("companyid");
            }
            String Hql = "FROM com.krawler.common.admin.Docs dm where dm.recordId=? and dm.moduleId=? and dm.company.companyID=? and dm.deleteflag!=1 order by uploadedon desc";
            ll = executeQuery(Hql, new Object[]{productid, moduleid, companyid});
            size = ll.size();

            //Update isshared flag in Docs Table, if document is available for given product
            if (ll.size() > 0) {
                String delQuery = "UPDATE com.krawler.common.admin.Docs dm SET dm.isshared='1' WHERE dm.moduleId=? and  dm.recordId=? and dm.company.companyID=?";
                executeUpdate(delQuery, new Object[]{moduleid, productid, companyid});
            }
        } catch (Exception e) {
            throw ServiceException.FAILURE("documentDAOImpl.getDocuments : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, null, "", ll, size);
    }
    /*
     * Delete Landing Cost Product Category  ERP-20637
     */
    public KwlReturnObject deleteProductLandingCostCategory(String productId) throws ServiceException{
        String delQuery = "delete from productid_landingcostcategoryid where productid = ?";
        int numRows = executeSQLUpdate( delQuery, new Object[]{productId});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    /**
     * 
     * @param requestParams
     * @return
     * @throws ServiceException 
     * @DESC get dimension value tagged to product 
     */
    public KwlReturnObject getProductCustomData(Map<String, Object> requestParams) throws ServiceException {
        String colnum = (String) requestParams.get("colnum");
        String productid = (String) requestParams.get("productid");
        boolean isdefaultbom = false;
        List returnList = new ArrayList();
        String query = "select col" + colnum + " from accproductcustomdata where productId = '" + productid + "'";
        returnList = executeSQLQuery(query);
        return new KwlReturnObject(true, "", null, returnList, returnList.size());
    }

    @Override
    public double getCycleCountQuantity(Map<String, Object> requestParams) throws ServiceException {
        List returnList = new ArrayList();
        ArrayList params = new ArrayList();
        String company="";
        String product="";
        Date businessDate=null;
        String storeId="";
        double quantity=0;
        if (requestParams.containsKey("company") && requestParams.get("company") != null) {
            company = requestParams.get("company").toString();
            params.add(company);
        }
        if (requestParams.containsKey("product") && requestParams.get("product") != null) {
            product = requestParams.get("product").toString();
            params.add(product);
        }
        if (requestParams.containsKey("businessDate") && requestParams.get("businessDate") != null) {
            businessDate = (Date)requestParams.get("businessDate");
            params.add(businessDate);
        }
        if (requestParams.containsKey("store") && requestParams.get("store") != null) {
            storeId = requestParams.get("store").toString();
            params.add(storeId);
        }
        String query = "select sum(in_cc_detail.stockuom_count) from in_cyclecount INNER JOIN in_cc_detail on in_cyclecount.id=in_cc_detail.cyclecount where in_cyclecount.company=? and "
                     +" in_cyclecount.product=? and in_cyclecount.businessdate=? and in_cyclecount.store=?";
        returnList = executeSQLQuery(query, params.toArray());
        if (returnList != null && returnList.get(0)!=null) {
            quantity = (Double) returnList.get(0);
        }
        return authHandler.roundQuantity(quantity,company);
    }
    
    /**
     * Method used to get purchase invoice Ids using landed invoice ID.
     * @param landedInvoiceID
     * @param companyid
     * @return
     * @throws ServiceException
     */
    @Override
    public List getConsignmentInvoice(String landedInvoiceID, String companyid) throws ServiceException {
        String query = " select gr.id from goodsreceipt gr INNER JOIN goodsreceiptid_landedInvoice tgl on gr.id=tgl.goodsreceiptid where tgl.landedinvoice=? and gr.company=? ";
        List list = executeSQLQuery(query, new Object[]{landedInvoiceID, companyid});
        return list;
    }
    
    @Override
    @Transactional(propagation = Propagation.REQUIRED)
    public IncidentCases getIncidentById(Map<String, Object> requestParams) throws ServiceException {
        String incidentId = requestParams.get("incidentId").toString();
        IncidentCases incidentCasesObj = (IncidentCases) get(IncidentCases.class, incidentId);
        return incidentCasesObj;
    }
    
    @Override
    public KwlReturnObject getAssemblyProductDefaultBuildOfMaterials(String productid) throws ServiceException {
        try {
            String selectQuery = "FROM com.krawler.hql.accounting.ProductAssembly pa WHERE pa.product.ID=? AND bomdetail.isDefaultBOM=TRUE";
            List Records = executeQuery(selectQuery, new Object[]{productid});
            return new KwlReturnObject(true, "Bill of Materials", null, Records, Records.size());
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
            throw ServiceException.FAILURE("acc.ProductImpl.getAssemblyProductDefaultBuildOfMaterials : " + ex.getMessage(), ex);
        }
    }
    @Override
    public List getProductsCategoryByProductID(String companyid, String productid) {
        String categoryName = "";
        List list = new ArrayList();
        String query = "";
        try {
            query = "SELECT m.value FROM masteritem m INNER JOIN productcategorymapping pc ON pc.productcategory=m.id WHERE m.company=? AND pc.productid=?";
            list = executeSQLQuery(query, new Object[]{companyid, productid});
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return list;
    }     
    /**
     *
     * @param reqParams
     * @return
     * @throws ServiceException
     * @Desc : Get Ingradient of Assembly Items
     */
    public KwlReturnObject getSubAssemblyProduct(JSONObject reqParams) throws ServiceException {
        try {
            String productid = reqParams.optString("productid");
            String query = "from ProductAssembly p where p.product.ID=?";
            List list = executeQuery(query, new Object[]{productid});
            return new KwlReturnObject(true, "", null, list, list.size());
        } catch (Exception ex) {
            throw ServiceException.FAILURE("checkSubProductforAssembly : " + ex.getMessage(), ex);
        }
    }
/**
 * 
 * @param productid
 * @Desc : Get sum of Price for sub products of assembly product
 * @return
 * @throws ServiceException 
 */
    public double getSumOfPurchasePriceForSubassebmblyItems(String productid) throws ServiceException {
        double rate = 0;
        String query = "select sum(pl.price) from pricelist pl inner join product p on pl.product=p.id "
                + "inner join productassembly pa on pa.subproducts=p.id where pa.product=? group by p.id";
        List list = executeSQLQuery(query, new Object[]{productid});
        if (list.size() > 0 && list.get(0) != null) {
            rate = (double) list.get(0);
        }
        return rate;

    }
    
    @Override
    public Map<String, Double> getProductQuantityUnderQA(Company company, Store store) throws ServiceException {
        Map productStockDetailMap = new HashMap();
        List params = new ArrayList();
        StringBuilder hql = new StringBuilder();

        hql.append(" SELECT product, SUM(quantity) FROM (");

        hql.append(" SELECT sa.product, sada.quantity FROM in_sa_detail_approval  sada ");
        hql.append(" INNER JOIN in_sa_approval saa ON  sada.sa_approval = saa.id ");
        hql.append(" INNER JOIN in_sa_detail sad ON  sad.id = sada.stock_adjustment_detail ");
        hql.append(" INNER JOIN in_stockadjustment sa ON sa.id = saa.stock_adjustment ");
        hql.append(" WHERE  sa.company = ? AND (sada.approval_status = 0)");

        params.add(company);
        if (store != null) {
            hql.append(" AND sa.store = ? ");
            params.add(store.getId());
        }

        hql.append(" UNION ALL ");

        hql.append(" SELECT st.product, stda.quantity FROM in_stocktransfer_detail_approval  stda ");
        hql.append(" INNER JOIN in_stocktransfer_approval sta ON  stda.stocktransfer_approval = sta.id ");
        hql.append(" INNER JOIN in_ist_detail std ON  std.id = stda.stocktransfer_detail_id ");
        hql.append(" INNER JOIN in_interstoretransfer st ON st.id = sta.stocktransferid ");
        hql.append(" WHERE  st.company = ? AND (stda.approval_status = 0 ) ");

        params.add(company);
        if (store != null) {
            hql.append(" AND st.tostore = ? ");
            params.add(store.getId());
        }

        hql.append(" UNION ALL ");
        /**
         * Quantity in QA store for Goods Receipt Order.
         */
        hql.append("SELECT p.id as product, grodistmapping.quantitydue as quantity from grodetailistmapping grodistmapping ");
        hql.append("inner join grodetails grod on grodistmapping.grodetail = grod.id ");
        hql.append("inner join product p on grod.product = p.id ");
        hql.append("inner join grorder gro on gro.id = grod.grorder ");
        hql.append("left join locationbatchdocumentmapping lbdm on grod.id=lbdm.documentid ");
        hql.append("inner join newproductbatch npb on lbdm.batchmapid=npb.id ");
        hql.append("inner join in_interstoretransfer inst on inst. fromstore = npb.warehouse and grodistmapping.istrequest = inst.id ");
        hql.append("inner join in_storemaster str on str.id = npb.warehouse  where gro.company = ? ");
        params.add(company);
        if (store != null) {
            hql.append(" AND npb.warehouse = ? ");
            params.add(store.getId());
        }

        hql.append(" GROUP BY grodistmapping.id ");
        
        hql.append(" UNION ALL ");
        /**
         * Quantity in QA store for WORK ORDER.
         */
        hql.append("SELECT p.id as product, wocdistmapping.quantitydue as quantity from wocdetailistmapping wocdistmapping ");
        hql.append("inner join workordercomponentdetail wocd on wocdistmapping.wocdetail = wocd.id ");
        hql.append("inner join product p on wocd.product = p.id ");
        hql.append("inner join workorder wo on wo.id = wocd.workorder ");
        hql.append("left join locationbatchdocumentmapping lbdm on wocd.id=lbdm.documentid ");
        hql.append("inner join newproductbatch npb on lbdm.batchmapid=npb.id ");
        hql.append("inner join in_interstoretransfer inst on inst. fromstore = npb.warehouse and wocdistmapping.istrequest = inst.id ");
        hql.append("inner join in_storemaster str on str.id = npb.warehouse  where wo.company = ? ");
        params.add(company);
        if (store != null) {
            hql.append(" AND npb.warehouse = ? ");
            params.add(store.getId());
        }

        hql.append(" GROUP BY wocdistmapping.id ");
        
        hql.append(" UNION ALL ");
        /**
         * Quantity in QA store for Delivery Order.
         */
        hql.append("select p.id as product, dodistmapping.quantitydue as quantity from dodqcistmapping dodistmapping ");
        hql.append("inner join dodetails dod on  dod.id = dodistmapping.dodetailid ");
        hql.append("inner join deliveryorder do on do.id = dod.deliveryorder ");
        hql.append("inner join in_interstoretransfer inst on dodistmapping.qcistrequest = inst.id ");
        hql.append("inner join product p on inst.product = p.id ");
        hql.append("inner join uom u on u.id = inst.uom ");
        hql.append("inner join in_storemaster str on str.id = inst.fromstore where do.company = ? ");

        params.add(company);
        if (store != null) {
            hql.append(" AND str.id = ? ");
            params.add(store.getId());
        }

        hql.append(" UNION ALL ");

        hql.append(" SELECT st.product, stda.quantity FROM in_stocktransfer_detail_approval  stda ");
        hql.append(" INNER JOIN in_stocktransfer_approval sta ON  stda.stocktransfer_approval = sta.id ");
        hql.append(" INNER JOIN in_sr_detail std ON  std.id = stda.stocktransfer_detail_id ");
        hql.append(" INNER JOIN in_goodsrequest st ON st.id = sta.stocktransferid ");
        hql.append(" WHERE  st.company = ? AND (stda.approval_status = 0 ) ");

        params.add(company);
        if (store != null) {
            hql.append(" AND st.fromstore = ? ");
            params.add(store.getId());
        }

        hql.append(" UNION ALL ");

        hql.append(" SELECT  ca .product, cda.quantity FROM in_consignmentdetails  cda ");
        hql.append(" INNER JOIN in_consignment ca ON  cda.consignment = ca.id ");
        hql.append(" WHERE  ca.company = ? AND (cda.approval_status = 0 ) ");

        params.add(company);
        if (store != null) {
            hql.append(" AND ca.store = ? ");
            params.add(store.getId());
        }

        hql.append(") combineTbl GROUP BY product ");
//        if (store != null) {
//        } else {
//            hql.append(" GROUP BY product");
//        }

        List list = executeSQLQuery(hql.toString(), params.toArray());

        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            Object[] objs = (Object[]) itr.next();
            String productId = objs[0] != null ? (String) objs[0] : null;
            double quantity = objs[1] != null ? (Double) objs[1] : 0;
            productStockDetailMap.put(productId, authHandler.roundQuantity(quantity,company.getCompanyID()));

        }
        return productStockDetailMap;
    }

    @Override
    public Map<String, Double> getProductQuantityUnderRepair(Company company, Store store) throws ServiceException {
        Map productStockDetailMap = new HashMap();
        List params = new ArrayList();
        StringBuilder hql = new StringBuilder();

        hql.append(" SELECT product, SUM(quantity) FROM (");

        hql.append(" SELECT sa.product, sada.quantity FROM in_sa_detail_approval  sada ");
        hql.append(" INNER JOIN in_sa_approval saa ON  sada.sa_approval = saa.id ");
        hql.append(" INNER JOIN in_sa_detail sad ON  sad.id = sada.stock_adjustment_detail ");
        hql.append(" INNER JOIN in_stockadjustment sa ON sa.id = saa.stock_adjustment ");
        hql.append(" WHERE  sa.company = ? AND (sada.repair_status IN (4,7) )");

        params.add(company);
        if (store != null) {
            hql.append(" AND sa.store = ? ");
            params.add(store.getId());
        }

        hql.append(" UNION ALL ");

        hql.append(" SELECT st.product, stda.quantity FROM in_stocktransfer_detail_approval  stda ");
        hql.append(" INNER JOIN in_stocktransfer_approval sta ON  stda.stocktransfer_approval = sta.id ");
        hql.append(" INNER JOIN in_ist_detail std ON  std.id = stda.stocktransfer_detail_id ");
        hql.append(" INNER JOIN in_interstoretransfer st ON st.id = sta.stocktransferid ");
        hql.append(" WHERE  st.company = ? AND (stda.repair_status IN (4,7) ) ");

        params.add(company);
        if (store != null) {
            hql.append(" AND st.tostore = ? ");
            params.add(store.getId());
        }

        hql.append(" UNION ALL ");
        /**
         * Quantity in Repair store for Goods Receipt Order.
         */
        hql.append(" select p.id as product, rm.rejectedquantitydue as quantity from repairgrodistmapping rm");
        hql.append(" inner join grodetailistmapping grodistmapping on grodistmapping.id = rm.grodistmapping ");
        hql.append(" inner join grodetails grod on grodistmapping.grodetail = grod.id ");
        hql.append(" inner join product p on grod.product = p.id ");
        hql.append(" inner join grorder gro on gro.id = grod.grorder ");
        hql.append(" left join locationbatchdocumentmapping lbdm on grod.id=lbdm.documentid ");
        hql.append(" inner join newproductbatch npb on lbdm.batchmapid=npb.id ");
        hql.append("where gro.company = ? ");

        params.add(company);
        if (store != null) {
            hql.append(" AND npb.warehouse  = ? ");
            params.add(store.getId());
        }
        
        hql.append(" GROUP BY rm.grodistmapping");
        hql.append(" UNION ALL ");
        /**
         * Quantity in Repair store for WORK ORDER.
         */
        hql.append(" SELECT p.id as product, rwocdim.rejectedquantitydue as quantity from repairwocdistmapping rwocdim ");
        hql.append(" inner join wocdetailistmapping wocdistmapping on wocdistmapping.id = rwocdim.wocdistmapping ");
        hql.append(" inner join workordercomponentdetail wocd on wocdistmapping.wocdetail = wocd.id ");
        hql.append(" inner join product p on wocd.product = p.id ");
        hql.append(" inner join workorder wo on wo.id = wocd.workorder ");
        hql.append(" left join locationbatchdocumentmapping lbdm on wocd.id=lbdm.documentid ");
        hql.append(" inner join newproductbatch npb on lbdm.batchmapid=npb.id ");
        hql.append(" where wo.company = ? ");
        params.add(company);
        if (store != null) {
            hql.append(" AND npb.warehouse = ? ");
            params.add(store.getId());
        }
    
        hql.append(" GROUP BY rwocdim.wocdistmapping");
        hql.append(" UNION ALL ");
        /**
         * Quantity in Repair store for Delivery Order.
         */
        hql.append(" select p.id as product, rm.quantitydue as quantity from rejectdodistmapping rm ");
        hql.append(" inner join dodqcistmapping dodm on dodm.id = rm.dodqcistmapping ");
        hql.append(" inner join dodetails dod on dodm.dodetailid = dod.id ");
        hql.append(" inner join product p on dod.product = p.id ");
        hql.append(" inner join deliveryorder do on do.id = dod.deliveryorder ");
        hql.append(" inner join in_interstoretransfer inst on dodm.qcistrequest = inst.id ");
        hql.append(" inner join uom u on u.id = inst.uom ");
        hql.append(" inner join in_storemaster str on str.id = inst.fromstore ");
        hql.append(" where do.company = ?");

        params.add(company);
        if (store != null) {
            hql.append(" AND str.id  = ? ");
            params.add(store.getId());
        }

        hql.append(" UNION ALL ");

        hql.append(" SELECT st.product, stda.quantity FROM in_stocktransfer_detail_approval  stda ");
        hql.append(" INNER JOIN in_stocktransfer_approval sta ON  stda.stocktransfer_approval = sta.id ");
        hql.append(" INNER JOIN in_sr_detail std ON  std.id = stda.stocktransfer_detail_id ");
        hql.append(" INNER JOIN in_goodsrequest st ON st.id = sta.stocktransferid ");
        hql.append(" WHERE  st.company = ? AND (stda.repair_status IN (4,7) ) ");

        params.add(company);
        if (store != null) {
            hql.append(" AND st.fromstore = ? ");
            params.add(store.getId());
        }

        hql.append(" UNION ALL ");

        hql.append(" SELECT ca .product, cda.quantity FROM in_consignmentdetails  cda ");
        hql.append(" INNER JOIN in_consignment ca ON  cda.consignment = ca.id ");
        hql.append(" WHERE  ca.company = ? AND (cda.repair_status IN (4,7) ) ");

        params.add(company);
        if (store != null) {
            hql.append(" AND ca.store = ? ");
            params.add(store.getId());
        }

        hql.append(") combineTbl GROUP BY product ");
//        if (store != null) {
//        } else {
//            hql.append(" GROUP BY product");
//        }

        List list = executeSQLQuery(hql.toString(), params.toArray());

        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            Object[] objs = (Object[]) itr.next();
            String productId = objs[0] != null ? (String) objs[0] : null;
            double quantity = objs[1] != null ? (Double) objs[1] : 0;
            productStockDetailMap.put(productId, authHandler.roundQuantity(quantity,company.getCompanyID()));

        }
        return productStockDetailMap;
    }
    @Override
    public Map<String, Double> getProductQuantityUnderQAForGRNAndDO(Company company, Store store, boolean isGRNOnly) throws ServiceException {
        Map productStockDetailMap = new HashMap();
        List params = new ArrayList();
        StringBuilder hql = new StringBuilder();

        hql.append(" SELECT product, SUM(quantity) FROM (");

        /**
         * Quantity in QA store for Goods Receipt Order.
         */
        hql.append("SELECT p.id as product, grodistmapping.quantitydue as quantity from grodetailistmapping grodistmapping ");
        hql.append("inner join grodetails grod on grodistmapping.grodetail = grod.id ");
        hql.append("inner join product p on grod.product = p.id ");
        hql.append("inner join grorder gro on gro.id = grod.grorder ");
        hql.append("left join locationbatchdocumentmapping lbdm on grod.id=lbdm.documentid ");
        hql.append("inner join newproductbatch npb on lbdm.batchmapid=npb.id ");
        hql.append("inner join in_interstoretransfer inst on inst. fromstore = npb.warehouse and grodistmapping.istrequest = inst.id ");
        hql.append("inner join in_storemaster str on str.id = npb.warehouse  where gro.company = ? ");
        params.add(company);
        if (store != null) {
            hql.append(" AND npb.warehouse = ? ");
            params.add(store.getId());
        }

        hql.append(" GROUP BY grodistmapping.id ");
        if (!isGRNOnly) {
            hql.append(" UNION ALL ");
            /**
             * Quantity in QA store for Delivery Order.
             */
            hql.append("select p.id as product, dodistmapping.quantitydue as quantity from dodqcistmapping dodistmapping ");
            hql.append("inner join dodetails dod on  dod.id = dodistmapping.dodetailid ");
            hql.append("inner join deliveryorder do on do.id = dod.deliveryorder ");
            hql.append("inner join in_interstoretransfer inst on dodistmapping.qcistrequest = inst.id ");
            hql.append("inner join product p on inst.product = p.id ");
            hql.append("inner join uom u on u.id = inst.uom ");
            hql.append("inner join in_storemaster str on str.id = inst.fromstore where do.company = ? ");

            params.add(company);
            if (store != null) {
                hql.append(" AND str.id = ? ");
                params.add(store.getId());
            }
        }
        hql.append(") combineTbl GROUP BY product ");
        List list = executeSQLQuery(hql.toString(), params.toArray());

        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            Object[] objs = (Object[]) itr.next();
            String productId = objs[0] != null ? (String) objs[0] : null;
            double quantity = objs[1] != null ? (Double) objs[1] : 0;
            productStockDetailMap.put(productId, authHandler.roundQuantity(quantity,company.getCompanyID()));

        }
        return productStockDetailMap;
    }
    
    
    @Override
    public Map<String, Double> getProductQuantityUnderQAForWO(Company company, Store store, boolean isWOOnly) throws ServiceException {
        Map productStockDetailMap = new HashMap();
        List params = new ArrayList();
        StringBuilder hql = new StringBuilder();

        hql.append(" SELECT product, SUM(quantity) FROM (");

        
        /**
         * Quantity in QA store for WORK ORDER.
         */
        hql.append("SELECT p.id as product, wocdistmapping.quantitydue as quantity from wocdetailistmapping wocdistmapping ");
        hql.append("inner join workordercomponentdetail wocd on wocdistmapping.wocdetail = wocd.id ");
        hql.append("inner join product p on wocd.product = p.id ");
        hql.append("inner join workorder wo on wo.id = wocd.workorder ");
        hql.append("left join locationbatchdocumentmapping lbdm on wocd.id=lbdm.documentid ");
        hql.append("inner join newproductbatch npb on lbdm.batchmapid=npb.id ");
        hql.append("inner join in_interstoretransfer inst on inst. fromstore = npb.warehouse and wocdistmapping.istrequest = inst.id ");
        hql.append("inner join in_storemaster str on str.id = npb.warehouse  where wo.company = ? ");
        params.add(company);
        if (store != null) {
            hql.append(" AND npb.warehouse = ? ");
            params.add(store.getId());
        }

        hql.append(" GROUP BY wocdistmapping.id ");
        
        hql.append(") combineTbl GROUP BY product ");
        List list = executeSQLQuery(hql.toString(), params.toArray());

        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            Object[] objs = (Object[]) itr.next();
            String productId = objs[0] != null ? (String) objs[0] : null;
            double quantity = objs[1] != null ? (Double) objs[1] : 0;
            productStockDetailMap.put(productId, authHandler.roundQuantity(quantity,company.getCompanyID()));

        }
        return productStockDetailMap;
    }

    @Override
    public Map<String, Double> getProductQuantityUnderRepairForGRNAndDO(Company company, Store store, boolean isGRNOnly) throws ServiceException {
        Map productStockDetailMap = new HashMap();
        List params = new ArrayList();
        StringBuilder hql = new StringBuilder();

        hql.append(" SELECT product, SUM(quantity) FROM (");

        /**
         * Quantity in Repair store for Goods Receipt Order.
         */
        hql.append(" select p.id as product, rm.rejectedquantitydue as quantity from repairgrodistmapping rm");
        hql.append(" inner join grodetailistmapping grodistmapping on grodistmapping.id = rm.grodistmapping ");
        hql.append(" inner join grodetails grod on grodistmapping.grodetail = grod.id ");
        hql.append(" inner join product p on grod.product = p.id ");
        hql.append(" inner join grorder gro on gro.id = grod.grorder ");
        hql.append(" left join locationbatchdocumentmapping lbdm on grod.id=lbdm.documentid ");
        hql.append(" inner join newproductbatch npb on lbdm.batchmapid=npb.id ");
        hql.append("where gro.company = ? ");

        params.add(company);
        if (store != null) {
            hql.append(" AND npb.warehouse  = ? ");
            params.add(store.getId());
        }
        hql.append(" GROUP BY rm.grodistmapping");
        if (!isGRNOnly) {
            hql.append(" UNION ALL ");
            /**
             * Quantity in Repair store for Delivery Order.
             */
            hql.append(" select p.id as product, rm.quantitydue as quantity from rejectdodistmapping rm ");
            hql.append(" inner join dodqcistmapping dodm on dodm.id = rm.dodqcistmapping ");
            hql.append(" inner join dodetails dod on dodm.dodetailid = dod.id ");
            hql.append(" inner join product p on dod.product = p.id ");
            hql.append(" inner join deliveryorder do on do.id = dod.deliveryorder ");
            hql.append(" inner join in_interstoretransfer inst on dodm.qcistrequest = inst.id ");
            hql.append(" inner join uom u on u.id = inst.uom ");
            hql.append(" inner join in_storemaster str on str.id = inst.fromstore ");
            hql.append(" where do.company = ?");

            params.add(company);
            if (store != null) {
                hql.append(" AND str.id  = ? ");
                params.add(store.getId());
            }
            
        }
        hql.append(") combineTbl GROUP BY product ");

        List list = executeSQLQuery(hql.toString(), params.toArray());

        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            Object[] objs = (Object[]) itr.next();
            String productId = objs[0] != null ? (String) objs[0] : null;
            double quantity = objs[1] != null ? (Double) objs[1] : 0;
            productStockDetailMap.put(productId, authHandler.roundQuantity(quantity,company.getCompanyID()));

        }
        return productStockDetailMap;
    }
       
    @Override
    public Map<String, Double> getProductQuantityUnderRepairForWO(Company company, Store store, boolean isGRNOnly) throws ServiceException {
        Map productStockDetailMap = new HashMap();
        List params = new ArrayList();
        StringBuilder hql = new StringBuilder();

        hql.append(" SELECT product, SUM(quantity) FROM (");

        /**
         * Quantity in Repair store for WORK ORDER.
         */
       
        hql.append(" SELECT p.id as product, rwocdim.rejectedquantitydue as quantity from repairwocdistmapping rwocdim ");
        hql.append(" inner join wocdetailistmapping wocdistmapping on wocdistmapping.id = rwocdim.wocdistmapping ");
        hql.append(" inner join workordercomponentdetail wocd on wocdistmapping.wocdetail = wocd.id ");
        hql.append(" inner join product p on wocd.product = p.id ");
        hql.append(" inner join workorder wo on wo.id = wocd.workorder ");
        hql.append(" left join locationbatchdocumentmapping lbdm on wocd.id=lbdm.documentid ");
        hql.append(" inner join newproductbatch npb on lbdm.batchmapid=npb.id ");
        hql.append(" where wo.company = ? ");
        params.add(company);
        if (store != null) {
            hql.append(" AND npb.warehouse = ? ");
            params.add(store.getId());
        }
        hql.append(" GROUP BY rwocdim.wocdistmapping");
        hql.append(") combineTbl GROUP BY product ");

        List list = executeSQLQuery(hql.toString(), params.toArray());

        Iterator itr = list.iterator();
        while (itr.hasNext()) {
            Object[] objs = (Object[]) itr.next();
            String productId = objs[0] != null ? (String) objs[0] : null;
            double quantity = objs[1] != null ? (Double) objs[1] : 0;
            productStockDetailMap.put(productId, authHandler.roundQuantity(quantity,company.getCompanyID()));

        }
        return productStockDetailMap;
    }
    
    /**
     * Description-Used to unmapped accounts while deleting product
     * @param productid
     * @throws ServiceException 
     */
    @Override
    public void unmapAccount(String productid) throws ServiceException {
        Product product = (Product) get(Product.class, productid);
        if (product.getPurchaseAccount() != null) {
            Account currentpaccount = product.getPurchaseAccount();
            String CurrentUsedIn = currentpaccount.getUsedIn();
            CurrentUsedIn = StringUtil.replaceUsedIn(CurrentUsedIn, Constants.Product_Purchase_Account);
            currentpaccount.setUsedIn(CurrentUsedIn);
            saveOrUpdate(currentpaccount);
        }
        if (product.getSalesAccount() != null) {
            Account currentsaccount = product.getSalesAccount();
            String CurrentUsedIn = currentsaccount.getUsedIn();
            CurrentUsedIn = StringUtil.replaceUsedIn(CurrentUsedIn, "Product Sales Account");
            currentsaccount.setUsedIn(CurrentUsedIn);
            saveOrUpdate(currentsaccount);
        }

        if (product.getPurchaseReturnAccount() != null) {
            Account currentpraccount = product.getPurchaseReturnAccount();
            String CurrentUsedIn = currentpraccount.getUsedIn();
            CurrentUsedIn = StringUtil.replaceUsedIn(CurrentUsedIn, Constants.Product_Purchase_Return_Account);
            currentpraccount.setUsedIn(CurrentUsedIn);
            saveOrUpdate(currentpraccount);
        }

        if (product.getSalesReturnAccount() != null) {
            Account currentsraccount = product.getSalesReturnAccount();
            String CurrentUsedIn = currentsraccount.getUsedIn();
            CurrentUsedIn = StringUtil.replaceUsedIn(CurrentUsedIn, Constants.Product_Sales_Return_Account);
            currentsraccount.setUsedIn(CurrentUsedIn);
            saveOrUpdate(currentsraccount);
        }
    }
    /**
     * DAO to return build assembly product details
     * @param transactionId
     * @return KwlReturnObject
     * @throws ServiceException
     */
    @Override
    public KwlReturnObject getBuildAssemblyProdcutDetails(String transactionId) throws ServiceException {
        List result = new ArrayList();
        try {
            String query = "select id from pbdetails where build = ?";
            List ProductBuildDetailsIds = executeSQLQuery(query, new Object[]{transactionId});
            for(int i = 0; i < ProductBuildDetailsIds.size(); i++) {
                ProductBuildDetails productBuildDetails = (ProductBuildDetails) get(ProductBuildDetails.class, ProductBuildDetailsIds.get(i).toString());
                if(productBuildDetails != null) {
                    result.add(productBuildDetails);
                }
            }            
        } catch (Exception e) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, e.getMessage());
            throw ServiceException.FAILURE("getBuildAssemblyDetailsItemJSON : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "getBuildAssemblyDetailsItemJSON", null, result, result.size());
    }
    public KwlReturnObject checkIsAssetIDAlreadyUsed(Map<String, Object> requestParams,NewBatchSerial batchserialOBj)throws   ServiceException{
        List resultList=Collections.emptyList();
        List filterParams=new ArrayList();
        boolean succesMsg=false;
        try{
            String hqlQuery=" from NewBatchSerial where company.companyID= ? and skufield= ? and product.id!= ? and serialname!=? ";
            filterParams.add(requestParams.get("company"));
            filterParams.add(requestParams.get("SkufieldValue"));
            filterParams.add(batchserialOBj.getProduct());
            filterParams.add(batchserialOBj.getSerialname());
            resultList=executeQuery(hqlQuery, filterParams.toArray());
            succesMsg=true;
        }catch(Exception ex){
                throw ServiceException.FAILURE("AccProductDaoImpl.checkIsAssetIDAlreadyUsed", ex);
        }
       return new KwlReturnObject(succesMsg, null, null, resultList, resultList.size());
     } 
    @Override
    public JSONObject getProductDisplayUOM(Product product, double quantity, double baseuomrate, boolean carryin, JSONObject obj) throws ServiceException {
        HashMap<String, Object> requestParams = new HashMap<>();
        try {
            String uomschematype = (product.getUomSchemaType() != null) ? product.getUomSchemaType().getID() : "";
            String displayuomid = (product.getDisplayUoM() != null) ? product.getDisplayUoM().getID(): "";
            if (!StringUtil.isNullOrEmpty(uomschematype) && !StringUtil.isNullOrEmpty(displayuomid)) {
                String companyid = (product.getCompany() != null) ? product.getCompany().getCompanyID(): "";
                requestParams.put("uomschematypeid", uomschematype);
                requestParams.put("currentuomid", displayuomid);
                requestParams.put("companyid", companyid);
                requestParams.put("carryin", carryin);
                KwlReturnObject res = getProductBaseUOMRate(requestParams);
                List<UOMSchema> list = res.getEntityList();
                if (list.size() > 0) {
                    for (UOMSchema us : list) {
                        obj.put("displayuomrate", us.getBaseuomrate());
                        double displayuomvalue = (quantity * baseuomrate) / us.getBaseuomrate();
                        obj.put("displayuomvalue", displayuomvalue);
                        obj.put(CustomDesignerConstants.DISPLAY_UOM, authHandler.formattedQuantity(displayuomvalue, companyid) + " " + product.getDisplayUoM().getNameEmptyforNA());
                    }
                } else {
                    obj.put("displayuomrate",1);
                    obj.put("displayuomvalue", quantity);
                    obj.put(CustomDesignerConstants.DISPLAY_UOM, authHandler.formattedQuantity(quantity, companyid) + " " + product.getDisplayUoM().getNameEmptyforNA());
                }
                obj.put("displayUoMid", product.getDisplayUoM().getID());
                obj.put("displayUoMName", product.getDisplayUoM().getNameEmptyforNA());
                obj.put("uomschematypeid", product.getUomSchemaType().getID());
                obj.put("baseuomid", product.getUnitOfMeasure()!=null?product.getUnitOfMeasure().getID():"");
            }
        } catch (JSONException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return obj;
    }
     
    /**
     * Description-Used to get Product Discount applied in Price Band screen
     * @param HashMap requestParams
     * @throws ServiceException 
     */
    @Override
    public KwlReturnObject getProductDiscountFromPriceListBand(HashMap<String, Object> requestParams) throws ServiceException {
        List result = new ArrayList();
        try {
        } catch (Exception e) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, e.getMessage());
            throw ServiceException.FAILURE("getProductDiscountFromPriceListBand : " + e.getMessage(), e);
        }
        return new KwlReturnObject(true, "getProductDiscountFromPriceListBand", null, result, result.size());
    }
    
    /**
     * Description - This method has written to get Batch Details for selected product & used for Barcode Purpose.
     * @param String, String
     * @throws ServiceException 
     */
    @Override
    public KwlReturnObject getBatchDetailsByProductID(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String q = "FROM com.krawler.common.admin.NewProductBatch nbp WHERE nbp.product=? and nbp.company.companyID=?";
        list = executeQuery( q, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    
    /**
     * Method to get approved/rejected/picked quantity from QC and repair store
     * for Delivery Order QC.
     *
     * @param company
     * @param store
     * @return
     * @throws ServiceException
     */
    @Override
    public Map<String, Double> getProductApprovedOrRejectedOrPickedQty(Company company, Store store) throws ServiceException {
        Map productStockDetailMap = new HashMap();
        List params = new ArrayList();
        StringBuilder hql = new StringBuilder();
        try {
            hql.append(" SELECT product, SUM(quantity) FROM (");
            /**
             * Quantity rejected from repair store for Delivery Order QC.
             */
            hql.append(" select p.id as product, rm.rejectedquantity as quantity from rejectdodistmapping rm ");
            hql.append(" inner join dodqcistmapping dodm on dodm.id = rm.dodqcistmapping ");
            hql.append(" inner join dodetails dod on dodm.dodetailid = dod.id ");
            hql.append(" inner join product p on dod.product = p.id ");
            hql.append(" inner join deliveryorder do on do.id = dod.deliveryorder ");
            hql.append(" inner join in_interstoretransfer inst on dodm.qcistrequest = inst.id ");
            hql.append(" inner join uom u on u.id = inst.uom ");
            hql.append(" inner join in_storemaster str on str.id = inst.fromstore ");
            hql.append(" where do.company = ?");

            params.add(company);
            if (store != null) {
                hql.append(" AND str.id  = ? ");
                params.add(store.getId());
            }
            hql.append(" UNION ALL ");
            /**
             * Quantity approved from repair store for Delivery Order QC.
             */
            hql.append(" select p.id as product, rm.repairedquantity as quantity from rejectdodistmapping rm ");
            hql.append(" inner join dodqcistmapping dodm on dodm.id = rm.dodqcistmapping ");
            hql.append(" inner join dodetails dod on dodm.dodetailid = dod.id ");
            hql.append(" inner join product p on dod.product = p.id ");
            hql.append(" inner join deliveryorder do on do.id = dod.deliveryorder ");
            hql.append(" inner join in_interstoretransfer inst on dodm.qcistrequest = inst.id ");
            hql.append(" inner join uom u on u.id = inst.uom ");
            hql.append(" inner join in_storemaster str on str.id = inst.fromstore ");
            hql.append(" where do.company = ?");

            params.add(company);
            if (store != null) {
                hql.append(" AND str.id  = ? ");
                params.add(store.getId());
            }

            hql.append(" UNION ALL ");
            /**
             * Quantity send to packing store (pick/pack/ship is activated) from
             * repair store for Delivery Order QC.
             */
            hql.append(" select p.id as product, rm.pickedquantity as quantity from rejectdodistmapping rm ");
            hql.append(" inner join dodqcistmapping dodm on dodm.id = rm.dodqcistmapping ");
            hql.append(" inner join dodetails dod on dodm.dodetailid = dod.id ");
            hql.append(" inner join product p on dod.product = p.id ");
            hql.append(" inner join deliveryorder do on do.id = dod.deliveryorder ");
            hql.append(" inner join in_interstoretransfer inst on dodm.qcistrequest = inst.id ");
            hql.append(" inner join uom u on u.id = inst.uom ");
            hql.append(" inner join in_storemaster str on str.id = inst.fromstore ");
            hql.append(" where do.company = ?");

            params.add(company);
            if (store != null) {
                hql.append(" AND str.id  = ? ");
                params.add(store.getId());
            }
            hql.append(" UNION ALL ");
            /**
             * Quantity in QA store for Delivery Order.
             */
            hql.append("select p.id as product, dodistmapping.approvedquantity as quantity from dodqcistmapping dodistmapping ");
            hql.append("inner join dodetails dod on  dod.id = dodistmapping.dodetailid ");
            hql.append("inner join deliveryorder do on do.id = dod.deliveryorder ");
            hql.append("inner join in_interstoretransfer inst on dodistmapping.qcistrequest = inst.id ");
            hql.append("inner join product p on inst.product = p.id ");
            hql.append("inner join uom u on u.id = inst.uom ");
            hql.append("inner join in_storemaster str on str.id = inst.fromstore where do.company = ? ");

            params.add(company);
            if (store != null) {
                hql.append(" AND str.id = ? ");
                params.add(store.getId());
            }
            hql.append(" UNION ALL ");
            /**
             * Quantity in QA store for Delivery Order.
             */
            hql.append("select p.id as product, dodistmapping.pickedquantity as quantity from dodqcistmapping dodistmapping ");
            hql.append("inner join dodetails dod on  dod.id = dodistmapping.dodetailid ");
            hql.append("inner join deliveryorder do on do.id = dod.deliveryorder ");
            hql.append("inner join in_interstoretransfer inst on dodistmapping.qcistrequest = inst.id ");
            hql.append("inner join product p on inst.product = p.id ");
            hql.append("inner join uom u on u.id = inst.uom ");
            hql.append("inner join in_storemaster str on str.id = inst.fromstore where do.company = ? ");

            params.add(company);
            if (store != null) {
                hql.append(" AND str.id = ? ");
                params.add(store.getId());
            }
            hql.append(") combineTbl GROUP BY product ");
            List list = executeSQLQuery(hql.toString(), params.toArray());
            Iterator itr = list.iterator();
            while (itr.hasNext()) {
                Object[] objs = (Object[]) itr.next();
                String productId = objs[0] != null ? (String) objs[0] : null;
                double quantity = objs[1] != null ? (Double) objs[1] : 0;
                productStockDetailMap.put(productId, authHandler.roundQuantity(quantity,company.getCompanyID()));

            }
        } catch (Exception ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.WARNING, ex.getMessage());
        }
        return productStockDetailMap;
    }
   
    @Override
    public boolean saveCompanyProductPriceList(JSONObject json) throws ServiceException {
        boolean success = true;
        try {
            List params = new ArrayList();
            String getCompanyQuery = "insert into companyproductpricelist(subdomain,productid ,price,currencyid) values (?,?,?,?) ";
            params.add(json.optString("subdomain"));
            params.add(json.optString("productid"));
            params.add(json.optDouble("price"));
            params.add(json.optString("currencyid"));
            executeSQLUpdate(getCompanyQuery, params.toArray());
        } catch (Exception e) {
            success = false;
            Logger.getLogger(accProductImpl.class.getName()).log(Level.INFO, e.getMessage());
        }
        return success;
    }
    
    @Override
    public KwlReturnObject getProductByProductIdAndSubdomain(String productID, String subdomain) throws ServiceException {
        KwlReturnObject result = null;
        if (!StringUtil.isNullOrEmpty(subdomain) && !StringUtil.isNullOrEmpty(productID)) {
            ArrayList params = new ArrayList();
            params.add(productID);
            params.add(subdomain);
            String query = "select p.id,c.companyid from product p inner join company c on c.companyid = p.company where p.productid=? and c.subdomain=?";
            List list = executeSQLQuery(query, params.toArray());
            int totalCount = list.size();
            result = new KwlReturnObject(true, null, null, list, totalCount);
        }
        return result;
    }
    
    /*
     * Description - This method has written to delete stock movement entries for Assembly Product
     * @param String, String
     * @return List of KwlReturnObject
     * @throws ServiceException 
    */
    public KwlReturnObject deleteStockMovement(String parentProductId, String companyid) throws ServiceException {
        String delQuery = "DELETE FROM StockMovement where assembledProduct.ID = ? and company.companyID=?";
        int numRows = executeUpdate( delQuery, new Object[]{parentProductId,companyid});
        return new KwlReturnObject(true, "", null, null, numRows);
    }
    
     public KwlReturnObject getProductsForComboSQLQuery(HashMap<String, Object> requestParams) throws ServiceException {
        
         KwlReturnObject extraCompanyPreferencesObj ;
            ExtraCompanyPreferences extraCompanyPreferences ;
            JSONObject jobj ;
            List list= null;
            int totalCount =0;
        try {
            
            extraCompanyPreferencesObj = getObject(ExtraCompanyPreferences.class.getName(), (String) requestParams.get("companyid"));
            extraCompanyPreferences = (ExtraCompanyPreferences) extraCompanyPreferencesObj.getEntityList().get(0);
             int prodDescType = Constants.Acc_Productcombo_Include_type;
            if (!StringUtil.isNullOrEmpty(extraCompanyPreferences.getColumnPref())) {
                jobj = new JSONObject(extraCompanyPreferences.getColumnPref());
                prodDescType = (Integer) jobj.optInt("Productflag", Constants.Acc_Productcombo_Include_type) ;
               }
            String condition = "";
            int moduleID = 0;
            ArrayList params = new ArrayList();

            boolean isMultiSelectProductsids = false;
            String companyid = (String) requestParams.get("companyid");
            String ids[] = (String[]) requestParams.get("ids");
            if (requestParams.containsKey("moduleid") && requestParams.get("moduleid") != null) {
                moduleID = Integer.parseInt(requestParams.get("moduleid").toString());
            }   
            /**
             * isMultiSelectProductsids : check true when getting selected Products
             */
            if (requestParams.containsKey("isMultiSelectProductsids") && requestParams.get("isMultiSelectProductsids") != null ) {
                isMultiSelectProductsids = Boolean.parseBoolean(requestParams.get("isMultiSelectProductsids").toString());
            }
            int start = 0;
            int limit = 15;
            boolean pagingFlag = false;
            boolean quickSearchFlag = false;

            boolean isFixedAsset = false;
            if (requestParams.containsKey("isFixedAsset")) {
                isFixedAsset = (Boolean) requestParams.get("isFixedAsset");
            }
            boolean isSalesPrice = false;
            if (requestParams.containsKey("isSalesPrice")) {
                isSalesPrice = (Boolean) requestParams.get("isSalesPrice");
            }

            boolean includeBothFixedAssetAndProductFlag = false;
            if (requestParams.containsKey("includeBothFixedAssetAndProductFlag")) {
                includeBothFixedAssetAndProductFlag = (Boolean) requestParams.get("includeBothFixedAssetAndProductFlag");
            }

            boolean excludeParent = false;
            if (requestParams.containsKey("excludeParent") && !StringUtil.isNullOrEmpty(requestParams.get("excludeParent").toString())) {
                excludeParent = Boolean.parseBoolean(requestParams.get("excludeParent").toString());
        }
        // For Inventory -Product use in inventory only when werehouse and location enable for that.
            boolean isStoreLocationEnable = false;
            if (requestParams.containsKey("isStoreLocationEnable") && !StringUtil.isNullOrEmpty(requestParams.get("isStoreLocationEnable").toString())) {
                isStoreLocationEnable = Boolean.parseBoolean(requestParams.get("isStoreLocationEnable").toString());
            }

            boolean isInventoryForm = false;
            if (requestParams.containsKey("isInventoryForm") && !StringUtil.isNullOrEmpty((String) requestParams.get("isInventoryForm"))) {
                isInventoryForm = Boolean.parseBoolean((String) requestParams.get("isInventoryForm"));
            }

            boolean isWastageApplicable = false;
            if (requestParams.containsKey("isWastageApplicable")) {
                isWastageApplicable = (Boolean) requestParams.get("isWastageApplicable");
            }
            boolean isForBarcode = false;
            if (requestParams.containsKey("isForBarcode")) {
                isForBarcode = (Boolean) requestParams.get("isForBarcode");
            }

            String productStore = "";
            if (requestParams.containsKey("productStore")) {
                productStore = requestParams.get("productStore").toString();
            }

            if (requestParams.containsKey("start") && requestParams.containsKey("limit") && !StringUtil.isNullOrEmpty(requestParams.get("start").toString())) {
                start = Integer.parseInt(requestParams.get("start").toString());
                limit = Integer.parseInt(requestParams.get("limit").toString());
                pagingFlag = true;
            }
            if (requestParams.containsKey("selectedProductsIds") && requestParams.get("selectedProductsIds") != null) {
                String productIdGroup = requestParams.get("selectedProductsIds").toString();
                productIdGroup = AccountingManager.getFilterInString(productIdGroup);
                if (isMultiSelectProductsids) {
                    condition += " AND p.id IN " + productIdGroup;
                } else {
                    condition += " AND p.id NOT IN " + productIdGroup;
                }
            }
            String producttype = (String) requestParams.get("type");
            params.add(companyid);
            if (ids != null) {
                condition += " and p.id in(? ";
                params.add(null);
                for (int i = 0; i < ids.length; i++) {
                    if (!StringUtil.isNullOrEmpty(ids[i])) {
                        condition += " ,?";
                        params.add(ids[i]);
                    }
                }
                condition += " )";
            }
            if (!StringUtil.isNullOrEmpty(producttype)) {
                condition += " and p.producttype=? ";
                params.add(producttype);
            }

            if (!includeBothFixedAssetAndProductFlag) {
                if (isFixedAsset) {
                    condition += " and p.isasset=1 ";
                } else {
                    condition += " and p.isasset=0 ";
                }
//            params.add(isFixedAsset);
            }

            if (requestParams.containsKey("natureOfStockItem") && requestParams.get("natureOfStockItem") != null) {
                condition += " and p.natureofstockitem=? ";
                params.add(requestParams.get("natureOfStockItem").toString());
            }

            if (isStoreLocationEnable) {
                condition += " and p.iswarehouseforproduct = 'T' and p.islocationforproduct = 'T' ";
            }

            if (isWastageApplicable) {
                condition += " and p.iswastageapplicable ='T'";
            }

            if (!StringUtil.isNullOrEmpty(productStore)) {
                condition += " and p.warehouse = ? ";
                params.add(productStore);
            }

            if (storageHandlerImpl.GetSATSCompanyId().contains(companyid)) {  //This is sats specific code
                if (moduleID == Constants.Acc_Vendor_Invoice_ModuleId || moduleID == Constants.Acc_Purchase_Order_ModuleId || moduleID == Constants.Acc_Vendor_Quotation_ModuleId) {
                    condition += " and p.producttype <>? ";
                    params.add(Producttype.ASSEMBLY);
                }
            } else {
                if (moduleID == Constants.Acc_Invoice_ModuleId || moduleID == Constants.Acc_ConsignmentRequest_ModuleId || moduleID == Constants.Acc_Customer_Quotation_ModuleId || moduleID == Constants.Acc_Sales_Order_ModuleId || moduleID == Constants.Acc_Delivery_Order_ModuleId || moduleID == Constants.Acc_Sales_Return_ModuleId || isSalesPrice
                        || moduleID == Constants.Acc_Cash_Sales_ModuleId) {
                        condition += " and p.producttype <>? ";
                        params.add(Producttype.Inventory_Non_Sales);
                }else if( moduleID == Constants.VENDOR_JOB_WORKORDER_MODULEID ){
                    condition += " and p.producttype = ? ";
                    params.add(Producttype.CUSTOMER_ASSEMBLY);
                }
            }

            if (isInventoryForm) {
                condition += " and p.producttype IN (?,?,?)";
                params.add(Producttype.ASSEMBLY);
                params.add(Producttype.INVENTORY_PART);
                params.add(Producttype.Inventory_Non_Sales);
            }
            int productsearchingflag = 1;
            if (requestParams.containsKey(Constants.PRODUCT_SEARCH_FLAG) && requestParams.get(Constants.PRODUCT_SEARCH_FLAG) != null) {
                productsearchingflag = Integer.parseInt(requestParams.get(Constants.PRODUCT_SEARCH_FLAG).toString());
            }
            if (requestParams.containsKey("ss") && requestParams.get("ss") != null && !isMultiSelectProductsids) {
                String ss = requestParams.get("ss").toString();
                String searchQuery = "";
                if (!StringUtil.isNullOrEmpty(ss)) {
                    if (isForBarcode) { // This flag is used to get exact match of product id for barcode reader.
                        searchQuery = " and p.productid = ? ";
                        params.add(ss);
                    } else {
                        String[] searchcol = new String[]{"p.name", "p.productid"};
                        try {
                            Map map = StringUtil.insertParamSearchStringMap(params, ss, 2);
                            map.put(Constants.PRODUCT_SEARCH_FLAG, productsearchingflag);
                            StringUtil.insertParamSearchString(map);
                            
                        } catch (SQLException ex) {
                            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                    }
                    condition += searchQuery;
                    quickSearchFlag = true;
                }
        }

        //search alphabetically on product name for android 
            if (requestParams.containsKey(Constants.sortstring) && requestParams.get(Constants.sortstring) != null) {
                String mobilesearch = requestParams.get(Constants.sortstring).toString().toUpperCase();
                if (!StringUtil.isNullOrEmpty(mobilesearch)) {
                    if (!mobilesearch.equalsIgnoreCase(Constants.NON_ALPHANUMERIC)) {
                        String[] searchArray = mobilesearch.split(",");
                        String[] searchcol = new String[searchArray.length];
                        
                        for (int i = 0; i < searchArray.length; i++) {
                            searchcol[i] = "p.name";
                            params.add(searchArray[i].trim() + "%");
                            params.add(searchArray[i].trim() + "%");
                        }
                        
                        String searchQuery = StringUtil.getSearchString(mobilesearch, "and", searchcol);
                        condition += searchQuery;
                        quickSearchFlag = true;
                    } else {
                        /**
                         * sort string key is non alphanumeric for Product Name
                         * starts with any Special Characters.
                         */
                        condition += "and ( (p.name NOT BETWEEN 'a' and 'z') and (p.name NOT BETWEEN 'A' and 'Z') and (p.name NOT BETWEEN '0' and '9'))";
                        condition += "and p.name NOT LIKE 'z%' and p.name NOT LIKE 'Z%' and p.name NOT LIKE '9%'";//for excluding EndPoint from Between Condition
                    }
                }
        }

        if (!quickSearchFlag && !excludeParent) {
                condition += " and p.parent is null ";
        }

        if (requestParams.containsKey("searchProductString") && requestParams.get("searchProductString") != null) {
                String searchProductString = requestParams.get("searchProductString").toString();
                if (!StringUtil.isNullOrEmpty(searchProductString)) {
                    condition += " and p.productid= ? ";
                    params.add(searchProductString.trim());
            }
            
        }

        if (requestParams.containsKey("customervendorcategory") && !StringUtil.isNullOrEmpty(requestParams.get("customervendorcategory").toString())) {
                condition += " and ( p.customercategory like ? )";
                params.add("%" + requestParams.get("customervendorcategory") + "%");
        }
        /*
         * Product search by Start with 'Product Name' and Any Match together
         * (ERP-32842)
         */
        String ss = "", locateCondition = "";
            if (requestParams.containsKey(Constants.ss) && !StringUtil.isNullOrEmpty((String) requestParams.get(Constants.ss))) {
                ss = requestParams.get("ss").toString().trim();
                locateCondition = "LOCATE('" + ss + "', p.name),";
        }
        //Query changed for Ticket No : ERP-19352
            String orderBy = " order by " + locateCondition + " length(p.productid),p.productid,p.producttype,p.name ";

            if (requestParams.containsKey("productsortingflag") && requestParams.get("productsortingflag") != null) {
                int productSortingFlag = Integer.parseInt(requestParams.get("productsortingflag").toString());
                if (productSortingFlag == 0) {
                    orderBy = " order by " + locateCondition + " p.name,length(p.productid),p.producttype,p.productid ";
                } else if (productSortingFlag == 1) {
                    orderBy = " order by " + locateCondition + " length(p.productid),p.productid,p.producttype, p.name ";
                }
                
        }
        /**
             * If Users Visibility is Enable then Append user condition
         */
             String customdatajoin = "";
             String usercondition = "";
             String conditiondesc = "";
             if (requestParams.containsKey("isUserVisibilityFlow") && requestParams.get("isUserVisibilityFlow") != null) {
                 usercondition = (String) requestParams.get("appendusercondtion");
                customdatajoin = " inner join accproductcustomdata pcd on p.id=pcd.productId ";
             }if (prodDescType == Constants.Acc_Productcombo_Include_description) {
                conditiondesc = "p.description as description";
            } else {
                conditiondesc = "pt.name as producttype";
            }
             String query = "select p.id,p.name,p.productid," + conditiondesc + ",isactive from product p inner join producttype pt on pt.id=p.producttype  where p.deleteflag='F'and p.company=? " + condition + usercondition + orderBy;
             list = executeSQLQuery(query, params.toArray());
             totalCount = list.size();
             if (pagingFlag && !isMultiSelectProductsids) {
                list = executeSQLQueryPaging(query, params.toArray(), new Integer[]{start, limit});
        }   
        } catch (JSONException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, "", null, list, totalCount);
        }
        
    /**
     * Method to get Landing Cost Categories for Product.
     * @param productid
     * @param companyid
     * @return KwlReturnObject
     * @throws ServiceException
     */ 
     @Override
    public KwlReturnObject getLandedCostCategoriesforProduct(String productid, String companyid) throws ServiceException {
        ArrayList params = new ArrayList();
        params.add(productid);
        params.add(companyid);
        String query = "select plc.lccategoryid,tlc.allocationid from productid_landingcostcategoryid plc "
                       + " INNER JOIN product p  ON plc.productid = p.id " 
                       +"  INNER JOIN t_landingcostcategory tlc ON plc.lccategoryid= tlc.id " 
                       +"  where p.id=? and p.company=?;";
        List list = executeSQLQuery(query, params.toArray());
        int totalCount = list.size();
        return new KwlReturnObject(true, "", null, list, totalCount);
    } 

    @Override
    public JSONObject getVendorsMappedProduct(String productid) throws ServiceException {
        ArrayList params = new ArrayList();
        int count = 0;
        JSONObject returnJObj = new JSONObject();
        List<Object[]> returnList = new ArrayList();
        StringBuilder venNameString=new StringBuilder();
        StringBuilder venCodeString=new StringBuilder();
        StringBuilder venIdString=new StringBuilder();
        try {
            if (!StringUtil.isNullOrEmpty(productid)) {
                productid = AccountingManager.getFilterInString(productid);
                String mysqlQuery = "select ven.id,ven.name,ven.acccode from vendorproductmapping vpm inner join vendor ven on ven.id=vpm.vendorid where vpm.vendorproducts IN "+productid;

                returnList = executeSQLQuery(mysqlQuery, params.toArray());
                count = returnList.size();
                if (!returnList.isEmpty() && returnList.size() > 0) {
                    for (Object[] row : returnList) {
                        if (row.length > 0 && row[0] != null) {
                            venIdString.append(row[0].toString()+",");
                        }

                        if (row.length > 1 && row[1] != null) {
                            venNameString.append(row[1].toString()+",");
                        }

                        if (row.length > 2 && row[2] != null) {
                            venCodeString.append(row[2].toString() +",");
                        }
                    }
                }
                if (venNameString.length() > 0) {
                    String vendorName = venNameString.toString();
                    vendorName = vendorName.substring(0, vendorName.lastIndexOf(","));
                    returnJObj.put("vendorname",vendorName);
                }
                
                if (venIdString.length() > 0) {
                    String vendorId = venIdString.toString();
                    vendorId = vendorId.substring(0, vendorId.lastIndexOf(","));
                    returnJObj.put("vendor",vendorId);
                }

                if (venCodeString.length() > 0) {
                    String vendorCode = venCodeString.toString();
                    vendorCode = vendorCode.substring(0, vendorCode.lastIndexOf(","));
                    returnJObj.put("vendorcode",vendorCode);
                }
                returnJObj.put(Constants.RES_TOTALCOUNT,count);
                
            }//end of product id
        } catch (JSONException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        } 
        return returnJObj;
    }
    
     /*
     * Method to get assembly products/sub assembly products with batch serial
     * details. Also we can perform quick search on serial no of main and sub
     * products.
     */
    @Override
    public KwlReturnObject getAssembyProductDetails(JSONObject paramJobj) throws ServiceException {
        int count = 0;
        List list = null;
        try {
            ArrayList params = new ArrayList();
            String productId = paramJobj.optString(Constants.productid);
            String companyId = paramJobj.optString(Constants.companyKey);
            boolean getSummaryOfAssemblyProduct = paramJobj.optBoolean("getSummaryOfAssemblyProduct", false);// flag for getting assembly product data searched by serialname.
            boolean exportflag = paramJobj.optBoolean("exportfalg", false); // flag for export case
            int start = -1, limit = -1;

            String selectQuery = "select distinct pbd.id as detailid,p.id as pid, invw.id as warehouseid,invw.name as warehouse, invl.id as locationid, invl.name as location,npb.batchname,nbs.serialname ";
            String selectCountQuery = "";
            String fromquery = "  from pbdetails pbd inner join productbuild pb on pb.id=pbd.build ";
            String joinQuery = " inner join product p on p.id = pbd.aproduct ";
            String orderBy = " order by refno ";
            String groupBy = " ";
            String conditionQuery = " where p.deleteflag = 'F' and p.isasset!='1' and p.producttype !='4efb0286-5627-102d-8de6-001cc0794cfa' and p.producttype !='f071cf84-515c-102d-8de6-001cc0794cfa' ";

            if (getSummaryOfAssemblyProduct) {
                String buildid = paramJobj.optString("buildid");
                boolean isBuild = paramJobj.optBoolean("isBuild", true);
                if (paramJobj.has("start") && paramJobj.has("limit") && !StringUtil.isNullOrEmpty(paramJobj.optString("start"))) {
                    start = paramJobj.optInt("start", -1);
                    limit = paramJobj.optInt("limit", -1);
                }

                fromquery = "  from productbuild pb  ";
                joinQuery = " inner join product p on p.id = pb.product ";
                conditionQuery += " and pb.company = ? and pb.quantity!=0 ";
                groupBy = " group by pb.id ";
                params.add(companyId);
                conditionQuery += isBuild ? " and pb.isbuild ='T' " : " and pb.isbuild ='F' ";

                selectCountQuery = "select count(distinct pb.id) ";
                selectQuery = " select distinct pb.id as detailid,pb.entrydate,p.id,p.name,pb.quantity,pb.refno,pb.seqformat,pb.memo,pb.description,p.productid,pb.journalentry,je.entryno,bom.bomcode,bom.bomname,invw.name as warehouse, invl.name as location,npb.batchname,GROUP_CONCAT(nbs.serialname) ";
//                    selectQuery = " select distinct pb.id as detailid,pb.entrydate,p.id,p.name,pb.quantity,pb.refno,pb.seqformat,pb.memo,pb.description,p.productid,pb.journalentry,je.entryno,bom.bomcode,bom.bomname ";
                joinQuery += " left join journalentry je on (pb.journalentry = je.id and pb.company = je.company) "
                        + " left join bomdetail bom on (bom.id =pb.bomdetail) ";

                if ((paramJobj.has("ss"))) {
                    String ss = paramJobj.optString("ss");
                    if (!StringUtil.isNullOrEmpty(ss)) {
                        String searchOnField = paramJobj.optString("searchOnField");
                        String[] searchcol = new String[]{"p.name", "p.productid", "p.description"};
                        if (searchOnField.trim().equals("SERIAL")) {
                            searchcol = new String[]{"nbs.serialname", "nbssub.serialname"};
                            joinQuery += " inner join pbdetails pbd on pbd.build = pb.id  "
                                    //                                    + "left join serialdocumentmapping sdm on (sdm.documentid = pb.id) "
                                    //                                    + "left join newbatchserial nbs on (nbs.id = sdm.serialid and nbs.company = pb.company)"
                                    + "left join serialdocumentmapping sdmsub on (sdmsub.documentid = pbd.id) "
                                    + "left join newbatchserial nbssub on (nbssub.id = sdmsub.serialid and nbssub.company = pb.company)";
                        } else if (searchOnField.trim().equals("BATCH")) {
                            searchcol = new String[]{"npb.batchname", "npbsub.batchname"};
                            joinQuery += " inner join pbdetails pbd on pbd.build = pb.id  "
                                    //                                    + "left join locationbatchdocumentmapping lbdm on pb.id=lbdm.documentid "
                                    //                                    + "inner join newproductbatch npb on (lbdm.batchmapid=npb.id and npb.company = pb.company) "
                                    + "left join locationbatchdocumentmapping lbdmsub on pbd.id=lbdmsub.documentid "
                                    + "left join newproductbatch npbsub on (lbdmsub.batchmapid=npbsub.id and npbsub.company = pb.company) ";
                        }
                        try {
                            Map map = StringUtil.insertParamSearchStringMap(params, ss, searchcol.length);
                            StringUtil.insertParamSearchString(map);
                        } catch (SQLException ex) {
                            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
                        }
                        String searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                        conditionQuery += searchQuery;

                    }
                }


                if (paramJobj.has(Constants.REQ_startdate) && paramJobj.has(Constants.REQ_enddate)) {
                    Date startDate = (Date) paramJobj.get(Constants.REQ_startdate);
                    Date endDate = (Date) paramJobj.get(Constants.REQ_enddate);
                    if (startDate != null && endDate != null) {
                        conditionQuery += " and (p.entryDate >=? and p.entryDate <=?) ";
                        params.add(startDate);
                        params.add(endDate);
                    }
                }

                if (!StringUtil.isNullOrEmpty(buildid)) {
                    conditionQuery += " and pb.id = ? ";
                    params.add(buildid);
                }

                if (!StringUtil.isNullOrEmpty(productId)) {
                    String productidArray[] = productId.split(",");
                    for (int i = 0; i < productidArray.length; i++) {
                        if (i == 0) {
                            conditionQuery += " and (";
                        } else {
                            conditionQuery += " or ";
                        }
                        conditionQuery += " p.id=?";
                        params.add(productidArray[i]);
                        if (i == productidArray.length - 1) {
                            conditionQuery += " ) ";
                        }
                    }
                }

            } else {
                conditionQuery += " and pb.id = ? and (inventoryquantity*pb.quantity)!=0 ";
                params.add(productId);

            }
                        //When product type is JOB WORK ASSEMBLY then documentid in locationbatchdocumentmaaping table is jobworkorderid else it is id of productbuild table SDP-13943
            joinQuery += " left join locationbatchdocumentmapping lbdm on (case when p.producttype=(Select pt.id from producttype pt where pt.name='Job Work Assembly') then pb.jobworkorderid=lbdm.documentid else pb.id=lbdm.documentid end)";
//            joinQuery += " left join locationbatchdocumentmapping lbdm on pb.id=lbdm.documentid ";

            if (getSummaryOfAssemblyProduct) {
                joinQuery += "left join newproductbatch npb on (lbdm.batchmapid=npb.id and npb.company = pb.company) ";
            } else {
                joinQuery += "left join newproductbatch npb on (lbdm.batchmapid=npb.id and npb.company = pb.company) ";
            }

            joinQuery += "left join inventorylocation invl on (invl.id = npb.location and invl.company = npb.company) "
                    + "left join inventorywarehouse invw on (invw.id = npb.warehouse and invw.company = npb.company) "
                    + "left join serialdocumentmapping sdm on (sdm.documentid = pb.id) "
                    + "left join newbatchserial nbs on (nbs.id = sdm.serialid and nbs.company = npb.company) ";


            if (getSummaryOfAssemblyProduct && start > -1 && limit > -1 && !exportflag && !StringUtil.isNullOrEmpty(selectCountQuery)) {
                list = executeSQLQuery(selectCountQuery + fromquery + joinQuery + conditionQuery + orderBy, params.toArray());
                if (!list.isEmpty() && list.size() > 0) {
                    count = (Integer) (((BigInteger) list.get(0)).intValue());
                }

                list = executeSQLQueryPaging(selectQuery + fromquery + joinQuery + conditionQuery + groupBy + orderBy, params.toArray(), new Integer[]{start, limit});
            } else {
                list = executeSQLQuery(selectQuery + fromquery + joinQuery + conditionQuery + groupBy + orderBy, params.toArray());
                count = list.size();
            }

        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    @Override
    public KwlReturnObject getAssetDetailsById(HashMap<String, Object> requestMap) throws ServiceException {

        int count = 0;
        List list = new ArrayList();
        List assetDetaillist;
        List prAssetDetaillist;
        try {
            String companyId = (String) requestMap.get("companyId");
            ArrayList params = new ArrayList();

            params.add(companyId);
            String condition = "";
            if (requestMap.containsKey("assetId")) {
                condition += " and ad.assetId IN  " + (String) requestMap.get("assetId");
            }

            String query = "select distinct ad.assetId from AssetDetails ad Where ad.company.companyID=? " + condition;

            assetDetaillist = executeQuery(query, params.toArray());
            if (assetDetaillist != null && assetDetaillist.size() > 0) {
                count += assetDetaillist.size();
                list.addAll(assetDetaillist);
            }
            query = "select distinct ad.assetId from PurchaseRequisitionAssetDetails ad Where ad.company.companyID=? " + condition;

            prAssetDetaillist = executeQuery(query, params.toArray());
            if (prAssetDetaillist != null && prAssetDetaillist.size() > 0) {
                count += prAssetDetaillist.size();
                list.addAll(prAssetDetaillist);
            }

        } catch (ServiceException ex) {
            Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    @Override
    public KwlReturnObject getRateFromWorkOrderComponentDetail(String istid, String companyid) throws ServiceException {
        String sql = null;
        List list = null;
        if (istid != null) {
            sql = "select wocd.initialpurchaseprice,sm.id from wocdetailistmapping wocdistm,workordercomponentdetail wocd,workorder wo,company c,in_interstoretransfer ist,in_stockmovement sm where wocdistm.wocdetail = wocd.id and wocd.workorder = wo.id and c.companyid = wo.company and ist.id = wocdistm.istrequest and sm.modulerefdetailid=wocd.id and ist.id = ? and c.companyid = ?";
            list = executeSQLQuery(sql, new Object[]{istid, companyid});
        } else {
            sql = "select wocd.initialpurchaseprice,sm.id,ist.id from wocdetailistmapping wocdistm,workordercomponentdetail wocd,workorder wo,company c,in_interstoretransfer ist where wocdistm.wocdetail = wocd.id and wocd.workorder = wo.id and c.companyid = wo.company and ist.id = wocdistm.istrequest and sm.modulerefdetailid=wocd.id and c.companyid = ?";
            list = executeSQLQuery(sql, new Object[]{companyid});
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
    @Override
    public boolean isWorkOrderComponentDetailSentToQA(String wocdid, String companyid)  throws ServiceException {
        boolean isWorkOrderComponentDetailSentToQA = false;
        String sql = "select count(wo.id) from wocdetailistmapping wocdistm,workordercomponentdetail wocd,workorder wo,company c where wocdistm.wocdetail = wocd.id and wocd.workorder = wo.id and c.companyid = wo.company and wocd.id = ? and c.companyid = ?";
        List cntlist = executeSQLQuery(sql, new Object[]{wocdid, companyid});
        if (cntlist != null && !cntlist.isEmpty()) {
            BigInteger bigInteger = (BigInteger) cntlist.get(0);
            if (bigInteger.intValue() > 0) {
                isWorkOrderComponentDetailSentToQA = true;
            }
        }
        return isWorkOrderComponentDetailSentToQA;
    }
    
    /**
     * Method to be used to get the rate and exchangerate for GRODetail. Price of IST sent for QA should be same GRODetail.
     *
     * @param istid
     * @param companyid
     * @return
     * @see http://jira.deskera.com/browse/ERP-35843
     * @throws ServiceException
     */
    @Override
    public KwlReturnObject getRateAndExchangeRateFromGoodsReceiptOrderDetail(String istid, String companyid)  throws ServiceException {        
        String sql = null;
        List list = null;
        if(istid != null){
            sql = "select grd.rate,gr.externalcurrencyrate,gr.currency,grd.id from grodetailistmapping gro,grodetails grd,grorder gr,company c,in_interstoretransfer ist where gro.grodetail = grd.id and grd.grorder = gr.id and c.companyid = gr.company and ist.company = c.companyid and ist.id = gro.istrequest and ist.id = ? and c.companyid = ?";
            list = executeSQLQuery(sql, new Object[]{istid, companyid});
        }
        else{
            sql = "select grd.rate,gr.externalcurrencyrate,gr.currency,grd.id as grdid,ist.id as istid from grodetailistmapping gro,grodetails grd,grorder gr,company c,in_interstoretransfer ist where gro.grodetail = grd.id and grd.grorder = gr.id and c.companyid = gr.company and ist.company = c.companyid and ist.id = gro.istrequest and c.companyid = ?";
            list = executeSQLQuery(sql, new Object[]{companyid});
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    @Override
    public boolean isGoodsReceiptOrderDetailSentToQA(String grodid, String companyid)  throws ServiceException {
        boolean isGoodsReceiptOrderDetailSentToQA = false;
        String sql = "select count(gr.id) from grodetailistmapping gro,grodetails grd,grorder gr,company c where gro.grodetail = grd.id and grd.grorder = gr.id and c.companyid = gr.company and grd.id = ? and c.companyid = ?";
        List cntlist = executeSQLQuery(sql, new Object[]{grodid, companyid});
        if (cntlist != null && !cntlist.isEmpty()) {
            BigInteger bigInteger = (BigInteger) cntlist.get(0);
            if (bigInteger.intValue() > 0) {
                isGoodsReceiptOrderDetailSentToQA = true;
            }
        }
        return isGoodsReceiptOrderDetailSentToQA;
    }
    
    @Override
    public List getGoodsReceiptOrderDetailSentToQA(String companyid)  throws ServiceException {
        String sql = "select grd.id from grodetailistmapping gro,grodetails grd,grorder gr,company c where gro.grodetail = grd.id and grd.grorder = gr.id and c.companyid = gr.company and c.companyid = ? group by grd.id having count(grd.id) >0";
        List cntlist = executeSQLQuery(sql, new Object[]{companyid});
        return cntlist;
    }
    
    /**
     * Method used to add initial purchase price using script.
     */
    public KwlReturnObject insertInitialPurchasePrice(String companyid) throws ServiceException {
        String query = "insert into pricelist(id,applydate,carryin,price,product,company,affecteduser,currency,uomid,initialprice) "
                + "select UUID(), pl.applydate,pl.carryin,pl.price,pl.product,pl.company,pl.affecteduser,pl.currency,pl.uomid,'T'  "
                + "from inventory inv   left join  ( select p1.*, IF(uom.name = 'N/A', ' ', uom.name) as productuomname, prodtype.name as producttypename from product p1  left join uom on uom.id = p1.unitOfMeasure  left join producttype prodtype on prodtype.id = p1.producttype where p1.company = ? )  as p "
                + " on p.id = inv.product   left join pricelist pl on pl.product = p.id and pl.affecteduser = '-1' and pl.carryin='T' "
                + " and pl.uomid = p.unitOfMeasure  and pl.currency=p.currency and (pl.applydate =(select max(applydate) as ld from pricelist where pricelist.product=inv.product and pricelist.carryin='T'  and pricelist.uomid = p.unitOfMeasure  and pricelist.currency=pl.currency and  pricelist.affecteduser='-1'  and pricelist.applydate<=inv.updatedate and inv.company=?  and p.deleteflag = 'F' and p.isasset!='1' and p.producttype NOT IN ('f071cf84-515c-102d-8de6-001cc0794cfa','4efb0286-5627-102d-8de6-001cc0794cfa','a6a350c4-7646-11e6-9648-14dda97925bd','a839448c-7646-11e6-9648-14dda97925bd')  group by inv.product))   left join locationbatchdocumentmapping lbdm on p.id=lbdm.documentid  inner join newproductbatch npb on lbdm.batchmapid=npb.id where inv.newinv='T' and inv.defective='F' and inv.carryin='T' and inv.company = ? and inv.quantity!=0  and p.deleteflag = 'F' and p.isasset!='1' and p.producttype NOT IN ('f071cf84-515c-102d-8de6-001cc0794cfa','4efb0286-5627-102d-8de6-001cc0794cfa','a6a350c4-7646-11e6-9648-14dda97925bd','a839448c-7646-11e6-9648-14dda97925bd') "
                + "and pl.id is not null and p.id not in (select product.id from product inner join pricelist on pricelist.product = product.id where pricelist.initialprice = 'T' and product.company = p.company) group by p.id";
        int numRows = executeSQLUpdate(query, new Object[]{companyid, companyid, companyid});
        return new KwlReturnObject(true, "Price has been updated successfully.", null, null, numRows);
    }
    
    @Override
    public KwlReturnObject getLocationWarehouseWiseAvailableQuantity(HashMap<String, Object> requestMap) throws ServiceException { 
        List list = new ArrayList();
        String location ="", warehouse="", companyid="", productid="", condition="";
        try {
            if(requestMap.containsKey("company") && requestMap.get("company")!=null){
                companyid = (String)requestMap.get("company");
            }
            if(requestMap.containsKey("product") && requestMap.get("product")!=null){
                productid = (String)requestMap.get("product");
            }
            if(requestMap.containsKey("warehouse") && requestMap.get("warehouse")!=null){
                warehouse = (String)requestMap.get("warehouse");
                condition += " AND warehouse='"+warehouse+"' " ;
            }
            if(requestMap.containsKey("location") && requestMap.get("location")!=null){
                location = (String)requestMap.get("location");
                condition += " AND location='"+location+"' ";
            }
            
//            String sql = "SELECT id, quantity, quantitydue, isopening, wastagequantity FROM newproductbatch WHERE company=? AND product=? ";
            String sql = "SELECT quantitydue FROM newproductbatch WHERE company=? AND product=? ";
            sql+=condition;
            list = executeSQLQuery(sql, new Object[]{companyid, productid});            
        } catch (Exception ex) {
            throw ServiceException.FAILURE("getLocationWarehouseWiseAvailableQuantity : " + ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, list.size());
    }
    
     /*
     * Method to get bom wise stock details for assembly products/sub assembly products. 
     */
    @Override
    public KwlReturnObject getAssembyProductBOMDetails(JSONObject paramJobj) throws ServiceException {
        int count = 0;
        List list = null;
        try {
            ArrayList params = new ArrayList();
            String ss = paramJobj.optString(Constants.ss);
            String companyId = paramJobj.optString(Constants.companyKey);
            boolean getSummaryOfAssemblyProduct = paramJobj.optBoolean("getSummaryOfAssemblyProduct", false);// flag for getting assembly product data searched by serialname.
            boolean exportflag = paramJobj.optBoolean("exportfalg", false); // flag for export case
            int start = -1, limit = -1;
            
            int quantityDigit = Constants.QUANTITY_DIGIT_AFTER_DECIMAL;
            if (Constants.CompanyPreferencePrecisionMap.containsKey(companyId)) {
                quantityDigit = (Integer) Constants.CompanyPreferencePrecisionMap.get(companyId).get(Constants.quantitydecimalforcompany);
            }
            
            String selectQuery = "";
            String buildQuery = "";
            String unBuildQuery = "";
            String deliveryorderQuery = "";
            String goodsreceiptorderQuery = "";
            String[] searchcol = null;
            String searchQuery = "";
            String searchStoreId = "";
            String searchStoreQuery = "";
            String searchProductId = "";
            String searchProductQuery = "";
            String searchBOMId = "";
            String searchBOMQuery = "";
            Map map = null;
            if(!StringUtil.isNullOrEmpty(ss)){
                searchcol = new String[]{"p.name", "p.productid", "bom.bomcode"};
                searchQuery = StringUtil.getSearchString(ss, "and", searchcol);
                map = StringUtil.insertParamSearchStringMap(params, ss, searchcol.length);
            }
            if (paramJobj.has("start") && paramJobj.has("limit") && !StringUtil.isNullOrEmpty(paramJobj.optString("start"))) {
                start = paramJobj.optInt("start", -1);
                limit = paramJobj.optInt("limit", -1);
            }
            if (paramJobj.has("storeid")){
                searchStoreId = paramJobj.getString("storeid");
                if (searchStoreId.equals("ALL")){
                searchStoreId="";
            }
                searchStoreQuery = " and sm.store= ? ";
            }
            // From Build Assembly Deletion Request
            if (paramJobj.has("productid")){
                searchProductId = paramJobj.getString("productid");
                searchProductQuery = " and p.id= ? ";
            }
            if (paramJobj.has("bomid")){
                searchBOMId = paramJobj.getString("bomid");
                searchBOMQuery = " and bom.id= ? ";
            }
            
            selectQuery= "SELECT pid, productname, bomid, bomcode, sum(case when cin='1' then FORMAT(qty,"+quantityDigit+") end) as buildquantity,"
                    + " sum(case when cin='2' then FORMAT(qty,"+quantityDigit+") end) as consumequantity, description from ( ";
            
            buildQuery = " SELECT p.id as pid, p.productid as productname, p.description, sum(FORMAT(smd.quantity,"+quantityDigit+")) as qty, sm.transaction_type as cin, "
                    + " bom.bomcode as bomcode, bom.id as bomid FROM productbuild pb "
                    + " INNER JOIN in_stockmovement sm ON (pb.id=sm.modulerefid and pb.product=sm.product)"
                    + " INNER JOIN in_sm_detail smd ON smd.stockmovement=sm.id "
                    + " INNER JOIN product p ON p.id=pb.product "
                    + " INNER join bomdetail bom on (bom.id =pb.bomdetail) "
                    + " WHERE  p.company = ? ";
            params.add(companyId);
                    if(!StringUtil.isNullOrEmpty(searchStoreId)){
                        buildQuery+= searchStoreQuery;
                        params.add(searchStoreId);
                    }
                    if(!StringUtil.isNullOrEmpty(searchProductId)){
                        buildQuery+= searchProductQuery;
                        params.add(searchProductId);
                    }
                    if(!StringUtil.isNullOrEmpty(searchBOMId)){
                        buildQuery+= searchBOMQuery;
                        params.add(searchBOMId);
                    }
                    if(!StringUtil.isNullOrEmpty(ss)){
                        buildQuery+= searchQuery;
                        StringUtil.insertParamSearchString(map);
                    }
            buildQuery+= " and p.deleteflag = 'F' and p.isasset!='1' and pb.isbuild='T' and p.producttype in ('"+ Producttype.ASSEMBLY + "','" + Producttype.CUSTOMER_ASSEMBLY + "') group by bom.id";
            
            
            unBuildQuery = " SELECT p.id as pid, p.productid as productname, p.description, sum(FORMAT(smd.quantity,"+quantityDigit+")) as qty, sm.transaction_type as cin, "
                    + " bom.bomcode as bomcode, bom.id as bomid FROM productbuild pb "
                    + " INNER JOIN in_stockmovement sm ON (pb.id=sm.modulerefid and pb.product=sm.product)"
                    + " INNER JOIN in_sm_detail smd ON smd.stockmovement=sm.id "
                    + " INNER JOIN product p ON p.id=pb.product "
                    + " INNER join bomdetail bom on (bom.id =pb.bomdetail) "
                    + " WHERE  p.company = ? ";
            params.add(companyId);
                    if(!StringUtil.isNullOrEmpty(searchStoreId)){
                        unBuildQuery+= searchStoreQuery;
                        params.add(searchStoreId);
                    }
                    if(!StringUtil.isNullOrEmpty(searchProductId)){
                        unBuildQuery+= searchProductQuery;
                        params.add(searchProductId);
                    }
                    if(!StringUtil.isNullOrEmpty(searchBOMId)){
                        unBuildQuery+= searchBOMQuery;
                        params.add(searchBOMId);
                    }
                    if(!StringUtil.isNullOrEmpty(ss)){
                        unBuildQuery+= searchQuery;
                        StringUtil.insertParamSearchString(map);
                    }
            unBuildQuery+= " and p.deleteflag = 'F' and p.isasset!='1' and pb.isbuild='F' and p.producttype in ('"+ Producttype.ASSEMBLY + "','" + Producttype.CUSTOMER_ASSEMBLY + "') group by bom.id";
            
            
            goodsreceiptorderQuery = " SELECT p.id as pid, p.productid as productname, p.description, sum(FORMAT(smd.quantity,"+quantityDigit+")) as qty, "
                    + " sm.transaction_type as cin, bom.bomcode as bomcode, bom.id as bomid FROM grodetails grod "
                    + " INNER JOIN in_stockmovement sm ON grod.id=sm.modulerefdetailid "
                    + " INNER JOIN in_sm_detail smd ON smd.stockmovement=sm.id "
                    + " INNER JOIN product p ON p.id=grod.product "
                    + " INNER join bomdetail bom on (bom.id =grod.bomcode) "
                    + " WHERE p.company = ? ";
            params.add(companyId);
                    if(!StringUtil.isNullOrEmpty(searchStoreId)){
                        goodsreceiptorderQuery+= searchStoreQuery;
                        params.add(searchStoreId);
                    }
                    if(!StringUtil.isNullOrEmpty(searchProductId)){
                        goodsreceiptorderQuery+= searchProductQuery;
                        params.add(searchProductId);
                    }
                    if(!StringUtil.isNullOrEmpty(searchBOMId)){
                        goodsreceiptorderQuery+= searchBOMQuery;
                        params.add(searchBOMId);
                    }
                    if(!StringUtil.isNullOrEmpty(ss)){
                        goodsreceiptorderQuery+= searchQuery;
                        StringUtil.insertParamSearchString(map);
                    }
            goodsreceiptorderQuery+= " and p.deleteflag = 'F' and p.isasset!='1'  and p.producttype in ('"+ Producttype.ASSEMBLY + "','" + Producttype.CUSTOMER_ASSEMBLY + "') group by bom.id  ";
            
            
            deliveryorderQuery = " SELECT p.id as pid, p.productid as productname, p.description, sum(FORMAT(smd.quantity,"+quantityDigit+")) as qty, sm.transaction_type as cin, bom.bomcode as bomcode, bom.id as bomid "
                    + " FROM dodetails dod "
                    + " INNER JOIN in_stockmovement sm ON dod.id=sm.modulerefdetailid "
                    + " INNER JOIN in_sm_detail smd ON smd.stockmovement=sm.id "
                    + " INNER JOIN product p ON p.id=dod.product "
                    + " INNER join bomdetail bom on (bom.id =dod.bomcode) "
                    + " WHERE p.company = ? ";
            params.add(companyId);
                    if(!StringUtil.isNullOrEmpty(searchStoreId)){
                        deliveryorderQuery+= searchStoreQuery;
                        params.add(searchStoreId);
                    }
                    if(!StringUtil.isNullOrEmpty(searchProductId)){
                        deliveryorderQuery+= searchProductQuery;
                        params.add(searchProductId);
                    }
                    if(!StringUtil.isNullOrEmpty(searchBOMId)){
                        deliveryorderQuery+= searchBOMQuery;
                        params.add(searchBOMId);
                    }
                    if(!StringUtil.isNullOrEmpty(ss)){
                        deliveryorderQuery+= searchQuery;
                        StringUtil.insertParamSearchString(map);
                    }
            deliveryorderQuery+= " and p.deleteflag = 'F' and p.isasset!='1' and p.producttype in ('"+ Producttype.ASSEMBLY + "','" + Producttype.CUSTOMER_ASSEMBLY + "') group by bom.id  ";
            
            
            selectQuery += buildQuery + " UNION " + unBuildQuery + " UNION " + goodsreceiptorderQuery + " UNION " + deliveryorderQuery ;
            selectQuery += " ) as invent group by bomid, pid";
            
                list = executeSQLQuery(selectQuery, params.toArray());
                count = list.size();
        if (start > -1 && limit > -1) {
            //selectQuery += " start ? limit ? "; 
            list = executeSQLQueryPaging( selectQuery, params.toArray(), new Integer[]{start, limit});
        }

        } catch (Exception ex) {
            throw ServiceException.FAILURE(ex.getMessage(), ex);
        }
        return new KwlReturnObject(true, null, null, list, count);
    }

    
    @Override
    public KwlReturnObject getProductCountfromInventoryAccount(String accountid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String query = "SELECT COUNT(id) FROM product WHERE inventoryaccount=? and company=?";
        list = executeSQLQuery(query, new Object[]{accountid,companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
    /**
     * Get Expense Invoice IDs for a product for landing cost category based transactions.
     * @param productid
     * @param companyid
     * @return
     * @throws ServiceException
     */
    @Override
    public KwlReturnObject getLandedInvoiceListForProduct(String productid, String companyid) throws ServiceException {
        List list = new ArrayList();
        String selQuery = "  select lcdm.expenseinvoiceid from grdetails grd " +
            " inner join inventory inv on inv.id = grd.id " +
            " inner join product p on p.id = inv.product " +
            " inner join productid_landingcostcategoryid plc on plc.productid = p.id " +
            " inner join landingcostdetailmapping lcdm ON lcdm.grdetailid = grd.id " +
            " where p.id=? and grd.company=? GROUP BY lcdm.expenseinvoiceid";
        list = executeSQLQuery(selQuery, new Object[]{productid, companyid});
        return new KwlReturnObject(true, "", null, list, list.size());
    }
      public boolean isDefaultSeuenceFormatSetForBuildAssembly(JSONObject paramJobj) throws AccountingException {
          boolean isDefaultSeuenceFormatSetForBuildAssembly = false;
          try {
              SequenceFormat format = null;
              KwlReturnObject kwlObj = null;
              //below code is for fetching default build assemby sequence format
              String companyid = paramJobj.getString(Constants.companyKey);
              Locale locale = Locale.forLanguageTag(paramJobj.getString(Constants.language));
              HashMap<String, Object> BAFormatParams = new HashMap<String, Object>();
              BAFormatParams.put(Constants.moduleid, Constants.Acc_Build_Assembly_Product_ModuleId);
              BAFormatParams.put("modulename", "autobuildassembly");
              BAFormatParams.put(Constants.companyKey, companyid);
              BAFormatParams.put("isdefaultFormat", true);
              kwlObj = accCompanyPreferencesObj.getSequenceFormat(BAFormatParams);
              if (kwlObj.getEntityList().size() != 0) {
                  format = (SequenceFormat) kwlObj.getEntityList().get(0);
                  isDefaultSeuenceFormatSetForBuildAssembly = true;
              } else {
                  throw new AccountingException(messageSource.getMessage("acc.product.defaultSequenceFormatNotSet", null, locale));
              }
          } catch (ServiceException ex) {
              Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
          } catch (JSONException ex) {
              Logger.getLogger(accProductImpl.class.getName()).log(Level.SEVERE, null, ex);
          }
          return isDefaultSeuenceFormatSetForBuildAssembly;
      }
}
